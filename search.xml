<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Ubuntu下p4vasp的安装</title>
    <url>/2017/11/18/A02/</url>
    <content><![CDATA[<p><img src="/2017/11/18/A02/A02-1.png" alt=""></p>
<p>使用vasp计算，后处理的小程序、小脚本有很多。其中最为出名的非p4vasp莫属了。从搭建模型，调整结构，DOS、能带计算，功函数等等，都可以使用它来完成。举个例子，本人博士四年，一直用它来查看和处理结果，再结合一些其他辅助的小程序和脚本，可以说是极大地提高了自己的工作效率。今天因写脚本需要，浏览了一下p4vasp官网，发现官网对p4vasp的安装解释非常简单。于是便测试了一下。本节主要包含3部分:</p>
<ul>
<li>第一部分：p4vasp官方的安装流程，相信大家按照这一步都可以完成安装；</li>
<li>第二部分：本人亲自安装的具体流程；</li>
<li>第三部分：傻瓜化安装流程。</li>
</ul>
<h3 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h3><p>p4vasp官网： <a href="http://www.p4vasp.at/。点击下方的链接，根据操作进行：">http://www.p4vasp.at/。点击下方的链接，根据操作进行：</a> </p>
<p><a href="http://www.p4vasp.at/#/doc/getstarted">http://www.p4vasp.at/#/doc/getstarted</a></p>
<p><img src="/2017/11/18/A02/A02-2.png" alt=""></p>
<h3 id="第二部分：动手安装流程："><a href="#第二部分：动手安装流程：" class="headerlink" title="第二部分：动手安装流程："></a>第二部分：动手安装流程：</h3><p>这一部分内容，是根据前面的官方介绍，亲自操刀实践的部分。</p>
<p>1） 首先说明下，本人的操作系统是：Ubuntu 16.04.3 LTS</p>
<p><img src="/2017/11/18/A02/A02-3.png" alt=""></p>
<p>2) 下载p4vasp：</p>
<p>目前，对Linux系统来说，最新的貌似只有source版本的了，binary的已经成为了历史。</p>
<p>对Windows用户来说，更可怜，p4vasp都没有更新，版本还是老样子，Windows的获取方法：</p>
<ul>
<li>通过这个链接下载：<a href="https://pan.baidu.com/s/1eT3MGvC">https://pan.baidu.com/s/1eT3MGvC</a> 密码：g9fn 。</li>
<li>也可以在QQ群文件中下载： 217821116 </li>
</ul>
<p>Linux用户则可以通过p4vasp官网下载：</p>
<p><img src="/2017/11/18/A02/A02-4.png" alt=""></p>
<p>3) 解压：</p>
<p><img src="/2017/11/18/A02/A02-5.png" alt=""></p>
<p>这里将p4vasp软件包解压到Documents目录下，当然，也可以使用官网介绍的解压命令进行。</p>
<p>4) 进入解压的目录，然后按照官网说的，Ubuntu用户，使用 <code>install-ubuntu-dependencies.sh</code> 这个脚本安装一些一些必须的dependencies. 如下图：运行命令后，会提示你是不是下载，输入<code>Y</code> 或者 <code>y</code> ，然后回车。屏幕此时开始疯狂地颤抖，说明正在下载安装。</p>
<p><img src="/2017/11/18/A02/A02-6.png" alt=""></p>
<p>注意： </p>
<ul>
<li><p>解压到什么地方不用要，可以放到桌面上，也可以直接解压在Download里面，本人习惯解压到Documents这个文件下。</p>
</li>
<li><p>这里大师兄先进入的 install 这个目录， 然后运行的脚本。安装完记得再返回去。</p>
</li>
</ul>
<p>5) 安装完成后，返回上一级目录，然后正式安装p4vasp。</p>
<p><img src="/2017/11/18/A02/A02-7.png" alt=""></p>
<p>等待屏幕颤抖完毕。</p>
<p><img src="/2017/11/18/A02/A02-8.png" alt=""></p>
<p>看到这里，基本上99.99% 成功安装了。</p>
<p>6) 测试一下： 终端直接输入： <code>p4v</code> ，效果如下：</p>
<p><img src="/2017/11/18/A02/A02-9.png" alt=""></p>
<p>打开p4vap了，说明安装成功。</p>
<p>7）检查下版本：（点击右上角的help）</p>
<p><img src="/2017/11/18/A02/A02-10.png" alt=""></p>
<p>最新版的p4vasp已经顺利安装成功。欢呼吧，少年！！</p>
<h3 id="傻瓜化安装"><a href="#傻瓜化安装" class="headerlink" title="傻瓜化安装"></a>傻瓜化安装</h3><p>在进行第二部分操作的前4年，本人一直用的这个办法：</p>
<p>1） 终端一个命令搞定：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install p4vasp</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="/2017/11/18/A02/A02-11.png" alt=""></p>
<p>输入Y，等待屏幕颤抖结束</p>
<p>2） 运行p4vasp：</p>
<p><img src="/2017/11/18/A02/A02-12.png" alt=""></p>
<p>3） 检查下版本：该版本为v0.3.29r1，比官网的最新版稍微旧一点。但不影响使用。</p>
<p><img src="/2017/11/18/A02/A02-13.png" alt=""></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>对于Ubuntu用户：</p>
<ul>
<li>建议大家使用官网介绍的办法。安装最新版的p4vasp。</li>
<li>如果遇到自己解决不了的问题，可以使用 sudo apt-get install p4vasp 这个命令一键搞定。</li>
<li>其他linux系统的用户，本人没有尝试过。</li>
</ul>
<p>Windows用户，目前只能使用本文中链接下载旧版本的了。</p>
<p>Mac 用户：浏览p4vasp的github网站，根据Readme文件自己尝试着安装吧。</p>
<p><a href="https://github.com/orest-d/p4vasp">https://github.com/orest-d/p4vasp</a></p>
]]></content>
      <categories>
        <category>LVASPTHW附录</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>p4vasp</tag>
      </tags>
  </entry>
  <entry>
    <title>自动生成KPOINTS的脚本</title>
    <url>/2017/12/21/A04/</url>
    <content><![CDATA[<p>前面学习了cd的一些用法，本节我们简单介绍下如何写自动生成KPOINTS文件的脚本。提到脚本，对于做计算的我们并不陌生，提交命令，分析数据，处理结果都会用到，脚本的存在使得一些繁重的工作极大地得到简化，节约了我们的时间和精力。但脚本怎么写出来的？怎么写脚本？很多人就望而却步了。</p>
<p><strong>1</strong> <strong>什么是脚本？</strong> </p>
<p>对于脚本的解释，大家可以浏览一下网上的解释，这里大师兄主要说一下自己的理解：</p>
<p>1）  脚本是一个文本文件；我们可以用文本编辑器打开，查看，和修改。知道了这一点，当你从某处获得一个脚本时，就可以阅读里面的内容了，进而知道该脚本是怎么运行的，有哪些地方值得注意，为了实现另一个结果我们需要修改什么参数等；</p>
<p>2）  脚本中的内容为程序语言；脚本中我们需要把我们期望的工作分解并转化为程序语言；所以你的选择有很多，bash， perl， python， java….， C++ 等等；</p>
<p>4）  脚本可以执行；通过执行脚本，实现我们的目的，这里主要是给大家强调一下，在今后的学习中，仔细观察脚本的执行流程！</p>
<p><strong>2 生成KPOINTS的脚本</strong></p>
<p>这里说的KPOINTS文件指的是自动生成网格的KPOINTS文件，能带计算由于比较特殊，最好手动输入。编辑器用的是vim，还可以使用 notepad++或者其他文本编辑器进行练习。</p>
<p>2.1  <code>kpoints.sh</code>版本1 </p>
<p>A）终端里面输入： <code>vi kpoints.sh</code></p>
<p>B）在vi 界面里面输入下面几行内容：</p>
<p><img src="/2017/12/21/A04/A04-1.jpg" alt=""></p>
<p>输入完毕后保存 。</p>
<p>C）脚本讲解：图中的除了第4行，所有命令都可以复制到 Terminal里面自己运行，然后查看结果。</p>
<p>C.1）前面我们学习了如何手动制作KPOINTS文件， 并知道KPOINTS文件每一行所代表的内容。因此该脚本就是帮助我们自动生成每一行的内容。忘记的同学请复习Ex01的内容。 </p>
<p>C.2）第一行： <code>echo  K-POINTS  &gt;  KPOINTS</code> （注意空格）</p>
<p><code>echo</code> 在bash语言中，代表输出打印的意思，<code>&gt;</code> 代表把前面的内容保存到后面的<code>KPOINTS</code>文件中； 如果目录下不存在<code>KPOINTS</code>文件，那么会自动创建；</p>
<p>如果存在，<code>KPOINTS</code>文件之前的内容会被 当前命令中 <code>&gt;</code> 前面的内容替换。也就是<code>KPOINTS</code>文件以前的内容被清理掉，并换成了最新的内容。</p>
<p>因此，运行这一行命令，我们会创建一个<code>KPOINTS</code>文件，里面只有一行文字： <code>K-POINTS</code></p>
<p>我们知道第一行的内容为说明，对计算不会产生影响，你也可以把 K-POINTS换成男朋友或者女朋友的名字….</p>
<p>C.3）第二行：</p>
<p>继续使用<code>echo</code>命令，将数字 <code>0</code> 保存到<code>KPOINTS</code>文件中。</p>
<p>这里 <code>&gt;&gt;</code> 两个箭头代表：将 <code>&gt;&gt;</code> 前面的内容保存到<code>KPOINTS</code>文件的最后一行。因此， 使用 <code>&gt;&gt;</code> 不会将<code>KPOINTS</code>之前的内容替换掉。如果目录下没有<code>KPOINTS</code>文件，使用<code>&gt;&gt;</code>也会和<code>&gt;</code>一样，创建一个。</p>
<p>这里的 <code>0</code> 代表自动生成网格：automatic generation scheme </p>
<p>C.4) 第三行：将 Gamma-centered 输出到<code>KPOINTS</code>的第三行里面，你需要知道G代表的是什么意思。如果你想用Monkhorst-Pack Grids，echo后面怎么写你要知道。建议一直用Gamma-centered。</p>
<p>C.5) 第4行：将<code>$1 $2 $3</code>输出到<code>KPOINTS</code>的第四行里面。</p>
<p>在这里，<code>$1 $2 $3</code>称为：arguments</p>
<p>代表的是我们运行脚本命令的时候，加入的三个方向上KPOINTS的数目。通过<code>$1 $2 $3</code>传递给 echo 命令。</p>
<p>如果不理解的话，跳过，等运行命令的时候就明白了。</p>
<p>C.6）第5行：Kpoints网格在三个方向的移动。一般来说0 0 0 即可。</p>
<p><strong>2.2 脚本运行：</strong> </p>
<p>A)     调用bash运行脚本：</p>
<p><img src="/2017/12/21/A04/A04-2.jpg" alt=""></p>
<p>图中我们运行脚本的时候命令为：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash kpoints.sh 3 3 1</span><br></pre></td></tr></table></figure><br>bash 意思是我们调用bash来执行该脚本；</p>
<p>kpoints.sh 为脚本的名称, 当然啦，名字可以任意换， .sh也可以不用加；</p>
<p>3 3 1 为脚本后面的参数，第一个3 对应脚本里面的<code>$1</code>, 第二个3 为<code>$2</code>,  1 为脚本里面的<code>$3</code></p>
<p>B）赋予脚本可执行权限： </p>
<p><img src="/2017/12/21/A04/A04-3.jpg" alt=""></p>
<p>赋予权限：<code>chmod  u+x  kpoint.sh</code></p>
<p>取消权限：<code>chmod u-x kpoint.sh</code></p>
<p>你会发现之前白色的脚本变成绿色的了，这说明本脚本可以执行了。不同电脑可能显示的颜色不容，有些甚至都不显示，大家不要纠结。但图中直接输入<code>kpoints.sh  3 3 1</code> 的时候失败了，我们必须用<code>./ kpoints.sh 3 3 1</code> 来执行。原因是系统不知道我们把脚本放在这里了。</p>
<p>怎么样才可以直接使用这个命令呢？ 将脚本转移到<code>~/bin</code> 文件夹中即可，如果你的系统中没有<code>~/bin</code> 这个文件夹，<code>mkdir ~/bin</code> 创建一下就完事。</p>
<p><img src="/2017/12/21/A04/A04-4.jpg" alt=""></p>
<p>OK，现在大功告成。我们可以根据之前的经验规则设置<code>KPOINTS</code>文件了。 </p>
<p><strong>2.3 脚本升级： 版本2</strong> </p>
<p>前面的脚本实现了我们所期望的功能，这里我们所说的升级，无非就是在前面的基础上再增添点东西，使得脚本看起来更加高大上，具有可读性或者更加智能化。这里我们主要介绍一下使用# 注释自己的脚本，使其可以被广大吃瓜群众所理解和接受。 </p>
<p><img src="/2017/12/21/A04/A04-5.jpg" alt=""></p>
<p>a）加入第一行，<code>#!</code>称为shebang （就是拼音，没错！）表示执行该脚本时会调用后面的程序；自行百度shebang的用途；</p>
<p>b）   3-5行中用 <code>#</code> 注释下，简单介绍本脚本的功能， 作者，使用方法；</p>
<p>c）   7-11 行用 <code>#</code> 注释下每一行命令中的作用。</p>
<p>d）由于每个人写脚本的方式和风格不同，脚本的注释对于方便大家理解非常有用。有时候即使自己写的脚本，一年半载之后也会忘记里面的内容，加上注释，会让我们快速掌握脚本里面的内容，在后期的维护或者升级中也发挥着重大的作用。</p>
<p><strong>2.4 其他升级：</strong></p>
<p>除了注释外，可以将脚本写的更加智能化，通过调控 <code>$1 $2 $3</code> 等脚本后面的参数, 加入一些<code>if</code>语句等，来实现<code>KPOINTS</code>文件中所有行均可以通过命令进行修改。比如：<code>kpoints.sh G 3 3 1</code> 和 <code>kpoints.sh M 3 3 1</code> 分别生成Gamma centered 和正常的MP 网格。</p>
<p>Linux下面还可以使用其他的方式来生成脚本，总之选择的方法很多。</p>
<p><strong>3  扩展练习：</strong> </p>
<p>3.1）重复本节所有操作，写人生中的第一个脚本；</p>
<p>3.2）网上搜索bash资料，认真练习。</p>
<p>3.3）<code>bash</code>在linux下处理日常工作非常有用，但数据分析的时候能力就有所欠缺了，建议大家学习<code>python</code>。Python有2.X和3.X的版本，2.X开始逐渐被抛弃，建议大家直接学习3.X的。</p>
<p><strong>4</strong> <strong>总结：</strong></p>
<p>看完本节，你会初步了解脚本是怎么写出来的，它是怎么执行的以及对战胜了对写脚本的恐慌心理。当你获得一个脚本的时候，尝试着打开它，将其中的语言分解成若干命令执行，查看该脚本的工作流程。勤学苦练，就可以流利地写属于自己的脚本了。在这方面多花一分钟，以后节省的就不是一分钟的事情了，当然也有可能会多花几分钟。但多学习点东西总归是好的。</p>
]]></content>
      <categories>
        <category>LVASPTHW附录</category>
      </categories>
      <tags>
        <tag>KPOINTS</tag>
        <tag>脚本</tag>
        <tag>Bash</tag>
      </tags>
  </entry>
  <entry>
    <title>通过Ubuntu连接服务器的方法</title>
    <url>/2017/11/18/A01/</url>
    <content><![CDATA[<p>本教程主要讲述的是如何在Ubuntu16.04操作系统上连接国科智算超算。分3部分：</p>
<ul>
<li>1）前期准备； </li>
<li>2）连接和挂载超算中心； </li>
<li>3）数据传输测试。</li>
</ul>
<p>在使用本教程前，首先确认已经收到了超算管理员分配的秘钥。通过Vim或者其他文本编辑工具，可以查看一下这个秘钥。超算中心好比是一个宝藏，这个宝藏的大门上有把锁，而开启这把锁的钥匙，就是管理员给我们的秘钥。</p>
<h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>下面的工作，一步一步来，相信99.99% 的人都可以顺利完成。</p>
<ul>
<li>为了方便理解，本人将管理员给的秘钥重新命名了一下。将下面的999改成管理员给你的那个数字。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@bigbro:~$ cp  ~/Desktop/id_rsa_gkzshpc999.gkzshpc999  .ssh/my_key</span><br></pre></td></tr></table></figure>
<p>经过上面的一步，管理员给的秘钥就被我们命名成：my_key了。这好比是我们在钥匙上贴了个标签，开门的时候直接找这个标签对应的钥匙就可以了。</p>
<p>如果你的Ubuntu系统下没有 .ssh 文件夹，可以自己先建一个，然后再运行上面的命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@bigbro:~$ mkdir .ssh</span><br></pre></td></tr></table></figure>
<ul>
<li><p>安装sshfs </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@bigbro:~$ sudo apt-get install sshfs </span><br><span class="line">[sudo] password <span class="keyword">for</span> qli: </span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree       </span><br><span class="line">Reading state information... Done</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建挂载国科智算的文件目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@bigbro:~$ mkdir gkzs</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开~/.bashrc文件，并添加下面的两行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> gkzs=<span class="string">&#x27;ssh -i /home/qli/.ssh/my_key  gkzshpc999@59.49.37.9 -p 9236&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> mgkzs=<span class="string">&#x27;sshfs -o IdentityFile=/home/qli/.ssh/my_key  -p 9236 gkzshpc999@59.49.37.9:  /home/qli/gkzs&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面我们的两行alias后面的内容主要为：</p>
<ul>
<li>我们的手（ssh）拿着钥匙（-i /home/qli/.ssh/my_key） 打开大门 （gkzshpc999@59.49.37.9 -p 9236）</li>
<li>我们的手（sshfs）拿着钥匙 （-o IdentityFile=/home/qli/.ssh/my_key） 打开大门 （-p 9236 gkzshpc999@59.49.37.9）后，并将宝藏运回家（/home/qli/gkzs） </li>
</ul>
</li>
<li><p>source 一下 ~/.bashrc 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@bigbro:~$ . ~/.bashrc</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="连接超算中心"><a href="#连接超算中心" class="headerlink" title="连接超算中心"></a>连接超算中心</h3><p>上面的工作完成之后，剩下的就是命令操作的事情了：</p>
<ul>
<li><p>连接超算中心：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@bigbro:~$ ls</span><br><span class="line">Desktop  Documents  Downloads  gkzs  lvliang  Music  Pictures  Public  SCVPN  teklahome  Templates  Videos</span><br><span class="line">qli@bigbro:~$ gkzs</span><br><span class="line">Last login: Thu Nov 22 05:07:16 2018 from 80.29.50.15</span><br><span class="line">[gkzshpc999@login02 ~]$ ls</span><br><span class="line">perl5</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开新的一个Terminal，我们挂载超算中心到我们的电脑上面，以便传输数据。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@bigbro:~$ ls</span><br><span class="line">Desktop  Documents  Downloads  gkzs  lvliang  Music  Pictures  Public  SCVPN  teklahome  Templates  Videos</span><br><span class="line">qli@bigbro:~$ ls gkzs/</span><br><span class="line"> </span><br><span class="line">qli@bigbro:~$ mgksz</span><br><span class="line">qli@bigbro:~$ ls gkzs/</span><br><span class="line">perl5</span><br></pre></td></tr></table></figure>
<h3 id="数据传输测试"><a href="#数据传输测试" class="headerlink" title="数据传输测试"></a>数据传输测试</h3><ul>
<li><p>在连接到服务器的界面：我们创建一个文件：mount_test。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[gkzshpc999@login02 ~]$ <span class="built_in">echo</span>  <span class="string">&#x27;I love BigBro&#x27;</span> &gt;  mount_test</span><br><span class="line">[gkzshpc999@login02 ~]$ ls</span><br><span class="line">mount_test  perl5</span><br><span class="line">[gkzshpc999@login02 ~]$ cat mount_test </span><br><span class="line">I love BigBro</span><br><span class="line">[gkzshpc999@login02 ~]$ </span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>在挂载的目录下查看：目录下多出来了刚刚创建的 mount_test文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@bigbro:~$ <span class="built_in">cd</span>  gkzs/</span><br><span class="line">qli@bigbro:~/gkzs$ ls</span><br><span class="line">mount_test  perl5</span><br><span class="line">qli@bigbro:~/gkzs$ cat mount_test </span><br><span class="line">I love BigBro</span><br><span class="line">qli@bigbro:~/gkzs$ </span><br><span class="line">qli@bigbro:~/gkzs$ cp ~/Desktop/CONTCAR  .</span><br><span class="line">qli@bigbro:~/gkzs$ ls</span><br><span class="line">CONTCAR  mount_test  perl5</span><br><span class="line">qli@bigbro:~/gkzs$ </span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面的最后操作中，我们从桌面上复制了一个CONTCAR到挂载的目录下，然后查看下服务器的终端：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[gkzshpc999@login02 ~]$ ls</span><br><span class="line">CONTCAR  mount_test  perl5</span><br><span class="line">[gkzshpc999@login02 ~]$ head -n 5 CONTCAR  </span><br><span class="line">Ru\(0\0\1)                              </span><br><span class="line">   1.00000000000000     </span><br><span class="line">     8.1377999784000004    0.0000000000000000    0.0000000000000000</span><br><span class="line">     4.0688999892000002    7.0475415119999996    0.0000000000000000</span><br><span class="line">     0.0000000000000000    0.0000000000000000   21.5631999968999999</span><br><span class="line">[gkzshpc999@login02 ~]$ </span><br></pre></td></tr></table></figure>
<p>完成了上面的操作，下面你就可以将自己电脑上准备的一些计算文件或者文件夹通过命令复制到超算中心，然后就可以提交任务了。</p>
]]></content>
      <categories>
        <category>LVASPTHW附录</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>超算中心</tag>
        <tag>sshfs</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令之cd使用心得</title>
    <url>/2017/12/20/A03/</url>
    <content><![CDATA[<h1 id="科研狗必备技能"><a href="#科研狗必备技能" class="headerlink" title="科研狗必备技能"></a>科研狗必备技能</h1><p>前面27节，我们已经通过气相分子的例子，带领大家顺利度过了菜鸟这一关。如果你掌握了其中的思想，勤加操练，看官网，认真阅读看大师兄推荐的参考书，相信你的能力足以甩出那些整天只知道搜集VASP学习资料，搜集DFT阅读书籍，而不去行动的人好几条街了。科研忌讳的就是眼高手低，你学到的知识和你下载的书成反比。</p>
<p>在菜鸟篇结束之后，大师兄需要把自己日常工作的一些小技巧展示给大家。一是作为大家摆脱菜鸟身份的奖励，二来为大家的进阶篇做好准备。今天我们主要讲解一下cd命令。 </p>
<p>在Linux系统下，cd是必不可少的一个命令: cd 可以实现进入文件夹，返回上一级文件夹等操作等，日常操作中一些简单的做法可以极大的简化我们的工作方式，减轻手指的负担，有效避免键盘手的形成。大师兄结合自己多年来理论计算化学的操作实践，简单列举了一些组合使用 cd 命令的方法，希望大家可以熟练使用。 </p>
<p><strong>注意：</strong> 本节没有大师兄的截图操作，大家需要认真练习，思考这些命令是怎么运行的。希望大家阅读完本文后，按照内容练习一番，至少要达到高级篇的水平。此外，本节内容和前面的密切相关，如果前面没有掌握的话，在具体的应用部分中阅读起来会有些吃力。此时，建议从头学习。</p>
<p><strong>1  菜鸟篇：</strong> 正常使用 cd 命令 </p>
<p>进入文件夹： <code>cd  xxx/xxx/xxx</code></p>
<p>返回上一级： <code>cd ..</code></p>
<p>返回上二级：<code>cd ../..</code></p>
<p><strong>2  初出茅庐：</strong> 懂得如何快速返回原来的文件夹目录</p>
<p>1)：<code>cd  -</code></p>
<p>2)：<code>cd  $OLDPWD</code></p>
<p>两者效果是一样的，区别是前者会在屏幕显示上一级的目录。</p>
<p>具体使用参见本书前面几节关于VASP批量操作的相关内容，<strong>尤其是在批量提交任务中的应用</strong>。这个命令一定一定一定要掌掌掌掌…握！！！</p>
<p><strong>3 进阶篇：</strong> 知道如何结合 cd 与 alias</p>
<p>试想一下，如果你的文件系统下，一层套一层，好东西藏的很深（大师兄内心荡漾着邪恶清脆的笑声），问题是，当你进入这个文件夹，后退时需要不停地敲击：<code>cd ../../../../../../../..</code>   </p>
<p>为避免这样的麻烦，可以这么做:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias ..=&#x27;cd ../../&#x27;</span><br><span class="line">alias ...=&#x27;cd ../../../&#x27;</span><br><span class="line">alias ....=&#x27;cd ../../../..&#x27;</span><br></pre></td></tr></table></figure><br>每个点代表向上返1级目录，后面自己补上，大师兄手指头不想继续写了。</p>
<p><strong>注意：</strong></p>
<p>1）：不要设置  <code>alias **.**=&#39;cd ../&#39;</code>  因为 <code>**.**</code> 在linux里面等于 <code>source</code> 命令。</p>
<p>2）：等号左右没有空格。</p>
<p>3）：等号右侧命令需要用单引号或者双引号括起来， 最好是用单引号。</p>
<p>不会的请自己查找前面关于<code>alias</code>的介绍章节。 </p>
<p><strong>4 高级篇：</strong> <code>cd</code> 与 <code>alias</code>、<code>&amp;</code> 、<code>ls</code>的结合</p>
<p>大师兄linux走火入魔，养成了一个进入文件夹就敲击 <code>ls</code> 命令的习惯，但是也舍不得折磨我那双精细的老手，于是，就组合了<code>cd</code>、<code>alias</code>、<code>&amp;</code>、和<code>ls</code> 命令，如下<code>alias ....=&#39;cd ../../../.. &amp;&amp; ls&#39;</code></p>
<p>这样你敲击4个点 <code>....</code>  返回上面4级目录的时候， 自动显示当前目录下的所有东西，避免再一次敲击<code>ls</code> 命令了。</p>
<p>在这里我们用到的是 <code>&amp;&amp;</code> 这个命令，它表示如果前面的命令成功了就进行 <code>&amp;&amp;</code> 的命令。</p>
<p>无聊的师弟师妹们可以这样玩一下：<code>cd ../../../.. &amp;&amp; cd -</code></p>
<p>但是如果 <code>&amp;&amp;</code> 前面的命令失败了，直接退出，后面的便不会运行，这种情况下你就需要用到  <strong>双排管</strong> 这个命令了。</p>
<p>什么是双排管？　答：　<strong>||</strong>　（中间没有空格，大师兄给起的名字）</p>
<p>师兄，这玩意怎么使用？ 看下面的例子就明白了：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ../abc &amp;&amp; ls</span><br></pre></td></tr></table></figure><br>上一级目录没有abc文件夹，<code>&amp;&amp;</code> 前面命令的失败了，<code>ls</code> 不会运行。</p>
<p><code>cd ../abc || ls</code>  上一级目录没有abc文件夹， <code>||</code>  前面命令的失败了，<code>ls</code>依然会运行。</p>
<p>此外，还有单管 <code>|</code>  （pipe）这个 命令，后面一般跟着前面一步结束的进一步操作。比如：</p>
<p>1）  <code>head –n 10 POSCAR | tail –n 1</code></p>
<p>2）  <code>grep &#39;  without&#39;  OUTCAR | tail  -n 1</code></p>
<p>3）  <code>grep &#39;  without&#39;  OUTCAR | awk &#39;&#123;print $4&#125;&#39;</code></p>
<p>4）  前面获取零点能的就是一个很好的例子</p>
<p>5）  ……（大家自由发挥） </p>
<p><strong>5  cd 私人定制篇</strong></p>
<p>如果你的一个课题的计算都在一个文件夹里面，可以这么设置，下次敲击命令时直接进入这个文件夹<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias xxx=&#x27;cd ~/bigbro/a/b/c/d/e/f/g/h/i/k&#x27; </span><br></pre></td></tr></table></figure><br>藏得这么深（师弟们懂的！），肯定是好东西，不拿出来分享愧对大师兄谆谆教诲！学会了这个命令，就避免了用鼠标乱点进入目录了。还可以避免文件找不到…. </p>
<p><strong>6 cd 整蛊篇</strong></p>
<p>如果你闲的蛋疼，还可以尝试着在办公室其他人的Linux终端下这样设置alias。二选一即可。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias cd=&#x27;cd ~&#x27;</span><br><span class="line">alias cd=&#x27;echo &quot;you are a dumbass&quot; &#x27;</span><br></pre></td></tr></table></figure></p>
<p>大家好好练习这些关于cd的基本命令，等手指头熟悉了cd的味道，大师兄下一节就会继续传授给大家其他的高级操作，进一步减轻手指头的负担。</p>
]]></content>
      <categories>
        <category>LVASPTHW附录</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>cd</tag>
        <tag>alias</tag>
      </tags>
  </entry>
  <entry>
    <title>自动生成POTCAR的脚本</title>
    <url>/2017/12/21/A05/</url>
    <content><![CDATA[<p>前面我们介绍了KPOINTS的小脚本的写法，本节我们主要讲解一下生成POTCAR的脚本。学习完本节，脚本的神秘色彩基本烟消云散，大家都可以尝试写自己的脚本了。再强调说明三点：</p>
<p>1）Windows用户不要用记事本写脚本;</p>
<p>2）Windows用户写完脚本后，在服务器上先运行：<code>dos2unix XXX</code>  (<code>XXX</code> 是你的脚本名)</p>
<p>3）Windows用户，如果计算出错，第一个要排除的是自己提交任务前有没有运行：<code>dos2unix</code>.</p>
<p><strong>1</strong> <strong>手动示例：</strong></p>
<p>比如我们POSCAR中包含有Cu C H O 四种种元素，那么我们就需要按照顺序生成一个对应的POTCAR。首先回顾一下前面介绍的POTCAR的制备方法：</p>
<p>1.1）获取这四个元素各自的POTCAR：并命名成<code>POTCAR_Cu</code>,<code>POTCAR_C</code>,<code>POTCAR_H</code>,<code>POTCAR_O</code></p>
<p>1.2）使用cat 命令将这四个POTCAR合并在一起：<code>cat POTCAR_Cu  POTCAR_C POTCAR_H POTCAR_O &gt; POTCAR</code></p>
<p>前面我们学过了 <code>&gt;</code> 的使用。分步练习：第一步将这些元素的POTCAR全部打印出来：</p>
<p><code>cat  POTCAR_Cu  POTCAR_C POTCAR_H POTCAR_O</code></p>
<p>第二步：将打印出来的内容通过 <code>&gt;</code>  保存到最终的POTCAR里面。</p>
<p><strong>脚本目的：</strong></p>
<p>自动从赝势库中提取所需元素的POTCAR并将它们合并在一起。我们赝势库的目录为：<code>/THFS/home/iciq-lq/bin/pot</code> 这个pot文件夹（我自己随便命名的）就包含了VASP的所有元素的POTCAR，最好放在一个不经常变动的地方，这里我们放到了<code>~/bin</code>目录里面。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/bin/pot$ ls</span><br><span class="line">Ac At_sv_GW  Bi_sv_GW  C_GW  C_s ....</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/bin/pot$ ls B*</span><br><span class="line">B:</span><br><span class="line">POTCAR  PSCTR</span><br><span class="line"></span><br><span class="line">Ba_sv:</span><br><span class="line">POTCAR  PSCTR</span><br><span class="line"></span><br><span class="line">Ba_sv_GW:</span><br><span class="line">POTCAR  PSCTR</span><br><span class="line"></span><br><span class="line">Be:</span><br><span class="line">POTCAR  PSCTR</span><br><span class="line"></span><br><span class="line">Be_GW:</span><br><span class="line">POTCAR  PSCTR</span><br></pre></td></tr></table></figure>
<p>所以我们可以使用下面的命令生成POTCAR：(不将这几个POTCAR先保存到当前目录下，直接调用赝势库中的POTCAR)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq$ cat /THFS/home/iciq-lq/bin/pot/Cu/POTCAR  /THFS/home/iciq-lq/bin/pot/C/POTCAR /THFS/home/iciq-lq/bin/pot/H/POTCAR  /THFS/home/iciq-lq/bin/pot/O/POTCAR  &gt; POTCAR</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq$ grep TIT POTCAR</span><br><span class="line">   TITEL  = PAW_PBE Cu 22Jun2005</span><br><span class="line">   TITEL  = PAW_PBE C 08Apr2002</span><br><span class="line">   TITEL  = PAW_PBE H 15Jun2001</span><br><span class="line">   TITEL  = PAW_PBE O 08Apr2002</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq$</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但这样子也很麻烦。</p>
<p><strong>2</strong> <strong>脚本预览：</strong></p>
<p>首先看下自动生成POTCAR的脚本，大家尽量先不看下面的解释，自己理解一下脚本的整个框架和运行的流程;</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="comment"># Create a GGA_PAW POTCAR file</span></span><br><span class="line"><span class="comment"># by BigBro  </span></span><br><span class="line"><span class="comment"># To Use it： potcar.sh Cu C H O</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define local potpaw_GGA pseudopotentialrepository:</span></span><br><span class="line">repo=<span class="string">&quot;/THFS/home/iciq-lq/bin/pot&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Check if older version of POTCAR ispresent</span></span><br><span class="line"><span class="keyword">if</span> [ -f POTCAR ] ; <span class="keyword">then</span></span><br><span class="line"> mv -f POTCAR old-POTCAR</span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot; ** Warning: old POTCAR file found and renamed to &#x27;old-POTCAR&#x27;.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Main loop - concatenate the appropriatePOTCARs (or archives)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $*</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"> <span class="keyword">if</span> <span class="built_in">test</span> -f <span class="variable">$repo</span>/<span class="variable">$i</span>/POTCAR ; <span class="keyword">then</span></span><br><span class="line">  cat <span class="variable">$repo</span>/<span class="variable">$i</span>/POTCAR&gt;&gt; POTCAR</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot; ** Warning: No suitable POTCAR for element &#x27;<span class="variable">$i</span>&#x27; found!! Skipped thiselement.&quot;</span></span><br><span class="line"> <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>讲解，这个脚本里面：</p>
<p>1）首先我们先设定赝势库的目录;<code>repo=&quot;/THFS/home/iciq-lq/bin/pot&quot;</code> <strong>等号前后不能有空格</strong>！！！</p>
<p>2）然后我们检查一下当前目录下是否存在POTCAR，如果存在的话，将其重命名为：<code>POTCAR-old</code>, 并输出警告信息。这里我们学到的是 <code>if</code> 句型：<code>if [ ] ; then; fi</code> 。<code>[]</code> 中间是if判断的条件，如果成立，则继续执行<code>then</code>后面的动作。</p>
<p><strong>if [ -f POTCAR ]; then</strong>  意思是如果存在POTCAR这个文件，那么… <strong>注意：</strong></p>
<p>a）<code>[ ]</code> 和里面的内容 <strong>–f POTCAR</strong> 要通过空格分开。所以：</p>
<ul>
<li><p><code>if [-f POTCAR ]</code>（<code>[</code> 和<code>-f</code>之间没有空格）</p>
</li>
<li><p><code>if [ -f POTCAR]</code> (<code>POTCAR</code> 和<code>]</code> 之间没有空格)</p>
</li>
<li><p><code>if [-f POTCAR]</code>（<code>-f</code>，<code>POTCAR</code>和 <code>[]</code> 之间都没有空格）</p>
</li>
</ul>
<p>这三种写法都是错误的;<strong>if [  -f POTCAR  ]</strong> 是正确的</p>
<p>b）<code>then</code> 后面如果另起一行的话，分号 （<strong>;</strong>） 可加可不加<code>;</code></p>
<p>c）<code>then</code> 后面的内容如果和then 在同一行，必须加上分号（<strong>;</strong>） ，前后有无空格均可，建议加上，这样语言会很清晰;</p>
<p>d）<code>then</code> 后面的命令执行完毕后，要加上 <code>fi</code> 结束。同理，如果<code>fi</code> 另起一行，则前面可以不加<code>;</code>如果<code>fi</code> 和 <code>then</code> 后面执行的命令在一行，前面需要加上分号（<strong>;</strong>）。</p>
<p>3）生成新的POTCAR文件; 这里我们用到的是一个<code>for</code>循环：</p>
<p>a)  <code>for i in $*</code></p>
<p>这一行的意思是，对于命令后面的所有参数（arguments），前面一节我们已经学过了<code>$1 $2 ...</code> 的含义，这里用的<code>$*</code> 可以让我们在命令后面加任意数目的参数<code>;</code>因为另起了一行，后面加不加分号（<code>;</code>）不重要。</p>
<p>b） <code>do</code>  执行的意思</p>
<p>c）<code>do</code>后面有个<code>if</code> 语句，如果目录下面是POTCAR的话，那么使用<code>cat</code> 命令将所有<code>$*</code>对应的POTCAR输出到最新的POTCAR中，注意，这里我们用到的是<code>&gt;&gt;</code>; 因为<code>for</code>循环是对于后面的参数挨个执行的。</p>
<p>d) 有两个<code>elif</code>，判断目录下的另外两个POTCAR文件的格式，如果是POTCAR.Z 文件的话，则使用<code>zcat</code> 将其输出到最新的POTCAR<code>;</code>如果是POTCAR.gz 文件的话，则使用gunzip –c 命令。</p>
<p>e）<code>else</code> 指的是除了前面三种以外的情况，如果POTCAR，POTCAR.Z或者POTCAR.gz都不存在，那么使用<code>echo</code>命令，输出警告，提醒用户检查。</p>
<p>f）使用<code>fi</code> 结束<code>if</code> 语句</p>
<p>g）使用 <code>done</code> 结束 <code>for</code> 循环。</p>
<p><strong>3</strong> <strong>运行脚本：</strong> </p>
<p>3.1）赋予脚本可执行权限，然后将其转移到主目录下的bin文件夹中，前面几节已经讲过了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod u+x potcar.sh</span><br><span class="line">mv potcar.sh ~/bin</span><br></pre></td></tr></table></figure>
<p>3.2 运行实例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq$ ls</span><br><span class="line">bin  LVASPTHW  old-POTCAR  POTCAR  potcar.sh  test_jobs</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq$ potcar.sh Cu C H O</span><br><span class="line"> ** Warning: old POTCAR file found and renamed to <span class="string">&#x27;old-POTCAR&#x27;</span>.</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq$ ls</span><br><span class="line">bin  LVASPTHW  old-POTCAR  POTCAR  potcar.sh  test_jobs</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq$ grep TIT POTCAR</span><br><span class="line">   TITEL  = PAW_PBE Cu 22Jun2005</span><br><span class="line">   TITEL  = PAW_PBE C 08Apr2002</span><br><span class="line">   TITEL  = PAW_PBE H 15Jun2001</span><br><span class="line">   TITEL  = PAW_PBE O 08Apr2002</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq$</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq$ potcar.sh BigBro</span><br><span class="line"> ** Warning: old POTCAR file found and renamed to <span class="string">&#x27;old-POTCAR&#x27;</span>.</span><br><span class="line"> ** Warning: No suitable POTCAR <span class="keyword">for</span> element <span class="string">&#x27;BigBro&#x27;</span> found!! Skipped thiselement.</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq$</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当前目录下存在POTCAR，脚本会给出警告，将其重命名为old-POTCAR，然后生成新的POTCAR文件，包含Cu C H O 这四种元素。如果有一个元素不存在（上面实例总的BigBro），potcar库里找不到，则输出错误提示。</p>
<p><strong>注意！注意！注意！</strong></p>
<p>上面例子中的错误，还可能是因为：</p>
<ul>
<li><p>1） 你的POSCAR的格式有问题（Windows用户常见的问题），如果发现这个错误，先运行下：<code>dos2unix POSCAR</code> 这个命令排除是Windows的格式问题。</p>
</li>
<li><p>2） 如果还不能解决，去你的POTCAR库里面找找，是不是真的没有这个元素的POTCAR文件。</p>
</li>
</ul>
<p><strong>4</strong> <strong>脚本分析：</strong> </p>
<p>4.1）生成一些特殊的POTCAR文件：</p>
<p>我们知道，每一个元素存在好几个不同的POTCAR，如图：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/bin/pot$ ls Cu*</span><br><span class="line">Cu:</span><br><span class="line">POTCAR  PSCTR</span><br><span class="line"></span><br><span class="line">Cu_GW:</span><br><span class="line">POTCAR  PSCTR</span><br><span class="line"></span><br><span class="line">Cu_pv:</span><br><span class="line">POTCAR  PSCTR</span><br><span class="line"></span><br><span class="line">Cu_sv_GW:</span><br><span class="line">POTCAR  PSCTR</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/bin/pot$ ls H</span><br><span class="line">H/        H1<span class="number">.33</span>/    H1<span class="number">.66</span>/    H<span class="number">.25</span>/     H<span class="number">.42</span>/     H<span class="number">.58</span>/     H<span class="number">.75</span>/     He/       He_GW/    Hf_pv/    Hf_sv_GW/ Hg_sv_GW/ H_h/      Ho/       H_s/</span><br><span class="line">H1<span class="number">.25</span>/    H1<span class="number">.5</span>/     H1<span class="number">.75</span>/    H<span class="number">.33</span>/     H<span class="number">.5</span>/      H<span class="number">.66</span>/     H_AE/     He_AE/    Hf/       Hf_sv/    Hg/       H_GW/     H_h_GW/   Ho_3/</span><br></pre></td></tr></table></figure>
<p>当我们需要使用 Cu_pv, C，H1.25，和O对应的POTCAR时，我们需要这样执行命令： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq$ ls</span><br><span class="line">bin  LVASPTHW  test_jobs</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq$ potcar.sh Cu_pv C H1.25 O</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq$ ls</span><br><span class="line">bin  LVASPTHW  POTCAR  test_jobs</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq$ grep TIT POTCAR</span><br><span class="line">   TITEL  = PAW_PBE Cu_pv 06Sep2000</span><br><span class="line">   TITEL  = PAW_PBE C 08Apr2002</span><br><span class="line">   TITEL  = PAW_PBE H1.25 07Sep2000</span><br><span class="line">   TITEL  = PAW_PBE O 08Apr2002</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq$</span><br></pre></td></tr></table></figure>
<p>因此，如果我们使用脚本的时候直接输入元素符号，默认读取的是与该元素符号相对应文件下的POTCAR。 </p>
<p><strong>5 读取POSCAR，自动生成POTCAR （防止出错的一个秘诀）</strong> </p>
<p>在我们的计算中，可以通过读取POSCAR中的元素信息，生成对应的POTCAR文件，这样可以避免POSCAR中元素和POTCAR中不一致的情况。那么我们需要怎么做呢？</p>
<p>5.1 首先我们要获取POSCAR中的元素信息： 查看一下POSCAR文件,发现元素信息在第6行，因此加了一个tail命令提取出来：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/potcar$ ls</span><br><span class="line">POSCAR</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/potcar$ head -n 6 POSCAR</span><br><span class="line">Ru   H</span><br><span class="line">   1.00000000000000</span><br><span class="line">   8.1377999784000004   0.0000000000000000   0.0000000000000000</span><br><span class="line">   4.0688999892000002   7.0475415119999996   0.0000000000000000</span><br><span class="line">   0.0000000000000000   0.0000000000000000  21.5631999968999999</span><br><span class="line">Ru   H</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/potcar$ head -n 6 POSCAR  | tail -n 1</span><br><span class="line">Ru   H</span><br></pre></td></tr></table></figure>
<p>5.2 使用我们刚刚写出来的脚本，通过使用<code>$()</code>调用前面命令的结果: （将获取的元素信息作为脚本命令的参数） </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/potcar$  potcar.sh  $(head -n 6  POSCAR | tail -n 1)</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/potcar$ grep TIT POTCAR</span><br><span class="line">   TITEL  = PAW_PBE Ru 04Feb2005</span><br><span class="line">   TITEL  = PAW_PBE H 15Jun2001</span><br></pre></td></tr></table></figure>
<p><strong>大功告成！！！！</strong> </p>
<p>5.3 不想每次输入这么长的命令：可以将其写进 ~/.bashrc文件中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias pos2pot=&quot;potcar.sh  $(head -n 6 POSCAR  | tail -n 1)&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/potcar$ ls</span><br><span class="line">POSCAR  POTCAR</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/potcar$ vi ~/.bashrc</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/potcar$ . ~/.bashrc</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/potcar$ pos2pot</span><br><span class="line"> ** Warning: old POTCAR file found and renamed to &#x27;old-POTCAR&#x27;.</span><br></pre></td></tr></table></figure>
<p>5.4 看完上面的部分，相信大家已经可以掌握很多内容了，额外福利，大师兄本人并没有使用<code>head -n 6 POSCAR  | tail -n 1</code> 来获取POSCAR中的元素信息。而是使用的sed命令： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/potcar$ sed -n 6p POSCAR</span><br><span class="line">Ru   H</span><br></pre></td></tr></table></figure>
<p><strong>6</strong> <strong>扩展练习：</strong> </p>
<p>6.1）手动将这个脚本打一遍，理解里面的内容，如果出错了，对比我的脚本，进行改正，直至可以正确运行为止;</p>
<p>6.2）去官网查看POTCAR相关的内容，了解每一个元素不同的POTCAR之间的区别，例如：Cu 和 Cu_pv</p>
<p>6.3) 复习<code>alias</code>，学习本文第5节的方法，思考一下，如何通过操控脚本，避免计算中的一些失误，有了自己的想法后，通过脚本付诸实践。</p>
<p><strong>7</strong> <strong>总结：</strong></p>
<p>写到这里，相信大家对于Linux系统下的一些基本操作已经熟练掌握了，脚本的怎么写，怎么去运行，心里也有了一个大致的了解，至少不会感觉写脚本是多么牛逼的工作了。这些内容都是我们保证计算准确，高效的很重要的一个因素。希望大家可以熟练掌握，最关键的是，要硬着头皮去练习，脚本看起来简单，等你写的时候就会出现各种各样的错误，只有不断练习，才能写出漂亮的脚本，提高自己的工作效率。 脚本已经上传至QQ群文件，也可百度网盘下载：链接：<a href="https://pan.baidu.com/s/1eqeVVOo5nzGJsfPgClNJDg">https://pan.baidu.com/s/1eqeVVOo5nzGJsfPgClNJDg</a>  </p>
]]></content>
      <categories>
        <category>LVASPTHW附录</category>
      </categories>
      <tags>
        <tag>脚本</tag>
        <tag>Bash</tag>
        <tag>POTCAR</tag>
      </tags>
  </entry>
  <entry>
    <title>VASP计算遇到错误怎么办？</title>
    <url>/2017/12/22/A06/</url>
    <content><![CDATA[<p>搞科研，总会遇到各种各样的问题需要解决，同样VASP计算也不例外，本文大师兄列举了一些解决问题的步骤和方法，只提供大体的方向，没有具体事例，大家结合自己的计算研究亲自去实践体会，写本文的目的是告诉大家：自己亲自解决问题才是你快速成长的加速器。 </p>
<p><img src="/2017/12/22/A06/A06-1.jpg" alt=""></p>
<h3 id="第1阶段："><a href="#第1阶段：" class="headerlink" title="第1阶段："></a>第1阶段：</h3><p> 靠自己（最重要的！） </p>
<p>1.1 凭自己的经验解决；</p>
<p>1.2 按照VASP的输出错误，进行修改解决；</p>
<p>1.3 查找VASP官网的相关参数；</p>
<p>1.4 平时多阅读VASP手册；</p>
<p>1.5 不懂的参数不要往INCAR里面放。</p>
<p><img src="/2017/12/22/A06/A06-2.jpg" alt=""></p>
<h3 id="第2阶段："><a href="#第2阶段：" class="headerlink" title="第2阶段："></a>第2阶段：</h3><p><strong>主动搜索（也是靠自己）</strong> </p>
<p>2.1 将错误信息复制到百度里面搜索，一般会得到一堆论坛或者博客的相关指导说明，按照里面的内容修改自己的输入文件，然后解决问题。</p>
<p><img src="/2017/12/22/A06/A06-3.jpg" alt=""></p>
<p>2.2  将错误信息复制到Google里面搜索，一般会得到VASP官网的论坛一节其他国外网址的相关错误示例，这时候，就要耐着性子把其中的内容读完，然后修改输入文件进行解决；一般来说，进行到这一步，至少60% 左右的问题可以解决!!! </p>
<h3 id="第3阶段："><a href="#第3阶段：" class="headerlink" title="第3阶段："></a>第3阶段：</h3><p><strong>靠师兄师姐，师弟师妹，老板</strong></p>
<p>如果时间过去2天，还没有解决。可以将自己的错误信息以及尝试的方法总结。</p>
<p>分享给组里的师兄弟，师姐妹们，寻求求助办法。如果还未解决，就要报告给自己的老师，求助指导！！！此时，解决的成功率应该能达到70-100% </p>
<p><strong>大师兄的建议</strong>：自己主动去解决是关键，这需要培养主动解决问题的能力。老板是辅助的策略，除了指导课题的方向，在学生遇到问题时能出马解决，这也是他或者她为什么是老板的原因之一。</p>
<h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h3 id="第4阶段（I）"><a href="#第4阶段（I）" class="headerlink" title="第4阶段（I）"></a>第4阶段（I）</h3><p><strong>论坛求助</strong></p>
<p>如果老板不给力（很多做实验的老板要求学生去做计算，大师兄本人极度鄙视这样的老板，完全就是对学生的不负责任！），可以去尝试论坛求助：这里大师兄推荐：</p>
<p><img src="/2017/12/22/A06/A06-5.jpg" alt=""></p>
<p>将问题复制到百度里面，你就会发现这个问题会在很多论坛里面出现。不过论坛求助有一点需要注意：发帖的人水平参差不齐，要抱着怀疑的态度去接受所有人的答复（<strong>记住，是所有人！！！</strong>），别人的回复只能当作参考。</p>
<p><strong>第4阶段（II）QQ群求助：</strong></p>
<p>这里大师兄列举了三个管理员认真负责的QQ群：</p>
<p>​                                                                               <strong>遇见大师兄</strong></p>
<p><img src="/2017/12/22/A06/A06-7.jpg" alt=""></p>
<p>​                                                                             <strong>第一性原理之家</strong></p>
<p><img src="/2017/12/22/A06/A06-8.jpg" alt=""></p>
<p>​                                                                                         <strong>物理化学材料互助群</strong></p>
<p><img src="/2017/12/22/A06/A06-9.jpg" alt=""></p>
<p>进行到这一步，基本上95%的问题可以解决了。 </p>
<p><strong>第5阶段：VASP官方论坛发帖</strong></p>
<p>以上都解决不了的话（极少的情况了），可以去VASP官网发帖求助，等待VASP的其他用户或者管理员解决。不过需要注册！</p>
<p><img src="/2017/12/22/A06/A06-10.jpg" alt=""></p>
<h3 id="第-6-阶段"><a href="#第-6-阶段" class="headerlink" title="第 6 阶段"></a>第 6 阶段</h3><p><strong>QQ群求助：</strong></p>
<p><strong>6.1 尊重别人的时间</strong></p>
<p>A）QQ群求助的时候，提供的信息要全面：</p>
<p>1）  算的什么体系</p>
<p>2） 算的什么内容</p>
<p>3）INCAR长什么样子</p>
<p>4）错误信息</p>
<p>5）KPOINTS以及POSCAR 很多人把图片一截，或者拿手机拍张照片就直接在群里求助了，这是对大家时间的极度不尊重。而且被应助的概率很低！！！你不尊重大家的时间，大家也不会浪费时间在你身上。 </p>
<p>B）可以将计算结果压缩，上传到QQ群文件进行求助（但不要把CHG，CHGCAR和WAVECAR等压缩到里面，因为它们太大，大家都懒得去下载！如果你上传了一个100M的求助文件，基本没人帮你！）</p>
<p>C）不要多群求助 有很多人加了很多群，把遇到的问题在所有的群里面都发了一遍！这样的行为简直就是在浪费大家的宝贵时间，本人见到这种情况，一般都不会去帮助。</p>
<p><strong>6.2</strong> <strong>把你得小心眼收起来！！！</strong> </p>
<p>A) 除了涉密的一些计算，其他情况没有必要给大家隐瞒什么，大家也不会坏到去抢你的课题去算！心胸狭隘的人也不配得到帮助！</p>
<p>B) 要虚心接受别人的批评，也就是心眼要大。大师兄也遇到很多奇葩，在群里求助，没人回答，就直接退群了。被别人批评了几句，也退群了。只能说这些没心胸的人也不值得去帮助。</p>
<p><strong>6.3</strong> <strong>互相帮助</strong></p>
<p>别人遇到的问题，如果你知道怎么解决，不要有所隐瞒。请认真帮助解决，用俺奶奶经常挂在嘴边的那句话：将心比心。这样大家的计算水平才可以得以普遍地提高。 请认真按照这个流程来解决问题，不要一出现问题，脑子不假思索就去论坛或者QQ群求助!!! 请记住，你的问题也代表了你的老板的水平。一般来说，不负责任的老板带出来的学生总会有各种各样的低级问题。 以上仅代表本人观点，不喜勿喷！祝大家踏踏实实做计算，多发实实在在的文章！</p>
<p>最后，新手的话，请认真学习Learn Vasp The Hard Way 这本书(www.bigbrosci.com) 按照大师兄写的内容，从头认真学习VASP（本书只作为参考，关键是去浏览官网！！！）；如果在学习中遇到问题，也可以把问题准备好，发送邮件给大师兄解决：lqcata@gmaill.com 最好不要直接QQ找我（拜托！）</p>
]]></content>
      <categories>
        <category>LVASPTHW附录</category>
      </categories>
      <tags>
        <tag>VASP出错</tag>
        <tag>解决问题</tag>
        <tag>QQ群</tag>
      </tags>
  </entry>
  <entry>
    <title>A07 Bader电荷计算</title>
    <url>/2011/12/23/A07/</url>
    <content><![CDATA[<p>最近，群里有人在问Bader电荷分析的问题，在这里，将Bader分析的基本流程，以及本人写的一个后处理的脚本分享一下，希望大家不要再纠缠这个问题了。大家务必认真浏览参考网址的内容。<a href="http://theory.cm.utexas.edu/henkelman/code/bader/">http://theory.cm.utexas.edu/henkelman/code/bader/</a> </p>
<p><img src="/2011/12/23/A07/A07-1.jpeg" alt=""></p>
<h1 id="计算流程"><a href="#计算流程" class="headerlink" title="计算流程"></a>计算流程</h1><h2 id="优化自己的体系结构"><a href="#优化自己的体系结构" class="headerlink" title="优化自己的体系结构:"></a>优化自己的体系结构:</h2><p>使用VASP计算，获得稳定的结构，过程略过。</p>
<h2 id="Bader电荷分析的计算部分"><a href="#Bader电荷分析的计算部分" class="headerlink" title="Bader电荷分析的计算部分:"></a>Bader电荷分析的计算部分:</h2><p>1) 将前面优化完的<code>CONTCAR</code> 重命名为<code>POSCAR</code></p>
<p>2) 设置INCAR:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LAECHG=.TRUE. </span><br><span class="line">LCHARG = .TRUE.</span><br><span class="line">NSW = 0</span><br><span class="line">IBRION = -1 ## 前面有了NSW = 0， 这个也可以不设置 </span><br></pre></td></tr></table></figure>
<p>3) <code>KPOINTS</code>可以用之前优化计算的，也可设置的稍微大些。</p>
<p>4) <code>WAVECAR</code>，<code>CHGCAR</code>等有的话就读一下(在第二步加上读它们的相关参数)。没有的话就不读了，这个无关紧要，不要纠结。<strong>但是</strong>，如果你的体系很难收敛的时候，建议保留上一步的WAVECAR以便节省计算时间，如果没有的话电子步数适当增加(NELM=200) 。 </p>
<h2 id="获取VTST的脚本"><a href="#获取VTST的脚本" class="headerlink" title="获取VTST的脚本"></a>获取VTST的脚本</h2><p>1)下载网址:</p>
<ul>
<li><p><a href="http://theory.cm.utexas.edu/vasp/scripts.html">http://theory.cm.utexas.edu/vasp/scripts.html</a>  (用到里面的chgsum.pl这个脚本)</p>
</li>
<li><p><a href="http://theory.cm.utexas.edu/henkelman/code/bader/">http://theory.cm.utexas.edu/henkelman/code/bader/</a>  (下载bader处理的脚本)</p>
</li>
</ul>
<p>2)将前面下载的内容解压，然后复制到<code>~/bin</code> 文件夹中。</p>
<p>3)如果后面运行的时候遇到权限问题:执行:</p>
<p><code>chmod u+x  ~/bin/chgsum.pl</code></p>
<p><code>chmod u+x  ~/bin/bader</code></p>
<h2 id="使用VTST的脚本处理结果"><a href="#使用VTST的脚本处理结果" class="headerlink" title="使用VTST的脚本处理结果"></a>使用VTST的脚本处理结果</h2><p>1) 进入计算的目录下面</p>
<p>2) <code>chgsum.pl AECCAR0 AECCAR2</code></p>
<p>注意: <code>AECCAR0</code>和<code>AECCAR2</code> 是由<code>LAECHG=.TRUE.</code>这个参数控制输出的。如果你计算没有得到这两个文件，仔细检查一下这个参数。</p>
<p>运行这个命令:你会得到类似这样的输出结果:</p>
<p><img src="/2011/12/23/A07/A07-2.jpeg" alt=""></p>
<p>结束后，你会得到 <code>CHGCAR_sum</code> 这个文件。</p>
<p>3) <code>bader CHGCAR -ref CHGCAR_sum</code></p>
<p><img src="/2011/12/23/A07/A07-3.jpeg" alt=""></p>
<p>注意:</p>
<p>i) 图中大师兄不小心把<code>CHGCAR</code>删掉了…所以没办法呈现完整的流程。放图上去只是想告诉大家，命令是正确的。ii) 如果你在服务器上运行，得到了这样的错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FATAL:kernel too old</span><br><span class="line">Segmentationfault</span><br></pre></td></tr></table></figure>
<p>那么，你需要将计算复制到本地电脑上(由于<code>CHGCAR</code>等文件很大，该过程比较蛋疼，需要忍一会儿)，然后用自己的电脑运行这个命令。(前提是电脑有<code>Linux</code>系统，没有的话，我也没办法。)</p>
<p>iii) 命令结束后，你会得到一些相应输出的文件：ACF.dat， BCF.dat， AVF.dat…</p>
<p>iv) 本人一般查看的是<code>ACF.dat</code>文件：（以SiH$_4$为例）</p>
<p>如下图:</p>
<p><img src="/2011/12/23/A07/A07-4.jpeg" alt=""></p>
<p>ACF.dat文件中，第一列的数字对应的是POSCAR中的原子顺序。</p>
<p>每个原子的电荷对应的是<code>CHARGE</code>那一列。注意，该列中的电荷是该原子价层电子中的电子总数。如果你想要知道这个原子是带正电或者负电荷，需要减去<code>POTCAR</code>中的电子数目。</p>
<p><img src="/2011/12/23/A07/A07-5.jpeg" alt=""></p>
<p>图中Si为第一个原子:有1.58个电子 ，减去POTCAR中的4，为 -2.42。</p>
<p>这表明Si失去了电子。2.42个电子分别转移到了4个H上面。</p>
<p>每个H有<script type="math/tex">1+2.42/4 = 1.6</script> 个电子。(对比下4个H中的电子)</p>
<h2 id="得到任意原子的电荷信息"><a href="#得到任意原子的电荷信息" class="headerlink" title="得到任意原子的电荷信息"></a>得到任意原子的电荷信息</h2><p>如果你对自己体系中的某一个或者某些特定的原子感兴趣，又不想每次打开<code>ACF.dat</code>文件或者已经导出来的excel文件。那么可以通过使用下面这个脚本提取相关的电荷信息。</p>
<p>1) 脚本运行命令如下图：<code>get-charge.py  Natom</code> Natom 是你感兴趣的原子序数</p>
<p><img src="/2011/12/23/A07/A07-6.jpeg" alt=""></p>
<p>注意:</p>
<p>A) 目前只支持一个，如果想查看多个，可以运行该命令若干次，或者使用一个for 循环即可: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in 1 2 3 4 5 ; do get-charge.py $i ; done </span><br></pre></td></tr></table></figure>
<p>B) 使用该命令前，请务必确认自己所关注的原子在POSCAR中的序数，如果不知道，可以通过p4vasp查看。</p>
<p><img src="/2011/12/23/A07/A07-7.jpeg" alt=""></p>
<p>2) 脚本内容如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line">script, Natom = sys.argv</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Natom is the atom number when run ths script </span></span><br><span class="line"><span class="comment"># Convert Natom into integer </span></span><br><span class="line"> </span><br><span class="line">Natom = <span class="built_in">int</span>(Natom)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Creat an empty list </span></span><br><span class="line">charge_list = []</span><br><span class="line"> </span><br><span class="line"><span class="comment"># read ACF.dat file and add all lines with charges into the charge_list </span></span><br><span class="line"><span class="comment"># These lines are started with atom numbers: line.rstrip().split()[0]</span></span><br><span class="line"><span class="comment"># line.rstrip() : &#x27;    19     -1.2426      6.3529      5.9723      9.9947      1.0601     10.4547&#x27;</span></span><br><span class="line"><span class="comment"># line.rstrip().split(): &#x27;19&#x27;, &#x27;-1.2426&#x27;, &#x27;6.3529&#x27;, &#x27;5.9723&#x27;, &#x27;9.9947&#x27;, &#x27;1.0601&#x27;, &#x27;10.4547&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span> (<span class="string">&#x27;ACF.dat&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> infile:</span><br><span class="line">    lines = infile.readlines()</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        <span class="keyword">if</span> line.rstrip().split()[<span class="number">0</span>].isdigit(): <span class="comment"># == True: # escape the first 2 and last 4 lines  </span></span><br><span class="line">            charge_list.append(line.rstrip())    </span><br><span class="line"> </span><br><span class="line"><span class="comment"># Print the charge information of Natom</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span>  charge_list:</span><br><span class="line"><span class="comment"># i.split() is used to split the whole line into different columns </span></span><br><span class="line">    <span class="keyword">if</span> Natom == <span class="built_in">int</span>(i.split()[<span class="number">0</span>]):</span><br><span class="line"><span class="comment"># The 5th data in each line is the charge value, so we print i.split()[4]   </span></span><br><span class="line">        <span class="built_in">print</span> Natom, i.split()[<span class="number">4</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>原理:</p>
<p>将<code>ACF.dat</code>中的信息以行的形式保存到一个列表里面。</p>
<p>然后根据用户输入的原子序数，调出来对应行中的电荷信息。</p>
<h1 id="扩展练习"><a href="#扩展练习" class="headerlink" title="扩展练习"></a>扩展练习</h1><p>1) 浏览VTST官网Bader电荷分析的有关内容。</p>
<p>2) 找几个简单的气相分子或者自己的体系练练手。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本节简单介绍了一下Bader电荷分析的计算流程，电荷分析的过程，以及本人自己写的一个小脚本。大家如果还有其他遇到的问题，可以在本文后面留言。我会持续更新相关的问题解答。</p>
]]></content>
      <categories>
        <category>LVASPTHW附录</category>
      </categories>
      <tags>
        <tag>Bader</tag>
        <tag>Henkelman</tag>
      </tags>
  </entry>
  <entry>
    <title>A08 Bader电荷计算(二)</title>
    <url>/2011/12/24/A08/</url>
    <content><![CDATA[<p>本节我们Bader电荷分析的常见问题做个总结。</p>
<h1 id="VTST的网站"><a href="#VTST的网站" class="headerlink" title="VTST的网站"></a>VTST的网站</h1><p>Henkelman 课题组主页：</p>
<p><a href="http://theory.cm.utexas.edu/henkelman/">http://theory.cm.utexas.edu/henkelman/</a></p>
<p>Bader计算的链接： </p>
<p><a href="http://theory.cm.utexas.edu/henkelman/code/bader/">http://theory.cm.utexas.edu/henkelman/code/bader/</a></p>
<p>VTST脚本链接：</p>
<p><a href="http://theory.cm.utexas.edu/vtsttools/">http://theory.cm.utexas.edu/vtsttools/</a> </p>
<p><img src="/2011/12/24/A08/A07/A07-1.jpeg" alt=""></p>
<h1 id="常见问题："><a href="#常见问题：" class="headerlink" title="常见问题："></a>常见问题：</h1><p><strong>电荷数字保留位数：</strong></p>
<p>Bader电荷分析只是定性的辅助工具，得到的结果肯定也是定性的。大致分析原子上的带电情况即可，不要去较真小数点后多少位，一般来说小数点后两位就足够了。</p>
<p><strong>ACF.dat 文件怎么看？</strong></p>
<p><code>ACF.dat</code> 中的<code>CHARGE</code>那一列，对应的是每个原子上<strong>总的</strong>价电子数目。</p>
<p>划重点： 1）总的 2）价电子数目</p>
<p><strong>如何判断原子的带电情况？</strong></p>
<p>你需要用<code>CHARGE</code>那列的数值去减去该原子对应的<code>POTCAR</code>中的价电子数目。</p>
<p><strong>怎么才能得到POTCAR中原子的价电子数目呢？</strong></p>
<p>打开<code>POTCAR</code>，查找关键词：<code>ZVAL</code>，后面对应的就是价电子数目，更方便点：</p>
<p><code>grep ZVAL POTCAR</code></p>
<p><strong>划重点：</strong>不要以为自己元素周期表倒背如流就可以随便设定原子的价电子数目。</p>
<p><code>POTCAR</code>中原子的价电子数目有些和周期表是一样的，比如H。</p>
<p>有些差别是很大的。比如：<code>Europium [Xe]4f76s2</code>,  Lanshipunvboshan<strong>you</strong>gatedihuoerdiuyilu 中的you。</p>
<p>You有9个价电子，但<code>POTCAR</code>中有17个。</p>
<p><strong>减完之后怎么分析？</strong></p>
<p>如果一个原子<code>POTCAR</code>中的电子数为5.</p>
<p>1） <code>ACF.dat</code>中该原子对应的CHARGE为6.2，6.2 - 5 = 1.2， 这说明该原子得到了1.2个电子。虽然是+1.2，但它的化合价是-1.2价。</p>
<p>2） <code>ACF.dat</code>中该原子对应的CHARGE 为 4.3， 4.3 – 5 = -0.7, 说明该原子失去了0.7个电子，虽然是负值，但它的化合价是 + 0.7 价。</p>
<p>注意：这里我们说的化合价，是基于Bader电荷分析得到的。由于Bader电荷分析是一个经验性的定性分析工具，这些化合价的值只能用来参考判断体系中电子的转移情况。</p>
<p>大家千万不要把这里的化合价跟我们中学所学到的化合价的概念混淆了。因为大部分的情况下，Bader电荷分析出来的化合价与我们在教科书里面所学到的化合价还是有区别的。</p>
<hr>
<p>师兄，前面扯了那多么，直接用<code>POTCAR</code>中的价电子数减去<code>CHARGE</code>对应的不就更直接了？</p>
<p>是的，你很聪明：对应前面的例子：</p>
<ul>
<li><p>1） 5 –6.2 = -1.2 说明该原子是-1.2价，得到了1.2个电子，</p>
</li>
<li><p>2） 5 - 4.3 = 0.7 说明该原子是 +0.7 价，失去了0.7个电子。</p>
</li>
</ul>
<p>所以得失电子和化学价是反着的。这点你能把握住，就会分析了。</p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>Bader电荷分析并不神秘，你需要做的有两点：</p>
<p>1） 去看VTST的官网，知道怎么去算；<br>2） 怎么通过得失电子判断原子的带电情况。<code>ACF.dat</code>中的<code>CHARGE</code>列，以及<code>POTCAR</code>中的价电子数。</p>
]]></content>
      <categories>
        <category>LVASPTHW附录</category>
      </categories>
      <tags>
        <tag>Bader</tag>
        <tag>Henkelman</tag>
      </tags>
  </entry>
  <entry>
    <title>A09 超算中心使用前的准备工作（一）</title>
    <url>/2011/12/25/A09/</url>
    <content><![CDATA[<p>感谢吕梁超算中心的支持，以后VASP的学习系列练习，都将在天河二号上面进行展示操作。一方面帮助大家继续学习VASP知识，另一方面也帮助大家快速掌握使用超算中心计算的技巧，进而避免一些焦头烂额的琐事。今天我们先讲解一下怎么在Ubuntu系统上，1）安装VPN, 2）连接天河二号超算中心，3）以及将超算中心挂载到本地电脑上，进行文件互传。</p>
<p>如果你是Windows用户，管理员在发送账号的时候，已经将使用说明一起发给你了。相信大家都可以顺利链接。那么请跳过本节内容。</p>
<p>但是Linux系统在计算具有的独特优势是Windows所不能比的，建议Windows用户继续看下去，对以后使用Linux系统做计算会有帮助。下一节，我们介绍如何使用脚本运行VASP软件，由于本人还在摸索，需要和管理沟通学习，大家再耐心等待一天。如果你想要试用或者申请超算中心的机时，请加QQ群：国防科大吕梁超算中心（204521798）了解更多的信息。</p>
<hr>
<h2 id="1-下载Linux版的VPN软件："><a href="#1-下载Linux版的VPN软件：" class="headerlink" title="1 下载Linux版的VPN软件："></a>1 下载Linux版的VPN软件：</h2><p>链接：<a href="https://www.hillstonenet.com/our-products/next-gen-firewalls-e-series/">https://www.hillstonenet.com/our-products/next-gen-firewalls-e-series/</a></p>
<p>直接跳到网页最底部，右侧点击 Linux OS 下载。<strong>注意</strong>：这个VPN不支持Ubuntu17 和 18的版本。</p>
<p><img src="/2011/12/25/A09/a09/a09-1.png" alt=""></p>
<p><img src="/2011/12/25/A09/a09/a09-2.png" alt=""></p>
<hr>
<h2 id="2-安装Linux-版VPN"><a href="#2-安装Linux-版VPN" class="headerlink" title="2 安装Linux 版VPN"></a>2 安装Linux 版VPN</h2><p>Hillstone 官网已经给出了详细的安装说明， 链接如下：</p>
<p><a href="http://docs.hillstonenet.com/en/Content/7_VPN/SSL_VPN_Client_L.htm#Starting">http://docs.hillstonenet.com/en/Content/7_VPN/SSL_VPN_Client_L.htm#Starting</a></p>
<p>大家可以参考链接，也可以根据下面的步骤进行。本人直接将官网的照片复制过来了。</p>
<p><img src="/2011/12/25/A09/a09/a09-3.png" alt=""></p>
<p>找到刚才下载的vpn软件： 右击 —&gt; 点击最底部的Properties</p>
<hr>
<p><img src="/2011/12/25/A09/a09/a09-4.png" alt=""></p>
<p>在弹出的窗口中，将Execute的那个框选中，然后点击左上角的叉号直接关闭。、</p>
<p>双击这个软件的图标，一步一步点下去，这样就完成安装啦，同时桌面上会生成VPN的快捷方式图标。</p>
<hr>
<h2 id="3-连接VPN"><a href="#3-连接VPN" class="headerlink" title="3 连接VPN"></a>3 连接VPN</h2><p>1） 打开VPN：双击桌面的VPN图标，会弹出让你输入电脑密码的对话框，输入密码，点击Authenticate按钮。</p>
<p><img src="/2011/12/25/A09/a09/a09-5.png" alt=""></p>
<p>2） 点击下图中的New 对应的加号，会弹出对话框，让你输入IP，账号密码</p>
<p><img src="/2011/12/25/A09/a09/a09-6.png" alt=""></p>
<p>注意：</p>
<ul>
<li><p>Name, Description 这两项随便填。</p>
</li>
<li><p>Host的IP超算中心给了三个，大家根据自己的网进行选择，如果一个不行，换另一个试试即可。</p>
</li>
<li><p>Port 就是 4433</p>
</li>
<li><p>User name和Password是VPN的账号和密码！！！</p>
</li>
<li>一定要选中Remember Password. 因为管理员给的密码实在是太安全了，Linux的VPN不能修改密码。如果嫌密码麻烦，可以在Windows连接成功后，修改VPN的密码。</li>
</ul>
<p>4） 点击OK就开始连接了</p>
<p>5） vpn的官网的填写说明，大家把网页中的第三条展开就可以看到了</p>
<p><img src="/2011/12/25/A09/a09/a09-7.png" alt=""></p>
<p>6） 连接过程以及成功是这个样子：</p>
<p><img src="/2011/12/25/A09/a09/a09-8.png" alt=""></p>
<p><img src="/2011/12/25/A09/a09/a09-9.png" alt=""></p>
<hr>
<h2 id="4-通过ssh连接超算中心服务器："><a href="#4-通过ssh连接超算中心服务器：" class="headerlink" title="4 通过ssh连接超算中心服务器："></a>4 通过ssh连接超算中心服务器：</h2><p>VPN登录成功后，后面我们就可以通过Terminal连接超算中心了。为了方便，提高效率，强烈建议大家按照下面的步骤进行：</p>
<p>1） 安装sshfs </p>
<p>这个用于把超算中心挂载到你的本地电脑上，后面再细说，先安装好。可以命令行一键搞定。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install sshfs</span><br></pre></td></tr></table></figure>
<p><img src="/2011/12/25/A09/a09/a09-10.png" alt=""></p>
<p>2） 在home目录下建一个文件夹，名字为： lvliang</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir ~/lvliang</span><br></pre></td></tr></table></figure>
<p>3） 将下面的内容加入到 .bashrc 文件中，将下面代码中的<code>172.16.20.XX</code> 换成超算管理员发给你的IP地址。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">####lvliang###</span><br><span class="line">alias lvliang=&#x27;ssh iciq-lq@172.16.20.XX&#x27;</span><br><span class="line">alias mlvliang=&#x27;sshfs iciq-lq@172.16.20.XX: ~/lvliang/&#x27;</span><br><span class="line">alias ulvliang=&quot;sudo umount ~/lvliang  -l&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>lvliang 这个命令用来连接超算中心，提交任务，运行命令处理任务等</li>
<li>mlvliang 用来挂载超算中心到你的电脑上，相当于把超算中心看作成一个移动硬盘</li>
<li>ulvliang 用来卸载超算中心。</li>
</ul>
<p>4） 保存后，更新下 .bashrc 文件，然后直接敲命令： lvliang 即可连接超算中心。</p>
<p>第一次连接，可能会出来一堆提示东西，输入Yes ，回车即可。</p>
<p>输入自己的超算中心账号密码，就可以登录啦。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qli@bigbro:~$ . .bashrc </span><br><span class="line">qli@bigbro:~$ lvliang </span><br><span class="line">iciq-lq@172.16.20.10&#x27;s password: </span><br><span class="line">Last login: Tue Dec  4 18:22:59 2018 from 172.16.31.135</span><br></pre></td></tr></table></figure>
<p>5）新用户刚开始的时候主目录下面什么都没有，强烈建议大家建一个 bin 文件夹，用来存放脚本。直接 <code>mkdir ~/bin</code> 即可。</p>
<hr>
<h2 id="5-上传或者下载数据（sshfs的使用）"><a href="#5-上传或者下载数据（sshfs的使用）" class="headerlink" title="5 上传或者下载数据（sshfs的使用）"></a>5 上传或者下载数据（sshfs的使用）</h2><p>1） 挂载超算中心到自己的本地电脑。</p>
<p>打开一个新的终端，</p>
<ul>
<li>输入前面我们写进.bashrc文件中的命令： mlvliang (m是mount的缩写)。</li>
<li>输入超算中心的密码：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qli@bigbro:~$ mlvliang </span><br><span class="line">iciq-lq@172.16.20.10&#x27;s password: </span><br><span class="line">qli@bigbro:~$ cd lvliang/</span><br><span class="line">qli@bigbro:~/lvliang$ ls</span><br><span class="line">bin  LVASPTHW  POTCAR  test_jobs</span><br><span class="line">qli@bigbro:~/lvliang$ </span><br></pre></td></tr></table></figure>
<p>现在超算中心就成功被挂载到我们电脑上了，我们可以随时进入并访问超算中的文件夹，通过<code>cp、mv、rsync</code>等命令往里面传数据，或者下载数据到本地的电脑。</p>
<hr>
<p>2） 例子1 ：</p>
<p>挂载超算中心登录后，我们将Ex01的文件下载（通过<code>cp</code>命令）到本地电脑桌面上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qli@bigbro:~/lvliang$ ls</span><br><span class="line">bin  LVASPTHW  POTCAR  test_jobs</span><br><span class="line">qli@bigbro:~/lvliang$ cd LVASPTHW/</span><br><span class="line">qli@bigbro:~/lvliang/LVASPTHW$ ls</span><br><span class="line">ex01  ex02  ex03  ex04  ex05  ex06  ex07  ex08  ex09  ex10  ex11  ex12  ex13  ex14  ex15  ex74  ex77  ex78  potcar</span><br><span class="line">qli@bigbro:~/lvliang/LVASPTHW$ cp ex01 ~/Desktop/</span><br><span class="line">qli@bigbro:~/lvliang/LVASPTHW$ ls ~/Desktop/ex01/</span><br><span class="line">INCAR  KPOINTS  POSCAR  POTCAR</span><br></pre></td></tr></table></figure>
<p>3） 例子2 ：</p>
<p>我们将电脑桌面的ex16文件夹上传（通过<code>cp</code>命令）到超算中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qli@bigbro:~/lvliang/LVASPTHW$ ls</span><br><span class="line">ex01  ex02  ex03  ex04  ex05  ex06  ex07  ex08  ex09  ex10  ex11  ex12  ex13  ex14  ex15  ex74  ex77  ex78  potcar</span><br><span class="line">qli@bigbro:~/lvliang/LVASPTHW$ cp ~/Desktop/ex16 .</span><br><span class="line">qli@bigbro:~/lvliang/LVASPTHW$ ls</span><br><span class="line">ex01  ex02  ex03  ex04  ex05  ex06  ex07  ex08  ex09  ex10  ex11  ex12  ex13  ex14  ex15  ex16  ex74  ex77  ex78  potcar</span><br><span class="line">qli@bigbro:~/lvliang/LVASPTHW$ </span><br></pre></td></tr></table></figure>
<p>4） 注意事项：</p>
<p>1） 必须通过mlvliang这个命令将超算中心挂载到本地电脑上之后，我们才可以互传文件。</p>
<p>2） 如果还没有挂载，就将电脑的内容复制到lvliang这个文件夹中，那么挂载之后，服务器中不会显示刚刚复制的内容</p>
<p>3） 不要用鼠标点击电脑里面的文件夹查看文件，这样会很慢，只能使用命令！！！切记！！</p>
<p>4） 卸载的时候，使用mlvliang 这个命令，然后输入自己的电脑密码（不是超算中心的了。）</p>
<p>5） 我们这样做，相当于把超算中心当做一个移动硬盘来使用，非常方便。</p>
<h2 id="6-异常问题的处理"><a href="#6-异常问题的处理" class="headerlink" title="6 异常问题的处理"></a>6 异常问题的处理</h2><p>1）挂载超算中心到本地电脑上的时候，有时候因为网络连接，会出现下图中的错误。这时候我们先使用<code>ulvliang</code>命令把超算中心卸载掉，然后再重新挂载就可以了。</p>
<p><img src="/2011/12/25/A09/a09/a09-11.png" alt=""></p>
<p>2） 如果上面还解决不了的话，可以尝试着先关机，出去溜达一会儿，然后回来再弄。或者找超算管理员解决。他们一般都很上心，服务响应很快。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本节就先介绍到这里，大家可以通过这样的方式，安装VPN，连接以及挂载超算中心，并将自己的文件上传到超算中心（比如VASP的那一堆POTCAR文件，自己的脚本，任务文件等等）。先把准备工作做好，下一节我们就可以提交任务进行计算了。</p>
]]></content>
      <categories>
        <category>LVASPTHW附录</category>
      </categories>
      <tags>
        <tag>超算中心</tag>
        <tag>吕梁</tag>
      </tags>
  </entry>
  <entry>
    <title>A10 超算中心使用前的准备工作（二）</title>
    <url>/2011/12/26/A10/</url>
    <content><![CDATA[<h2 id="天河二号（吕梁超算）提交VASP作业的脚本和命令"><a href="#天河二号（吕梁超算）提交VASP作业的脚本和命令" class="headerlink" title="天河二号（吕梁超算）提交VASP作业的脚本和命令"></a>天河二号（吕梁超算）提交VASP作业的脚本和命令</h2><hr>
<p>上一节我们讲了怎么连接天河2号超算中心。这一节，我们主要讲一下VASP提交任务的脚本和命令。在天河2号提交任务非常简单，大家只要记住：<code>一个脚本</code>和<code>一个命令</code>就可以了。首先我们看一下提交任务的实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex_a09$ ls</span><br><span class="line">INCAR  job_sub  KPOINTS  POSCAR  POTCAR</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex_a09$ yhbatch -p gsc -N 1 -J test job_sub </span><br><span class="line">Submitted batch job 1028912</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex_a09$ yhq</span><br><span class="line">             JOBID    PARTITION                       NAME             USER ST       TIME  NODES NODELIST(REASON)</span><br><span class="line">           1028912          gsc                       test          iciq-lq PD       0:00      1 (None)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上图中：</p>
<p>1） job_sub 是提交任务的脚本，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">export LD_LIBRARY_PATH=/THFS/opt/intel/composer_xe_2013_sp1.3.174/mkl/lib/intel64:$LD_LIBRARY_PATH</span><br><span class="line">yhrun -p gsc -n 24 /THFS/opt/vasp/5.4.4/vasp.5.4.4/bin/vasp_std </span><br></pre></td></tr></table></figure>
<p>2） 提交任务的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yhbatch -p gsc -N 1 -J test job_sub</span><br></pre></td></tr></table></figure>
<p>-p  gsc 是指定提交任务的队列</p>
<p>-N 1 是提交任务的节点数（每个节点24核）</p>
<p>-J test  是提交任务的名字，这里我们给任务起的名字是：test。</p>
<p>4）如果你想用2个节点，提交一个名为 bigbro的任务，可以使用下面的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yhbatch -p gsc -N 2 -J bigbro job_sub</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="不同版本的任务提交"><a href="#不同版本的任务提交" class="headerlink" title="不同版本的任务提交"></a>不同版本的任务提交</h2><p>当然，超算中心上上面也安装了不同的VASP版本，5.3，5.4以及用于过渡态计算的VTST系列版本。如果我们使用编译了VTST的5.4.4版本提交一个过渡态的任务。需要做的有2点：</p>
<p>1） 找到编译了VTST的5.4.4版本的VASP安装目录。在天河2号，所有的软件都装在 /THFS/opt 这个目录下。Vasp也不例外，如果你进入这个目录，就会发现它。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex78/step2$ <span class="built_in">cd</span> /THFS/opt/</span><br><span class="line">iciq-lq@ln3:/THFS/opt$ <span class="built_in">cd</span> vasp/</span><br><span class="line">iciq-lq@ln3:/THFS/opt/vasp$ ls</span><br><span class="line">5.2   5.3.5   5.3.5_neb   5.3.5-wannier90-2.0  5.4.1_neb  .... 5.4.1_sol_vtst  5.4.4_neb  ....</span><br><span class="line">iciq-lq@ln3:/THFS/opt/vasp$ <span class="built_in">cd</span> 5.4.4_neb/</span><br><span class="line">iciq-lq@ln3:/THFS/opt/vasp/5.4.4_neb$ ls</span><br><span class="line">vasp.5.4.4  vasp.5.lib  vtstcode-174  vtstcode.gz  vtstscripts-933  vtstscripts.gz</span><br><span class="line">iciq-lq@ln3:/THFS/opt/vasp/5.4.4_neb$ <span class="built_in">cd</span> vasp.5.4.4/</span><br><span class="line">iciq-lq@ln3:/THFS/opt/vasp/5.4.4_neb/vasp.5.4.4$ ls</span><br><span class="line">arch  bin  build  makefile  makefile.include  README  src</span><br><span class="line">iciq-lq@ln3:/THFS/opt/vasp/5.4.4_neb/vasp.5.4.4$ <span class="built_in">cd</span> bin/</span><br><span class="line">iciq-lq@ln3:/THFS/opt/vasp/5.4.4_neb/vasp.5.4.4/bin$ ls</span><br><span class="line">vasp_gam  vasp_ncl  vasp_std</span><br><span class="line">iciq-lq@ln3:/THFS/opt/vasp/5.4.4_neb/vasp.5.4.4/bin$ <span class="built_in">pwd</span></span><br><span class="line">/THFS/opt/vasp/5.4.4_neb/vasp.5.4.4/bin</span><br><span class="line">iciq-lq@ln3:/THFS/opt/vasp/5.4.4_neb/vasp.5.4.4/bin$ </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>一路追踪，直至找到安装目录中bin文件夹下面的vasp_std可执行程序（一般是绿色的）。使用<code>pwd</code>命令得到当前的路径。 </p>
<p>2） 修改提交任务脚本的最后一行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">export LD_LIBRARY_PATH=/THFS/opt/intel/composer_xe_2013_sp1.3.174/mkl/lib/intel64:$LD_LIBRARY_PATH</span><br><span class="line">yhrun -p gsc -n 24 /THFS/opt/vasp/5.4.4_neb/vasp.5.4.4/bin/vasp_std</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>将之前的目录，替换成刚刚通过<code>pwd</code>命令输出的内容。记得在目录后面加上<code>vasp_std</code> 表示你要运行这个目录下的<code>vasp_std</code>文件。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到此为止，连接VPN，天河2号，挂载服务器到本地电脑，互传文件，以及使用脚本提交vasp任务。你已经都掌握了。后面的就是好好利用超算中心，得到自己所期望的数据，好好搞科研了。如果想试用超算中心，加下方的QQ群，或者直接联系超算中心即可。</p>
<hr>
<p><img src="/2011/12/26/A10/a10/a10-8.jpeg" alt=""></p>
<p>超算中心试用联系方式：<a href="mailto:lvlianghpc01@163.com">lvlianghpc01@163.com</a>；</p>
<p>联系电话（微信）：15383480556 <strong>18903588277</strong></p>
]]></content>
      <categories>
        <category>LVASPTHW附录</category>
      </categories>
      <tags>
        <tag>Bader</tag>
        <tag>Henkelman</tag>
      </tags>
  </entry>
  <entry>
    <title>国科智算提交VASP任务</title>
    <url>/2018/12/08/A11/</url>
    <content><![CDATA[<h1 id="国科智算提交VASP任务"><a href="#国科智算提交VASP任务" class="headerlink" title="国科智算提交VASP任务"></a>国科智算提交VASP任务</h1><p>今天QQ群里，有人问怎么在国科智算的超算中心提交VASP的任务。本着一言不合就写教程的态度，这一节我们就看下VASP的任务是怎么提交的。提交任务的脚本见群文件：<code>vasp_qiangli.sh</code>。下载后重命名成<code>vasp.sh</code>即可。想试用的，购买机时的可以加QQ群：608307988咨询一下。</p>
<h2 id="Slurm"><a href="#Slurm" class="headerlink" title="Slurm"></a>Slurm</h2><p>国科智算上系统采用的是<code>slurm</code> 任务调度工具。<strong>Simple Linux Utility for Resource Management</strong>，它是一个用于<code>Linux</code>和 <code>Unix</code> 内核系统的免费、开源的任务调度工具，被世界范围内的超级计算机和计算机群广泛采用。它提供了三个关键功能。第一，为用户分配一定时间的专享或非专享的资源(计算机节点)，以供用户执行工作。第二，它提供了一个框架，用于启动、执行、监测在节点上运行着的任务(通常是并行的任务，例如<code>MPI</code>，第三，为任务队列合理地分配资源。 大约60％的<a href="https://zh.wikipedia.org/wiki/TOP500">500强</a>超级计算机上都运行着<code>Slurm</code>，包括2016年前世界上最快的计算机<a href="https://zh.wikipedia.org/wiki/%E5%A4%A9%E6%B2%B3%E4%BA%8C%E5%8F%B7">天河-2</a>。 以上是来自<a href="https://www.wikipedia.org">维基百科</a>的解释，具体的大家可以浏览<code>Slurm</code> 的官网：<a href="https://slurm.schedmd.com/">Slurm Workload Manager</a></p>
<h2 id="Sbatch"><a href="#Sbatch" class="headerlink" title="Sbatch"></a>Sbatch</h2><p>在这个调度系统中，提交任务时我们需要用到命令： <code>sbatch</code>  : <a href="https://slurm.schedmd.com/sbatch.html">https://slurm.schedmd.com/sbatch.html</a> </p>
<p><code>sbatch</code> 命令后面要跟一堆的参数，比如计算时间，节点数，邮箱，队列，调用的环境变量，任务名称等等。但这些信息通过命令直接输入又有些麻烦，所以我们把它们放到一个<code>脚本</code>里面，免得每次都重新输入一大长串的内容。而这个脚本，也就是我们本节内容的主角： <code>vasp.sh</code>。</p>
<p>首先，我们浏览<code>sbatch</code>的详细参数： <a href="https://slurm.schedmd.com/sbatch.html">https://slurm.schedmd.com/sbatch.html</a> </p>
<p>然后根据这些参数，我们就可以创建一个<code>vasp.sh</code>脚本了。</p>
<h2 id="vasp-sh"><a href="#vasp-sh" class="headerlink" title="vasp.sh"></a>vasp.sh</h2><p>下面就是<code>vasp.sh</code> 的主要内容：有2种写法，这两种写法也可以混着用，不影响。主要还是要参考<code>sbatch</code>的使用说明，需要什么就按照格式填写相应的内容。</p>
<p><strong>写法（一）</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#SBATCH -J BigBro              ## Job Name</span></span><br><span class="line"><span class="comment">#SBATCH -o %j.out              ## standard output </span></span><br><span class="line"><span class="comment">#SBATCH -e %j.err              ## standard error</span></span><br><span class="line"><span class="comment">#SBATCH -p operation           ## Partition</span></span><br><span class="line"><span class="comment">#SBATCH -N 1                   ## Number of nodes</span></span><br><span class="line"><span class="comment">#SBATCH --ntasks-per-node=28   ## Each node has 28 tasks</span></span><br><span class="line"><span class="comment">#SBATCH -t 02-23:57:25         ## time for your job: 2 d，23 h ，57 min and 23 s</span></span><br><span class="line"></span><br><span class="line">module load mpi/intelmpi/2017.4.239</span><br><span class="line">mpirun /public/software/apps/vasp/544/vasp.5.4.4/bin/vasp_std</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> <strong>写法（二）</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#SBATCH --job-name=BigBro      ## Job Name</span></span><br><span class="line"><span class="comment">#SBATCH --output=%j.out        ## standard output </span></span><br><span class="line"><span class="comment">#SBATCH --error=%j.err         ## standard error</span></span><br><span class="line"><span class="comment">#SBATCH --partition=operation  ## Partition</span></span><br><span class="line"><span class="comment">#SBATCH --nodes=1              ## Number of nodes</span></span><br><span class="line"><span class="comment">#SBATCH --ntasks-per-node=28   ## Each node has 28 tasks</span></span><br><span class="line"><span class="comment">#SBATCH --time=02-23:57:25     ## time for your job: 2 d，23 h ，57 min and 23 s</span></span><br><span class="line"></span><br><span class="line">module load mpi/intelmpi/2017.4.239</span><br><span class="line">mpirun /public/software/apps/vasp/544/vasp.5.4.4/bin/vasp_std</span><br></pre></td></tr></table></figure>
<p>上面每一行的含义，大师兄都注释出来了。</p>
<p>从第二行往下一次为：</p>
<ul>
<li>任务的名字，</li>
<li><code>VASP</code>的标准输出，</li>
<li>错误输出，</li>
<li>任务运行的分区，</li>
<li>使用的节点，</li>
<li>每个节点的的<code>tasks</code>数目。这个<code>tasks</code>可以理解为每个节点的核数，国科智算的新机器每个节点是28个核。</li>
<li>以及你的计算所用的时间。</li>
</ul>
<p>最后两行为：我们调用的环境变量以及运行<code>vasp</code>程序。</p>
<p>需要注意的是，脚本里面的内容比如<code>-N</code>（修改任务所需的节点数目）、<code>-J</code>（修改任务的名字）这些我们频繁更换的，可以从脚本里面拿出来，在命令中运行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sbtach -N 2 -J test vasp.sh </span><br></pre></td></tr></table></figure>
<p>本人自己的计算，一般28个核就够，任务名字也懒得修改。就把<code>-N</code>,<code>-J</code>写到vasp.sh中了。大家根据自己的任务特点自动修改就行了。下面我们具体演示一下。</p>
<h2 id="实例操作1："><a href="#实例操作1：" class="headerlink" title="实例操作1："></a>实例操作1：</h2><p>我们要在<code>operation</code>分区，运行一个<code>VASP</code>的单点计算，任务名称为：<code>single</code>， 使用2个节点，限制时间为2个小时；那么脚本的修改以及任务提交如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gkzshpc101@login02:~/ex-A11/test_single$ </span><br><span class="line">gkzshpc101@login02:~/ex-A11/test_single$ ls</span><br><span class="line">INCAR  KPOINTS  POSCAR  POTCAR  vasp.sh</span><br><span class="line">gkzshpc101@login02:~/ex-A11/test_single$ cat vasp.sh </span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment">#SBATCH -J single </span></span><br><span class="line"><span class="comment">#SBATCH -o out.%j</span></span><br><span class="line"><span class="comment">#SBATCH -e err.%j</span></span><br><span class="line"><span class="comment">#SBATCH -p operation </span></span><br><span class="line"><span class="comment">#SBATCH -N 2</span></span><br><span class="line"><span class="comment">#SBATCH --ntasks-per-node=28</span></span><br><span class="line"><span class="comment">#SBATCH -t 02:00:25</span></span><br><span class="line"></span><br><span class="line">module load mpi/intelmpi/2017.4.239</span><br><span class="line">mpirun /public/software/apps/vasp/544/vasp.5.4.4/bin/vasp_std</span><br><span class="line">gkzshpc101@login02:~/ex-A11/test_single$ sbatch  vasp.sh </span><br><span class="line">Submitted batch job 35525</span><br><span class="line">gkzshpc101@login02:~/ex-A11/test_single$ squeue </span><br><span class="line">             JOBID PARTITION     NAME     USER ST       TIME  NODES NODELIST(REASON)</span><br><span class="line">             35525 operation   single gkzshpc1  R       0:09      2 c[0032-0033]</span><br><span class="line">gkzshpc101@login02:~/ex-A11/test_single$ ls</span><br><span class="line">CHG  CHGCAR  CONTCAR  DOSCAR  EIGENVAL  err.35525  IBZKPT  INCAR  KPOINTS  OSZICAR  out.35525  OUTCAR  PCDAT  POSCAR  POTCAR  REPORT  vasprun.xml  vasp.sh  WAVECAR  XDATCAR</span><br><span class="line">gkzshpc101@login02:~/ex-A11/test_single$ </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="实例操作2："><a href="#实例操作2：" class="headerlink" title="实例操作2："></a>实例操作2：</h2><p>我们在<code>Operation</code>分区，运行一个<code>VASP</code>的<code>CI-NEB</code>的过渡态计算任务，任务名称为：<code>NEB</code>，使用4个节点，限制时间为12个小时；那么脚本的修改以及任务提交如下：插了7个点，用112个核算，16个核算一个点。下面有点长，文字描述就到此结束，自己慢慢看，希望对大家有所帮助。<strong>注意：</strong>脚本里面，我们换成编译了<code>VTST</code>的<code>vasp 5.4.1</code>版本。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">gkzshpc101@login02:~/ex-A11/test_neb$ ls</span><br><span class="line"><span class="number">00</span>  <span class="number">01</span>  <span class="number">02</span>  <span class="number">03</span>  <span class="number">04</span>  <span class="number">05</span>  <span class="number">06</span>  <span class="number">07</span>  <span class="number">08</span>  FS  INCAR  IS  KPOINTS  POTCAR  vasp.sh</span><br><span class="line">gkzshpc101@login02:~/ex-A11/test_neb$ cat vasp.sh </span><br><span class="line">#<span class="comment">!/bin/bash</span></span><br><span class="line">#SBATCH -J NEB </span><br><span class="line">#SBATCH -o <span class="keyword">out</span>.%j</span><br><span class="line">#SBATCH -e err.%j</span><br><span class="line">#SBATCH -p operation </span><br><span class="line">#SBATCH -N <span class="number">4</span></span><br><span class="line">#SBATCH --ntasks-per-node=<span class="number">28</span></span><br><span class="line">#SBATCH -t <span class="number">12</span>:<span class="number">00</span>:<span class="number">25</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> load mpi/intelmpi/<span class="number">2017.4</span><span class="number">.239</span></span><br><span class="line">mpirun /<span class="keyword">public</span>/software/apps/vasp/<span class="number">541_neb</span>/vasp<span class="number">.5</span><span class="number">.4</span><span class="number">.1</span>/bin/vasp_std</span><br><span class="line">gkzshpc101@login02:~/ex-A11/test_neb$ </span><br><span class="line">gkzshpc101@login02:~/ex-A11/test_neb$ sbatch  vasp.sh </span><br><span class="line">Submitted batch job <span class="number">35526</span></span><br><span class="line">gkzshpc101@login02:~/ex-A11/test_neb$ squeue </span><br><span class="line">             JOBID PARTITION     <span class="keyword">NAME</span>     USER ST       TIME  NODES NODELIST(REASON)</span><br><span class="line">             <span class="number">35526</span> operation      NEB gkzshpc1  R       <span class="number">0</span>:<span class="number">07</span>      <span class="number">4</span> c[<span class="number">0056</span>-<span class="number">0057</span>,<span class="number">0060</span>-<span class="number">0061</span>]</span><br><span class="line">gkzshpc101@login02:~/ex-A11/test_neb$ ls</span><br><span class="line"><span class="number">00</span>  <span class="number">01</span>  <span class="number">02</span>  <span class="number">03</span>  <span class="number">04</span>  <span class="number">05</span>  <span class="number">06</span>  <span class="number">07</span>  <span class="number">08</span>  err<span class="number">.35526</span>  FS  INCAR  IS  KPOINTS  <span class="keyword">out</span><span class="number">.35526</span>  POTCAR  vasprun.xml  vasp.sh</span><br><span class="line">gkzshpc101@login02:~/ex-A11/test_neb$ ls *</span><br><span class="line">err<span class="number">.35526</span>  FS  INCAR  IS  KPOINTS  <span class="keyword">out</span><span class="number">.35526</span>  POTCAR  vasprun.xml  vasp.sh</span><br><span class="line"></span><br><span class="line"><span class="number">00</span>:</span><br><span class="line">POSCAR</span><br><span class="line"></span><br><span class="line"><span class="number">01</span>:</span><br><span class="line">CHG  CHGCAR  CONTCAR  DOSCAR  EIGENVAL  IBZKPT  OSZICAR  OUTCAR  PCDAT  POSCAR  REPORT  WAVECAR  XDATCAR</span><br><span class="line"></span><br><span class="line"><span class="number">02</span>:</span><br><span class="line">CHG  CHGCAR  CONTCAR  DOSCAR  EIGENVAL  IBZKPT  OSZICAR  OUTCAR  PCDAT  POSCAR  REPORT  stdout  WAVECAR  XDATCAR</span><br><span class="line"></span><br><span class="line"><span class="number">03</span>:</span><br><span class="line">CHG  CHGCAR  CONTCAR  DOSCAR  EIGENVAL  IBZKPT  OSZICAR  OUTCAR  PCDAT  POSCAR  REPORT  stdout  WAVECAR  XDATCAR</span><br><span class="line"></span><br><span class="line"><span class="number">04</span>:</span><br><span class="line">CHG  CHGCAR  CONTCAR  DOSCAR  EIGENVAL  IBZKPT  OSZICAR  OUTCAR  PCDAT  POSCAR  REPORT  stdout  WAVECAR  XDATCAR</span><br><span class="line"></span><br><span class="line"><span class="number">05</span>:</span><br><span class="line">CHG  CHGCAR  CONTCAR  DOSCAR  EIGENVAL  IBZKPT  OSZICAR  OUTCAR  PCDAT  POSCAR  REPORT  stdout  WAVECAR  XDATCAR</span><br><span class="line"></span><br><span class="line"><span class="number">06</span>:</span><br><span class="line">CHG  CHGCAR  CONTCAR  DOSCAR  EIGENVAL  IBZKPT  OSZICAR  OUTCAR  PCDAT  POSCAR  REPORT  stdout  WAVECAR  XDATCAR</span><br><span class="line"></span><br><span class="line"><span class="number">07</span>:</span><br><span class="line">CHG  CHGCAR  CONTCAR  DOSCAR  EIGENVAL  IBZKPT  OSZICAR  OUTCAR  PCDAT  POSCAR  REPORT  stdout  WAVECAR  XDATCAR</span><br><span class="line"></span><br><span class="line"><span class="number">08</span>:</span><br><span class="line">CHG  CHGCAR  CONTCAR  DOSCAR  EIGENVAL  IBZKPT  OSZICAR  OUTCAR  PCDAT  POSCAR  REPORT  stdout  WAVECAR  XDATCAR</span><br><span class="line">gkzshpc101@login02:~/ex-A11/test_neb$ </span><br><span class="line">gkzshpc101@login02:~/ex-A11/test_neb$ head -n <span class="number">10</span> <span class="keyword">out</span><span class="number">.35526</span> </span><br><span class="line"> running on  <span class="number">112</span> total cores</span><br><span class="line"> each image running on   <span class="number">16</span> cores</span><br><span class="line"> distrk:  each k-point on   <span class="number">16</span> cores,    <span class="number">1</span> groups</span><br><span class="line"> distr:  one band on    <span class="number">1</span> cores,   <span class="number">16</span> groups</span><br><span class="line"> vasp<span class="number">.5</span><span class="number">.4</span><span class="number">.1</span> <span class="number">05</span>Feb16 (build May <span class="number">24</span> <span class="number">2018</span> <span class="number">19</span>:<span class="number">36</span>:<span class="number">47</span>) <span class="keyword">complex</span>    </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LVASPTHW附录</category>
      </categories>
      <tags>
        <tag>Sbatch</tag>
        <tag>Slurm</tag>
        <tag>VASP</tag>
        <tag>国科智算</tag>
      </tags>
  </entry>
  <entry>
    <title>A12 通过job-ID快速进入计算目录</title>
    <url>/2018/12/15/A12/</url>
    <content><![CDATA[<p>通过job-ID快速进入计算目录，可以有效地避免狂输cd命令，提高我们的计算效率。本节我们通过在国科智算超算中心的演示，介绍一个Slurm任务管理系统，保存任务ID，计算目录，并快速根据ID进入计算目录的方法。</p>
<h2 id="核心思想："><a href="#核心思想：" class="headerlink" title="核心思想："></a>核心思想：</h2><p>有很多种方法可以实现：通过Job-ID进入计算目录的办法。这里只介绍本节的思路。</p>
<ul>
<li>通过<code>squeue</code> 命令获取用户所有的任务的ID；</li>
<li>通过<code>scontrol</code> 命令获取所有ID对应的计算目录</li>
<li>将计算ID，以及对应的目录保存到一个<code>txt</code>文件中。</li>
<li>通过在<code>~/.bashrc</code>中使用scource命令，激活<code>bash</code>脚本中进入目录的操作。</li>
</ul>
<p>之所以将计算目录保存到<code>txt</code>文件中，是因为如果计算已经完成的话，则不可以通过<code>scontrol</code>命令来获取目录，这时候，我们就可以在<code>txt</code>文件中查找相应的信息。</p>
<h2 id="准备流程"><a href="#准备流程" class="headerlink" title="准备流程"></a>准备流程</h2><p>按照流程操作，每一步都很重要，漏掉的话，可能会导致功能无法实现。</p>
<p>1 下载脚本：</p>
<ul>
<li>链接：<a href="https://pan.baidu.com/s/1FEHdOecGvShbspfn9B7fIw">https://pan.baidu.com/s/1FEHdOecGvShbspfn9B7fIw</a>  提取码：dmd9 </li>
<li>国科智算QQ群文件：608307988 （申请试用）</li>
<li>大师兄QQ群文件：217821116</li>
</ul>
<p>将<code>ent.sh</code> 和<code>job_check.py</code>复制到<code>~/bin</code> 目录下，赋予可执行权限。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gkzshpc101@login02:~/bin$ chmod  u+x ent.sh</span><br><span class="line">gkzshpc101@login02:~/bin$ chmod  u+x job_check.py</span><br></pre></td></tr></table></figure>
<p>2 在bin目录下创建一个：<code>job-check</code>的目录，以及在该目录中创建一个空的<code>job_list.txt</code>文件，用来存储我们的任务信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gkzshpc101@login02:~/bin$ mkdir job_check &amp;&amp; touch job_check/job_list.txt</span><br></pre></td></tr></table></figure>
<p>3 修改<code>job_check.py</code>脚本中</p>
<p>1）13行中的账户信息，<code>gkzshpc101</code>改成你自己的账户</p>
<p>2） 32行中的那个目录信息，改成下面目录输出的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gkzshpc101@login02:~/bin$ <span class="built_in">cd</span> job_check </span><br><span class="line">gkzshpc101@login02:~/bin/job_check$ <span class="built_in">pwd</span></span><br><span class="line">/public1/home/gkzshpc101/bin/job_check</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">This script is used to</span></span><br><span class="line"><span class="string">1) record the job_ID and directories</span></span><br><span class="line"><span class="string">2) print the job path from the job_ID</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> Popen, PIPE</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_id</span>():</span></span><br><span class="line">    list_j = [] <span class="comment"># list for the job_ID</span></span><br><span class="line">    process = Popen([<span class="string">&#x27;squeue&#x27;</span>, <span class="string">&#x27;-lu&#x27;</span>,  <span class="string">&#x27;gkzshpc101&#x27;</span>], stdout=PIPE, stderr=PIPE)</span><br><span class="line">    stdout, stderr = process.communicate()</span><br><span class="line">    list_out =  stdout.split(<span class="string">&#x27;\n&#x27;</span>)[<span class="number">2</span>:]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(list_out)-<span class="number">1</span>):</span><br><span class="line">        list_j.append(list_out[i].split()[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> list_j</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_dir</span>(<span class="params">job_id</span>):</span></span><br><span class="line">    job_dir = <span class="literal">None</span></span><br><span class="line">    command = <span class="string">&#x27;scontrol show job &#x27;</span> + job_id</span><br><span class="line">    process1 = Popen(command, shell = <span class="literal">True</span>,  stdout=PIPE, stderr=PIPE)</span><br><span class="line">    stdout1, stderr1 = process1.communicate()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> stdout1.split(<span class="string">&#x27;\n&#x27;</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;WorkDir&#x27;</span> <span class="keyword">in</span> i:</span><br><span class="line">            <span class="comment">#job_dir.append(i.split(&#x27;=&#x27;)[1])</span></span><br><span class="line">            job_dir = i.split(<span class="string">&#x27;=&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> job_dir</span><br><span class="line"></span><br><span class="line">id_dict = &#123;&#125;</span><br><span class="line"><span class="keyword">with</span>  <span class="built_in">open</span>(<span class="string">&#x27;/public1/home/gkzshpc101/bin/job_check/job_list.txt&#x27;</span>, <span class="string">&#x27;a+&#x27;</span>) <span class="keyword">as</span> file_in:</span><br><span class="line">    lines = file_in.readlines()</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        key = line.split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        value = line.split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">        id_dict[key] = value</span><br><span class="line"></span><br><span class="line">    list_j = get_id()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> list_j:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> id_dict.keys():</span><br><span class="line">            id_dict[i] = get_dir(i)</span><br><span class="line">            file_in.write(i + <span class="string">&#x27;:&#x27;</span> + get_dir(i) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">job_id = sys.argv[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> id_dict.keys():</span><br><span class="line">    <span class="keyword">if</span> job_id <span class="keyword">in</span> i:</span><br><span class="line">        <span class="built_in">print</span>(id_dict.get(i).strip())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line">pwd_work=$(job_check.py <span class="variable">$1</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$pwd_work</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$pwd_work</span></span><br></pre></td></tr></table></figure>
<p>4 修改<code>~/.bashrc</code>文件，添加下面这一行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias ent=&#x27;source ~/bin/ent.sh &#x27;</span><br></pre></td></tr></table></figure>
<p>source 一下<code>~/.bashrc</code>文件： <code>. ~/.bashrc</code></p>
<h2 id="运行实例："><a href="#运行实例：" class="headerlink" title="运行实例："></a>运行实例：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gkzshpc101@login02:~/test_ncore/test1/14$ ls</span><br><span class="line">INCAR  KPOINTS POSCAR  POTCAR vasp.sh</span><br><span class="line">gkzshpc101@login02:~/test_ncore/test1/14$ sbatch  vasp.sh</span><br><span class="line">Submitted batch job 14999</span><br><span class="line">gkzshpc101@login02:~/test_ncore/test1/14$ squeue</span><br><span class="line">             JOBID PARTITION     NAME     USER ST       TIME  NODES NODELIST(REASON)</span><br><span class="line">             14999 operation     vasp gkzshpc1  R       0:02      1 c0077</span><br><span class="line">gkzshpc101@login02:~/test_ncore/test1/14$ <span class="built_in">cd</span> </span><br><span class="line">gkzshpc101@login02:~$ ent 999</span><br><span class="line">/public1/home/gkzshpc101/test_ncore/test1/14</span><br><span class="line">gkzshpc101@login02:~/test_ncore/test1/14$ ls</span><br><span class="line">CHG  CHGCAR  CONTCAR  DOSCAR  EIGENVAL  IBZKPT  INCAR  KPOINTS  OSZICAR  OUTCAR  PCDAT  POSCAR  POTCAR  REPORT  vasp.out  vasprun.xml  vasp.sh  WAVECAR  XDATCAR</span><br><span class="line">gkzshpc101@login02:~/test_ncore/test1/14$</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LVASPTHW附录</category>
      </categories>
      <tags>
        <tag>超算中心</tag>
        <tag>国科智算</tag>
        <tag>job-ID</tag>
        <tag>快速进入</tag>
      </tags>
  </entry>
  <entry>
    <title>ASE的安装</title>
    <url>/2019/03/22/A13/</url>
    <content><![CDATA[<h4 id="什么是ASE？"><a href="#什么是ASE？" class="headerlink" title="什么是ASE？"></a>什么是ASE？</h4><p>ASE 是Atomic Simulation Environment的简称。详细的介绍大家可以浏览官网：<a href="https://wiki.fysik.dtu.dk/ase/about.html。ASE是一个基于python的程序库，可以做的事情很多，不同程序任务的设置，结构的搭建，结构分析都可以做。">https://wiki.fysik.dtu.dk/ase/about.html。ASE是一个基于python的程序库，可以做的事情很多，不同程序任务的设置，结构的搭建，结构分析都可以做。</a></p>
<h4 id="为什么用ASE？"><a href="#为什么用ASE？" class="headerlink" title="为什么用ASE？"></a>为什么用ASE？</h4><ul>
<li><p>ASE里面包含了很多的功能，其中个人认为最为方便地就是计算模型不同文件类型的转换。比如将cif文件转化为POSCAR，将POSCAR转化为xyz文件，等等；</p>
</li>
<li><p>可以在学习ASE的时候，顺便学习python的一些知识；</p>
</li>
<li><p>使用ASE分析计算结果；</p>
</li>
<li>使用ASE学习做计算；这里分享<code>江山</code>推荐的一本书：<a href="https://github.com/jkitchin/dft-book">https://github.com/jkitchin/dft-book</a></li>
</ul>
<h4 id="怎么安装ASE？"><a href="#怎么安装ASE？" class="headerlink" title="怎么安装ASE？"></a>怎么安装ASE？</h4><p>如果你用的是国防科大吕梁超算中心，管理员已经安装好了ASE，那么需要你做的只有一步，添加ASE的路径到<code>.bashrc</code>文件中就可以直接用了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/opt/python3.6/bin$ ls ase*</span><br><span class="line">ase  ase-build  ase-db  ase-gui  ase-info  ase-run</span><br><span class="line">iciq-lq@ln3:/THFS/opt/python3.6/bin$ <span class="built_in">pwd</span></span><br><span class="line">/THFS/opt/python3.6/bin</span><br><span class="line">iciq-lq@ln3:/THFS/opt/python3.6/bin$ tail -n 1 ~/.bashrc</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/THFS/opt/python3.6/bin</span><br></pre></td></tr></table></figure>
<p>如果你想在自己电脑上安装ASE。安装过程很简单，详细的信息请参考：<a href="https://wiki.fysik.dtu.dk/ase/install.html。Mac太贵，没尝试过，Windows系统本人不太熟悉，下面附上在Windows10中Ubuntu寄生系统的安装过程（跟正儿八经Ubuntu系统的安装流程一样）；">https://wiki.fysik.dtu.dk/ase/install.html。Mac太贵，没尝试过，Windows系统本人不太熟悉，下面附上在Windows10中Ubuntu寄生系统的安装过程（跟正儿八经Ubuntu系统的安装流程一样）；</a> 总共就三步。</p>
<ul>
<li><p>安装pip：如果已经安装了pip，则就剩2步了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install python-pip</span><br><span class="line">sudo apt install python3-pip</span><br></pre></td></tr></table></figure>
<p>一个是基于python2，一个是python3的。</p>
</li>
<li><p><img src="/2019/03/22/A13/a13-1.png" alt=""></p>
</li>
</ul>
<ul>
<li><p>安装ASE：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install --upgrade --user ase</span><br></pre></td></tr></table></figure>
<p><img src="/2019/03/22/A13/a13-2.png" alt=""></p>
</li>
<li><p>添加ASE的路径到<code>.bashrc</code>文件。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/home/bigbro/.<span class="built_in">local</span>/bin</span><br></pre></td></tr></table></figure>
<p>在Terminal里面输入<code>ase</code>，然后摁下<code>tab</code>键：如果跟下面的输出一样，说明八九不离十了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bigbro@DESKTOP-S6R3TUP:~$ ase</span><br><span class="line">ase             ase-build       ase-db          ase-gui         ase-info        ase-run         ase_figures.sh  aselite.py      aselite.pyc</span><br><span class="line">bigbro@DESKTOP-S6R3TUP:~$ ase --version</span><br><span class="line">ase-3.17.0</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LVASPTHW附录</category>
      </categories>
      <tags>
        <tag>ASE</tag>
        <tag>Windows</tag>
        <tag>UBUNTU</tag>
      </tags>
  </entry>
  <entry>
    <title>ASE转换文件到POSCAR格式</title>
    <url>/2019/04/30/A14/</url>
    <content><![CDATA[<p>被批评公众号长草了，简单介绍一下ASE转换文件的小技巧，顺便锄下草。顺利学会下面操作的前提:</p>
<p>1) 已经在自己电脑上安装好了ASE。</p>
<p>2) 电脑里面有POSCARtoolkit.py脚本。见（<a href="https://www.bigbrosci.com/2018/11/11/ex73/）">https://www.bigbrosci.com/2018/11/11/ex73/）</a></p>
<h4 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h4><p>下面是终端里面转换格式的懒人命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ase gui  file_from  -o POSCAR </span><br></pre></td></tr></table></figure>
<p>1 <code>ase gui</code>  是我们转化文件格式的命令。</p>
<p>2 <code>file_from</code> 是你想要转换的文件，可以为cif, xyz, xsd等。ASE支持很多格式文件的读取和输出，具体的大家可以参考下面网址：</p>
<p>a) <a href="https://wiki.fysik.dtu.dk/ase/ase/io/io.html#module-ase.io">https://wiki.fysik.dtu.dk/ase/ase/io/io.html#module-ase.io</a></p>
<p>b）<a href="https://wiki.fysik.dtu.dk/ase/_modules/ase/io/formats.html">https://wiki.fysik.dtu.dk/ase/_modules/ase/io/formats.html</a></p>
<p>3  <code>-o</code> 代表输出文件，这里我们写的是POSCAR，也可以写成CONTCAR。</p>
<p> 如果：</p>
<p>1）想转换成xyz文件，改成 -o XXX.xyz;</p>
<p>2）想转换成cif文件，改成 -o XXX.cif;</p>
<p>总之，</p>
<p>想转什么文件就写什么文件；</p>
<p>想转啥格式的就写啥后缀。</p>
<p>如果失败的话，可能不支持，那就接着用自己的老方法吧。</p>
<h4 id="个人使用经验："><a href="#个人使用经验：" class="headerlink" title="个人使用经验："></a>个人使用经验：</h4><p>本人的计算模型经常在<code>xyz</code>和<code>POSCAR</code>两个格式之间切换。下面分析下ASE转换的优点和缺点。</p>
<p>1）从POSCAR到xyz文件（优点）：</p>
<p>在xyz文件的第二行中，ASE会写入一些体系的周期性的信息，这一点非常棒。方便从xyz再转换回POSCAR或者CONTCAR。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@bigbro:~/Desktop/<span class="built_in">test</span>$ ls</span><br><span class="line">CONTCAR</span><br><span class="line">qli@bigbro:~/Desktop/<span class="built_in">test</span>$ cat CONTCAR</span><br><span class="line">Au\(1\1\1)</span><br><span class="line">   1.00000000000000</span><br><span class="line">    20.0000000000000000    0.0000000000000000    0.0000000000000000</span><br><span class="line">     0.0000000000000000   21.0000000000000000    0.0000000000000000</span><br><span class="line">     0.0000000000000000    0.0000000000000000   22.0000000000000000</span><br><span class="line">   C    H</span><br><span class="line">     2     4</span><br><span class="line">Selective dynamics</span><br><span class="line">Direct</span><br><span class="line">  0.1615221012872249  0.4048804874587976  0.3815091574487524   T   T   T</span><br><span class="line">  0.1387568880386591  0.3452706062587786  0.3846145011058063   T   T   T</span><br><span class="line">  0.2143704422309978  0.4168857617494277  0.3865629189119751   T   T   T</span><br><span class="line">  0.1712711104214057  0.3044252978921785  0.3929860718019034   T   T   T</span><br><span class="line">  0.1271257560199507  0.4443139925926637  0.3733323288922066   T   T   T</span><br><span class="line">  0.0855583096767520  0.3352469534052885  0.3790158532393584   T   T   T</span><br><span class="line"></span><br><span class="line">qli@bigbro:~/Desktop/<span class="built_in">test</span>$ ls</span><br><span class="line">CONTCAR</span><br><span class="line">qli@bigbro:~/Desktop/<span class="built_in">test</span>$ ase gui CONTCAR  -o c2h4.xyz</span><br><span class="line">/home/qli/anaconda2/lib/python2.7/site-packages/ase/gui/ag.py:86: UserWarning: You should be using <span class="string">&quot;ase convert ...&quot;</span> instead!</span><br><span class="line">  warnings.warn(<span class="string">&#x27;You should be using &quot;ase convert ...&quot; instead!&#x27;</span>)</span><br><span class="line">qli@bigbro:~/Desktop/<span class="built_in">test</span>$ cat c2h4.xyz</span><br><span class="line">6</span><br><span class="line">Lattice=<span class="string">&quot;20.0 0.0 0.0 0.0 21.0 0.0 0.0 0.0 22.0&quot;</span> Properties=species:S:1:pos:R:3 pbc=<span class="string">&quot;T T T&quot;</span></span><br><span class="line">C       3.23044203       8.50249024       8.39320146</span><br><span class="line">C       2.77513776       7.25068273       8.46151902</span><br><span class="line">H       4.28740884       8.75460100       8.50438422</span><br><span class="line">H       3.42542221       6.39293126       8.64569358</span><br><span class="line">H       2.54251512       9.33059384       8.21331124</span><br><span class="line">H       1.71116619       7.04018602       8.33834877</span><br></pre></td></tr></table></figure>
<p><code>Lattice=XXX</code> 这一行可以帮助你从xyz转回POSCAR。另外，转换的时候，会出现一个warning信息，装看不见就行了。</p>
<p>2）从xyz到POSCAR</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">qli@bigbro:~/Desktop/test$ ase gui c2h4.xyz -o POSCAR</span><br><span class="line">/home/qli/anaconda2/lib/python2<span class="number">.7</span>/site-packages/ase/gui/ag.py:<span class="number">86</span>: UserWarning: You should be using <span class="string">&quot;ase convert ...&quot;</span> instead<span class="comment">!</span></span><br><span class="line">  warnings.warn(<span class="string">&#x27;You should be using &quot;ase convert ...&quot; instead!&#x27;</span>)</span><br><span class="line">qli@bigbro:~/Desktop/test$ cat POSCAR -n</span><br><span class="line">     <span class="number">1</span>   C  H</span><br><span class="line">     <span class="number">2</span>   <span class="number">1.0000000000000000</span></span><br><span class="line">     <span class="number">3</span>      <span class="number">20.0000000000000000</span>    <span class="number">0.0000000000000000</span>    <span class="number">0.0000000000000000</span></span><br><span class="line">     <span class="number">4</span>       <span class="number">0.0000000000000000</span>   <span class="number">21.0000000000000000</span>    <span class="number">0.0000000000000000</span></span><br><span class="line">     <span class="number">5</span>       <span class="number">0.0000000000000000</span>    <span class="number">0.0000000000000000</span>   <span class="number">22.0000000000000000</span></span><br><span class="line">     <span class="number">6</span>     <span class="number">2</span>   <span class="number">4</span></span><br><span class="line">     <span class="number">7</span>  Cartesian</span><br><span class="line">     <span class="number">8</span>    <span class="number">3.2304420299999999</span>  <span class="number">8.5024902400000002</span>  <span class="number">8.3932014600000002</span></span><br><span class="line">     <span class="number">9</span>    <span class="number">2.7751377599999998</span>  <span class="number">7.2506827300000003</span>  <span class="number">8.4615190200000008</span></span><br><span class="line">    <span class="number">10</span>    <span class="number">4.2874088400000003</span>  <span class="number">8.7546009999999992</span>  <span class="number">8.5043842200000004</span></span><br><span class="line">    <span class="number">11</span>    <span class="number">3.4254222099999998</span>  <span class="number">6.3929312600000001</span>  <span class="number">8.6456935799999997</span></span><br><span class="line">    <span class="number">12</span>    <span class="number">2.5425151200000000</span>  <span class="number">9.3305938400000006</span>  <span class="number">8.2133112399999995</span></span><br><span class="line">    <span class="number">13</span>    <span class="number">1.7111661899999999</span>  <span class="number">7.0401860200000002</span>  <span class="number">8.3383487699999996</span></span><br></pre></td></tr></table></figure>
<p>从xyz转化成POSCAR的时候，ASE的优点：</p>
<p>1）按照Cartesian格式输出。</p>
<p>2）元素行在第一行。</p>
<p>缺点：</p>
<p>1）输出文件还是老式的VASP格式（vasp 4.6）。第6行前面少了元素哪一行。</p>
<p>解决办法：ASE把这一行写到第一行了。我们直接在vim里面，把第一行复制到第6行前面就OK。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span>  C  H</span><br><span class="line"> <span class="number">2</span>  <span class="number">1.0000000000000000</span></span><br><span class="line"> <span class="number">3</span>     <span class="number">20.0000000000000000</span>    <span class="number">0.0000000000000000</span>    <span class="number">0.0000000000000000</span></span><br><span class="line"> <span class="number">4</span>      <span class="number">0.0000000000000000</span>   <span class="number">21.0000000000000000</span>    <span class="number">0.0000000000000000</span></span><br><span class="line"> <span class="number">5</span>      <span class="number">0.0000000000000000</span>    <span class="number">0.0000000000000000</span>   <span class="number">22.0000000000000000</span></span><br><span class="line"> <span class="number">6</span>  C  H</span><br><span class="line"> <span class="number">7</span>    <span class="number">2</span>   <span class="number">4</span></span><br><span class="line"> <span class="number">8</span> Cartesian</span><br><span class="line"> <span class="number">9</span>   <span class="number">3.2304420299999999</span>  <span class="number">8.5024902400000002</span>  <span class="number">8.3932014600000002</span></span><br><span class="line"><span class="number">10</span>   <span class="number">2.7751377599999998</span>  <span class="number">7.2506827300000003</span>  <span class="number">8.4615190200000008</span></span><br><span class="line"><span class="number">11</span>   <span class="number">4.2874088400000003</span>  <span class="number">8.7546009999999992</span>  <span class="number">8.5043842200000004</span></span><br><span class="line"><span class="number">12</span>   <span class="number">3.4254222099999998</span>  <span class="number">6.3929312600000001</span>  <span class="number">8.6456935799999997</span></span><br><span class="line"><span class="number">13</span>   <span class="number">2.5425151200000000</span>  <span class="number">9.3305938400000006</span>  <span class="number">8.2133112399999995</span></span><br><span class="line"><span class="number">14</span>   <span class="number">1.7111661899999999</span>  <span class="number">7.0401860200000002</span>  <span class="number">8.3383487699999996</span>                           </span><br></pre></td></tr></table></figure>
<p>缺点2）少了固定元素的哪一行，以及固定坐标的’T’ 和 ‘F’ 。</p>
<p>解决办法：通过前面介绍的<code>POSCARtoolkit.py</code>脚本来解决，运行下面的命令，输入固定的层数即可。具体用法见（<a href="https://www.bigbrosci.com/2018/11/11/ex73/）">https://www.bigbrosci.com/2018/11/11/ex73/）</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@bigbro:~/Desktop/<span class="built_in">test</span>$ ls</span><br><span class="line">c2h4.xyz  CONTCAR  POSCAR</span><br><span class="line">qli@bigbro:~/Desktop/<span class="built_in">test</span>$ POSCARtoolkit.py -i POSCAR  -f</span><br><span class="line">x</span><br><span class="line">x</span><br><span class="line">x</span><br><span class="line">    -----------------------------------------------------------</span><br><span class="line">    Cartesian Coordinates found, only <span class="keyword">for</span> fixing atoms!</span><br><span class="line">    Then <span class="built_in">type</span> how many layers to be fixed, from bottom to top.</span><br><span class="line">    -----------------------------------------------------------</span><br><span class="line"></span><br><span class="line">    Found 1 layers, choose how many layers to be fixed------&gt; 0 </span><br><span class="line"></span><br><span class="line">    -----------------------------------------------------------</span><br><span class="line">    POSCAR with Cartesian Coordiations is named as POSCAR_C</span><br><span class="line">x</span><br><span class="line">x</span><br><span class="line">x</span><br><span class="line">qli@bigbro:~/Desktop/<span class="built_in">test</span>$ ls</span><br><span class="line">c2h4.xyz  CONTCAR  POSCAR  POSCAR_C</span><br><span class="line">qli@bigbro:~/Desktop/<span class="built_in">test</span>$ cat POSCAR_C</span><br><span class="line"> C  H</span><br><span class="line"> 1.0000000000000000</span><br><span class="line">    20.0000000000000000    0.0000000000000000    0.0000000000000000</span><br><span class="line">     0.0000000000000000   21.0000000000000000    0.0000000000000000</span><br><span class="line">     0.0000000000000000    0.0000000000000000   22.0000000000000000</span><br><span class="line"> C  H</span><br><span class="line">   2   4</span><br><span class="line">Selective</span><br><span class="line">Cartesian</span><br><span class="line">        +3.2304420300   +8.5024902400   +8.3932014600    T   T   T</span><br><span class="line">        +2.7751377600   +7.2506827300   +8.4615190200    T   T   T</span><br><span class="line">        +4.2874088400   +8.7546010000   +8.5043842200    T   T   T</span><br><span class="line">x</span><br><span class="line">x</span><br><span class="line">x</span><br></pre></td></tr></table></figure>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><p>个人还是比较喜欢用ASE来进行文件格式的转换，方便实用。方法千万种，能找到适合自己的就行。此外，尝试新的方法的时候，一定要认真研究分析下输出的文件（脚本、程序或多或少都会有些bug），保证对于自己的体系不出错后再继续使用，安全第一。此外，如果你有自己独特的、简单粗暴的、傻瓜式的、不通过鼠标敲敲点点的转换方法，也欢迎分享。</p>
]]></content>
      <categories>
        <category>LVASPTHW附录</category>
      </categories>
      <tags>
        <tag>ASE</tag>
        <tag>POSCARtoolkit.py</tag>
        <tag>格式转换</tag>
      </tags>
  </entry>
  <entry>
    <title>ExA15 Ubuntu下p4vasp与Python3不兼容的解决办法</title>
    <url>/2019/08/11/A15/</url>
    <content><![CDATA[<p>伴随着Python2的落幕，Python3的兴起，很多基于2的软件也面临着着要么被遗忘，要么主动拥抱Python3的选择。其中就有我们最喜欢的p4vasp。<a href="https://github.com/orest-d/p4vasp">https://github.com/orest-d/p4vasp</a> 或者<a href="http://www.p4vasp.at/">www.p4vasp.at</a>。本人不认识作者，也不知道啥时候出新的版本。使用p4vasp需要有python2，但其他软件又需要python3。为此我们不得不做出一些选择， 最残忍的莫过于弃用p4vasp啦。本节介绍两个办法：</p>
<p>1） 修改p4vasp运行默认的python版本</p>
<p>2）通过update-alternatives切换系统默认的python版本。</p>
<h4 id="办法-1"><a href="#办法-1" class="headerlink" title="办法-1"></a>办法-1</h4><p>这个方法是公众号的牛牛（刘科）留言提出来的：</p>
<p><code>第一步</code>： 修改<code>p4v</code>脚本：将最后一行中的<code>python</code> 改成<code>python2</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@lhz:~$ sudo gedit /usr/bin/p4v </span><br><span class="line">qli@lhz:~$ cat /usr/bin/p4v </span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"><span class="built_in">export</span> LD_PRELOAD=libstdc++.so.6</span><br><span class="line"><span class="built_in">export</span> UBUNTU_MENUPROXY=0</span><br><span class="line"><span class="built_in">export</span> P4VASP_HOME=/usr/share/p4vasp</span><br><span class="line"><span class="built_in">exec</span> /usr/bin/python2 /usr/share/p4vasp/p4v.py <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>第二步</code> 修改<code>p4v.py</code>， 将第一行中的<code>python</code> 改成<code>python2</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@lhz:~$ sudo gedit /usr/share/p4vasp/p4v.py</span><br><span class="line">qli@lhz:~$ head -n 2 /usr/share/p4vasp/p4v.py</span><br><span class="line"><span class="comment">#!/usr/bin/env python2</span></span><br><span class="line"><span class="comment"># Copyright (C) 2003 Orest Dubay &lt;orest.dubay@univie.ac.at&gt;</span></span><br></pre></td></tr></table></figure>
<p>运行实例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@lhz:~$ python  --version </span><br><span class="line">Python 3.7.3</span><br><span class="line">qli@lhz:~$ p4v </span><br><span class="line">Gtk-Message: 08:12:51.061: Failed to load module <span class="string">&quot;canberra-gtk-module&quot;</span></span><br><span class="line">(p4v.py:27951): libglade-WARNING **: 08:12:51.176: Could not load support <span class="keyword">for</span> `gnome<span class="string">&#x27;: libgnome.so: cannot open shared object file: No such file or directory</span></span><br><span class="line"><span class="string">(p4v.py:27951): libglade-WARNING **: 08:12:51.519: unknown attribute `swapped&#x27;</span> <span class="keyword">for</span> &lt;signal&gt;.</span><br><span class="line">Exception TypeError: <span class="string">&quot;&#x27;NoneType&#x27; object is not callable&quot;</span> <span class="keyword">in</span> &lt;object repr() failed&gt; ignored</span><br></pre></td></tr></table></figure>
<h4 id="办法-2"><a href="#办法-2" class="headerlink" title="办法-2"></a>办法-2</h4><p>百度或者google里面搜一下：update-alternatives python 就会得到一系列的操作教程。本文不再瞎扯。</p>
<p><code>第一步</code> </p>
<p>查看自己系统中python2和python3的版本，终端里面输入：python然后摁tab键，显示如下，本人安装了python2.7 和python3.7。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@lhz:~$ </span><br><span class="line">qli@lhz:~$ python</span><br><span class="line">python  python2.7-config    python3   python3.7m  python3-jsonschema  python3-pbr  pythontex python2   python2-config  python3.7 python3.7m-config   python3m  python3-unit2  pythontex3 python2.7   python2-jsonschema  python3.7-config    python3-config python3m-config  python-config    </span><br></pre></td></tr></table></figure>
<p><code>第二步</code></p>
<p>设置update-alternatives：在终端里面，依次输入下面两个命令行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@lhz:~$ sudo update-alternatives --install /usr/bin/python python /usr/bin/python2.7 1</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@lhz:~$ sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.7 2</span><br></pre></td></tr></table></figure>
<p>这样就设置OK啦。更加具体的，网上已经泛滥了</p>
<p><code>第三步</code></p>
<p> 切换python版本，使用下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@lhz:~$ sudo update-alternatives --config python</span><br></pre></td></tr></table></figure>
<p>下面是具体运行的例子，首先本人将上面的命令行保存到<code>.bashrc</code>文件中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@lhz:~$ grep pversion .bashrc</span><br><span class="line"><span class="built_in">alias</span> pversion=<span class="string">&#x27;sudo update-alternatives --config python&#x27;</span></span><br><span class="line">qli@lhz:~$ </span><br><span class="line">qli@lhz:~$ python --version </span><br><span class="line">Python 2.7.16</span><br><span class="line">qli@lhz:~$ p4v </span><br><span class="line">Gtk-Message: 08:03:38.110: Failed to load module <span class="string">&quot;canberra-gtk-module&quot;</span></span><br><span class="line">(p4v.py:3156): libglade-WARNING **: 08:03:38.346: Could not load support <span class="keyword">for</span> `gnome<span class="string">&#x27;: libgnome.so: cannot open shared object file: No such file or directory</span></span><br><span class="line"><span class="string">(p4v.py:3156): libglade-WARNING **: 08:03:38.782: unknown attribute `swapped&#x27;</span> <span class="keyword">for</span> &lt;signal&gt;.</span><br><span class="line">Exception TypeError: <span class="string">&quot;&#x27;NoneType&#x27; object is not callable&quot;</span> <span class="keyword">in</span> &lt;object repr() failed&gt; ignored</span><br><span class="line">Exception TypeError: <span class="string">&quot;&#x27;NoneType&#x27; object is not callable&quot;</span> <span class="keyword">in</span> &lt;object repr() failed&gt; ignored</span><br><span class="line">Exception TypeError: <span class="string">&quot;&#x27;NoneType&#x27; object is not callable&quot;</span> <span class="keyword">in</span> &lt;object repr() failed&gt; ignored</span><br><span class="line">Exception TypeError: <span class="string">&quot;&#x27;NoneType&#x27; object is not callable&quot;</span> <span class="keyword">in</span> &lt;object repr() failed&gt; ignored</span><br></pre></td></tr></table></figure>
<p>当前版本是python2.7，可以正常运行p4vasp。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@lhz:~$ pversion </span><br><span class="line">[sudo] password <span class="keyword">for</span> qli: </span><br><span class="line">There are 2 choices <span class="keyword">for</span> the alternative python (providing /usr/bin/python).</span><br><span class="line"></span><br><span class="line">  Selection    Path                Priority   Status</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">  0            /usr/bin/python2.7   2         auto mode</span><br><span class="line">* 1            /usr/bin/python2.7   2         manual mode</span><br><span class="line">  2            /usr/bin/python3.7   1         manual mode</span><br><span class="line"></span><br><span class="line">Press &lt;enter&gt; to keep the current choice[*], or <span class="built_in">type</span> selection number: 2</span><br><span class="line">update-alternatives: using /usr/bin/python3.7 to provide /usr/bin/python (python) <span class="keyword">in</span> manual mode</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当前的python版本，会在最左侧那一列用<code>*</code> 标出来。换成python3的话，输入 左侧所对应的数值就OK了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@lhz:~$ python --version </span><br><span class="line">Python 3.7.3</span><br><span class="line">qli@lhz:~$ p4v </span><br><span class="line">  File <span class="string">&quot;/usr/share/p4vasp/p4v.py&quot;</span>, line 9</span><br><span class="line">    can get <span class="built_in">source</span> code from http://www.pygtk.org <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">                                                    ^</span></span><br><span class="line"><span class="string">SyntaxError: invalid syntax</span></span><br><span class="line"><span class="string">qli@lhz:~$ pversion </span></span><br><span class="line"><span class="string">There are 2 choices for the alternative python (providing /usr/bin/python).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  Selection    Path                Priority   Status</span></span><br><span class="line"><span class="string">------------------------------------------------------------</span></span><br><span class="line"><span class="string">  0            /usr/bin/python2.7   2         auto mode</span></span><br><span class="line"><span class="string">  1            /usr/bin/python2.7   2         manual mode</span></span><br><span class="line"><span class="string">* 2            /usr/bin/python3.7   1         manual mode</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Press &lt;enter&gt; to keep the current choice[*], or type selection number: 1</span></span><br><span class="line"><span class="string">update-alternatives: using /usr/bin/python2.7 to provide /usr/bin/python (python) in manual mode</span></span><br></pre></td></tr></table></figure>
<p>顺利将python切换到版本3，但p4vasp这时候就不能用了。</p>
<p><code>小结</code></p>
<p>希望p4vasp赶紧出基于python3的版本，如果不出的话，大家就先这样凑活着用吧。如果牛牛们还有更好的解决办法，可以将教程稍微整理下，发送到邮箱lqcata@gmail.com，本人会继续更新到本节当中。</p>
]]></content>
      <categories>
        <category>LVASPTHW附录</category>
      </categories>
      <tags>
        <tag>p4vasp</tag>
        <tag>python2</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title>ASE的骚操作系列</title>
    <url>/2020/08/31/A17/</url>
    <content><![CDATA[<p>对科研狗们来说，ASE不是Automotive Service Excellence的缩写，而是Atomic Simulation Environment。<br>是一款基于Python语言的工具软件，可以方便地处理DFT计算中结构搭建，准备输入文件准备，读取输出文件，既可以可视化，又可以用来转换文件格式。本文主要介绍ASE在DFT计算中的骚操作。这个”骚”字让我想起来小学的时候，同桌读了屈原的《离骚》，然后转过头来用这个字来笑话我，说我真骚。我被憋的满脸通红却不知如何反驳。骚就骚吧，骚前面加个<code>离</code>可以千古流传，那么我相信，它后面加个<code>操作</code>也可以对大家日常的计算有所帮助。<br>首先声明：本教程具有自动过滤功能。每次过滤的时候，我都会提醒一下，以防你被滤纸卡住。但如果你读完教程却不能顺利进行操作，请不要找我，请分解自己让自己滤下去。</p>
<p><strong>滤纸-1</strong>： ASE成功安装了没？ （<a href="https://wiki.fysik.dtu.dk/ase/install.html）被卡住就不要继续喽！">https://wiki.fysik.dtu.dk/ase/install.html）被卡住就不要继续喽！</a></p>
<p>今天我们讲的骚操作就是用ASE来进行格式转换。这也是本人日常用的最多的一个，最稳定也最方便的一个操作。既然是操作，那么就举个栗子吧：</p>
<p>例子1）：将mol文件转化为xyz。 </p>
<p>首先在Chemspider数据库中，下载一个乙烷3D构型的mol文件。</p>
<p><strong>滤纸-2</strong>：Chemspider 是啥玩意，怎么下载mol文件？ 之前教程有讲过，不会的找百度。被卡住就不要继续喽！</p>
<p>操作过程： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qli@bigbro:~/Downloads$ ls</span><br><span class="line">6084.mol</span><br><span class="line">qli@bigbro:~/Downloads$ head -n 13 6084.mol </span><br><span class="line">6324</span><br><span class="line">  Marvin  12300703363D          </span><br><span class="line"></span><br><span class="line">  8  7  0  0  0  0            999 V2000</span><br><span class="line">    0.7686    0.0000    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0</span><br><span class="line">   -0.7686   -0.0000    0.0000 C   0  0  0  0  0  0  0  0  0  0  0  0</span><br><span class="line">    1.1430    1.0253    0.0000 H   0  0  0  0  0  0  0  0  0  0  0  0</span><br><span class="line">    1.1430   -0.5127    0.8880 H   0  0  0  0  0  0  0  0  0  0  0  0</span><br><span class="line">    1.1430   -0.5127   -0.8880 H   0  0  0  0  0  0  0  0  0  0  0  0</span><br><span class="line">   -1.1430   -1.0253    0.0000 H   0  0  0  0  0  0  0  0  0  0  0  0</span><br><span class="line">   -1.1430    0.5127   -0.8880 H   0  0  0  0  0  0  0  0  0  0  0  0</span><br><span class="line">   -1.1430    0.5127    0.8880 H   0  0  0  0  0  0  0  0  0  0  0  0</span><br><span class="line">  1  2  1  0  0  0  0</span><br><span class="line">qli@bigbro:~/Downloads$ ase gui 6084.mol  -o C2H6.xyz </span><br><span class="line">/home/qli/.local/lib/python3.8/site-packages/ase/gui/ag.py:85: UserWarning: You should be using &quot;ase convert ...&quot; instead!</span><br><span class="line">  warnings.warn(&#x27;You should be using &quot;ase convert ...&quot; instead!&#x27;)</span><br><span class="line">(qrobot) qli@bigbro:~/Downloads$ cat C2H6.xyz </span><br><span class="line">8</span><br><span class="line">Properties=species:S:1:pos:R:3 pbc=&quot;F F F&quot;</span><br><span class="line">C        0.76860000       0.00000000       0.00000000</span><br><span class="line">C       -0.76860000      -0.00000000       0.00000000</span><br><span class="line">H        1.14300000       1.02530000       0.00000000</span><br><span class="line">H        1.14300000      -0.51270000       0.88800000</span><br><span class="line">H        1.14300000      -0.51270000      -0.88800000</span><br><span class="line">H       -1.14300000      -1.02530000       0.00000000</span><br><span class="line">H       -1.14300000       0.51270000      -0.88800000</span><br><span class="line">H       -1.14300000       0.51270000       0.88800000</span><br><span class="line">qli@bigbro:~/Downloads$ ase gui C2H6.xyz </span><br><span class="line">qli@bigbro:~/Downloads$ </span><br></pre></td></tr></table></figure>
<p>我们成功用ase gui 将mol转化为了xyz文件。</p>
<p>1） 每次运行都会出现那行警示信息，让你用ase convert转化。命令如下：</p>
<p>ase convert -i mol -o xyz 6084.mol  C2H6.xyz </p>
<p>这个命令比较长，输入起来烦人，远远不如ase gui 干脆利落。警告信息就用你那高度近视镜自行滤过吧。</p>
<p>2)  <code>-o</code>  中的字母<code>o</code>是out的缩写，意思是输出。  </p>
<p>3） ase gui 后面跟一个文件，可以直接可视化。</p>
<p>学会了<code>ase gui</code>的命令操作，下面我们需要进一步分解自己，以便透过更多的滤纸。</p>
<p><strong>滤纸-3</strong>： </p>
<p>DFT计算中有很多的文件格式，VASP有POSCAR(CONTCAR)，Gaussian有gjf或者com，Material Studio导出来可以有cif啥的。这些格式之间转换着实让一些新手头疼。以至于经常在群里看到有人询问类似的问题。如果你没有用文本编辑器打开这些格式的文件，并认真分析下它们的数据结构，那么你被滤纸卡住了。请把自己变小一些再继续阅读。</p>
<p>分析一下上面的操作：<code>ase gui  6084.mol -o C2H6.xyz</code></p>
<p>6084.mol 是我们读取的对象，C2H6.xyz 是输出的文件。回到大家常用的VASP计算上来，cif文件文件都不陌生，那么我们就转化一下它吧。</p>
<p><strong>例子-2： 将CIF转化为XYZ，POSCAR</strong></p>
<p>首先从Materials Project 下载一个干冰的cif文件。</p>
<p><strong>滤纸-4</strong>：如果你不知道啥是MP。打开这个网址：<a href="https://materialsproject.org，注册，随便下载个cif文件。">https://materialsproject.org，注册，随便下载个cif文件。</a></p>
<p>操作过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qli@bigbro:~/Downloads$ ls</span><br><span class="line">6084.mol  C2H6.xyz  CO2_mp-20066_conventional_standard.cif</span><br><span class="line">qli@bigbro:~/Downloads$ head -n 5 CO2_mp-20066_conventional_standard.cif </span><br><span class="line"></span><br><span class="line"># generated using pymatgen</span><br><span class="line"></span><br><span class="line">data_CO2</span><br><span class="line">_symmetry_space_group_name_H-M   &#x27;P 1&#x27;</span><br><span class="line">_cell_length_a   5.80269900</span><br><span class="line">_cell_length_b   5.80269900</span><br><span class="line">qli@bigbro:~/Downloads$ ase gui CO2_mp-20066_conventional_standard.cif -o CO2_mp-20066.xyz </span><br><span class="line">/home/qli/.local/lib/python3.8/site-packages/ase/gui/ag.py:85: UserWarning: You should be using &quot;ase convert ...&quot; instead!</span><br><span class="line">  warnings.warn(&#x27;You should be using &quot;ase convert ...&quot; instead!&#x27;)</span><br><span class="line">qli@bigbro:~/Downloads$ ls</span><br><span class="line">6084.mol  C2H6.xyz  CO2_mp-20066_conventional_standard.cif  CO2_mp-20066.xyz</span><br><span class="line">qli@bigbro:~/Downloads$ cat CO2_mp-20066.xyz </span><br><span class="line">12</span><br><span class="line">Lattice=&quot;5.802699 0.0 0.0 0.0 5.802699 0.0 0.0 0.0 5.802699&quot; Properties=species:S:1:pos:R:3 spacegroup=&quot;P 1&quot; unit_cell=conventional pbc=&quot;T T T&quot;</span><br><span class="line">C        0.00000000       0.00000000       0.00000000</span><br><span class="line">C        2.90134950       0.00000000       2.90134950</span><br><span class="line">C        2.90134950       2.90134950       0.00000000</span><br><span class="line">C        0.00000000       2.90134950       2.90134950</span><br><span class="line">O        0.67853280       0.67853280       0.67853280</span><br><span class="line">O        2.22281670       5.12416620       3.57988230</span><br><span class="line">O        3.57988230       2.22281670       5.12416620</span><br><span class="line">O        5.12416620       3.57988230       2.22281670</span><br><span class="line">O        5.12416620       5.12416620       5.12416620</span><br><span class="line">O        3.57988230       0.67853280       2.22281670</span><br><span class="line">O        2.22281670       3.57988230       0.67853280</span><br><span class="line">O        0.67853280       2.22281670       3.57988230</span><br><span class="line">qli@bigbro:~/Downloads$ ase gui CO2_mp-20066_conventional_standard.cif -o POSCAR </span><br><span class="line">/home/qli/.local/lib/python3.8/site-packages/ase/gui/ag.py:85: UserWarning: You should be using &quot;ase convert ...&quot; instead!</span><br><span class="line">  warnings.warn(&#x27;You should be using &quot;ase convert ...&quot; instead!&#x27;)</span><br><span class="line">qli@bigbro:~/Downloads$ cat POSCAR </span><br><span class="line"> C  O </span><br><span class="line"> 1.0000000000000000</span><br><span class="line">     5.8026989999999996    0.0000000000000000    0.0000000000000000</span><br><span class="line">     0.0000000000000000    5.8026989999999996    0.0000000000000000</span><br><span class="line">     0.0000000000000000    0.0000000000000000    5.8026989999999996</span><br><span class="line">   4   8</span><br><span class="line">Cartesian</span><br><span class="line">  0.0000000000000000  0.0000000000000000  0.0000000000000000</span><br><span class="line">  2.9013494999999998  0.0000000000000000  2.9013494999999998</span><br><span class="line">  2.9013494999999998  2.9013494999999998  0.0000000000000000</span><br><span class="line">  0.0000000000000000  2.9013494999999998  2.9013494999999998</span><br><span class="line">  0.6785328048660000  0.6785328048660000  0.6785328048660000</span><br><span class="line">  2.2228166951340000  5.1241661951339994  3.5798823048659996</span><br><span class="line">  3.5798823048659996  2.2228166951340000  5.1241661951339994</span><br><span class="line">  5.1241661951339994  3.5798823048659996  2.2228166951340000</span><br><span class="line">  5.1241661951339994  5.1241661951339994  5.1241661951339994</span><br><span class="line">  3.5798823048659996  0.6785328048660000  2.2228166951340000</span><br><span class="line">  2.2228166951340000  3.5798823048659996  0.6785328048660000</span><br><span class="line">  0.6785328048660000  2.2228166951340000  3.5798823048659996</span><br><span class="line">qli@bigbro:~/Downloads$ ase gui POSCAR </span><br><span class="line">qli@bigbro:~/Downloads$ </span><br></pre></td></tr></table></figure>
<p>OK，大功告成。可以拖到服务器提交任务了。值得注意的是，ASE输出的POSCAR总是把元素行放在第一行的位置，类似于VASP4的POSCAR格式，如果不爽的话，</p>
<p>1） 自行修改为VASP5/6的POSCAR格式。</p>
<p>2） 也可以修改ASE的源代码，</p>
<p>2.1） 找到ASE的安装目录，打开 <code>ase/io</code> 目录下的<code>vasp5.py</code> 文件；</p>
<p>2.2） 将<code>vasp.py</code>中<code>vasp5 = False</code> 全部改为<code>vasp5 = True</code>；</p>
<p>2.3） 保存<code>vasp.py</code> 即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qli@bigbro:~/anaconda3/lib/python3.8/site-packages/ase/io$ pwd</span><br><span class="line">/home/qli/anaconda3/lib/python3.8/site-packages/ase/io</span><br><span class="line">qli@bigbro:~/anaconda3/lib/python3.8/site-packages/ase/io$ grep vasp5 vasp.py</span><br><span class="line">    vasp5 = True</span><br><span class="line">        vasp5 = True</span><br><span class="line">    if not vasp5:</span><br><span class="line">               symbol_count=None, long_format=True, vasp5=True,</span><br><span class="line">    if vasp5:</span><br><span class="line">qli@bigbro:~/anaconda3/lib/python3.8/site-packages/ase/io$ cd ~/Downloads/</span><br><span class="line">qli@bigbro:~/Downloads$ ls</span><br><span class="line">6084.mol  C2H6.xyz  CO2_mp-20066_conventional_standard.cif  CO2_mp-20066.xyz  POSCAR</span><br><span class="line">qli@bigbro:~/Downloads$ ase gui CO2_mp-20066_conventional_standard.cif  -o POSCAR</span><br><span class="line">/home/qli/.local/lib/python3.8/site-packages/ase/gui/ag.py:85: UserWarning: You should be using &quot;ase convert ...&quot; instead!</span><br><span class="line">  warnings.warn(&#x27;You should be using &quot;ase convert ...&quot; instead!&#x27;)</span><br><span class="line">qli@bigbro:~/Downloads$ head -n 6 POSCAR</span><br><span class="line"> C  O</span><br><span class="line"> 1.0000000000000000</span><br><span class="line">     5.8026989999999996    0.0000000000000000    0.0000000000000000</span><br><span class="line">     0.0000000000000000    5.8026989999999996    0.0000000000000000</span><br><span class="line">     0.0000000000000000    0.0000000000000000    5.8026989999999996</span><br><span class="line">   C   O</span><br></pre></td></tr></table></figure>
<p>如果有其他的需求，可以继续研究ASE或者等后面的骚操作。再继续分解自己：怎么才能把其他格式的文件转化成我需要的格式呢？</p>
<p>上文中的例子已经给你足够的启发了。</p>
<p>妹妹你大胆地往前走<br>往前走 莫回呀头<br>通天的大路 九千九百<br>九千九百九呀<br>……</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>ASE</tag>
        <tag>格式转换</tag>
      </tags>
  </entry>
  <entry>
    <title>ExA16 通过ASE简单扩胞的小脚本</title>
    <url>/2019/10/03/A16/</url>
    <content><![CDATA[<p>我们计算的时候，经常会遇到扩胞的需求。比如，我们要优化（4x4）的Ag(111)的一个slab。直接切一个slab拿来优化，可能会比较耗时。另一个办法就是我们先优化一个（1x1)的Ag(111)的slab，然后在将优化完的结构扩成（4x4)的，最后再优化。这样能有效地减少工作量。</p>
<p>扩胞的话，有很多工具可以选择，MS, P4vasp,等等可视化的软件，用鼠标点点就OK了。也可以使用一些现成的脚本，小程序。本节就介绍一个通过ASE进行扩胞的小脚本，也是本人偶然在一个网站发现的。有兴趣的可以自己看下： <a href="https://www.nsc.liu.se/~pla/blog/2013/02/26/vaspsupercells/">https://www.nsc.liu.se/~pla/blog/2013/02/26/vaspsupercells/</a> </p>
<p>废话不多说，直接上例子，例子完了是脚本的具体内容。</p>
<p>如果你有自己的脚本或者推荐的程序，也欢迎发送到本人邮箱：lqcata@gmail.com。后面我们会逐渐扩展本节的内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@bigbro:~/Desktop/test_expand$ ls</span><br><span class="line">CONTCAR  expand.py</span><br><span class="line">qli@bigbro:~/Desktop/test_expand$ cat CONTCAR  </span><br><span class="line">Ag                                      </span><br><span class="line">   1.00000000000000     </span><br><span class="line">     3.0472766735234269    0.0000000000000000    0.0000000000000000</span><br><span class="line">     1.5236383367617135    2.6390190116310261    0.0000000000000000</span><br><span class="line">     0.0000000000000000    0.0000000000000000   22.4642729552180782</span><br><span class="line">   Ag</span><br><span class="line">     4</span><br><span class="line">Selective dynamics</span><br><span class="line">Direct</span><br><span class="line">  0.0000000000000000  0.0000000000000000  0.0000000000000000   F   F   F</span><br><span class="line">  0.3333333333333357  0.3333333333333357  0.1107576902236147   F   F   F</span><br><span class="line">  0.6666666666666643  0.6666666666666643  0.2214586458624846   T   T   T</span><br><span class="line"> -0.0000000000000000 -0.0000000000000000  0.3323996157642722   T   T   T</span><br><span class="line"> </span><br><span class="line">  0.00000000E+00  0.00000000E+00  0.00000000E+00</span><br><span class="line">  0.00000000E+00  0.00000000E+00  0.00000000E+00</span><br><span class="line">  0.00000000E+00  0.00000000E+00  0.00000000E+00</span><br><span class="line">  0.00000000E+00  0.00000000E+00  0.00000000E+00</span><br><span class="line">qli@bigbro:~/Desktop/test_expand$ python expand.py  CONTCAR  2 2 1 </span><br><span class="line">qli@bigbro:~/Desktop/test_expand$ ls</span><br><span class="line">CONTCAR  expand.py  POSCAR_ex</span><br><span class="line">qli@bigbro:~/Desktop/test_expand$ cat POSCAR_ex </span><br><span class="line">Supercell</span><br><span class="line"> 1.0000000000000000</span><br><span class="line">     6.0945533470468538    0.0000000000000000    0.0000000000000000</span><br><span class="line">     3.0472766735234269    5.2780380232620523    0.0000000000000000</span><br><span class="line">     0.0000000000000000    0.0000000000000000   22.4642729552180782</span><br><span class="line">  16</span><br><span class="line">Selective dynamics</span><br><span class="line">Direct</span><br><span class="line">  0.0000000000000000  0.0000000000000000  0.0000000000000000   F   F   F</span><br><span class="line">  0.1666666666666679  0.1666666666666679  0.1107576902236147   F   F   F</span><br><span class="line">  0.3333333333333321  0.3333333333333321  0.2214586458624846   T   T   T</span><br><span class="line">  0.0000000000000000  0.0000000000000000  0.3323996157642722   T   T   T</span><br><span class="line">  0.0000000000000000  0.5000000000000000  0.0000000000000000   F   F   F</span><br><span class="line">  0.1666666666666679  0.6666666666666679  0.1107576902236147   F   F   F</span><br><span class="line">  0.3333333333333321  0.8333333333333323  0.2214586458624846   T   T   T</span><br><span class="line">  0.0000000000000000  0.5000000000000000  0.3323996157642722   T   T   T</span><br><span class="line">  0.4999999999999999  0.0000000000000000  0.0000000000000000   F   F   F</span><br><span class="line">  0.6666666666666679  0.1666666666666679  0.1107576902236147   F   F   F</span><br><span class="line">  0.8333333333333320  0.3333333333333321  0.2214586458624846   T   T   T</span><br><span class="line">  0.4999999999999999  0.0000000000000000  0.3323996157642722   T   T   T</span><br><span class="line">  0.4999999999999999  0.5000000000000000  0.0000000000000000   F   F   F</span><br><span class="line">  0.6666666666666677  0.6666666666666679  0.1107576902236147   F   F   F</span><br><span class="line">  0.8333333333333320  0.8333333333333323  0.2214586458624846   T   T   T</span><br><span class="line">  0.4999999999999999  0.5000000000000000  0.3323996157642722   T   T   T</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>脚本内容如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment">## https://www.nsc.liu.se/~pla/blog/2013/02/26/vaspsupercells/</span></span><br><span class="line"><span class="keyword">import</span>  ase.io.vasp</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">cell_file = sys.argv[<span class="number">1</span>]</span><br><span class="line">x,y,z = [<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> sys.argv[<span class="number">2</span>:<span class="number">5</span>]]</span><br><span class="line">cell = ase.io.vasp.read_vasp(cell_file)</span><br><span class="line">ase.io.vasp.write_vasp(<span class="string">&quot;POSCAR_ex&quot;</span>,cell*(x,y,z), label=<span class="string">&#x27;Supercell&#x27;</span>,direct=<span class="literal">True</span>,sort=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>使用前提是你已经安装好了ASE。</p>
<p>再次啰嗦一下，欢迎大家分享自己扩胞的小脚本，推荐的小程序，一起完善本节的内容。请发送到本人邮箱：lqcata@gmail.com。</p>
]]></content>
      <categories>
        <category>LVASPTHW附录</category>
      </categories>
      <tags>
        <tag>p4vasp</tag>
        <tag>ASE</tag>
        <tag>扩胞</tag>
      </tags>
  </entry>
  <entry>
    <title>Pymatgen的骚操作系列（计算离子电导率）</title>
    <url>/2020/09/08/A18/</url>
    <content><![CDATA[<p>ASE 在 DFT 计算中的骚操作令人印象深刻。类似 ASE 的科研工具还有很多，比如 VASPKIT 和 QVASP。熟练使用这些科研工具肯定会助力大家快速完成科研任务，发出更好更高质量的文章。</p>
<p>此次，本文向大家隆重介绍另一款出色的科研工具：Pymatgen。</p>
<p>Pymatgen 是 python materials genomics 的缩写，它是一款基于 python 的、开源的、强大的材料分析软件（<a href="https://pymatgen.org/）。">https://pymatgen.org/）。</a></p>
<p>Pymatgen 包含一系列能够表示元素（Element）、位点（Site）、分子（Molecule）、和结构（Structure）的类（Class）。它具有为很多计算软件提供前处理和后处理的能力。这些计算软件包括VASP，ABINIT，exciting，FEFF，QCHEM，LAMMPS，ADF，AIIDA，ASE，Gaussian，Lobster，Phonopy，Shengbte，Pwscf，和Zeo++等等。它能实现科研狗的众多后处理需求，包括生成相图（Phase diagram）和布拜图（Pourbaix diagrams），分析态密度和能带等等。</p>
<p>Pymatgen 还提供了很多数据库（Materials Project REST API，Crystallography Open Database，and other external data sources）的接口，方便大家从数据库中查询结构和其他数据。</p>
<p>真是科研狗快乐科研之利器呀！</p>
<blockquote>
<p>以下是Pymatgen官网提供的后处理的例子：</p>
</blockquote>
<p><img src="/2020/09/08/A18/examples.png" alt=""></p>
<p><em>Top: (left) Phase and (right) Pourbaix diagram from the Materials API. Bottom left: Calculated bandstructure plot using pymatgen’s parsing and plotting utilities. Bottom right: Arrhenius plot using pymatgen’s DiffusionAnalyzer.</em></p>
<p><strong>此次，本文就介绍一下如何使用 Pymatgen 的 DiffusionAnalyzer 类去计算锂离子固态电解质中锂离子电导率。</strong></p>
<h2 id="计算离子电导率的理论与公式"><a href="#计算离子电导率的理论与公式" class="headerlink" title="计算离子电导率的理论与公式"></a>计算离子电导率的理论与公式</h2><p>目前，比较准确的计算离子电导率的方法是先用NVT系综第一性原理分子动力学（<strong>AIMD</strong>，<em>ab initio</em> molecular dynamics）模拟材料中离子在不同温度下的运动，然后计算出离子的平均（average）均方位移（<strong>MSD</strong>，mean square displacement），再计算出自扩散系数（D$_s$，self-diffusion coefficient），最后求得离子在某温度下的电导率（$\sigma$，conductivity）。</p>
<h3 id="如何进行AIMD计算"><a href="#如何进行AIMD计算" class="headerlink" title="如何进行AIMD计算"></a>如何进行AIMD计算</h3><p>AIMD计算通常非常耗时，所以，为了减少计算成本，我们可以适当放宽计算精度。如果用 VASP 进行计算，具体的，大家可以</p>
<ul>
<li>采用较小的截断能。氧化物用 400 eV，硫化物用 280 eV，硒化物用 270 eV</li>
<li>采用Gamma点作为K点设置，并使用gam版本的 VASP 进行计算</li>
<li>采用单胞计算，如果材料的单胞包含比较多的原子</li>
<li>采用合适的步长，比如2 fs，即 POTIM = 2</li>
</ul>
<h3 id="后处理的基本公式"><a href="#后处理的基本公式" class="headerlink" title="后处理的基本公式"></a>后处理的基本公式</h3><p>一旦AIMD计算完成，大家就可以着手计算离子电导率了。本文首先先介绍以下计算过程中使用的公式，方便有兴趣的同学自己开发脚本。</p>
<blockquote>
<p>平均均方位移（average MSD）可以通过以下公式计算：</p>
<script type="math/tex; mode=display">
averageMSD=\langle[\, \mathbf r(t)]^2\,\rangle=\frac{1}{N}\sum_{i}^{N}\langle[\,  \mathbf r_i(t+t_0)]\,^2 - [\,  \mathbf r_i(t_0)]\,^2\rangle</script><p>$\mathbf r_i(t)$ 是第 $i$ 个离子在 $t$ 时刻的位移。</p>
<p>自扩散系数（$D_s$）可以通过以下公式计算：</p>
<script type="math/tex; mode=display">
D_s=\frac{averageMSD}{2dt}</script><p>$d$ 是离子在材料中的扩散维度（一般地，$d=3$），$t$ 是离子扩散的时间。</p>
<p>最后，离子电导率（$\sigma$）可以这样计算：</p>
<script type="math/tex; mode=display">
\sigma=\frac{ne^2Z^2}{k_BT}D_s</script><p>$n$ 是材料中的离子密度，$e$ 是元电荷，$Z$ 是离子的价态，$k_B$ 是玻尔兹曼常数，$T$ 是温度。</p>
</blockquote>
<h2 id="电导率计算的例子"><a href="#电导率计算的例子" class="headerlink" title="电导率计算的例子"></a>电导率计算的例子</h2><p>现在我们通过一个 Li_Sn_S 材料的例子来详细了解一下整个计算和处理的过程。该材料的结构显示如下：</p>
<p><img src="/2020/09/08/A18/Li_Sn_S.jpg" alt=""></p>
<p>本例中采用单胞做计算，INCAR 设置如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[test@ln0%tianhe2 li_sn_s]$ vi INCAR</span><br><span class="line"></span><br><span class="line">ISTART = <span class="number">0</span></span><br><span class="line">ICHARG = <span class="number">2</span></span><br><span class="line">IBRION = <span class="number">0</span></span><br><span class="line">ISIF = <span class="number">2</span></span><br><span class="line">NPAR = <span class="number">8</span></span><br><span class="line">NSW = <span class="number">30000</span></span><br><span class="line">TEBEG = <span class="number">900</span> <span class="comment">#还要设置成 1500K 等等</span></span><br><span class="line">PREC = N</span><br><span class="line">POTIM = <span class="number">2</span></span><br><span class="line">SMASS = <span class="number">0.0</span></span><br><span class="line">NELMIN = <span class="number">4</span></span><br><span class="line">LWAVE = F</span><br><span class="line">LCHARG = F</span><br><span class="line">IALGO = <span class="number">48</span></span><br><span class="line">LREAL = A</span><br></pre></td></tr></table></figure>
<p>AIMD 计算结束之后会得到 XDATCAR 文件。很多时候，由于超算的时间限制，一个完整的AIMD计算需要提交两三次，从而产生两三个 XDATCAR 文件，这时，我们只要把它们按顺序通过 cat 命令合并在一起就行。例如我们有三个 XDATCAR 文件，分别命名成 XDATCAR01，XDATCAR02，和 XDATCAR03。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[test@ln0%tianhe2 li_sn_s]$ cat XDATCAR01 XDATCAR02 XDATCAR03 &gt; XDATCAR </span><br></pre></td></tr></table></figure>
<p><strong>新得到的XDATCAR文件，注意删掉重复的与晶格信息相关的行</strong>，一般续算的次数也不多，在使用上面命令的时候，手动把<code>XDATCAR02</code>, <code>XDATCAR03</code> 中的删除即可。</p>
<h3 id="Pymatgen-大显身手"><a href="#Pymatgen-大显身手" class="headerlink" title="Pymatgen 大显身手"></a>Pymatgen 大显身手</h3><h4 id="安装pymatgen"><a href="#安装pymatgen" class="headerlink" title="安装pymatgen"></a>安装pymatgen</h4><p>首先让我们安装 pyamtgen，推荐大家参考官网，使用 anaconda 安装，否则会出现问题。安装好了anaconda之后，不管是 linux 还是 windows, 安装 pyamtgen 的指令是一样的。下面以吕梁天河超算为例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">[test@ln0%</span><span class="bash">tianhe2 li_sn_s]$ conda install --channel conda-forge pymatgen</span></span><br></pre></td></tr></table></figure>
<p>安装完成后，我们可以试着运行 python，导入 Pyamtgen 模块，如果像下面一样没有出错，就是安装成功了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[test@ln0%tianhe2 li_sn_s]$ python</span><br><span class="line">Python <span class="number">3.7</span><span class="number">.3</span> (default, Mar <span class="number">27</span> <span class="number">2019</span>, <span class="number">22</span>:<span class="number">11</span>:<span class="number">17</span>) </span><br><span class="line">[GCC <span class="number">7.3</span><span class="number">.0</span>] :: Anaconda, Inc. on linux</span><br><span class="line"><span class="type">Type</span> <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> <span class="keyword">or</span> <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pymatgen</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure>
<h4 id="查看-DiffusionAnalyzer-的类"><a href="#查看-DiffusionAnalyzer-的类" class="headerlink" title="查看 DiffusionAnalyzer 的类"></a>查看 DiffusionAnalyzer 的类</h4><p>大家可以通过官方文档（<a href="https://pymatgen.org/pymatgen.analysis.diffusion_analyzer.html）查看接下来要使用的类，熟悉一下代码的用法。">https://pymatgen.org/pymatgen.analysis.diffusion_analyzer.html）查看接下来要使用的类，熟悉一下代码的用法。</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiffusionAnalyzer</span>(<span class="params">MSONable</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, structure, displacements, specie, temperature,</span></span></span><br><span class="line"><span class="params"><span class="function">                 time_step, step_skip, smoothed=<span class="string">&quot;max&quot;</span>, min_obs=<span class="number">30</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                 avg_nsteps=<span class="number">1000</span>, lattices=<span class="literal">None</span></span>):</span></span><br></pre></td></tr></table></figure>
<p>这段代码显示，运行这个类需要一系列的输入信息，包括材料结构（structure），位移（displacements），要研究的离子（specie），温度（temperature）等等。</p>
<p>但是这个类提供了很多方法让大家可以通过读取 XDATCAR 或者 vasprun 文件的方式来实例化，例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_structures</span>(<span class="params">cls, structures, specie, temperature,</span></span></span><br><span class="line"><span class="params"><span class="function">                        time_step, step_skip, initial_disp=<span class="literal">None</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                        initial_structure=<span class="literal">None</span>, **kwargs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Convenient constructor that takes in a list of Structure objects to</span></span><br><span class="line"><span class="string">        perform diffusion analysis.</span></span><br><span class="line"><span class="string">        Args:</span></span><br><span class="line"><span class="string">            structures ([Structure]): list of Structure objects (must be</span></span><br><span class="line"><span class="string">                ordered in sequence of run). E.g., you may have performed</span></span><br><span class="line"><span class="string">                sequential VASP runs to obtain sufficient statistics.</span></span><br><span class="line"><span class="string">        ... ...</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>好了，废话不多说，直接上代码，开始进行后处理。</p>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><p>新建一个文件，名字为<code>li_conductivity.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">分析AIMD结果，计算MSD 和 conductivity</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> pymatgen.core.trajectory <span class="keyword">import</span> Trajectory</span><br><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.outputs <span class="keyword">import</span> Xdatcar</span><br><span class="line"><span class="keyword">from</span> pymatgen <span class="keyword">import</span> Structure</span><br><span class="line"><span class="keyword">from</span> pymatgen.analysis.diffusion_analyzer <span class="keyword">import</span> DiffusionAnalyzer</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这一步是读取 XDATCAR，得到一系列结构信息</span></span><br><span class="line">traj = Trajectory.from_file(<span class="string">&#x27;XDATCAR&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这一步是实例化 DiffusionAnalyzer 的类</span></span><br><span class="line"><span class="comment"># 并用 from_structures 方法初始化这个类； 900 是温度，2 是POTIM 的值，1是间隔步数</span></span><br><span class="line"><span class="comment"># 间隔步数（step_skip）不太容易理解，但是根据官方教程:</span></span><br><span class="line"><span class="comment"># dt = timesteps * self.time_step * self.step_skip</span></span><br><span class="line"></span><br><span class="line">diff = DiffusionAnalyzer.from_structures(traj,<span class="string">&#x27;Li&#x27;</span>,<span class="number">900</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以用内置的 plot_msd 方法画出 MSD 图像</span></span><br><span class="line"><span class="comment"># 有些终端不能显示图像，这时候可以调用 export_msdt() 方法，得到数据后再自己作图</span></span><br><span class="line">diff.plot_msd()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来直接得到 离子迁移率， 单位是 mS/cm</span></span><br><span class="line">C = diff.conductivity</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;result.dat&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;# AIMD result for Li-ion\n&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;temp\tconductivity\n&#x27;</span>)</span><br><span class="line">    f.write(<span class="string">&#x27;%d\t%.2f\n&#x27;</span> %(<span class="number">900</span>,C))</span><br></pre></td></tr></table></figure>
<p>在终端运行该文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[test@ln0%tianhe2 li_sn_s]$ python li_conductivity.py</span><br></pre></td></tr></table></figure>
<p>一段时间后就会得到MSD图像和离子电导率</p>
<p><img src="/2020/09/08/A18/MSD.png" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[test@ln0%tianhe2 li_sn_s]$ vi result.dat</span><br><span class="line"></span><br><span class="line"># AIMD result for Li-ion</span><br><span class="line">temp	conductivity</span><br><span class="line">900	884.05</span><br></pre></td></tr></table></figure>
<p>可见，该材料在 900K 时的锂离子电导率为 884.05 mS/cm。</p>
<h4 id="例子下载："><a href="#例子下载：" class="headerlink" title="例子下载："></a>例子下载：</h4><p>链接：<a href="https://pan.baidu.com/s/1WGzOVJBoe6Ym8mvR1uWanA">https://pan.baidu.com/s/1WGzOVJBoe6Ym8mvR1uWanA</a><br>提取码：jhc5</p>
<h4 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h4><ul>
<li>简短几行代码就可以计算出离子电导率，那么如何得出材料在300K下的电导率呢？</li>
<li>如何计算离子在材料中的迁移势垒？</li>
<li>如何可视化离子在材料中的扩散路径？</li>
</ul>
<p>本文只是浅谈离子电导率的计算，欢迎大家指出计算过程中的不足之处。</p>
<h4 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a>打赏</h4><p>如果感觉本文对你的相关研究有帮助，欢迎打赏，支持作者的热心付出。如果你也有自己的骚操作，热烈欢迎无私分享，可以通过QQ联系（122103465）</p>
<p><img src="/2020/09/08/A18/打赏码.jpg" style="zoom:25%;"></p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>Pymatgen</tag>
      </tags>
  </entry>
  <entry>
    <title>ASE的骚操作系列（扩胞）</title>
    <url>/2020/09/11/A19/</url>
    <content><![CDATA[<p>本节介绍一下ASE的另一个骚操作—-扩胞。说到扩胞，这个大家都不陌生，可以有很多种方式来实现，本教程中就介绍了p4vasp的一种操作，今天就看一下ASE的骚操作吧。废话不多说，直接上例子和脚本。</p>
<h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><p>本例子中，主要把优化好的一个(1x1)-Ru(0001)的slab 扩胞为（4x4）的slab。为什么这样做呢？因为直接优化刚刚切好的（4x4)slab会有些费时间。先优化（1x1)的，在CONTCAR的基础上扩展为（4x4）的，再优化会相对来说快一些。但现在大家服务器一般都很给力，从刚切好的（1x1) slab直接扩展到（4x4），然后再优化也可以的。不管怎么样，扩胞这个操作都是必须的。如果你硬要抬扛说，我可以直接从bulk切出来（4x4)的，不用扩胞这么麻烦。OK，这也是可以的。但等你需要扩胞操作的时候，记得回来看这个骚操作就行。</p>
<p>先展示一下效果吧： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@bigbro:~/Desktop/A19$ ls</span><br><span class="line">CONTCAR  expand.py </span><br><span class="line">qli@bigbro:~/Desktop/A19$ python3 expand.py  CONTCAR  4 4 1 </span><br><span class="line">qli@bigbro:~/Desktop/A19$ ls</span><br><span class="line">CONTCAR  expand.py  POSCAR</span><br><span class="line">qli@bigbro:~/Desktop/A19$ ase gui <span class="string">&quot;-R -90x&quot;</span> CONTCAR </span><br><span class="line">qli@bigbro:~/Desktop/A19$ ase gui <span class="string">&quot;-R -90x&quot;</span> POSCAR </span><br></pre></td></tr></table></figure>
<p>扩胞前：（CONTCAR）</p>
<p><img src="/2020/09/11/A19/1x1.png" alt=""></p>
<p>扩胞后：（POSCAR）</p>
<p><img src="/2020/09/11/A19/4x4.png" alt=""></p>
<h4 id="脚本："><a href="#脚本：" class="headerlink" title="脚本："></a>脚本：</h4><p>脚本可以通过git-hub下载，链接：</p>
<p><a href="https://github.com/BigBroSci-LVTHW/LVTHW/tree/master/source/_posts/A19">https://github.com/BigBroSci-LVTHW/LVTHW/tree/master/source/_posts/A19</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Created on Wed Oct  2 10:54:36 2019</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: qli</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> sys, os</span><br><span class="line"><span class="keyword">import</span> ase.io.vasp</span><br><span class="line"></span><br><span class="line">file_read = sys.argv[<span class="number">1</span>]</span><br><span class="line">x,y,z     = [<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> sys.argv[<span class="number">2</span>:<span class="number">5</span>]]</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cell = ase.io.vasp.read_vasp(<span class="string">&quot;CONTCAR&quot;</span>)</span><br><span class="line">    ase.io.vasp.write_vasp(<span class="string">&quot;POSCAR&quot;</span>,cell*(x, y, z), direct=<span class="literal">True</span>,sort=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="built_in">print</span>(os.getcwd())</span><br></pre></td></tr></table></figure>
<p>前面的扩胞命令：<code>expand.py  CONTCAR  4 4 1</code></p>
<p><code>CONTCAR</code> 对应的为 <code>sys.argv[1]</code></p>
<p><code>4 4 1</code> 分别为在<code>x,y,z</code> 三个方向扩胞的倍数。</p>
<h4 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a>打赏</h4><p>如果感觉本文对你的相关研究有帮助，欢迎打赏，支持作者的热心付出。如果你也有自己的骚操作，热烈欢迎无私分享，可以通过QQ（122103465）或者邮件（lqcata@gmail.com）联系。</p>
<p><img src="/2020/09/11/A19/打赏码.jpg" style="zoom:25%;"></p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>ASE</tag>
        <tag>扩胞</tag>
        <tag>骚操作</tag>
      </tags>
  </entry>
  <entry>
    <title>ASE的骚操作系列（SMILES-To-XYZ）</title>
    <url>/2020/09/19/A20/</url>
    <content><![CDATA[<p>今天我们介绍ASE的另一个骚操作：结合Openbabel自动搭分子结构。与其说是ASE的骚操作，不如把这个骚字放在Openbabel头上。Openbabel是一款功能极其强大的结构转化工具。如果你在用它，我就不在这里啰嗦了。如果你没听过，可以通过这个链接来初步了解一下。（<a href="http://openbabel.org/wiki/Main_Page）">http://openbabel.org/wiki/Main_Page）</a></p>
<p>鉴于Openbabel的安装比较蛋疼，先送一波福利（Mac，Linux用户）。下面是本人通过Anaconda（已经路转粉）创建虚拟环境，并且安装这些软件的一些命令。通过它们可以让你安全顺利，麻溜滴地安装Openbabel, RDkit, Ase，和pymatgen。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create --name qrobot</span><br><span class="line">conda activate qrobot</span><br><span class="line">conda install -c conda-forge openbabel</span><br><span class="line">conda install -c conda-forge rdkit</span><br><span class="line">conda install -c conda-forge ase</span><br><span class="line">conda install --channel conda-forge pymatgen</span><br></pre></td></tr></table></figure>
<p>RDkit也是一款功能及其强大地软件，尤其是化学信息学，生物化学相关的领域。如果不了解，点击这个官网学习。（<a href="https://www.rdkit.org/）顺便吐槽一下，百度里面你搜索一堆RDkit的使用，大部分都是把官网例子复制过来，然后贴个二维码要钱的。交不交智商税决定权在你手上，如果手痒，请跳到文末最后，把钱打赏给我。">https://www.rdkit.org/）顺便吐槽一下，百度里面你搜索一堆RDkit的使用，大部分都是把官网例子复制过来，然后贴个二维码要钱的。交不交智商税决定权在你手上，如果手痒，请跳到文末最后，把钱打赏给我。</a></p>
<p>废话不多说，转到我们今天的主题： SMILES to XYZ。又是一个新知识，什么是SMILES？ </p>
<p>SMILES是<strong>simplified molecular-input line-entry system</strong> 的缩写，旨在用ASCII字符串来标识，描述分子的结构。如果你不了解，可以通过下面两个链接初步了解一下：</p>
<p><a href="https://en.wikipedia.org/wiki/Simplified_molecular-input_line-entry_system">https://en.wikipedia.org/wiki/Simplified_molecular-input_line-entry_system</a></p>
<p><a href="https://www.daylight.com/dayhtml/doc/theory/theory.smiles.html">https://www.daylight.com/dayhtml/doc/theory/theory.smiles.html</a></p>
<p>通过SMILES我们可以将一个分子用字符串来标识出来，比如我们后面练习中的：</p>
<p>乙醇（CCO），甲烷（C），甲基（[CH3]）, 苯（c1ccccc1）。</p>
<p>所以，在操作之前，你需要知道所搭结构的SMILES字符串。通过上面两个链接，耐心钻研一下，应该不到1天就可以搞定大部分的分子。将SMILES转化为3D的结构，可以通过Openbabel，也可以通过RDkit。今天我们就介绍前者。下面是脚本内容（smiles_to_xyz.py）以及使用的效果。最后，我们再详细解释这个脚本是怎么工作的。</p>
<h5 id="脚本内容"><a href="#脚本内容" class="headerlink" title="脚本内容"></a>脚本内容</h5><p>下载链接：<a href="https://github.com/BigBroSci-LVTHW/LVTHW/tree/master/source/_posts/A20">https://github.com/BigBroSci-LVTHW/LVTHW/tree/master/source/_posts/A20</a> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3 </span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">convert SMILES to xyz</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> openbabel <span class="keyword">import</span> pybel</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> ase</span><br><span class="line"><span class="keyword">import</span> ase.io</span><br><span class="line"><span class="keyword">from</span> ase <span class="keyword">import</span> Atoms</span><br><span class="line"><span class="keyword">from</span> ase.constraints <span class="keyword">import</span> FixAtoms</span><br><span class="line"> </span><br><span class="line">smiles, out_name = sys.argv[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Introduction to SMILES:</span></span><br><span class="line"><span class="string">https://en.wikipedia.org/wiki/Simplified_molecular-input_line-entry_system</span></span><br><span class="line"><span class="string">https://www.daylight.com/dayhtml/doc/theory/theory.smiles.html</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Use openbabel to convert SMILES to xyz. </span></span><br><span class="line">mol = pybel.readstring(<span class="string">&quot;smi&quot;</span>, smiles)</span><br><span class="line">mol.make3D(forcefield=<span class="string">&#x27;mmff94&#x27;</span>, steps=<span class="number">100</span>)</span><br><span class="line"><span class="comment"># mol.write(&quot;xyz&quot;, filename=out_name+&#x27;_pybel.xyz&#x27;, overwrite=True)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># USE ase to make POSCAR</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; https://wiki.fysik.dtu.dk/ase/ase/atoms.html&#x27;&#x27;&#x27;</span></span><br><span class="line">geo = Atoms()</span><br><span class="line">geo.set_cell(np.array([[<span class="number">16.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>],[<span class="number">0.0</span>, <span class="number">17.0</span>, <span class="number">0.0</span>],[<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">18.0</span>]]))</span><br><span class="line">geo.set_pbc((<span class="literal">True</span>,<span class="literal">True</span>,<span class="literal">True</span>))</span><br><span class="line"><span class="keyword">for</span> atom <span class="keyword">in</span> mol:</span><br><span class="line">    atom_type = atom.atomicnum</span><br><span class="line">    atom_position = np.array([<span class="built_in">float</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> atom.coords])</span><br><span class="line">    geo.append(atom_type)</span><br><span class="line">    geo.positions[-<span class="number">1</span>] = atom_position</span><br><span class="line">geo.center()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;https://wiki.fysik.dtu.dk/ase/ase/constraints.html&#x27;&#x27;&#x27;</span></span><br><span class="line">c = FixAtoms(indices=[atom.index <span class="keyword">for</span> atom <span class="keyword">in</span> geo <span class="keyword">if</span> atom.symbol == <span class="string">&#x27;XX&#x27;</span>])</span><br><span class="line">geo.set_constraint(c)</span><br><span class="line"></span><br><span class="line">ase.io.write(out_name + <span class="string">&#x27;_ase.xyz&#x27;</span>, geo, <span class="built_in">format</span>=<span class="string">&#x27;xyz&#x27;</span>)</span><br><span class="line">ase.io.write(out_name + <span class="string">&#x27;_POSCAR&#x27;</span>, geo, <span class="built_in">format</span>=<span class="string">&#x27;vasp&#x27;</span>, vasp5=<span class="string">&#x27;True&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="脚本运行"><a href="#脚本运行" class="headerlink" title="脚本运行"></a>脚本运行</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> (qrobot) qli@MacBook-Pro test_openbabel % python3 smiles_to_xyz.py <span class="string">&#x27;[CH3]&#x27;</span> Methyl</span><br><span class="line"> (qrobot) qli@MacBook-Pro test_openbabel % python3 smiles_to_xyz.py <span class="string">&#x27;CCO&#x27;</span> ET</span><br><span class="line"> (qrobot) qli@MacBook-Pro test_openbabel % python3 smiles_to_xyz.py <span class="string">&#x27;C&#x27;</span> Methane</span><br><span class="line"> (qrobot) qli@MacBook-Pro test_openbabel % python3 smiles_to_xyz.py <span class="string">&#x27;c1ccccc1&#x27;</span> BZ</span><br><span class="line"> (qrobot) qli@MacBook-Pro test_openbabel % ls</span><br><span class="line">BZ_POSCAR         BZ_ase.xyz        ET_POSCAR         ET_ase.xyz        Methane_POSCAR    Methane_ase.xyz   Methyl_POSCAR     Methyl_ase.xyz    smiles_to_xyz.py</span><br></pre></td></tr></table></figure>
<h5 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h5><p><img src="/2020/09/19/A20/BZ.png" alt=""></p>
<p><img src="/2020/09/19/A20/ET.png" alt="ET"></p>
<p><img src="/2020/09/19/A20/Methane.png" alt="Methane"></p>
<p><img src="/2020/09/19/A20/Methyl.png" alt="Methyl"></p>
<h5 id="内容详解"><a href="#内容详解" class="headerlink" title="内容详解"></a>内容详解</h5><ol>
<li>Openbabel部分其实就三行代码，非常简单。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> mol = pybel.readstring(<span class="string">&quot;smi&quot;</span>, smiles)</span><br><span class="line"><span class="number">2</span> mol.make3D(forcefield=<span class="string">&#x27;mmff94&#x27;</span>, steps=<span class="number">100</span>)</span><br><span class="line"><span class="number">3</span> <span class="comment"># mol.write(&quot;xyz&quot;, filename=out_name+&#x27;_pybel.xyz&#x27;, overwrite=True)</span></span><br></pre></td></tr></table></figure>
<p>1) 读取SMILES，并创建一个mol的对象（object）。</p>
<p>2) <code>make3D</code> 通过MMFF94力场对生成的3D结构优化了100步。 </p>
<p>3) 保存结构，这里我把它注释掉了，因为后面我们要通过ASE来生成xyz和POSCAR。</p>
<ol>
<li>ASE部分，代码多一些，可能本人水平有限吧。不管怎么样，这里主要告诉大家的一点就是：我们可以将Openbabel和ASE无缝连接起来。同样，你也可以把ASE与你自己写的一些东西关联，这样就可以调用ASE的功能来快速实现一些小目标了。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> geo = Atoms()</span><br><span class="line"><span class="number">2</span> geo.set_cell(np.array([[<span class="number">16.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>],[<span class="number">0.0</span>, <span class="number">17.0</span>, <span class="number">0.0</span>],[<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">18.0</span>]]))</span><br><span class="line"><span class="number">3</span> geo.set_pbc((<span class="literal">True</span>,<span class="literal">True</span>,<span class="literal">True</span>))</span><br><span class="line"><span class="number">4</span> <span class="keyword">for</span> atom <span class="keyword">in</span> mol:</span><br><span class="line"><span class="number">5</span>    atom_type = atom.atomicnum</span><br><span class="line"><span class="number">6</span>    atom_position = np.array([<span class="built_in">float</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> atom.coords])</span><br><span class="line"><span class="number">7</span>    geo.append(atom_type)</span><br><span class="line"><span class="number">8</span>    geo.positions[-<span class="number">1</span>] = atom_position</span><br><span class="line"><span class="number">9</span> geo.center()</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;https://wiki.fysik.dtu.dk/ase/ase/constraints.html&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="number">10</span> c = FixAtoms(indices=[atom.index <span class="keyword">for</span> atom <span class="keyword">in</span> geo <span class="keyword">if</span> atom.symbol == <span class="string">&#x27;XX&#x27;</span>])</span><br><span class="line"><span class="number">11</span> geo.set_constraint(c)</span><br><span class="line"></span><br><span class="line"><span class="number">12</span> ase.io.write(out_name + <span class="string">&#x27;_ase.xyz&#x27;</span>, geo, <span class="built_in">format</span>=<span class="string">&#x27;xyz&#x27;</span>)</span><br><span class="line"><span class="number">13</span> ase.io.write(out_name + <span class="string">&#x27;_POSCAR&#x27;</span>, geo, <span class="built_in">format</span>=<span class="string">&#x27;vasp&#x27;</span>, vasp5=<span class="string">&#x27;True&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>1）创建一个ASE的Atom空对象；</p>
<p>2）设置放分子的格子大小，这里我们用的是16x17x18 $\AA^3$的。如果嫌小，自己改大一下就可以了。</p>
<p>3）设置周期性；</p>
<p>4-8）将<code>Openbabel</code>的<code>mol</code>对象中的原子添加到<code>ASE</code>的<code>Atom</code>对象里面。</p>
<p>9）将分子放到格子的中心。</p>
<p>10-11）固定或者放开原子，这里我们打算放开所有的原子，所以用到了一个<code>XX</code> 。如果原子符号是<code>XX</code>，那么就固定住。其实世界上根本就没有<code>XX</code>原子，因此所有的原子就会被放开了。</p>
<p>12-13） 保存xyz和VASP的POSCAR。</p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>通过SMILES来搭建结构非常方便，当然也可以通过数据库下载，可视化程序例如GaussianView等自己手动搭建。</p>
<p>值得注意的是，不管通过什么方式搭建的结构，提交任务之前，都要尽可能保证结构的合理性。所以不要搭建完结构就立刻提交任务，先认真检查一遍，没有任何问题之后再提交。</p>
<h5 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a>打赏</h5><p>如果感觉本文对你的相关研究有帮助，欢迎打赏，支持作者的热心付出。如果你也有自己的骚操作，热烈欢迎无私分享，可以通过QQ（122103465）或者邮件（lqcata@gmail.com）联系。</p>
<p><img src="/2020/09/19/A20/打赏码.jpg" style="zoom:25%;"></p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>ASE</tag>
        <tag>骚操作</tag>
        <tag>SMILES</tag>
        <tag>搭结构</tag>
        <tag>Openbabel</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu20中P4VASP的安装</title>
    <url>/2020/09/22/A21/</url>
    <content><![CDATA[<p>P4vasp是一款基于Python2的，用于可视化，搭建结构的软件。由于Python2已经被时代所淘汰，p4vasp官网也不见任何的针对python3的更新改进，这个软件估计要凉，跟我们再见了。但Ubuntu20安装也不是很难，能撑到博士毕业应该问题不大。经过多次的测试，下面是p4vasp的安装过程，非常简单。</p>
<h5 id="下载并解压"><a href="#下载并解压" class="headerlink" title="下载并解压"></a>下载并解压</h5><p>下载链接：<a href="http://www.p4vasp.at/#/download">http://www.p4vasp.at/#/download</a> </p>
<p>这里本人把安装包解压缩到了<code>~/Documents/</code> 目录下。</p>
<h5 id="安装步骤-1"><a href="#安装步骤-1" class="headerlink" title="安装步骤-1"></a>安装步骤-1</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@bigbrosci:~/Documents/p4vasp-0.3.30$ ls</span><br><span class="line">BUGS           install           odpdom                setenvironment.sh</span><br><span class="line">ChangeLog      install-local.sh  p4v                   src</span><br><span class="line">data           install.sh        p4vasp-0.3.30-1.spec  <span class="built_in">test</span></span><br><span class="line">diagnostic.py  lib               p4vasp.log            uninstall.sh</span><br><span class="line">doc            LICENSE           p4v.py                utils</span><br><span class="line">ext            Makefile          README                vinfo.py</span><br><span class="line">FAQS           Makefile.MacOS    README.MacOS          vinfo.pyc</span><br><span class="line">qli@bigbrosci:~/Documents/p4vasp-0.3.30$ sudo apt-get install gcc make</span><br><span class="line">qli@bigbrosci:~/Documents/p4vasp-0.3.30$ sudo apt-get install make</span><br><span class="line">qli@bigbrosci:~/Documents/p4vasp-0.3.30$ sudo apt-get install python2-dev</span><br></pre></td></tr></table></figure>
<h5 id="安装步骤-2："><a href="#安装步骤-2：" class="headerlink" title="安装步骤-2："></a>安装步骤-2：</h5><p><a href="http://archive.ubuntu.com/ubuntu/pool/universe/p/pygtk/">http://archive.ubuntu.com/ubuntu/pool/universe/p/pygtk/</a></p>
<p>从这个网站下载：python-gtk2 和 python-glade2的deb文件，下载后，双击即可安装。</p>
<p><strong>注意：</strong>先安装gtk2，再安装glade2。</p>
<p><img src="/2020/09/22/A21/A21.png" style="zoom:50%;"></p>
<h5 id="安装步骤-3："><a href="#安装步骤-3：" class="headerlink" title="安装步骤-3："></a>安装步骤-3：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qli@bigbrosci:~/Documents/p4vasp-0.3.30$ sudo apt-get install libxft-dev</span><br><span class="line">qli@bigbrosci:~/Documents/p4vasp-0.3.30$ sudo apt-get install libglfw3-dev libgl1-mesa-dev libglu1-mesa-dev</span><br><span class="line">qli@bigbrosci:~/Documents/p4vasp-0.3.30$ bash install/install-ubuntu-dependencies.sh</span><br><span class="line">qli@bigbrosci:~/Documents/p4vasp-0.3.30$ bash install.sh</span><br></pre></td></tr></table></figure>
<h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><p><code>bash install/install-ubuntu-dependencies.sh</code> 这一步最后可能会出<code>python-epydoc</code>的报错，可以忽略。</p>
<h5 id="反馈："><a href="#反馈：" class="headerlink" title="反馈："></a>反馈：</h5><p>上面的命令是Ubuntu20里面安装用的，如果安装过程出现问题，或者有更好的安装方法，欢迎交流讨论：</p>
<p>QQ：122103465</p>
<p>E-mail：lqcata@gmail.com</p>
<p>至于其他的Linux系统，本人没有测试，如果你有比较好的安装方法，也欢迎分享讨论。</p>
<h5 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a>打赏</h5><p>如果感觉本文对你的相关研究有帮助，欢迎打赏，支持作者的热心付出。如果你也有自己的骚操作，热烈欢迎无私分享，可以通过QQ（122103465）或者邮件（lqcata@gmail.com）联系。</p>
<p><img src="/2020/09/22/A21/打赏码.jpg" style="zoom:25%;"></p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>p4vasp</tag>
        <tag>安装</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu虚拟机的安装</title>
    <url>/2020/09/23/A22/</url>
    <content><![CDATA[<p>为方便新手入坑，这里我们先介绍一下Ubuntu虚拟机的安装细节。VMWARE和VirtualBox是两个主要的选择，前者收费，后者免费。当然介绍免费的喽。 本节主要把安装的过程展示一遍，然后把需要注意的细节强调一下。安装虚拟机要量力而行，优先在台式机上安装虚拟机。如果你的电脑配置很普通的话，运行起来可能不会很流畅。</p>
<h5 id="第一步：-准备工作"><a href="#第一步：-准备工作" class="headerlink" title="第一步： 准备工作"></a>第一步： 准备工作</h5><p>1 下载Ubuntu的安装包</p>
<p><a href="https://ubuntu.com/download/desktop">https://ubuntu.com/download/desktop</a></p>
<p>2 下载Virtual Box，并安装</p>
<p><a href="https://www.virtualbox.org/wiki/Downloads">https://www.virtualbox.org/wiki/Downloads</a></p>
<p>3 下载Virtual Box的扩展包并安装（Extension Pack）</p>
<p><img src="/2020/09/23/A22/VM_D.png" alt=""></p>
<h5 id="第二步：安装虚拟机-初始化"><a href="#第二步：安装虚拟机-初始化" class="headerlink" title="第二步：安装虚拟机(初始化)"></a>第二步：安装虚拟机(初始化)</h5><p>2.1） 创建新的虚拟机</p>
<p><img src="/2020/09/23/A22/1.png" alt=" 9.38.59" style="zoom:50%;"></p>
<p>2.2）设置虚拟机的名字，名字里面只要你输入<code>Ubuntu</code>字样，后面的Type和Version会自动更新，<code>Machine Folder</code> 最好选择一个硬盘比较大的盘。 </p>
<p><img src="/2020/09/23/A22/2.png" alt="2" style="zoom:50%;"></p>
<p>2.3） 设置虚拟机的内存，本人喜欢设置为host的一半。</p>
<p><img src="/2020/09/23/A22/2_1.png" alt="2_1" style="zoom:50%;"></p>
<p>2.4）创建虚拟机，按照图片选择即可。</p>
<p><img src="/2020/09/23/A22/2_2.png" alt="2_2" style="zoom:50%;"></p>
<p><img src="/2020/09/23/A22/3.png" alt="3" style="zoom:50%;"></p>
<p><img src="/2020/09/23/A22/4.png" alt="4" style="zoom:50%;"></p>
<p>2.5） 设置虚拟机的<code>vdi</code>文件的目录，如果前面选择好了，这个采用默认即可。虚拟机的大小：如果使用Ubuntu比较频繁，安装的软件、数据处理等比较多的话，根据自己的情况酌情增加下。但是尽量别太小，到时候存储不够容易导致死机崩溃。</p>
<p>另外一个需要注意的是：Ubuntu的系统以及后面你安装的软件，下载的东西，写的脚本等都会存在这个vdi文件里面，如果你换了一台电脑，还想继续使用虚拟机，大可不用再重复本教程的操作，直接导入vdi即可（前面2.4步骤的第一个图片）。</p>
<p><img src="/2020/09/23/A22/5.png" alt="5" style="zoom:50%;"></p>
<p>2.6） 经过前面步骤，虚拟机初始化基本完成了（界面上可以看到），按照箭头，点<code>Settings</code>。</p>
<p><img src="/2020/09/23/A22/6.png" style="zoom:50%;"></p>
<p>2.7) <code>System</code>设置处理器的数目，同样也是host的一半。太小Ubuntu容易卡死，太大host容易卡死。</p>
<p><img src="/2020/09/23/A22/7.png" alt="7" style="zoom:50%;"></p>
<p>2.8）指定Ubuntu安装iso文件的目录，点<code>Storage</code> —&gt; <code>光盘 Empty</code> —&gt; <code>右侧光盘图标</code> </p>
<p><img src="/2020/09/23/A22/9.png" alt="9" style="zoom:50%;"></p>
<p>2.9） 在弹出的对话框，选择前面下载好的Ubuntu安装文件。</p>
<p><img src="/2020/09/23/A22/10.png" alt="8" style="zoom:50%;"></p>
<p><img src="/2020/09/23/A22/11.png" alt="11" style="zoom: 50%;"></p>
<p><img src="/2020/09/23/A22/12.png" alt="12" style="zoom:50%;"></p>
<h5 id="3-安装虚拟机-（Ubuntu的安装）"><a href="#3-安装虚拟机-（Ubuntu的安装）" class="headerlink" title="3 安装虚拟机 （Ubuntu的安装）"></a>3 安装虚拟机 （Ubuntu的安装）</h5><p>3.1） 点击下方图片的<code>Start</code>绿色图表，开始启动安装</p>
<p><img src="/2020/09/23/A22/13.png" alt="11" style="zoom:50%;"></p>
<p>3.2） 选择Install Ubuntu，后面的一路<code>Continue</code></p>
<p><img src="/2020/09/23/A22/14.png" alt="14" style="zoom:50%;"></p>
<p>3.3） 设置键盘类型</p>
<p><img src="/2020/09/23/A22/15.png" alt="15" style="zoom:50%;"></p>
<p>3.4）按照下面的选择，<code>Continue</code></p>
<p><img src="/2020/09/23/A22/16.png" alt="16" style="zoom:50%;"></p>
<p><img src="/2020/09/23/A22/17.png" alt="17" style="zoom:50%;"></p>
<p>3.5) 设置用户名，计算机名，以及密码。</p>
<p><img src="/2020/09/23/A22/18.png" alt="18" style="zoom: 67%;"></p>
<p>3.6） Ubuntu 终于开始安装了，电脑配置好的别走开，配置不好的一边凉快等着去。（PS：配置不好不建议虚拟机，卡的你怀疑人生）</p>
<p><img src="/2020/09/23/A22/19.png" alt="19" style="zoom:50%;"></p>
<p>3.7） 安装完成后，会提示让你先移除安装的ISO文件，然后再点<code>ENTER</code></p>
<p><img src="/2020/09/23/A22/20.png" style="zoom:50%;"></p>
<p>3.8） 这里本人把安装包改了下名字，然后点<code>ENTER</code>。</p>
<p><img src="/2020/09/23/A22/21.png" alt=" 10.04.45" style="zoom:50%;"></p>
<p>3.9) Ubuntu 初步安装完成。</p>
<h5 id="4-后续设置"><a href="#4-后续设置" class="headerlink" title="4 后续设置"></a>4 后续设置</h5><p>前面只是顺利安装成功，但距离真正可以使用，还有几个设置需要继续操作下。</p>
<p>4.1）安装增强扩展包。（前面准备工作中，我们在host中安装了扩展包，Ubuntu里面也需要安装一下）</p>
<p><img src="/2020/09/23/A22/21_1.png" alt="21_1" style="zoom:50%;"></p>
<p><img src="/2020/09/23/A22/22.png" alt="22" style="zoom:50%;"></p>
<p><img src="/2020/09/23/A22/23.png" alt="23" style="zoom:50%;"></p>
<p>最明显的效果：</p>
<p>安装增强包前，不管你怎么拖放VirtualBox的界面，Ubuntu的界面总是那么一点。</p>
<p><img src="/2020/09/23/A22/24.png" alt="24" style="zoom:50%;"></p>
<p>安装后：Ubuntu的界面可以随意调整。（重启后才会更新效果）</p>
<p><img src="/2020/09/23/A22/25.png" alt="25" style="zoom:50%;"></p>
<p>4.2）设置虚拟机的网络。</p>
<p><code>Setting</code> —&gt; <code>Network</code>，然后按照下面的设置即可。</p>
<p><img src="/2020/09/23/A22/26.png" alt="26" style="zoom:50%;"></p>
<p>4.2) 设置剪切板共享：host复制的文字可以直接粘贴在Ubuntu里，反之亦然。(重启后生效)</p>
<p><img src="/2020/09/23/A22/27_1.png" alt="27_1" style="zoom:50%;"></p>
<p>4.3） 设置共享文件夹。</p>
<p>共享文件夹可以让你在host和Ubuntu之间及其方便地进行数据分享。</p>
<p>4.3.1 Virtual Box界面，点<code>Settings</code> —&gt; <code>Shared Folders</code>，然后按照下面图中设置即可。</p>
<p><img src="/2020/09/23/A22/27.png" alt="27" style="zoom:50%;"></p>
<p><code>Folder Path</code>为host的文件夹目录</p>
<p><code>Mount Point</code> 为虚拟机中所挂在的位置。</p>
<p>点OK， 然后我们进入到虚拟机中，会发现一个类似硬盘的图标，名为：<code>Shared</code>，点一下，发现没有权限。</p>
<p><img src="/2020/09/23/A22/28.png" alt="28" style="zoom:50%;"></p>
<p><code>解决办法</code></p>
<p>在Ubuntu中，打开终端<code>Terminal</code>，输入命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@bigbro:~/Desktop$ sudo adduser <span class="variable">$USER</span> vboxsf </span><br><span class="line">[sudo] password <span class="keyword">for</span> qli: </span><br><span class="line">Adding user <span class="string">&#x27;qli&#x27;</span> to group <span class="string">&#x27;vboxsf&#x27;</span> ...</span><br><span class="line">Adding user qli to group vboxsf</span><br><span class="line">Done.</span><br></pre></td></tr></table></figure>
<p>完事后，重启虚拟机。如果不能启动，显示USB相关的报错信息。取消USB的选项，再次启动即可。</p>
<p><img src="/2020/09/23/A22/29.png" alt="28" style="zoom:50%;"></p>
<p>到这里，虚拟机的安装，设置基本就完成了，剩下的就是在Ubuntu里面安装一些常用的软件程序了。这个会在后续教程里面简单介绍。</p>
<h5 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a>打赏</h5><p>如果感觉本文对你的相关研究有帮助，欢迎打赏，支持作者的热心付出。如果你遇到相关的问题，或者也有自己擅长的操作，热烈欢迎无私分享，可以通过QQ（122103465）或者邮件（lqcata@gmail.com）联系。</p>
<p><img src="/2020/09/23/A22/打赏码.jpg" style="zoom:25%;"></p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>安装</tag>
        <tag>VirtualBox</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu常用软件的安装</title>
    <url>/2020/09/24/A23/</url>
    <content><![CDATA[<p>前面一节我们介绍了Ubuntu虚拟机的安装，今天就介绍一些Ubuntu常用软件的软装。大部分极其简单，敲个命令，输入下密码就能解决。少部分非常简单，设置下环境变量就可以解决。有些安装比较蛋疼的可以借助第三方平台比如Anaconda等来安装，也可以归纳到非常简单的行列中。所以，So easy！！！</p>
<h5 id="1-第一件事："><a href="#1-第一件事：" class="headerlink" title="1  第一件事："></a>1  第一件事：</h5><p>打开终端（<code>CONTROL</code> + <code>ALT</code> + <code>T</code>），创建<code>~/bin</code> 文件夹。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qli@bigbrosci:~$ mkdir ~/bin</span><br></pre></td></tr></table></figure>
<p>这个文件夹用于存储一些日常的脚本文件，可执行的小程序。 平时勤备份也不会占用太大空间。</p>
<h5 id="2-命令安装程序"><a href="#2-命令安装程序" class="headerlink" title="2 命令安装程序"></a>2 命令安装程序</h5><p>复制下面的<code>sudo apt-get</code>命令，输入到<code>Terminal</code>中，回车，输入密码即可。 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install python3-pip</span><br><span class="line">sudo apt-get install curl</span><br><span class="line">curl https://bootstrap.pypa.io/get-pip.py --output get-pip.py</span><br><span class="line">sudo python get-pip.py</span><br><span class="line"></span><br><span class="line">sudo apt-get install vim </span><br><span class="line">sudo apt-get install vim-gtk</span><br><span class="line">sudo apt-get install sshfs</span><br><span class="line">sudo apt-get install rename </span><br><span class="line">sudo apt-get install xclip </span><br><span class="line">sudo apt-get install git </span><br><span class="line">sudo apt-get install gnuplot</span><br><span class="line">sudo apt-get install xcrysden</span><br><span class="line">sudo apt-get tree</span><br><span class="line">sudo apt-get install inkscape  </span><br><span class="line"></span><br><span class="line">sudo apt-get install fish </span><br><span class="line">sudo apt-get install tmux </span><br><span class="line">sudo apt-get install texlive-full</span><br><span class="line">sudo apt-get install kile  </span><br></pre></td></tr></table></figure>
<p>pip 用来安装python程序；</p>
<p>vim就不介绍了；</p>
<p>sshfs 用来把服务器挂载到本地电脑，方便传输数据；</p>
<p>rename 可以很方便批量命名；</p>
<p>xclip 可以把命令的输出复制到剪切板里面，方便鼠标粘贴；</p>
<p>git 用来从git-hub下载，上传，管理一些脚本程序等， </p>
<p>gnuplot 画图用的</p>
<p>xcrysden 可视化软件</p>
<p>tree 方便显示文件目录</p>
<p>inkscape 一款非常好用的做图软件</p>
<p>fish，tmux 装逼效果明显，没对象的重点关注下，好好学习一番，当然功能没的说，很强大。</p>
<p>Latex 写文章的可以使用最后两个命令安装。</p>
<p>其他的暂时也想不起来，如果你有推荐的，可以发邮件给我，后面再添上去。（lqcata@gmail.com）</p>
<h5 id="3-安装Anaconda"><a href="#3-安装Anaconda" class="headerlink" title="3  安装Anaconda"></a>3  安装Anaconda</h5><p>它可以帮助你节省很多时间和精力去安装软件。下载后，按照下面命令，然后一路狂摁回车或者输入<code>yes</code>即可，官网也有安装教程，这里就不累赘了。通过Anaconda安装其他软件，可以参考前面的教程：<a href="https://www.bigbrosci.com/2020/09/19/A20/">https://www.bigbrosci.com/2020/09/19/A20/</a> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@bigbrosci:~/Downloads$ ls</span><br><span class="line">Anaconda3-2020.07-Linux-x86_64.sh  p4vasp-0.3.30.tgz </span><br><span class="line">qli@bigbrosci:~/Downloads$ bash Anaconda3-2020.07-Linux-x86_64.sh </span><br><span class="line">Welcome to Anaconda3 2020.07</span><br><span class="line"></span><br><span class="line">In order to <span class="built_in">continue</span> the installation process, please review the license</span><br><span class="line">agreement.</span><br><span class="line">Please, press ENTER to <span class="built_in">continue</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; </span><br></pre></td></tr></table></figure>
<p>Anaconda安装的软件可以通过<a href="https://anaconda.org">https://anaconda.org</a> 来查询，都会列出来安装的命令，比如RDkit：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda install -c rdkit rdkit</span><br></pre></td></tr></table></figure>
<p>另一个需要注意的是，Anaconda安装后，最喜爱的<code>p4vasp</code>不能正常使用了。解决办法如下：</p>
<p>1） 找到p4v的目录，一般在<code>/usr/bin/</code></p>
<p>2）将<code>p4v</code>中的<code>python</code> 全部改为<code>python2</code></p>
<p>3)  将<code>p4v.py</code> 第一行中的<code>python</code>改为<code>python2</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(base) qli@bigbrosci:~$ p4v </span><br><span class="line">  File <span class="string">&quot;/usr/bin/p4v.py&quot;</span>, line 9</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;&quot;</span><span class="string">&quot;You need to get version 2.0 (or later) of PyGTK for this to work. You</span></span><br><span class="line"><span class="string">             can get source code from http://www.pygtk.org &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">          ^</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line">(base) qli@bigbrosci:~$ <span class="built_in">which</span> p4v </span><br><span class="line">/usr/bin/p4v</span><br><span class="line">(base) qli@bigbrosci:~$ sudo vi /usr/bin/p4v</span><br><span class="line">[sudo] password <span class="keyword">for</span> qli: </span><br><span class="line">(base) qli@bigbrosci:~$ sudo vi /usr/bin/p4v.py </span><br><span class="line">(base) qli@bigbrosci:~$ grep python  /usr/bin/p4v</span><br><span class="line"><span class="built_in">export</span> PYTHONPATH=<span class="variable">$PYTHONPATH</span>:/usr/lib/python2.7/dist-packages</span><br><span class="line"><span class="built_in">exec</span> python2 /usr/bin/p4v.py <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line">(base) qli@bigbrosci:~$ grep python  /usr/bin/p4v.py </span><br><span class="line"><span class="comment">#!/usr/bin/env python2</span></span><br></pre></td></tr></table></figure>
<h5 id="4-其他可执行的程序"><a href="#4-其他可执行的程序" class="headerlink" title="4 其他可执行的程序"></a>4 其他可执行的程序</h5><p>这里我们以VESTA为例，这种方法非常简单实用。</p>
<p>4.1） 下载解压VESTA程序包。（<a href="https://jp-minerals.org/vesta/en/）">https://jp-minerals.org/vesta/en/）</a> 直接通过官网下载即可，没必要去群里面求助，也没必要往群里面上传。</p>
<p>4.2） 本人习惯性地将其解压到<code>/home/qli/Documents/VESTA-gtk3</code></p>
<p>4.3)   设置环境变量，将下面的<code>export</code> 两行复制到<code>~/.bashrc</code> 文件中， <code>source</code> 下 <code>.bashrc</code> 文件，然后直接敲命令<code>VESTA</code>即可打开可视化界面。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@bigbrosci:~/Documents/VESTA-gtk3$ ls</span><br><span class="line">asfdc           Library_License  RIETAN.sh          style         VESTA-core</span><br><span class="line">bvparm2016.cif  libVESTA.so      spgra.dat          style.ini     VESTA_def.ini</span><br><span class="line">elements        LICENSE          spgro.dat          template.ins  VESTA-gui</span><br><span class="line">elements.ini    mspgr.dat        STRUCTURE_TIDY     tmp           VESTA.ini</span><br><span class="line">img             PowderPlot       STRUCTURE_TIDY.sh  VESTA         wyckoff.dat</span><br><span class="line">qli@bigbrosci:~/Documents/VESTA-gtk3$ <span class="built_in">pwd</span></span><br><span class="line">/home/qli/Documents/VESTA-gtk3</span><br><span class="line">qli@bigbrosci:~/Documents/VESTA-gtk3$ <span class="built_in">cd</span> </span><br><span class="line">qli@bigbrosci:~$ vi .bashrc</span><br><span class="line"><span class="built_in">export</span> VESTA=<span class="string">&#x27;/home/qli/Documents/VESTA-gtk3&#x27;</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$VESTA</span></span><br><span class="line">qli@bigbrosci:~$ <span class="built_in">source</span> .bashrc	 </span><br><span class="line">qli@bigbrosci:~$ VESTA</span><br></pre></td></tr></table></figure>
<p><code>注意</code> 上面VESTA的路径记得换成你自己电脑里面的。</p>
<h5 id="5-Ubuntu的备份"><a href="#5-Ubuntu的备份" class="headerlink" title="5 Ubuntu的备份"></a>5 Ubuntu的备份</h5><p>本人喜欢瞎折腾，也经常会把电脑搞崩溃，备份就显得尤其重要。对于Ubuntu来说，前面我们在虚拟机的安装中提到存储Ubuntu系统的<code>vdi</code>文件，如果你有足够大的硬盘，可以定期将一个稳定版本的vdi保存起来，万一系统崩溃，删掉坏的，导入最新的备份即可。</p>
<p>如果没有用虚拟机，直接装的Ubuntu系统，或者双系统，可以尝试定期保存<code>~/bin</code> 和<code>~/.bashrc</code> 文件，本人之前就是这样做的（现在懒得折腾，系统不坏了），它们不怎么占空间，打包压缩下，邮件基本就可以上传。如果系统坏掉了，非得安装一个新的才能解决的时候，只需要重复本教程，下载一些常用的软件，以及用备份的<code>~/bin</code> 和<code>~/.bashrc</code> 文件还原一下设置即可。数据一般来说都直接存储在服务器中，相关备份不在本教程讨论范围之内。</p>
<p>当然还有其他的办法备份和恢复虚拟机，比如创建当前Ubuntu版本的iso文件，定期备份当前整个系统以便引导修复等等，精力有限，不再累赘。有兴趣的可以尝试。</p>
<h5 id="6-打赏"><a href="#6-打赏" class="headerlink" title="6 打赏"></a>6 打赏</h5><p>如果感觉本文对你的相关研究有帮助，欢迎打赏，支持作者的热心付出。如果你也有自己擅长的操作等，热烈欢迎无私分享，可以通过QQ（122103465）或者邮件（lqcata@gmail.com）联系。</p>
<p><img src="/2020/09/24/A23/打赏码.jpg" alt="打赏码" style="zoom: 33%;"></p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>安装</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>离子迁移概率密度可视化</title>
    <url>/2020/10/02/A24/</url>
    <content><![CDATA[<p>大师兄在9月8日的文章中讲了如何用 Pymatgen 计算离子的电导率（该方法可以用来研究固态电解质等问题），<strong>本次，大师兄介绍一下如何使用 Pymatgen 可视化离子的迁移概率密度。</strong></p>
<p>先举个例子，</p>
<blockquote>
<p>在“Design principles for solid-state lithium superionic conductors”一文中（Wang et al., Nature Materials <strong>2015</strong>, <em>14</em> , 1026–1031. ），作者用Ab Initio Molecular Dynamic （AIMD）计算了Li 离子在Li$\mathrm{_1}<script type="math/tex">\mathrm{_0}$GeP$\mathrm{_2}$S$\mathrm{_1}</script>\mathrm{_2}$， Li$\mathrm{_7}$P$\mathrm{_3}$S$\mathrm{_1}$$\mathrm{_1}$，Li$\mathrm{_2}$S，和 Li$\mathrm{_4}$GeS$\mathrm{_4}$ 四种材料中的迁移概率密度（Probability Density），结果如下图所示：</p>
</blockquote>
<p><img src="/2020/10/02/A24/A24_1.png" alt=""></p>
<blockquote>
<ul>
<li>从图中可以看出Li离子在图a所示材料中主要沿c轴方向的通道迁移，而且由于这个通道连通得比较好，Li离子的迁移势垒会比较低（0.22~0.25 eV）。</li>
<li>Li离子在图b所示的材料的迁移路径形成了一个三维网格，而且由于这个概率密度比图b中的概率密度分布得更加均匀，Li离子的迁移势垒更低（0.18~0.19 eV）。</li>
<li>图b所示的材料就完全不行了，因为Li离子的概率密度仅分布在特定的位点附近，说明离子不能有效地移动。</li>
<li>Li离子在图d所示材料中也存在迁移局域化的行为。</li>
<li>作者总结说 “A general principle for the design of Li-ion conductors with low activation energy can be distilled from the above findings: all of the sites within the diffusion network should be energetically close to equivalent, with large channels connecting them.”</li>
</ul>
</blockquote>
<p><strong>那么我们如何在自己的计算中画出这样的图呢？</strong>Pymatgen 举手说，它可以帮忙！</p>
<p>但是在开始之前，我们要安装Pymatgen的插件：<strong>Pymatgen-diffusion</strong>（<a href="https://github.com/materialsvirtuallab/pymatgen-diffusion）。">https://github.com/materialsvirtuallab/pymatgen-diffusion）。</a></p>
<h2 id="安装-Pymatgen-diffusion"><a href="#安装-Pymatgen-diffusion" class="headerlink" title="安装 Pymatgen-diffusion"></a>安装 Pymatgen-diffusion</h2><p><strong>推荐大家使用最新版的Anaconda安装Pymatgen及其插件。</strong>点击上面的链接，进入官网后，点击最新版本链接，</p>
<p><img src="/2020/10/02/A24/A24_2.png" alt=""></p>
<p>我们可以下载.zip文件，</p>
<p><img src="/2020/10/02/A24/A24_3.png" alt=""></p>
<p>下载完成后，大家可以解压这个文件，得到 pymatgen-diffusion-2019.8.18文件夹。</p>
<p>我们把其中的 pymatgen_diffusion 文件夹放到 Anaconda的site-packages文件夹下，路径是 Windows 系统：……\Anaconda\Lib\site-packages；Linux系统：……/anaconda3/lib/pythonx.x/site-packages，就算安装好了。</p>
<p>接下来我们可以启动python，导入这个模块，如果不报错就没有问题了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[test@ln0%tianhe2 li_sn_s]$ python</span><br><span class="line">Python 3.8.3 (default, Jul  2 2020, 16:21:59) </span><br><span class="line">[GCC 7.3.0] :: Anaconda, Inc. on linux</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; import pymatgen_diffusion</span><br><span class="line">&gt;&gt;&gt; </span><br></pre></td></tr></table></figure>
<h2 id="学习用法"><a href="#学习用法" class="headerlink" title="学习用法"></a>学习用法</h2><p>我们可以在其github网站上通过例子学习这个模块的用法。</p>
<p><img src="/2020/10/02/A24/A24_4.png" alt=""></p>
<p>点击打开 probbility_analysis.ipynb 文件。</p>
<p><img src="/2020/10/02/A24/A24_5.png" alt=""></p>
<p>其内容如下（有所删减）：如果不想看的话可直接查看 <strong>开始作图</strong> 部分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.analysis.diffusion_analyzer <span class="keyword">import</span> DiffusionAnalyzer</span><br><span class="line"><span class="keyword">from</span> pymatgen_diffusion.aimd.pathway <span class="keyword">import</span> ProbabilityDensityAnalysis</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment">#ProbabilityDensityAnalysis object</span></span><br><span class="line">filename=<span class="string">&quot;/Users/iekhengchu/repos/pymatgen-diffusion/pymatgen_diffusion/aimd/tests/cNa3PS4_pda.json&quot;</span></span><br><span class="line"></span><br><span class="line">data = json.load(<span class="built_in">open</span>(<span class="string">&quot;../pymatgen_diffusion/aimd/tests/cNa3PS4_pda.json&quot;</span>, <span class="string">&quot;r&quot;</span>))</span><br><span class="line">diff_analyzer = DiffusionAnalyzer.from_dict(data) <span class="comment"># 初始化DiffusionAnalyzer类</span></span><br><span class="line"></span><br><span class="line">pda = ProbabilityDensityAnalysis.from_diffusion_analyzer(diff_analyzer, interval=<span class="number">0.5</span>, </span><br><span class="line">                                                         species=(<span class="string">&quot;Na&quot;</span>, <span class="string">&quot;Li&quot;</span>)) <span class="comment">#可以指定离子</span></span><br><span class="line"><span class="comment">#Save probability distribution to a CHGCAR-like file</span></span><br><span class="line">pda.to_chgcar(filename=<span class="string">&quot;CHGCAR_new2.vasp&quot;</span>) <span class="comment">#保存概率密度文件</span></span><br></pre></td></tr></table></figure>
<h2 id="开始作图"><a href="#开始作图" class="headerlink" title="开始作图"></a>开始作图</h2><p>代码（test.py）如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen_diffusion.aimd.pathway <span class="keyword">import</span> ProbabilityDensityAnalysis</span><br><span class="line"><span class="keyword">from</span> pymatgen.core.trajectory <span class="keyword">import</span> Trajectory</span><br><span class="line"><span class="keyword">from</span> pymatgen.io.vasp.outputs <span class="keyword">import</span> Xdatcar</span><br><span class="line"><span class="keyword">from</span> pymatgen.analysis.diffusion_analyzer <span class="keyword">import</span> DiffusionAnalyzer</span><br><span class="line"></span><br><span class="line">traj = Trajectory.from_file(<span class="string">&#x27;XDATCAR&#x27;</span>)</span><br><span class="line">diff = DiffusionAnalyzer.from_structures(traj,<span class="string">&#x27;Li&#x27;</span>,<span class="number">900</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">pda = ProbabilityDensityAnalysis.from_diffusion_analyzer(diff,interval=<span class="number">0.5</span>,species=(<span class="string">&quot;Li&quot;</span>))</span><br><span class="line">pda.to_chgcar(filename=<span class="string">&quot;pda.vasp&quot;</span>) <span class="comment">#保存概率密度文件</span></span><br></pre></td></tr></table></figure>
<p>此处理过程大概耗时8分钟，因机器而异。</p>
<p>在VESTA中可视化如下：</p>
<p><img src="/2020/10/02/A24/A24_6.png" alt=""></p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>Pymatgen</tag>
        <tag>骚操作</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>超好用的材料类机器学习开源软件-Matminer</title>
    <url>/2020/12/16/A25/</url>
    <content><![CDATA[<p>今天向大家隆重介绍一款材料类的机器学习开源软件：Matminer！机器学习预测材料性质，乃至逆向设计材料是材料领域的热门研究话题。很多同学有心做机器学习方面的研究，奈何不知道有哪些实用的代码，从而使项目一拖再拖。材料类的机器学习软件有很多，我比较喜欢Matminer这一款，因为它是由Pymatgen开发者开发的，非常易于使用。现在就向大家介绍一下这款软件（本教程根据Matminer官网<a href="https://hackingmaterials.lbl.gov/matminer/#installing-matminer撰写）">https://hackingmaterials.lbl.gov/matminer/#installing-matminer撰写）</a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Matminer是用于材料数据挖掘的基于Python的开源软件。它可以从各种数据库获取材料属性数据，将复杂材料属性(如成分、晶体结构、能带结构)表征为与物理相关的特征量，训练机器学习模型，并分析数据挖掘的结果。</p>
<p>Matminer使用pandas数据格式。它还有一个进阶的自动化版本叫Automatminer，可以自动化的训练机器学习模型并得到结果。</p>
<p>Matminer 可以生产可交互的图像。下面的流程图生动展示了matminer的工作内容。Matminer 可以访问Citrine，Materials Project，MDF等数据库，获得材料结构、能带、力学性能等多种性质。这些性质可以被转换成数值化的、可视化的特征量，该特征量可以被用于训练机器学习模型。</p>
<p><img src="/2020/12/16/A25/A25.png" alt=""></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Matminer的安装过程非常简单，大家只要安装好Anaconda3 (Python 3.6) 后，在终端输入 pip install matminer 就行了。建议大家一并安装Pymatgen。</p>
<p>下面以天河超算为例，展示matminer的安装过程：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建基于python 3.6 的虚拟环境，名字叫 py36</span></span><br><span class="line">(base) [test@ln0%tianhe2 ~]$ conda create -n py36 python=<span class="number">3.6</span></span><br></pre></td></tr></table></figure>
<p>安装好环境后，激活该环境，并安装pymatgen 和 matminer</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 激活环境用conda activate 命令</span></span><br><span class="line">(base) [test@ln0%tianhe2 ~]$ conda activate py36</span><br><span class="line"></span><br><span class="line"><span class="comment"># 括号里的 base 就会变成 py36</span></span><br><span class="line">(py36) [test@ln0%tianhe2 ~]$ conda install -c conda-forge pymatgen</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面这个命令为安装 matminer</span></span><br><span class="line">(py36) [test@ln0%tianhe2 ~]$ pip install matminer</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>下面测试安装结果，输入下列命令，如果不出错，就是安装成功了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(py36) [test@ln0%tianhe2 ~]$ python</span><br><span class="line">Python <span class="number">3.6</span><span class="number">.12</span> |Anaconda, Inc.| (default, Sep  <span class="number">8</span> <span class="number">2020</span>, <span class="number">23</span>:<span class="number">10</span>:<span class="number">56</span>) </span><br><span class="line">[GCC <span class="number">7.3</span><span class="number">.0</span>] on linux</span><br><span class="line"><span class="type">Type</span> <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> <span class="keyword">or</span> <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pymatgen</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> matminer</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure>
<p>现在可以尽情地去测试啦！后续教程将陆续分享。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>Pymatgen</tag>
        <tag>骚操作</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>利用matminer从数据库获取数据</title>
    <url>/2020/12/22/A26/</url>
    <content><![CDATA[<p><a href="https://nbviewer.jupyter.org/github/hackingmaterials/matminer_examples/blob/master/matminer_examples/data_retrieval-nb/data_retrieval_basics.ipynb">https://nbviewer.jupyter.org/github/hackingmaterials/matminer_examples/blob/master/matminer_examples/data_retrieval-nb/data_retrieval_basics.ipynb</a></p>
<h2 id="从Materials-Project-数据库获取"><a href="#从Materials-Project-数据库获取" class="headerlink" title="从Materials Project 数据库获取"></a>从Materials Project 数据库获取</h2><p>从Materials Project数据库获取数据得用到 matminer.data_retrieval.retrieve_MP.MPDataRetrieval 功能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先导入模块</span></span><br><span class="line"><span class="keyword">from</span> matminer.data_retrieval.retrieve_MP <span class="keyword">import</span> MPDataRetrieval</span><br><span class="line"><span class="comment"># 实例化 MPDataRetrieval 这个类</span></span><br><span class="line">mpdr = MPDataRetrieval(api_key=<span class="string">&#x27;your_own_api_key&#x27;</span>) </span><br><span class="line"><span class="comment"># 在实例化 MPDataRetrieval 时需要输入用户在 Material Project 网站的 API Key.</span></span><br></pre></td></tr></table></figure>
<h2 id="示例1：获取所有单元素材料的密度"><a href="#示例1：获取所有单元素材料的密度" class="headerlink" title="示例1：获取所有单元素材料的密度"></a>示例1：获取所有单元素材料的密度</h2><p>上一次的介绍说到，matminer 处理的数据跟 pandas 库一样，是 dataframe，所以我们要用 get_dataframe 方法获取数据; dataframe 看起来就像excel 表格一样。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = mpdr.get_dataframe(criteria=&#123;<span class="string">&quot;nelements&quot;</span>: <span class="number">1</span>&#125;, properties=[<span class="string">&#x27;density&#x27;</span>, <span class="string">&#x27;pretty_formula&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;There are &#123;&#125; entries on MP with 1 element&quot;</span>.<span class="built_in">format</span>(df[<span class="string">&#x27;density&#x27;</span>].count())) <span class="comment"># 计算有多少材料</span></span><br><span class="line"><span class="comment">#请自行关注 df[&#x27;density&#x27;].count() 语句</span></span><br></pre></td></tr></table></figure>
<p>criteria 是搜索条件，它是一个字典，字典里面可以有多个键值对; properties 是想要获取的材料性质，它是个列表，里面可以有多个性质。其实criteria 也是材料的性质。想知道所有可用的性质，请参考 <a href="https://github.com/materialsproject/pymatgen/blob/master/pymatgen/ext/matproj.py">https://github.com/materialsproject/pymatgen/blob/master/pymatgen/ext/matproj.py</a></p>
<p>上述代码意味着 我们想在数据库中搜索材料，这些材料元素种类为1，对于这些材料，我们想得到它们的密度和化学式信息。</p>
<p>结果如下：</p>
<p><img src="/2020/12/22/A26/re1.png" style="zoom:80%;"></p>
<p>让我们看一下这个 dataframe 表格长什么样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.head()  <span class="comment"># 这个语句会显示 df 这个表格的前几行，可以看到，我们获得了 716 个单元素材料。</span></span><br><span class="line">           <span class="comment"># 表格里记录了我们需要的密度 和 化学式的性质，以及它们的ID</span></span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2020/12/22/A26/re2.png" style="zoom: 80%;"></p>
<h3 id="示例2：获取所有带隙大于-4-0-eV的材料"><a href="#示例2：获取所有带隙大于-4-0-eV的材料" class="headerlink" title="示例2：获取所有带隙大于 4.0 eV的材料"></a>示例2：获取所有带隙大于 4.0 eV的材料</h3><p>方法挺简单的，就是在上个例子的 get_dataframe 方法中设置新的搜索条件: 带隙大于4.0 eV.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 带隙是 band_gap，大于4怎么写呢？ 是 greater than, 缩写成 gt. 在 matminer中要写成 $gt </span></span><br><span class="line"><span class="comment"># 大家注意体会 criteria 的字典形式。criteria=, properties= 可以省略不写。</span></span><br><span class="line">df = mpdr.get_dataframe(&#123;<span class="string">&quot;band_gap&quot;</span>: &#123;<span class="string">&quot;$gt&quot;</span>: <span class="number">4.0</span>&#125;&#125;, [<span class="string">&#x27;pretty_formula&#x27;</span>, <span class="string">&#x27;band_gap&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;There are &#123;&#125; entries on MP with a band gap larger than 4.0&quot;</span>.<span class="built_in">format</span>(df[<span class="string">&#x27;band_gap&#x27;</span>].count()))</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2020/12/22/A26/re3.png" style="zoom:80%;"></p>
<p>再看一下表格长什么样子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.head()</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2020/12/22/A26/re4.png" style="zoom:80%;"></p>
<p>如果想把表格保存成excel可读写的格式，可以用下面的语句：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.to_csv(<span class="string">&#x27;materials_bg_gt_4.csv&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="示例3：获取-VRH-剪切模量和体积模量¶"><a href="#示例3：获取-VRH-剪切模量和体积模量¶" class="headerlink" title="示例3：获取 VRH 剪切模量和体积模量¶"></a>示例3：获取 VRH 剪切模量和体积模量<a href="http://localhost:8888/notebooks/get_data_from_pymatgen.ipynb#示例3：获取-VRH-剪切模量和体积模量">¶</a></h3><p>首先得要求这些材料存在弹性的性质，其次，我们还想要求这些弹性数据没有警告信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 存在弹性常数信息用 &quot;elasticity&quot;: &#123;&quot;$exists&quot;: True&#125; 表示，没有警告信息用 一个空列表表示：&quot;elasticity.warnings&quot;: []</span></span><br><span class="line"></span><br><span class="line">df = mpdr.get_dataframe(&#123;<span class="string">&quot;elasticity&quot;</span>: &#123;<span class="string">&quot;$exists&quot;</span>: <span class="literal">True</span>&#125;, <span class="string">&quot;elasticity.warnings&quot;</span>: []&#125;,</span><br><span class="line">                        [<span class="string">&#x27;pretty_formula&#x27;</span>, <span class="string">&#x27;elasticity.K_VRH&#x27;</span>, <span class="string">&#x27;elasticity.G_VRH&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;There are &#123;&#125; elastic entries on MP with no warnings&quot;</span>.<span class="built_in">format</span>(df[<span class="string">&#x27;elasticity.K_VRH&#x27;</span>].count()))</span><br></pre></td></tr></table></figure>
<p>搜索结果如下：</p>
<p><img src="/2020/12/22/A26/r5.png" style="zoom:80%;"></p>
<p>我们想统计一下这些数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.describe() <span class="comment"># 该语句可以很方便地对表格中的每一列数据进行统计，给出数量，平均数，方差，最小、最大值等信息</span></span><br></pre></td></tr></table></figure>
<p>得到：</p>
<p><img src="/2020/12/22/A26/r6.png" style="zoom:80%;"></p>
<p><strong>接下来看一个更复杂的例子</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">除了上次的搜索条件外，我们想搜索包含 Pb 和 Te 的材料：&quot;elements&quot;: &#123;&quot;$all&quot;: [&quot;Pb&quot;, &quot;Te&quot;]&#125; </span></span><br><span class="line"><span class="string">材料的稳定性也在考虑之中，energy above hull 必须在1e-6以下：&quot;e_above_hull&quot;: &#123;&quot;$lt&quot;: 1e-6&#125;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">df = mpdr.get_dataframe(criteria=&#123;<span class="string">&quot;elasticity&quot;</span>: &#123;<span class="string">&quot;$exists&quot;</span>: <span class="literal">True</span>&#125;, </span><br><span class="line">                         <span class="string">&quot;elasticity.warnings&quot;</span>: [],</span><br><span class="line">                         <span class="string">&quot;elements&quot;</span>: &#123;<span class="string">&quot;$all&quot;</span>: [<span class="string">&quot;Pb&quot;</span>, <span class="string">&quot;Te&quot;</span>]&#125;,</span><br><span class="line">                         <span class="string">&quot;e_above_hull&quot;</span>: &#123;<span class="string">&quot;$lt&quot;</span>: <span class="number">1e-6</span>&#125;&#125;, <span class="comment"># to limit the number of hits for the sake of time</span></span><br><span class="line">                        properties = [<span class="string">&quot;elasticity.K_VRH&quot;</span>, <span class="string">&quot;elasticity.G_VRH&quot;</span>, <span class="string">&quot;pretty_formula&quot;</span>, </span><br><span class="line">                                      <span class="string">&quot;e_above_hull&quot;</span>, <span class="string">&quot;bandstructure&quot;</span>, <span class="string">&quot;dos&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;There are &#123;&#125; elastic entries on MP with no warnings that contain &quot;</span></span><br><span class="line">      <span class="string">&quot;Pb and Te with energy above hull ~ 0.0 eV&quot;</span>.<span class="built_in">format</span>(df[<span class="string">&#x27;elasticity.K_VRH&#x27;</span>].count()))</span><br></pre></td></tr></table></figure>
<p>结果是：</p>
<p>There are 3 elastic entries on MP with no warnings that contain Pb and Te with energy above hull ~ 0.0 eV</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.head()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/12/22/A26/r7.png" alt=""></p>
<p>下面来查看一下其中一个材料的能带和DOS图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pymatgen.electronic_structure.plotter <span class="keyword">import</span> BSDOSPlotter <span class="comment"># 调用 Pymatgen 作图</span></span><br><span class="line"></span><br><span class="line">mpid = <span class="string">&#x27;mp-20740&#x27;</span></span><br><span class="line">idx = df.index[df.index==mpid][<span class="number">0</span>]  <span class="comment"># 获取 mp-20740 这个材料所在的行数</span></span><br><span class="line">plt = BSDOSPlotter().get_plot(bs=df.loc[idx, <span class="string">&#x27;bandstructure&#x27;</span>], dos=df.loc[idx, <span class="string">&#x27;dos&#x27;</span>]);</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/12/22/A26/r8.png" style="zoom:80%;"></p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><ul>
<li><p>matminer获得的数据(本教程保存在 df 变量中)可以可视化，也可以直接用来做机器学习。有兴趣的同学请自学 pandas 这个 python 库，学习 dataframe 数据的处理方法。</p>
</li>
<li><p>Pymatgen 做的能带和DOS图不够美观。大家可以留言，我有机会可以跟大家分享修改pymatgen代码来美化这些图。</p>
</li>
<li><p>官网的教程是基于 jupyter notebook的。jupyter notebook 的好处是既能运行代码，又能自由地给代码加注释，公式，图片。所得到的文档便于阅读和理解。希望大家也能学会这个python 库。</p>
</li>
<li><p>如果想调用 jupyter notebook来运行上述代码，建议大家在具有图形界面的终端上试验。以windows 系统为例，再按照上篇教程创建好 py36 虚拟环境后，需要</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install jupyter <span class="comment"># 具体的使用方法请参考其它网络教程</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>本文还附带jupyter notebook 版本的文档供大家阅读和使用 【链接：<a href="https://pan.baidu.com/s/153PcfiM3vaAG71MCCTFuCQ">https://pan.baidu.com/s/153PcfiM3vaAG71MCCTFuCQ</a><br>提取码：w4us 】</p>
</li>
</ul>
<p>本次的教程到这就结束了。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>Pymatgen</tag>
        <tag>骚操作</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>从Citrine Informatics数据库获取数据</title>
    <url>/2021/01/01/A27/</url>
    <content><![CDATA[<p>Citrine 也是一个材料学数据库，自带了机器学习工具，大家也可以研究琢磨一下。官网是 <a href="https://citrination.com/search/simple?searchMatchOption=fuzzyMatch。这里，我们将通过几个例子了解如何在这个数据库中获取数据。在Citrine中获取数据需要用到">https://citrination.com/search/simple?searchMatchOption=fuzzyMatch。这里，我们将通过几个例子了解如何在这个数据库中获取数据。在Citrine中获取数据需要用到</a> matminer.data_retrieval.retrieve_Citrine.CitrineDataRetrieval 这个工具，其跟materials project类似，也学要一个API_key。大家可以在官网注册，并记录下API_Key。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#请先在终端中输入： pip install citrination_client ； 否则会报错</span></span><br><span class="line"><span class="comment">#然后我们回到代码，导入 CitrineDataRetrieval 这个模块</span></span><br><span class="line"><span class="keyword">from</span> matminer.data_retrieval.retrieve_Citrine <span class="keyword">import</span> CitrineDataRetrieval</span><br></pre></td></tr></table></figure>
<h4 id="示例1：获取化学式为-Si-的所有材料的实验测得的能带"><a href="#示例1：获取化学式为-Si-的所有材料的实验测得的能带" class="headerlink" title="示例1：获取化学式为 Si 的所有材料的实验测得的能带"></a>示例1：获取化学式为 Si 的所有材料的实验测得的能带</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先实例化这个工具，需要提供你的API_Key</span></span><br><span class="line">cdr = CitrineDataRetrieval(api_key=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 接下来，类似从materials project获取数据，我们需要用get_dataframe函数</span></span><br><span class="line">df = cdr.get_dataframe(criteria=&#123;<span class="string">&#x27;formula&#x27;</span>:<span class="string">&#x27;Si&#x27;</span>, <span class="string">&#x27;data_type&#x27;</span>: <span class="string">&#x27;EXPERIMENTAL&#x27;</span>&#125;, </span><br><span class="line">                       properties=[<span class="string">&#x27;Band gap&#x27;</span>],</span><br><span class="line">                       secondary_fields=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  0%|                                                                                            | 0/7 [00:00&lt;?, ?it/s]d:\programs\anaconda3\envs\py36\lib\site-packages\matminer\data_retrieval\retrieve_Citrine.py:103: FutureWarning:</span><br><span class="line"></span><br><span class="line">pandas.io.json.json_normalize is deprecated, use pandas.json_normalize instead</span><br><span class="line"></span><br><span class="line">100%|████████████████████████████████████████████████████████████████████████████████████| 7/7 [00:00&lt;00:00, 87.33it/s]</span><br><span class="line"></span><br><span class="line">all available fields:</span><br><span class="line">[<span class="string">&#x27;Band gap&#x27;</span>, <span class="string">&#x27;uid&#x27;</span>, <span class="string">&#x27;Band gap-units&#x27;</span>, <span class="string">&#x27;category&#x27;</span>, <span class="string">&#x27;references&#x27;</span>, <span class="string">&#x27;chemicalFormula&#x27;</span>, <span class="string">&#x27;Crystallinity&#x27;</span>, <span class="string">&#x27;Band gap-conditions&#x27;</span>, <span class="string">&#x27;Band gap-methods&#x27;</span>, <span class="string">&#x27;Band gap-dataType&#x27;</span>]</span><br><span class="line"></span><br><span class="line">suggested common fields:</span><br><span class="line">[<span class="string">&#x27;references&#x27;</span>, <span class="string">&#x27;chemicalFormula&#x27;</span>, <span class="string">&#x27;Crystallinity&#x27;</span>, <span class="string">&#x27;Band gap&#x27;</span>, <span class="string">&#x27;Band gap-units&#x27;</span>, <span class="string">&#x27;Band gap-conditions&#x27;</span>, <span class="string">&#x27;Band gap-methods&#x27;</span>, <span class="string">&#x27;Band gap-dataType&#x27;</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df <span class="comment">#查看表格</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/01/01/A27/r1.png" alt=""></p>
<p>从上面结果可以看出，数据库里有化学式为Si的材料共7中实验测得的能带数据。这些数据来源的文献，带隙的值，实验方法都被记录了下来。</p>
<h4 id="示例2：获取材料对-OH-和-O物种的吸附能"><a href="#示例2：获取材料对-OH-和-O物种的吸附能" class="headerlink" title="示例2：获取材料对 OH 和 O物种的吸附能"></a>示例2：获取材料对 <em>OH 和 </em>O物种的吸附能</h4><p>想不到citrine数据库还有各种材料对<em>OH 和 </em>O 物种的吸附能，一起来看看怎么获取把。要查询更多的数据库，请探索官网<a href="https://citrination.com/datasets">https://citrination.com/datasets</a> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我们发现这里不需要指定筛选条件，只需要返回所需要的性质即可。</span></span><br><span class="line">df_OH = cdr.get_dataframe(criteria=&#123;&#125;, properties=[<span class="string">&#x27;adsorption energy of OH&#x27;</span>], secondary_fields=<span class="literal">True</span>)</span><br><span class="line">df_O = cdr.get_dataframe(criteria=&#123;&#125;, properties=[<span class="string">&#x27;adsorption energy of O&#x27;</span>], secondary_fields=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<pre><code>  0%|                                                                                            | 0/9 [00:00&lt;?, ?it/s]d:\programs\anaconda3\envs\py36\lib\site-packages\matminer\data_retrieval\retrieve_Citrine.py:103: FutureWarning:

pandas.io.json.json_normalize is deprecated, use pandas.json_normalize instead

100%|███████████████████████████████████████████████████████████████████████████████████| 9/9 [00:00&lt;00:00, 128.63it/s]


all available fields:
[&#39;uid&#39;, &#39;Adsorption energy of OH&#39;, &#39;Adsorption energy of OH-units&#39;, &#39;Morphology&#39;, &#39;Surface facet&#39;, &#39;category&#39;, &#39;references&#39;, &#39;chemicalFormula&#39;, &#39;Adsorption energy of OH-conditions&#39;, &#39;Adsorption energy of OH-dataType&#39;]

suggested common fields:
[&#39;references&#39;, &#39;chemicalFormula&#39;, &#39;Surface facet&#39;, &#39;Adsorption energy of OH&#39;, &#39;Adsorption energy of OH-units&#39;, &#39;Adsorption energy of OH-dataType&#39;, &#39;Morphology&#39;, &#39;Adsorption energy of OH-conditions&#39;]


100%|█████████████████████████████████████████████████████████████████████████████████| 21/21 [00:00&lt;00:00, 140.70it/s]

all available fields:
[&#39;uid&#39;, &#39;Surface facet&#39;, &#39;Adsorption energy of O&#39;, &#39;category&#39;, &#39;references&#39;, &#39;chemicalFormula&#39;, &#39;Reconstruction&#39;, &#39;Adsorption energy of O-units&#39;, &#39;Adsorption energy of O-conditions&#39;]

suggested common fields:
[&#39;references&#39;, &#39;chemicalFormula&#39;, &#39;Surface facet&#39;, &#39;Adsorption energy of O&#39;, &#39;Adsorption energy of O-units&#39;, &#39;Adsorption energy of O-conditions&#39;, &#39;Reconstruction&#39;]
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_OH.head()</span><br></pre></td></tr></table></figure>
<p><img src="/2021/01/01/A27/r2.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_O.head()</span><br></pre></td></tr></table></figure>
<p><img src="/2021/01/01/A27/r3.png" alt=""></p>
<p>大家可以看到，这些数据库里面的数据还不够丰富。大家也可以把自己计算得到的数据上传到citrine数据库中，促进科学知识的开放获取。</p>
<ul>
<li>实际上 citrine 数据库包含了很多实验数据，下次的分享中，我们会把citrine数据库中的实验数据和materials project中的计算数据做个对比。</li>
<li>强烈推荐大家在学习的时候使用jupyter notebook。</li>
<li>附上jupyter notebook文件共大家参考：【链接：<a href="https://pan.baidu.com/s/1W1XKj-Fnjmx1yIe2QB7_MQ">https://pan.baidu.com/s/1W1XKj-Fnjmx1yIe2QB7_MQ</a> 提取码：jvoi 】</li>
</ul>
<p>本次分享到此结束。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>骚操作</tag>
        <tag>软件</tag>
        <tag>Citrine</tag>
      </tags>
  </entry>
  <entry>
    <title>通过ASE获取原子之间的距离</title>
    <url>/2022/04/04/A28/</url>
    <content><![CDATA[<h2 id="通过ASE获取原子之间的距离"><a href="#通过ASE获取原子之间的距离" class="headerlink" title="通过ASE获取原子之间的距离"></a>通过ASE获取原子之间的距离</h2><p>原子之间的距离是计算化学中模型搭建，结果分析中经常需要分析的部分。而计算原子的之间的距离也非常简单，通过可视化软件直接点两个原子就可以直接显示出来，可以通过自写的一些小脚本来实现。跟均相的体系不同，周期性体系由于周期性边界的存在，有时候模型中两个原子之间的距离需要将周期性边界条件考虑进去才能正确得到。今天简单介绍一个通过ASE获取原子之间的距离，并且考虑周期性边界条件的影响的小脚本。</p>
<h4 id="具体例子展示一下："><a href="#具体例子展示一下：" class="headerlink" title="具体例子展示一下："></a>具体例子展示一下：</h4><p>图里面是$TiO{_2}(101)$表面上吸附的一个Pt单原子模型，如果直接计算Pt和Ti之间距离的话（图1），测量一下为 7.461 $\AA$。实际上我们把slab模型沿着y轴重复下就会发现，还有一个更短的Pt-Ti距离。</p>
<p><img src="/2022/04/04/A28/1.png"></p>
<p>图1： Pt-Ti原子之间的距离</p>
<p>测量下，距离为：3.818 $\AA$。在周期性计算中，如果刚开始模型搭建的时候没有考虑到这一点，或者分子比较大，亦或者AIMD过程中分子到处跑，都会出现类似这样的情形。所以在测量距离时候，要注意周期性边界对数值的影响。当然最理想的情况就是模型搭建的时候将这一情况考虑进来，尽可能将分子放在slab的中间部分。如果出现这种情况，测量的时候加上周期性边界条件的校正即可，这也是本节要介绍的内容。</p>
<p><img src="/2022/04/04/A28/2.png"></p>
<p>图2：考虑周期性边界条件后Pt-Ti之间的距离</p>
<p>首先我们看下体系的坐标，在<code>p4vasp</code>的界面中，<code>POSCAR</code>中每个原子对应着不同的序号（序号是从<code>1</code>开始的），比如：Pt在POSCAR中是第109号原子，前面测量的Pt-Ti距离就是109号和23号原子之间的距离。计算两点之间的距离公式相信大家初高中的时候已经学过了。过程很简单（参考下面脚本中注释掉的部分。）：1）获取两个原子之间的坐标； 2）套公式得到距离。本节介绍通过ASE写个小脚本获取两个原子之间的距离。</p>
<p><img src="/2022/04/04/A28/3.png"></p>
<p>图3：p4vasp中原子的序号</p>
<h4 id="脚本内容"><a href="#脚本内容" class="headerlink" title="脚本内容"></a>脚本内容</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Created on Fri Apr 22 10:06:51 2022</span></span><br><span class="line"><span class="string">@author: qli</span></span><br><span class="line"><span class="string">Command: python3 get_dis_AB.py  atom_A_index atom_B_index</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> ase.io <span class="keyword">import</span> read, write</span><br><span class="line"><span class="keyword">import</span> os, sys</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Important Note: Atoms are indexed from 0.</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">atom_A, atom_B = [<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> sys.argv[<span class="number">1</span>:<span class="number">3</span>]]</span><br><span class="line">model = read(<span class="string">&#x27;POSCAR&#x27;</span>)</span><br><span class="line">positions = model.get_positions()</span><br><span class="line">dis_AB_1 = model.get_distance(atom_A, atom_B, mic=<span class="literal">True</span>)</span><br><span class="line">dis_AB_2 = model.get_distance(atom_A, atom_B, mic=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">round</span>(dis_AB_1, <span class="number">4</span>), <span class="string">&#x27;\t&#x27;</span>,<span class="built_in">round</span>(dis_AB_2,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">## Not Used </span></span><br><span class="line"><span class="comment">#coord_A = positions[atom_A]</span></span><br><span class="line"><span class="comment">#coord_B = positions[atom_B]</span></span><br><span class="line"><span class="comment">#dis_AB = np.linalg.norm(coord_A-coord_B)</span></span><br><span class="line"><span class="comment">#print(round(dis_AB,4))                     </span></span><br></pre></td></tr></table></figure>

<ol>
<li>atom_A，和 atom_B 是要测量的2个原子，<code>注意：ASE中原子的序号是从0开始的</code>，所以上面的例子中，Ti和Pt在ASE中则是22和108号原子。</li>
<li>脚本里面读的是<code>POSCAR</code>，根据自己的需求改成<code>CONTCAR</code>或者其他的带有坐标的文件。</li>
<li><code>mic=True</code> 考虑周期性边界的影响。<code>mic=False</code> 则是直接测量两个原子的距离。</li>
<li>最后面注释的几行是获取原子坐标，通过<code>numpy</code>计算距离的例子，效果等于前面<code>mic=False</code>.</li>
<li>脚本使用的命令：<code>python3 get_dis_AB.py  22 108 </code></li>
</ol>
<h4 id="脚本效果："><a href="#脚本效果：" class="headerlink" title="脚本效果："></a>脚本效果：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@bigbro:~/Desktop/example$ python3 get_dis_AB.py  22 108</span><br><span class="line">3.8175 	 7.4611</span><br></pre></td></tr></table></figure>

<h4 id="改进下输出格式"><a href="#改进下输出格式" class="headerlink" title="改进下输出格式"></a>改进下输出格式</h4><p>将前面脚本中<code>print</code>的一行删掉，换成下面的即可，反正数值已经在这里了，怎么输出根据自己爱好，把print对应的效果改改即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Atom_A\tAtom_B\tdis_A-B&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%s\t%s\t%.4f&#x27;</span> %(atom_A, atom_B, dis_AB_1))</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@bigbro:~/Desktop/example$ python3 get_dis_AB.py  22 108</span><br><span class="line">Atom_A Atom_B	dis_A-B</span><br><span class="line">22	108	3.8175</span><br></pre></td></tr></table></figure>

<h4 id="放到-bin目录下，随时可以使用："><a href="#放到-bin目录下，随时可以使用：" class="headerlink" title="放到~/bin目录下，随时可以使用："></a>放到<code>~/bin</code>目录下，随时可以使用：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@bigbro:~/Desktop/example$ chmod u+x get_dis_AB.py </span><br><span class="line">qli@bigbro:~/Desktop/example$ mv get_dis_AB.py  ~/bin/</span><br><span class="line">qli@bigbro:~/Desktop/example$ ls</span><br><span class="line">POSCAR</span><br><span class="line">qli@bigbro:~/Desktop/example$ get_dis_AB.py  22 108 </span><br><span class="line">Atom_A	Atom_B	dis_A-B</span><br><span class="line">22	108	3.8175</span><br></pre></td></tr></table></figure>

<p>没有<code>~/bin</code>的话，自己创建一个即可：<code>mkdir ~/bin</code></p>
<p>有兴趣的也可以自己尝试着解决周期性边界条件对计算两原子之间距离的影响，GitHub上也有很多类似的代码。也欢迎大家分享自己的代码或者链接；可以发送到我的邮箱：<code>lqcata@gmail.com</code>或者直接Q:<code>122103465</code>，微信：<code>BigBroSci</code> 联系。</p>
<p><img src="/2022/04/04/A28/qrcode.png"></p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>ASE</tag>
        <tag>软件</tag>
        <tag>原子距离</tag>
      </tags>
  </entry>
  <entry>
    <title>通过关键词判断优化任务收敛</title>
    <url>/2017/11/27/M_02/</url>
    <content><![CDATA[<p>今天QQ群里，有人（小风）问怎么通过reached这样的关键词来判断自己的任务是否收敛。</p>
<p>首先：阿牛哥哥说说了，实现的方法有很多种？这大实话一点都不假！</p>
<p>然后：乐平老师说，问问题的人没有问用什么语言写？这Python高手深藏不漏。</p>
<p>紧接着：杠精大神用bash语言coding了一番，敲出若干行神秘的文字：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">check=$(grep &quot;reach&quot; vasp.log | tail -1)</span><br><span class="line">if [ &quot;$check&quot; == &quot;&quot; ];then</span><br><span class="line">   echo &quot;$n $i $j cp POSCAR CONTCAR&quot; &gt;&gt; ../conver.log</span><br><span class="line">   cp POSCAR CONTCAR</span><br><span class="line">else</span><br><span class="line">   echo &quot;$n $i $j $check&quot; &gt;&gt; ../conver.log</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>下面我们就通过学习赋值和if语句来揭开上面的神秘文字。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>如果：f(A) = B，且f(C) = B，那么A的某一个性质 = C的某一个性质， 其中f() 是对操作对象在固定范围所实施的一个固定的方法。</p>
<p>也就是说对A和C进行同样的操作，同时都得到了B，那么说明A的某一个性质 = C的某一个性质 。</p>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>我们写脚本的目的是要通过B来判断A与C的关系。</p>
<p>A是我们已知的结果；</p>
<p>C是我们未知的结果；</p>
<p>B也就是我们说的赋值的对象。</p>
<p>首先，我们看一个已经收敛的例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@bigbro:~/ch4$ grep reached OUTCAR</span><br><span class="line">------------------------ aborting loop because EDIFF is reached ----------------------------------------</span><br><span class="line">------------------------ aborting loop because EDIFF is reached ----------------------------------------</span><br><span class="line">------------------------ aborting loop because EDIFF is reached ----------------------------------------</span><br><span class="line"> reached required accuracy - stopping structural energy minimisation</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>我们知道，如果使用<code>grep reached OUTCAR</code>这个命令，我们会得到2个结果，一个是<code>aborting loop because EDIFF is reached</code>，暂且记为A1， 另一个是<code>reached required accuracy - stopping structural energy minimisation</code> ，暂且记为A2。如果一个优化任务收敛的话，我们是通过A2来判断的。那么现在我们就可以把A2名字改成A了。A有什么特点呢？ 我们随便列2个。</p>
<p>1） A在OUTCAR中只出现一次，且出现在最后一行。</p>
<p>2） A的第一个单词是reached。</p>
<p>现在，我们将reached这个单词赋值为B。也就是让B为收敛冠名，只要满足通过上面2个条件筛选出来的结果是B，就说明计算收敛了。</p>
<p>筛选这个操作怎么进行呢？ </p>
<ul>
<li>利用特点1）： 使用<code>tail</code> 这个命令。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qli@tekla2:~/ch4$ grep reached OUTCAR</span><br><span class="line">------------------------ aborting loop because EDIFF is reached ----------------------------------------</span><br><span class="line">------------------------ aborting loop because EDIFF is reached ----------------------------------------</span><br><span class="line">------------------------ aborting loop because EDIFF is reached ----------------------------------------</span><br><span class="line"> reached required accuracy - stopping structural energy minimisation</span><br><span class="line">qli@tekla2:~/ch4$ grep reached OUTCAR  |tail -n 1</span><br><span class="line"> reached required accuracy - stopping structural energy minimisation</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>利用特点2）：使用<code>cut</code>或者<code>awk</code>命令来获取第一个单词。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@tekla2:~/ch4$ grep reached OUTCAR  |tail -n 1</span><br><span class="line"> reached required accuracy - stopping structural energy minimisation</span><br><span class="line">qli@tekla2:~/ch4$ grep reached OUTCAR  |tail -n 1 | cut -c 2-8</span><br><span class="line">reached</span><br><span class="line">qli@tekla2:~/ch4$ grep reached OUTCAR  |tail -n 1 | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span></span><br><span class="line">reached</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>判断C = B ? </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@tekla2:~/ch4$ b=<span class="string">&#x27;reached&#x27;</span></span><br><span class="line">qli@tekla2:~/ch4$ c=$(grep reached OUTCAR  |tail -n 1 | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br><span class="line">qli@tekla2:~/ch4$ <span class="built_in">echo</span> <span class="variable">$c</span></span><br><span class="line">reached</span><br><span class="line">qli@tekla2:~/ch4$ c=`grep reached OUTCAR  |tail -n 1 | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>`</span><br><span class="line">qli@tekla2:~/ch4$ <span class="built_in">echo</span> <span class="variable">$c</span></span><br><span class="line">reached</span><br><span class="line">qli@tekla2:~/ch4$ <span class="keyword">if</span> [ c=b ]; <span class="keyword">then</span> <span class="built_in">echo</span> bigbro ; <span class="keyword">fi</span></span><br><span class="line">bigbro</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>个人经验</category>
      </categories>
      <tags>
        <tag>收敛</tag>
        <tag>优化</tag>
        <tag>OUTCAR</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu18.使用VESTA报错的解决办法</title>
    <url>/2017/11/27/M_01/</url>
    <content><![CDATA[<p>今天在Ubuntu18的版本上用了一下VESTA，发现17.XX版本的问题还依然存在。</p>
<p>当你敲命令：<code>VESTA</code>之后，会得到包含下面信息的错误。</p>
<p><code>error while loading shared libraries libpng12.so.0</code></p>
<p>解决步骤：</p>
<p>1）点下面的链接，下载libpng12的deb文件。</p>
<p><a href="https://packages.debian.org/jessie/amd64/libpng12-0/download">https://packages.debian.org/jessie/amd64/libpng12-0/download</a></p>
<p>2）双击下载的deb文件，安装即可。</p>
<p>3）再用命令打开VESTA就不会出错了。</p>
]]></content>
      <categories>
        <category>个人经验</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>VESTA</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的数据库总结</title>
    <url>/2019/09/28/M_03/</url>
    <content><![CDATA[<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eHmVsslNkaBtAHO0jsHMuK5APDGLDXXLGYribdZDjcjYmEiaz7KtQPzPe1L0wYiaY0Ok2jtgl80Kx11zHDlWG8jfg/640?wx_fmt=png" alt="img"></p>
<p>汇集本人日常学习中的一些数据库，个人感觉不错的网站。也会不断地更新完善。如果你有好的数据库，链接，推荐的书籍，也欢迎发邮件至lqcata@gmail.com留言帮助我们更新。</p>
<h4 id="结构查找"><a href="#结构查找" class="headerlink" title="结构查找"></a>结构查找</h4><h5 id="The-Materials-Project"><a href="#The-Materials-Project" class="headerlink" title="The Materials Project"></a>The Materials Project</h5><p> <a href="https://www.materialsproject.org/">https://www.materialsproject.org/</a></p>
<p>使用方法：</p>
<p>1） 点击右上方：Login  </p>
<p>2） 点击： Sign in with your email address </p>
<p>3） 输入自己的邮箱，然后点击：send login link</p>
<p>4） 打开邮箱，点击链接，即可查询数据库。</p>
<h5 id="ioChem-BD"><a href="#ioChem-BD" class="headerlink" title="ioChem-BD"></a>ioChem-BD</h5><p> <a href="http://www.iochem-bd.org/">http://www.iochem-bd.org/</a> </p>
<p>本人老板和其他几个老板一起做的数据库，涵盖VASP，高斯等主流程序，可以上传结果。数据库依托于巴塞罗那超算中心。本人博士，博后的所有工作都在这个数据库中。</p>
<h5 id="ChemSpider"><a href="#ChemSpider" class="headerlink" title="ChemSpider"></a>ChemSpider</h5><p> <a href="http://www.chemspider.com/">http://www.chemspider.com/</a> RSC旗下的一个数据库，非常方便查找下载结构。</p>
<h5 id="Pubchem"><a href="#Pubchem" class="headerlink" title="Pubchem"></a>Pubchem</h5><p><a href="https://pubchem.ncbi.nlm.nih.gov/">https://pubchem.ncbi.nlm.nih.gov/</a> </p>
<h5 id="ICSD-数据库"><a href="#ICSD-数据库" class="headerlink" title="ICSD 数据库"></a>ICSD 数据库</h5><p> <a href="http://www2.fiz-karlsruhe.de/icsd_home.html">http://www2.fiz-karlsruhe.de/icsd_home.html</a> , 需要账号密码</p>
<h5 id="CCDC-The-Cambridge-Crystallographic-Data-Centre"><a href="#CCDC-The-Cambridge-Crystallographic-Data-Centre" class="headerlink" title="CCDC: The Cambridge Crystallographic Data Centre"></a>CCDC: The Cambridge Crystallographic Data Centre</h5><p><a href="https://www.ccdc.cam.ac.uk/">https://www.ccdc.cam.ac.uk/</a></p>
<h5 id="cccbdb-数据库"><a href="#cccbdb-数据库" class="headerlink" title="cccbdb 数据库"></a>cccbdb 数据库</h5><p><a href="https://cccbdb.nist.gov">https://cccbdb.nist.gov</a></p>
<h5 id="团簇数据库："><a href="#团簇数据库：" class="headerlink" title="团簇数据库："></a>团簇数据库：</h5><p><a href="http://www-wales.ch.cam.ac.uk/~wales/CCD/CoCCD/cobalt.html">http://www-wales.ch.cam.ac.uk/~wales/CCD/CoCCD/cobalt.html</a>  </p>
<p>可能有些老了。</p>
<p><a href="https://ww2.mathworks.cn/matlabcentral/fileexchange/33449-cluster-generator">https://ww2.mathworks.cn/matlabcentral/fileexchange/33449-cluster-generator</a> </p>
<h5 id="Wulffman"><a href="#Wulffman" class="headerlink" title="Wulffman"></a>Wulffman</h5><p><a href="https://www.ctcms.nist.gov/wulffman/">https://www.ctcms.nist.gov/wulffman/</a></p>
<h5 id="XPS"><a href="#XPS" class="headerlink" title="XPS"></a>XPS</h5><p><a href="https://xpssimplified.com/">https://xpssimplified.com/</a></p>
<p><strong>Cn Fullerenes</strong></p>
<p><a href="http://www.nanotube.msu.edu/fullerene/fullerene-isomers.html">http://www.nanotube.msu.edu/fullerene/fullerene-isomers.html</a></p>
<h4 id="热力学数据"><a href="#热力学数据" class="headerlink" title="热力学数据"></a>热力学数据</h4><p>NIST 数据库： <a href="https://physics.nist.gov/cuu/Constants/index.html">https://physics.nist.gov/cuu/Constants/index.html</a>  </p>
<p>CRC Handbook of physical chemistry ： <a href="http://hbcponline.com/faces/contents/ContentsSearch.xhtml">http://hbcponline.com/faces/contents/ContentsSearch.xhtml</a> 查找热力学参数，晶格常数，entropy等等。</p>
<p><a href="http://www2.ucdsb.on.ca/tiss/stretton/database/inorganic_thermo.htm">http://www2.ucdsb.on.ca/tiss/stretton/database/inorganic_thermo.htm</a> 无机化合物的物理和热力学相关数据</p>
<p><a href="http://www.knowledgedoor.com/2/elements_handbook/cohesive_energy.html">http://www.knowledgedoor.com/2/elements_handbook/cohesive_energy.html</a> 结合能</p>
<p><a href="http://www.surface-tension.de/">http://www.surface-tension.de/</a> 表面张力</p>
<p><a href="http://www.wiredchemist.com/chemistry/data/thermodynamic-data">http://www.wiredchemist.com/chemistry/data/thermodynamic-data</a></p>
<p><a href="https://atct.anl.gov/">https://atct.anl.gov/</a></p>
<h4 id="物理常数"><a href="#物理常数" class="headerlink" title="物理常数"></a>物理常数</h4><p><a href="https://physics.nist.gov/cuu/Constants/index.html">https://physics.nist.gov/cuu/Constants/index.html</a></p>
<p><a href="http://wild.life.nctu.edu.tw/class/common/energy-unit-conv-table.html">http://wild.life.nctu.edu.tw/class/common/energy-unit-conv-table.html</a></p>
<p><a href="http://halas.rice.edu/conversions">http://halas.rice.edu/conversions</a></p>
<h4 id="书籍文献下载："><a href="#书籍文献下载：" class="headerlink" title="书籍文献下载："></a>书籍文献下载：</h4><p>google和google scholar：科学上网。</p>
<p><a href="http://gen.lib.rus.ec/">http://gen.lib.rus.ec/</a> 下载书籍</p>
<p>资源丰富，但不要贪多，更不要下一堆放到自己电脑里占地方。找几本好书，认真静下心来好好学习。</p>
<p><a href="http://www.expaper.cn/">http://www.expaper.cn/</a> 科研速递论坛， 求助文献，书籍，成功率极高。</p>
<p>sci-hub 系列，现在网上各种域名，插件，桌面版的都有，我就不瞎凑热闹了。</p>
<p>5000人QQ群:  157099073  汇聚大家的力量，解决每一篇小文献的困难。</p>
<p>书籍和文献下载的原则，宁缺毋滥，认真阅读每一篇下载的文献，对自己的时间负责。别图多。</p>
<h4 id="VASP-相关"><a href="#VASP-相关" class="headerlink" title="VASP 相关"></a>VASP 相关</h4><p><strong>VASP官网</strong></p>
<p><a href="http://www.vasp.at/">http://www.vasp.at/</a>, VASP最权威，最专业的学习资料都在这里面了。英文刚开始看起来有点不适应，坚持下去，慢慢就好了。不建议看除官网以外的那些乱七八糟的说明（包括我自己写的教程）</p>
<p><strong>VASP 教程视频</strong></p>
<p><a href="http://www.nersc.gov/users/training/events/3-day-vasp-workshop/">http://www.nersc.gov/users/training/events/3-day-vasp-workshop/</a>, A 3-day VASP Workshop at NERSC: VASP 开发者（长发大胡子那哥们）做的workshop, youtube 有视频。链接：<a href="https://www.youtube.com/playlist?list=PL20S5EeApOSumWZkzsaYxAvozjvFZ3ks4">https://www.youtube.com/playlist?list=PL20S5EeApOSumWZkzsaYxAvozjvFZ3ks4</a> </p>
<p><strong>VASP官方论坛</strong></p>
<p><a href="https://cms.mpi.univie.ac.at/vasp-forum/">https://cms.mpi.univie.ac.at/vasp-forum/</a></p>
<p>VASP官方论坛，需要注册才可以提问，但一般来说你的问题已经有人提问过了，直接复制到google里面，基本都会显示该论坛的链接。可以不保存。</p>
<p><strong>Henkelman 课题组</strong></p>
<p><a href="http://theory.cm.utexas.edu/henkelman/">http://theory.cm.utexas.edu/henkelman/</a>, 大量VASP相关的脚本，VTST计算过渡态，bader电荷分析，CHGCAR处理脚本等，向Henkelman致以崇高的敬意。</p>
<p><strong>ASE</strong>： Atomic Simulation Environment： <a href="https://wiki.fysik.dtu.dk/ase/，">https://wiki.fysik.dtu.dk/ase/，</a> 适合催化计算相关</p>
<p><strong>Pymatgen</strong>： <a href="http://pymatgen.org/">http://pymatgen.org/</a>, 适合材料计算的</p>
<p><strong>K-path</strong>： <a href="https://www.materialscloud.org/work/tools/seekpath">https://www.materialscloud.org/work/tools/seekpath</a> </p>
<p>能带Kpath选择的网站，上传自己的结构，便可以得到建议的路径。</p>
<p><strong>Chemml</strong>: <a href="https://hachmannlab.github.io/chemml/">https://hachmannlab.github.io/chemml/</a></p>
<p><strong>p4vasp</strong>：<a href="http://www.p4vasp.at/">http://www.p4vasp.at/</a></p>
<p><strong>RDkit</strong>：<a href="https://www.rdkit.org/">https://www.rdkit.org/</a>  </p>
<p><strong>VASPkit</strong> ： <a href="https://sourceforge.net/projects/vaspkit/files/">https://sourceforge.net/projects/vaspkit/files/</a> 来自中国的良心软件, VASP计算前后处理，功能强大，使用简单，老少皆宜。</p>
<p><strong>VESTA </strong> ： <a href="http://jp-minerals.org/vesta/en/">http://jp-minerals.org/vesta/en/</a> 来自日本的良心软件</p>
<p><strong>Xcrysden</strong>  ：<a href="http://www.xcrysden.org/，">http://www.xcrysden.org/，</a> 用于批量做图，选择K-path做能带图，等。</p>
<p><strong>Openbabel</strong> ：<a href="http://openbabel.org/wiki/Main_Page">http://openbabel.org/wiki/Main_Page</a>  强大的格式转换工具，它说第二，没人敢说第一。</p>
<p><strong>RDkit</strong>：化学信息学重要的开源包。</p>
<h4 id="程序软件相关："><a href="#程序软件相关：" class="headerlink" title="程序软件相关："></a>程序软件相关：</h4><h5 id="Bash-：http-tldp-org-HOWTO-Bash-Prog-Intro-HOWTO-html"><a href="#Bash-：http-tldp-org-HOWTO-Bash-Prog-Intro-HOWTO-html" class="headerlink" title="Bash ：http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO.html"></a>Bash ：<a href="http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO.html">http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO.html</a></h5><p><a href="https://learnpythonthehardway.org/">https://learnpythonthehardway.org/</a></p>
<p><a href="https://www.liaoxuefeng.com">https://www.liaoxuefeng.com</a>, 廖雪峰的网站，英文不想读的话，可以到这里学习。</p>
<p><a href="https://matplotlib.org/">https://matplotlib.org/</a>  用python画图</p>
<p><a href="https://www.scipy.org/">https://www.scipy.org/</a> python 科学运算相关的库 </p>
<p><a href="https://stackoverflow.com/">https://stackoverflow.com/</a>  一般谷歌搜索遇到出现的程序问题，都可以在这里找到答案。</p>
<p><a href="https://www.geeksforgeeks.org">https://www.geeksforgeeks.org</a></p>
<p> <a href="https://stackoverflow.com/">https://stackoverflow.com/</a>  一般谷歌搜索遇到出现的程序问题，都可以在这里找到答案。</p>
<h5 id="大牛们的Git-Hub-网站"><a href="#大牛们的Git-Hub-网站" class="headerlink" title="大牛们的Git-Hub 网站"></a>大牛们的Git-Hub 网站</h5><p>很多懂程序, 喜欢分享的大牛们都有自己的github网址，下面会逐渐完善。</p>
<p>1）<a href="https://github.com/Ionizing">https://github.com/Ionizing</a> （www.bigbrosci.com这个网站就是这牛人帮忙搭建的）</p>
<p>2）<a href="https://github.com/wangvei">https://github.com/wangvei</a> （VASPkit的作者，王伟老师）</p>
<p>3）<a href="https://github.com/QijingZheng">https://github.com/QijingZheng</a>  （很屌的一个大牛，虽然没见过）</p>
<p>4） <a href="https://github.com/obaica">https://github.com/obaica</a> （只要Follow了他，基本就可以找到其他大牛的github了）</p>
<p>5）<a href="https://github.com/tamaswells">https://github.com/tamaswells</a> （脚本小王子，the king of sharing）</p>
<p>6）<a href="https://github.com/jensengroup">https://github.com/jensengroup</a>  （总有一些人，会默默地支持穷人们的科研）</p>
<p>7）<a href="https://github.com/LePingKYXK">https://github.com/LePingKYXK</a></p>
<p>8）<a href="http://home.ustc.edu.cn/~lipai/scripts/vasp.html">http://home.ustc.edu.cn/~lipai/scripts/vasp.html</a></p>
<h4 id="理论计算，推荐书籍："><a href="#理论计算，推荐书籍：" class="headerlink" title="理论计算，推荐书籍："></a>理论计算，推荐书籍：</h4><h5 id="1）-Density-Functional-Theory-A-Practical-Introduction"><a href="#1）-Density-Functional-Theory-A-Practical-Introduction" class="headerlink" title="1） Density Functional Theory: A Practical Introduction"></a>1） Density Functional Theory: A Practical Introduction</h5><p><a href="http://onlinelibrary.wiley.com/book/10.1002/9780470447710">http://onlinelibrary.wiley.com/book/10.1002/9780470447710</a> </p>
<p>有权限的直接下载；没有权限的不要在网上瞎求，很多公式都不全，这个要注意。</p>
<h5 id="2）Atkin’s-Physical-Chemisty-（10th）"><a href="#2）Atkin’s-Physical-Chemisty-（10th）" class="headerlink" title="2）Atkin’s Physical Chemisty （10th）"></a>2）Atkin’s Physical Chemisty （10th）</h5><p>网上到处都是，最新的是第10版，如果下载不了，看第9版即可。</p>
<h5 id="3）of-Modern-Catalysis-and-Kinetics"><a href="#3）of-Modern-Catalysis-and-Kinetics" class="headerlink" title="3）of Modern Catalysis and Kinetics"></a>3）of Modern Catalysis and Kinetics</h5><p>做多相催化的强烈建议！<a href="http://onlinelibrary.wiley.com/book/10.1002/3527602658">http://onlinelibrary.wiley.com/book/10.1002/3527602658</a> </p>
<p>以上书籍，如不提供下载链接，基本都可以在 <a href="http://gen.lib.rus.ec/">http://gen.lib.rus.ec/</a>  这个网站获得。</p>
<h4 id="溶剂相关的："><a href="#溶剂相关的：" class="headerlink" title="溶剂相关的："></a>溶剂相关的：</h4><p><a href="https://www.organicdivision.org/wp-content/uploads/2016/12/organic_solvents.html">https://www.organicdivision.org/wp-content/uploads/2016/12/organic_solvents.html</a></p>
<p><a href="http://murov.info/orgsolvents.htm">http://murov.info/orgsolvents.htm</a></p>
<h4 id="求职相关"><a href="#求职相关" class="headerlink" title="求职相关"></a>求职相关</h4><h5 id="Psik-Network：-http-psi-k-net"><a href="#Psik-Network：-http-psi-k-net" class="headerlink" title="Psik Network： http://psi-k.net/"></a>Psik Network： <a href="http://psi-k.net/">http://psi-k.net/</a></h5><p>注册后，一旦有人在网络里面发送海外职位信息，你便会收到邮件提醒。更为重要的是，网站里面有很多珍贵的学习资料。</p>
<h5 id="Linkedin-领英-https-www-linkedin-com-，"><a href="#Linkedin-领英-https-www-linkedin-com-，" class="headerlink" title="Linkedin 领英 https://www.linkedin.com/，"></a>Linkedin 领英 <a href="https://www.linkedin.com/，">https://www.linkedin.com/，</a></h5><p>有些老板也会在这上面发布招聘信息，本人当年的博士位置，就是在这里面发现的。 </p>
<h5 id="Research-gate：-https-www-researchgate-net"><a href="#Research-gate：-https-www-researchgate-net" class="headerlink" title="Research gate： https://www.researchgate.net/,"></a>Research gate： <a href="https://www.researchgate.net/">https://www.researchgate.net/</a>,</h5><p>可以用来下文献，关注同行最新进展。</p>
<hr>
<p>（七）理论计算，推荐书籍：</p>
<p>1 DFT: A Practical Introduction</p>
<p> <a href="http://onlinelibrary.wiley.com/book/10.1002/9780470447710">http://onlinelibrary.wiley.com/book/10.1002/9780470447710</a> </p>
<p>1）有权限的直接下载</p>
<p>2）没有权限的不要在网上瞎求，很多公式都不全，这个要注意。</p>
<p>2 Atkin’s Physical Chemisty （10th）</p>
<p>网上到处都是，最新的是第10版，如果下载不了，看第9版即可。</p>
<p>3 Concepts of Modern Catalysis and Kinetics 多相催化的强烈建议！</p>
<p><a href="http://onlinelibrary.wiley.com/book/10.1002/3527602658">http://onlinelibrary.wiley.com/book/10.1002/3527602658</a> </p>
<p>以上书籍，如不提供下载链接，基本都可以在 <a href="http://gen.lib.rus.ec/">http://gen.lib.rus.ec/</a>  这个网站获得。</p>
<hr>
<p>其他： </p>
<p>1 颜色数据库：</p>
<p><a href="https://www.rapidtables.com/web/color/RGB_Color.html">https://www.rapidtables.com/web/color/RGB_Color.html</a> </p>
<p>2 元素周期表：</p>
<p><a href="http://www.rsc.org/periodic-table">http://www.rsc.org/periodic-table</a></p>
<p><a href="https://www.ptable.com/">https://www.ptable.com/</a></p>
<p><a href="http://www.periodictable.com/">http://www.periodictable.com/</a></p>
<p>3 Latex相关：</p>
<p>本人的文章，除合作的外， 基本都是用latex写的，但是推荐网址的话，确实想不起有什么来。找一个latex入门pdf，练上几天，遇到问题google搜索，慢慢就好了。如果非要推荐一个网址的话，那么就选这个： <a href="https://tex.stackexchange.com/">https://tex.stackexchange.com/</a>  和 www.google.com </p>
<hr>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/eHmVsslNkaBtAHO0jsHMuK5APDGLDXXL7M3g9VbsIicuyWwcNrwXMnL9cQBsvrIeRFbgNmHiaAlMp1yZTswmcNeA/640?wx_fmt=jpeg" alt="img"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/eHmVsslNkaBtAHO0jsHMuK5APDGLDXXLjOuXI8VKlV8BECMzI4PehhbehXThX1tysRKCM2tJrEufnh9JwSQ97w/640?wx_fmt=jpeg" alt="img"></p>
<p>也欢迎大家关注微信公众号</p>
]]></content>
      <categories>
        <category>个人经验</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title>z01 分享一本葵花宝典</title>
    <url>/2019/10/07/S01/</url>
    <content><![CDATA[<p><img src="/2019/10/07/S01/share01/z01_1.png" alt=""></p>
<p>Python现在越来越流行，连微信朋友圈都开始推广一些python培训课程广告了：俩美女一起上班，一个瞬间完成工作，另一个一脸懵逼地问道你咋这么快就干完活啦？另一个回答道：因为我学习了Python啊。是的，Python确实有这些神奇的功效，但在网络这么发达的时代，想学习python的途径有很多，参加什么割韭菜的培训班啦，找个计算机学院的男女朋友啦，向师兄师姐学习啦，自己学习琢磨啦等等。</p>
<p><img src="/2019/10/07/S01/share01/z01_2.png" alt=""></p>
<p>学习Python的一个好处就是，很多懂python的都会github上分享一些自己的脚本，但这些脚本很多时候不是为你的课题量身定制的。稍微懂点可以加以修改就变成自己科研的一个利器了。更重要的好处就是广告里面所凸显的，由于计算中很多操作都是可以重复的，写个小脚本可以快速完成自己的工作任务，提高效率，省出时间该干嘛干嘛去。此外，很多复杂的任务，手动计算量很大，也得需要写点脚本来帮忙。那种瞬间完成任务的感觉，不会点程序语言的人是不会体验到的。而且，现在小学生，初中生都开始学习python了，我们也没有理由不跟上时代的潮流。</p>
<p><img src="/2019/10/07/S01/share01/z01_3.jpg" alt=""></p>
<p>看到这里，应该能明白本文的目的。不要你交99元，也不给你优惠99元。大师兄推荐一本武林秘籍，专门针对科研人员的一本科学计算相关的Python书。里面大量例子简单易懂，解释详细，带你缓缓走入Python的程序世界，平日闲的没事加以练习，犹如武林高手给你灌输真气一般，达到计算的另一个境界，轻而易举超越那些培训班被割过的韭菜们。</p>
<p>获取方式，扫描右侧或者下方二维码关注公众号：大师兄科研网，回复：<strong>武林秘籍</strong> 就可以获取下载链接了。为了避免别人学会了python跟你抢男女朋友，课题组争宠，大家下载后私下练习就OK啦，有对象的，一起练习讨论效果更佳。</p>
<p><img src="/2019/10/07/S01/share01/z01_4.jpg" alt=""></p>
]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>基于DFT+U研究应力调控CeO2(111)催化分解水制氢的活性</title>
    <url>/2019/10/13/S03/</url>
    <content><![CDATA[<p><img src="/2019/10/13/S03/share03/s031.png" alt=""></p>
<p><strong>基于DFT+<em>U</em>研究应力调控CeO2(111)催化分解水制氢的活性</strong></p>
<p><code>研究背景</code></p>
<p>氢能清洁无污染，是最具潜力的能量载体。使用太阳能、风能和水能转换得到的清洁电能电解水制氢是人来未来最具发展潜力的、可持续的、绿色环保的制氢技术。传统低温碱性电解水制氢技术的效率受限于液体电解质较低的传质过程和氧电极较慢的反应动力。相比于液体传质技术，新兴发展的高温固体燃料电池 (SOEC)技术以固体作为传质媒介，充分利用工业废热提供反应所需的热能，具有极高的传质效率和水电解效率。然而人们对SOEC制氢反应机理尚缺乏深刻认识。计算模拟技术是揭示能源材料领域中多相催化反应过程及机理的重要手段，可以辅助了解SOEC电解水的关键反应步骤，以开发、低廉且稳定的催化剂用于增强氢电极的稳定性以及提高制氢反应在燃料电池中的效率。兼具优异的电子和离子传质能力的氧化铈（CeO2）是SOEC水分解重要的催化剂和稳定剂。CeO2优越的催化活性归因于Ce3+与Ce4+的氧化还原循环。基于密度泛函理论，该工作使用Hubbard-<em>U<strong>（</strong>U</em>eff=4.5 eV）修正的方法来描述Ce 4<em>f</em>轨道电子的强关联作用，研究表面应力对CeO2(111)催化制氢的影响。</p>
<p><code>研究内容</code></p>
<p>水在CeO2表面分解制氢包括三个基本反应步骤：（1）CeO2(111)表面生成一个氧空位；（2）H2O吸附于氧空位附近最终形成表面OH-；（3）表面OH-分解形成H2并留下一个晶格氧，如Figure 1所示水分解过程中形成的反应中间体以及最终生成H2的反应过程。该工作主要研究了三种可能的反应路径，即不同OH- 覆盖率下形成H2的过程如Figure 1所示。通过研究应力对三种不同反应路径中反应中间体形成的影响，以及应力对各反应步骤反应能垒的调控，来探究应力如何增强CeO2催化制氢的性能。</p>
<p>首先，研究发现拉伸应变有效增强了氧空位和OH-等中间体的稳定性，随之增加了各反应步骤的反应能垒。与之相反的是压缩应变可以通过减弱OH-与表面的结合能，从而降低生成H2的能垒。通过计算不同反应温度下中间体的自由能可以获得沿着2H，4H和5H的反应路径能量图。研究发现不管处于何种应力条件下生成氧空位和氧空位的扩散，以及OH-的形成不需要很高的能量势垒，而OH-分解形成H2是水分解制氢反应路径中能垒最高的一个步骤。然后，通过对比不同反应温度下，研究发现在温度低于1000 K时，沿着5H路径可以最快速地水分解生成H2 如图2所示，且最佳反应路径不受应力的影响。然而，当温度升高到1200 K时，应力有效地调控了制氢的反应路径，即拉伸应力下最优路径沿着5H，而在压缩应力下最优反应路径沿着2H或者4H。此外，研究还发现反应速度随着压缩应力的增大而增快，且当压缩应力大于3%时，反应速度获得显著提升。因此，计算模拟理论研究显示压缩应力（&gt;3%）有利于增强CeO2(111)催化水分解制氢的反应活性。</p>
<p><img src="/2019/10/13/S03/share03/s032.png" alt=""></p>
<p>图1. 2H，4H和5H覆盖的CeO2(111)表面生成H2的反应路径示意图。黄色, 红色，蓝色，白色，黑色和灰色原子球分别代表Ce，表面O，次表面O，H，次表面氧空位和表面氧空位。</p>
<p><img src="/2019/10/13/S03/share03/s033.png" alt=""></p>
<p>图2不同反应温度与应力条件下最优反应路径生成H2的反应速度对比图。</p>
<p><code>作者简介</code></p>
<p>本文第一作者，武甜甜为丹麦科技大学能源转化与储存系博士后研究员。</p>
<p>Google Scholar： </p>
<p><a href="https://scholar.google.com/citations?user=rm84jfsAAAAJ&amp;hl=en">https://scholar.google.com/citations?user=rm84jfsAAAAJ&amp;hl=en</a></p>
<p>指导老师为：Tejs Vegge教授。</p>
<p>课题组主页：<a href="https://www.dtu.dk/english/service/phonebook/person?id=5334&amp;tab=1。">https://www.dtu.dk/english/service/phonebook/person?id=5334&amp;tab=1。</a></p>
<p>本文经作者授权发布，版权属于第一作者。</p>
]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>文章</tag>
        <tag>ACS Catalysis</tag>
      </tags>
  </entry>
  <entry>
    <title>理论模拟导向的催化剂理性高效设计策略用于醇的选择性胺化</title>
    <url>/2019/10/12/S02/</url>
    <content><![CDATA[<p><img src="/2019/10/12/S02/share02/s021.png" alt=""></p>
<p>理论模拟导向的催化剂理性高效设计策略用于醇的选择性胺化</p>
<p>第一作者：王涛</p>
<p>通讯作者：Philippe Sautet</p>
<p><strong>研究背景</strong></p>
<p>胺是工业上生产药物、农用化学品、生物活性剂、聚合物和染料的重要中间体化合物，其中伯胺是衍生化反应的关键试剂。传统合成胺的方法包括氨与烷基卤的直接反应，或通过还原硝基络合物和腈，但是这些工艺的缺陷在于产生有害的副产物、废弃物并消耗大量氢气。而利用氨气通过借氢反应机理直接胺化脂肪类醇用于合成胺被认为是一种有潜力的绿色合成路线并且已经有数千吨规模的工业化应用。然而，合成胺工业仍然面临诸多挑战，尤其是选择性合成伯胺。在此背景下，探索催化剂的本征性质与合成胺活性和选择性的依赖关系变得尤为重要。近年来，理论模拟的飞速发展使得揭示催化过程中的构效关系成为可能。本文结合第一性原理微观动力学模拟和实验，揭示了决定醇的胺化活性和选择性的关键因素并构建了其与碳和氧原子吸附能的依赖关系，实现了该反应金属合金催化剂的理性高效筛选，为实验上醇胺化催化剂的设计和升级提供了重要理论参考。</p>
<p><strong>内容和讨论</strong></p>
<p><strong>A.</strong> <strong>醇的胺化反应机理:</strong> 首先甲醇的胺化被作为模型反应进行研究，该反应机理主要包括三部分(如图1)：醇的脱氢生成醛；醛与NH3迅速反应生成亚胺；亚胺的加氢生成胺。基于上述反应机理，DFT计算在九种过渡金属的密堆积表面系统展开。由于实际反应气氛中具有大量的NH3，因此催化剂的表面会覆盖一定浓度的NH3，早期的研究发现表面覆盖1/9 ML的NH3有助于准确描述胺化反应催化剂的活性顺序。其中，第二步醛与NH3反应生成亚胺被认为是气相里的快速平衡反应而且是理论模拟上的难点，该工作通过详细的反应器动力学模拟证明采用Eley–Rideal 反应机理能够准确描述该关键步骤。最终为微观动力学模拟提供了可靠的反应机理。</p>
<p><img src="/2019/10/12/S02/share02/s022.png" alt=""></p>
<p><strong>图1</strong>: 甲醇与氨气的胺化反应机理</p>
<p><strong>B.</strong> <strong>线性降维:</strong> 基于Norskov课题组提出的d带中心理论和scaling关系，反应过程中表面物种的吸附能并非相互独立的而是受制于scaling关系，并且基元反应的能垒也可以通过BEP关系与反应热关联，因此通过详细的描述符的筛选以及线性拟合可以实现降维和最优描述符的确认。由于该反应涉及含C、N、O的三类中间体，scaling关系可以最终将该反应中涉及的中间体的能量与C、N和O原子的吸附能进行关联。然而，包含三种不同描述符导致无法利用典型的二维火山曲线进行活性描述。深入研究发现：N原子的吸附能同样依赖于C和O原子的吸附能并且具有完美的线性关系（如图2）。而该依赖关系的物理化学根源一方面为N(3.0)原子的电负性恰好介于C(2.5)和O(3.5)原子之间，另一方面N原子的最高占据轨道能量(HOMO)可以线性分解为C和O原子的相应能量。基于上述分析，甲醇胺化反应的能量维度被降低为二(C和O原子的吸附能)。</p>
<p><img src="/2019/10/12/S02/share02/s023.png" alt="">**</p>
<p><strong>图2</strong>: N原子的吸附能与C和O原子吸附能的线性关系</p>
<p><strong>C.</strong> <strong>醇的胺化活性和选择性与简单描述符的依赖关系:</strong> 基于图1的反应机理和图2的线性降维，通过构建微观动力学模型，最终建立了醇胺化的反应速率(TOF)与C和O原子吸附能的依赖关系。如图3a所示，由于对C和O原子吸附能力的区别，九种金属分布于火山图的不同位置而呈现出不同的反应活性。然而，针对醇的胺化反应，人们更加关心且关键的问题是选择性。因此，该工作进一步系统考察了导致伯胺选择性降低的不同可能性，最终发现CH3NH和CH2NH物种的耦合是导致选择性丢失的关键因素之一，并巧妙的将其与简单描述符进行了关联，最终构建了醇胺化生成伯胺的选择性与C和O原子吸附能的依赖关系如图3b。随着CH3NH/CH2NH耦合能垒(<em>E</em>a)的增加，副反应变得困难，进而催化剂的选择性增加。至此，通过计算催化剂表面C和O原子的吸附能，结合图3中的火山图便可定性预测相应催化剂的醇胺化反应的活性和选择性，从而大大提高催化剂的筛选效率。</p>
<p><img src="/2019/10/12/S02/share02/s024.png" alt=""></p>
<p><strong>图3:</strong> 醇的胺化活性(a)和选择性(b)与C和O原子吸附能的依赖关系</p>
<p><strong>D.</strong> <strong>实验室论证预测:</strong> 基于上述活性和选择性图，通过对元素周期表中不同过渡金属进行两两排列组合，最终计算了三百余种双金属合金的C和O原子吸附能，并预测出系列有潜力的醇选择性胺化催化剂。基于上述理论预测，索尔维公司研发中心对不同合金进行了详细的实验室测试以论证图3的可靠性。具体的：本文合成了系列Co基合金催化剂，一方面由于Co金属的相对廉价，另一方面Co具有较高的活性和伯胺选择性。根据图3a的理论预测，提高Co的活性需要设法降低其O原子的吸附能，由于Pt和Pd具有弱的O吸附能力，因此将Co与Pt和Pd形成合金将可以实现反应活性提高的，然而基于图3b的信息，这将同时伴随着伯胺选择性的降低。事实上，图4和图5的实验结果也证实了CoPt和CoPd合金相比Co金属的高活性和低伯胺选择性。此外，图3表明：将Co与Ag和Ru组合将会维持甚至提高活性且提高选择性。该预测结果同样与图4和图5中的实验结果一致，并且成功设计出活性选择性都大大提高的CoAg合金催化剂。本文预测的其他有潜力的合金催化剂也将进一步推动实验上对醇胺化反应研究。</p>
<p><img src="/2019/10/12/S02/share02/s025.png" alt="img"></p>
<p><strong>图4:</strong> 实验上不同催化剂醇的胺化生成伯胺的TOF</p>
<p><img src="/2019/10/12/S02/share02/s026.png" alt=""></p>
<p><strong>图5:</strong> 实验上不同催化剂醇的胺化生成伯胺的选择性</p>
<p><strong>总结和展望</strong></p>
<p>通过精确的第一性原理计算和微观动力学方法，准确的模拟了醇的胺化这一复杂反应的详细机理，揭示了决定金属合金催化剂醇的胺化活性和选择性的关键因素，并与简单易得的C和O原子吸附能进行关联，系统的实验测试论证了理论预测的可靠性。最终大大提高了醇胺化反应金属合金催化剂的筛选效率，为工业上醇胺化催化剂的设计和升级提供了参考。此外，该工作采用的改进的动力学模拟方法能够引入反应器环境对复杂反应机理的影响，一方面实现对实验条件更加精准的描述，另一方面能够准确定性预测金属合金催化剂的活性和选择性的变化趋势，为后续高通量催化剂筛选提供了基础。</p>
<p><strong>作者简介</strong></p>
<p>文章第一作者王涛博士目前为美国斯坦福大学SUNCAT中心博士后研究员，通讯作者Philippe Sautet为美国加州大学洛杉矶分校教授、ACS Catalysis副主编、法国科学院院士、美国能源局IMASC能源前沿研究中心副主任，长期致力于理论催化方向的基础研究。此外，法国里昂高等师范学院、法国里尔大学、比利时根特大学以及跨国公司索尔维研发中心E2P2实验室也为该工作提供了支持。本文经大师兄涛本人授权发布。</p>
<p>文章链接：<a href="https://www.nature.com/articles/s41929-019-0327-2">https://www.nature.com/articles/s41929-019-0327-2</a></p>
<p> <img src="/2019/10/12/S02/share02/s027.jpg" alt=""></p>
<p>关注公众号：大师兄科研网，回复：<strong>胺化</strong>，可以获取下载链接。</p>
]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>文章</tag>
        <tag>Nature Catalysis</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Hall Petch关系(一)</title>
    <url>/2019/10/13/S04/</url>
    <content><![CDATA[<p>Hall Petch关系是材料学中描述多晶材料最为重要的一个相关关系，它反映了材料强度与晶粒的尺寸的开方成反比。同时材料在极小晶粒尺寸下表现出的反常Hall Petch 关系也一度成为材料学家的研究热点。关于反常Hall Petch关系的研究发现屡现于高水平期刊，本文将不做更多介绍。从Hall Petch关系的第一次报导开始，已经有大量的文章针对各种材料体系（纯金属，金属间化合物，多相合金等等）进行了相关研究。然而，从Hall Petch 关系提出至今，依旧没有出现一个完美简洁的理论可以解释这个现象。研究人员为了解释这个现象已经提出了大量的理论，在接下来的篇幅中，作者将从中提取了几个典型的理论做简要介绍</p>
<p>1951年，Hall（文献1）发表的论文中首次报导了钢中存在的Hall Petch关系:</p>
<p>$\sigma=\sigma<em>0 + k</em>{HP}d^{-1/2} $</p>
<p>其中$\sigma$表示流变应力，d表示晶粒尺寸，k是Hall Petch 系数，其对不同材料，温度和应变条件都非常敏感。</p>
<p>与此同时，他也在文章中首次提出了试图解释Hall Petch关系的pile up（位错阻塞）模型。</p>
<p><img src="/2019/10/13/S04/share04/share042.png" alt=""></p>
<p>该理论认为材料的强度来自于外力作用下导致的晶粒内部位错源开动，位错源启动后形成的位错林被晶粒之间的界面（晶界）阻碍后引起了材料的应力强化。简单起见，我们不妨假设两个近似六边形的晶粒以晶界AB接触，左边晶粒的中心O点存在一个位错源，在外加应力的作用下位错源沿着某一滑移面释放出一系列位错。随着第一个发射的位错冲撞到晶界AB上，整个位错列队被禁锢在位错源与晶界之间。由于晶界墙的阻力和新产生位错的弹性应变，整个位错列最后会形成一个稳定分布，假设晶粒的平均尺寸为d，则位错列中位错的数目为：</p>
<p>$n=\frac{(1-v)d\tau_e}{2\mu{b}}$</p>
<p>其中$\tau_e$表示位错的有效剪切应力，它可以表示为：</p>
<p>$\tau_e=\tau-\tau_i$</p>
<p>显然，它实际上是在加载应力中扣除了弹性应力部分。试想如果你要产生一根位错，首先晶体要发生塑性变形，因此塑性变形前的弹性部分并不是我们应该要考虑的部分。既然我们已经知道位错列中位错的数目，如果我们粗略地认为，所有的位错作用到晶界上的应力都是等效的，那么晶界上受到的应力$\tau_p$为</p>
<p>$\tau_p = n\tau_e$</p>
<p>Hall认为，材料屈服发生于位错列冲破晶界的时候，也就是说 $\tau_p$大于临界值$\tau_c$。如果我们取等号，再将前面的n代入，我们就可以得到：</p>
<p>$\tau = \tau_i +\surd{\frac{2\tau_c\mu{b}}{1-v}} \times d^{-1/2}$</p>
<p>该公式看起来非常合理简洁，-1/2次方的关系也出来了。但是如果材料的屈服依靠的是位错像裂纹一般冲破晶界，我们应该在实验中大量发现，但实际上，只有少数几篇文献报导过相关现象。更重要的是，依据该理论计算的屈服强度跟实际数据还是有较大出入。</p>
<p>在pile up模型的基础上，Cotrell（文献2）认为，材料的屈服并非来自于位错林冲破晶界，而是由于位错林在晶界的终端的应力场诱发了邻近晶粒中的位错源(如下图的R处)的开动。这样子需要的 临界应力要小于pile-up模型。<br><img src="/2019/10/13/S04/share04/share047.png" alt=""><br>晶粒内部出现位错源固然可行，但是另一方面，晶界本身就是天生的位错源，在晶粒内部没有经受剧烈变形的情况下，晶界上的位错形核位置要远远多于晶粒内部。Li （文献3）于1963年提出了boundary source（晶界位错源）模型。为了方便起见，我们不妨假设晶粒是边长为d的立方体。假设晶粒的每一个面上的台阶密度为m，假设每一个台阶都有一定几率发射位错。进一步简化，我们不妨认为每个台阶都会发射位错，则一个面的总位错数目为$md^2$。每一个晶粒与毗邻晶粒公用一个晶面，则一个晶粒可以认为有三个晶界面属于这个晶粒。所以:<br><img src="/2019/10/13/S04/share04/share048.png" alt=""><br>我们可以认为一个晶粒有3$md^2$个位错。这些位错在外加应力作用下继续向晶内扩散，形成位错林。位错林的密度为:<br>$\rho = 3md^2 / d^3 = 3m/d$<br>另一方面，晶体材料的位错密度和强度之间可以由著名的Taylor公式来描述:<br>$\sigma = \sigma_0 + M\alpha\mu{b}\surd\rho$<br>代入前者即得:</p>
<p>$\sigma = \sigma_0 + M\alpha\mu{b}3^{1/2}m^{1/2}d^{-1/2}$ </p>
<p>我们再一次获得了Hall Petch关系。在原文中也有说明这个方式计算的理论屈服强度与pile up模型基本一致。目前介绍的这两个模型，前者认为位错完全起源于晶粒内部，后者则认为位错完全起源于晶界，两者分别是实际情况下的两个极端。但是殊途同归，两个极端最后得到了相同的结论和近似的屈服强度。不过，这两个模型的局限性也是明显的，实验中Hall Petch曲线的斜率对晶粒结构和化学成分非常敏感，但是上述模型中并未考虑这些实际因素。</p>
<p>值得注意的是，在2002年的一篇文章4中，该文作者成功在MD模拟中发现了晶界处位错的形核和发射过程。</p>
<p><img src="/2019/10/13/S04/share04/share0412.png" alt=""></p>
<p>（未完待续）</p>
<p>1 Hall, E. O. The deformation and ageing of mild steel: III discussion of results. Proceedings of the Physical Society. Section B 64.9 (1951): 747.<br>2  A.H. Cottrell,: The Mechanical Properties of Matter, Wiley, New York (1964)<br>3 Li, James CM. Petch relation and grain boundary sources. Transactions of the Metallurgical Society of AIME 227.1 (1963): 239.<br>4 Van Swygenhoven, H., P. M. Derlet, and A. Hasnaoui. Atomic mechanism for dislocation emission from nanosized grain boundaries. Physical Review B 66.2 (2002): 024101.<br>本文经ponychen授权发布，版权属于ponychen。</p>
]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>Hall Petch</tag>
        <tag>ponychen</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Hall Petch关系(二)</title>
    <url>/2019/10/14/S05/</url>
    <content><![CDATA[<p>在上文中，我们介绍了用于解释Hall Petch关系的位错阻塞模型和晶界位错源模型。两种理论都是较为早期出现的模型，原理上相对简单，因此文章中仔细介绍了相对应的推导过程。本文将继续介绍剩下的相关模型，由于推理过程相对复杂，读者如果对具体推导过程有兴趣可以阅读对应参考文献。</p>
<p>上文介绍的两种模型都未在公式中直接体现材料变形中塑性应变对Hall Petch系数的影响。因此，位错阻塞模型和晶界位错源模型仅仅只能描述多晶材料在屈服极限之下的情况。我们知道，当多晶材料所受应变超过其屈服极限，材料由于位错的交截和阻碍出现了加工硬化。加工硬化势必会影响Hall Petch系数的数值。在Meakin和Petch（文献1）提出的work haraening（加工硬化）模型中，Hall Petch系数被看成是一个与应变有关的因变量。</p>
<p><img src="/2019/10/14/S05/share05/share051.png" alt=""></p>
<p>由于Hall Petch系数中包含了应变，该模型同时成功预测了材料中的加工硬化行为。如果我们将晶粒尺寸d固定，可以发现该模型描述了一种应力与应变成抛物线形状的加工硬化关系，这与很多实验是相符合的。</p>
<p>目前为止介绍的所有模型都默认认为位错来自于位错源的开动。然而实际上，当晶体被弯曲，或者在晶粒之间的交叠以及孔洞处，由于非均匀变形，晶体为了降低变形带来的巨大应力，会自发形成一些几何必须位错来释放应力。下图展示:</p>
<p><img src="/2019/10/14/S05/share05/share052.png" alt=""></p>
<p>当晶体被弯曲时，晶体中自发在易滑移面上出现的几何必须位错林。在Ashby（文献2）等提出的几何必须位错模型中，作者认为晶界作为晶体中的应力协调区，其上的位错类型主要为几何必须位错主导，并且晶体中绝大部分的几何必须位错都位于晶界上，因此材料的强度由晶界上的几何必须位错密度决定。而平衡位错密度又由晶粒尺寸决定，通过结合加工硬化模型，作者获得了如下的Hall Petch关系式。</p>
<p><img src="/2019/10/14/S05/share05/share053.png" alt=""></p>
<p>位错阻塞模型将材料的强度归功于晶粒内部位错源开动的位错受阻，而目前介绍的其他模型则都将材料的强度归功于晶界处的位错密度受阻。在这两种极端情况的基础上，Meyersm（文献3）等人认为（复合模型），一个多晶材料应该被分为两部分：连续的拥有较高流变强度的晶界部分以及被晶界包围的离散的拥有较低流变强度的块体部分（见下图4，t为晶界厚度）。</p>
<p><img src="/2019/10/14/S05/share05/share054.png" alt=""></p>
<p>当材料承受外力时，晶界部分首先发生变形，形成大量几何必须位错；随着进一步变形，晶界首先发生局部屈服形成加工硬化层，并形核大量位错向晶粒内运动；最后，随着晶粒内位错密度的上升，晶粒部分发生屈服。至此，材料整体完成了整个塑性变形过程。基于这一过程假设，作者得出了如下关系。</p>
<p><img src="/2019/10/14/S05/share05/share055.png" alt=""></p>
<p>可以发现，该关系式并非符合正常的Hall Petch关系，式子中同时出现了一次方和二次方项。作者进一步假设随着晶粒尺寸的增大，其容纳几何必须位错的数量也在上升，因此其厚度t也在上升。基于这一假设，作者得到了下图的强度与晶粒尺寸的关系。</p>
<p><img src="/2019/10/14/S05/share05/share056.png" alt=""></p>
<p>可以发现，复合模型在晶粒尺寸较大的时候可以较好的匹配Hall Petch关系，而当晶粒尺寸小到纳米级的时候，复合模型成功预测了超细晶材料的强度反常降低现象的存在。这是之前所有的理论模型都无法给出的结果。</p>
<p>实际上，在复合模型之后材料学家依旧提出了大量的理论模型，其目的也不仅仅是在于解释Hall Petch关系。由于篇幅所限，本文仅仅介绍了一些具有代表性的模型。实际上，从实验的角度来说，很多材料也并非严格遵循Hall Petch关系中-1/2指数，该指数存在一个很大的范围。对于我们来说，-1/2只是代表材料强度与晶粒尺寸联系的一个优美符号。</p>
<ol>
<li>Meakin, J., and N. J. Petch. “Report ASD-TDR-63-324.” <em>Symposium on the Role of Substructure in the Mechanical Behavior of Metals,(ASD-7DR-63-324, Orlando, 1963) pp</em>. 1963.</li>
<li>Ashby, M. F. “The deformation of plastically non-homogeneous materials.” <em>The Philosophical Magazine: A Journal of Theoretical Experimental and Applied Physics</em>21.170 (1970): 399-424.</li>
<li>Meyersm, Marc A., and E. Ashworth. “A model for the effect of grain size on the yield stress of metals.” <em>Philosophical Magazine A</em> 46.5 (1982): 737-759.</li>
<li>Kato, Masaharu. “Hall–Petch relationship and dislocation model for deformation of ultrafine-grained and nanocrystalline metals.” <em>Materials Transactions</em> 55.1 (2014): 19-24.</li>
</ol>
<p>本文经ponychen授权发布，版权属于ponychen。</p>
]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>Hall Petch</tag>
        <tag>ponychen</tag>
      </tags>
  </entry>
  <entry>
    <title>高阶弹性常数计算的一点建议</title>
    <url>/2019/10/15/S06/</url>
    <content><![CDATA[<p>在线弹性理论中，体系被施加一个无穷小的应变，从而体系应变后的能量可以以小应变为自变量泰勒展开，并忽略二阶导以上的高阶项。通过对不同特定的独立的应变模式求解能量应变方程或者应力应变方程，我们可以获得材料所有的二阶弹性常数（SOECs）。SOECs反映了体系的简谐弹性特征。通过SOECs，一方面我们可以获得体系的基于Vogit-Reuss-Hill平均的多晶力学性能，包括杨氏模量，剪切模量，体积模量，泊松比和维氏硬度等，以及在此基础之上的各向异性系数等等特征；另一方面，我们也可以通过SOECs获得单晶力学性能在空间中的具体分布，并将其用图的模式直观的表示出来。</p>
<p><img src="/2019/10/15/S06/share06/share061.png" alt=""></p>
<p>图中我们展示了某种金属的杨氏模量和剪切模量（每个面的平均值）的空间分布图，感兴趣的读者可以猜猜这是哪种布拉维晶型的金属。</p>
<p>在实际负载下，材料承受的往往是有限形变，这时候材料的非简谐弹性将称为不可忽视的因素。很多实验数据有去测量体系的三阶弹性常数（TOECs），甚至四阶弹性常数（FOECs）。注意到TOECs和FOECs相对比SOECs在实验中更加受到实验精度的影响，具体的测量非常困难。如果我们能在理论上对其进行预测，将变得非常有意义。实际上已经有若干文献进行了相关研究，笔者也抱着好奇的态度尝试进行了TOECs和FOECs的计算。原理上来说相对简单，我们只需要将能量对应变进行泰勒展开，将阶次保留到四次，即可同时获得SOECs，TOECs和FOECs。</p>
<p><img src="/2019/10/15/S06/share06/share062.png" alt=""></p>
<p>将所有的应变η设为同一个数值，我们就可以用一个包含四次，三次和二次项的多项式来拟合计算的数据，获得包含各个弹性常数的多元一次方程组。求解这个这个方程组即可获得所有的弹性常数。</p>
<p>不过实际操作起来并没有这么简单。即使是最简单的立方体系，其TOECs也达到了6个，而FOECs更是达到了11个。对于更低对称性的体系，其计算量更是一个天文数字（开玩笑的，天文倒不至于，很大就是了）。一种避让的方法就是，我们可以用应力对应变进行展开，这样相对需要的独立应变数少一些。笔者使用Au作为测试体系，根据文献对体系施加了11种独立应变，如下图。</p>
<p><img src="/2019/10/15/S06/share06/share063.png" alt=""></p>
<p>感兴趣的童鞋可以直接阅读文末给的参考文献。笔者通过测试发现，首先，体系的应变量必须足够大。笔者一开始犯上了计算SOECs的习惯，使用的很小的应变，计算结果简直南辕北辙。后来将应变加到15%后，获得的TOECs相对理想。细想也是，应变很小时，体系还处于线弹性阶段，这时候的非谐弹性非常微弱，极容易被数值误差干扰。将应变加大到非谐区后，数值就非常稳定了。同时，尽管我们使用了大应变条件，但是实际上高阶弹性常数的具体数值依旧会对数值精度的波动非常敏感。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Au/GPa</th>
<th>C111</th>
<th>C112</th>
<th>C123</th>
<th>C144</th>
<th>C155</th>
<th>C456</th>
</tr>
</thead>
<tbody>
<tr>
<td>exp</td>
<td>-1730</td>
<td>-922</td>
<td>-233</td>
<td>-13</td>
<td>-648</td>
<td>-12</td>
</tr>
<tr>
<td>mine</td>
<td>-1207</td>
<td>-847</td>
<td>-275</td>
<td>7</td>
<td>-616</td>
<td>62</td>
</tr>
</tbody>
</table>
</div>
<p>同文献一样，笔者使用了非常高精度的k点半径和截断能。随着精度的提高，结果趋于较好的收敛。笔者在此展示了笔者自己算的TOECs与实验的比较，两者相对来说还是比较接近的（相对实验的误差与文献差不多）。总的来说，如果有小伙伴需要计算材料的TOECs或者FOECs，笔者建议一定要对应变，k点，截断能三者都要做仔细地收敛测试。</p>
<p>Wang,Hao, and Mo Li. “Ab initio calculations of second-, third-, andfourth-order elastic constants for single crystals.” <em>PhysicalReview B</em> 79.22 (2009): 224102.</p>
<p>本文经ponychen授权发布，版权属于ponychen。</p>
]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>ponychen</tag>
        <tag>弹性常数</tag>
      </tags>
  </entry>
  <entry>
    <title>Ipad 连接服务器APP</title>
    <url>/2021/12/26/S07/</url>
    <content><![CDATA[<p>在ipad，手机上运行终端，连接服务器可以让我们随时随地查看，提交任务。在这里推荐一款ipad和iphone上的终端APP: SSHaking。如果你用的安卓系统，一些推荐的APP可以直接到文章底部去找。<br>先依照个人使用的经验，列出来以下SSHaking的优点：</p>
<p>1） 界面简洁，没广告；</p>
<p>2） 可以同时打开好几个terminal界面；</p>
<p>3）连接服务器设置也很简单；</p>
<p>4） 支持连接多个Hosts； （平时常用的terminus只支持一个，连多个的话要花钱，服务器如果只有一个，也推荐terminus）</p>
<p>5） 免费！！！！</p>
<p>6）APP的开发者很牛，可能也很帅！</p>
<p>7）希望大家多多下载这款APP，有什么bug及时给作者提出来，而且作者看到后修复的也很及时。</p>
<p>如果你用的是安卓系统，可以有以下几个选择：</p>
<p>1） juiceSSH (轻和浅吟🐳)<br>2） Admin hands (HeyTamas)</p>
<p>括号里是提供APP名字的好心人。如果你也有推荐的其他好用的APP(免费的)，可以在微信公众号留言。</p>
<p> <img src="/2021/12/26/S07/F00/QR_code.jpeg" alt=""></p>
<p><a href="https://mp.weixin.qq.com/s/jvghzIlV6NOsNFjUa445xQ">https://mp.weixin.qq.com/s/jvghzIlV6NOsNFjUa445xQ</a></p>
]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>Ipad</tag>
        <tag>SSHaking</tag>
        <tag>Terminal</tag>
        <tag>神器</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex00 为什么是&quot;The Hard Way&quot;</title>
    <url>/2022/07/18/ex00/</url>
    <content><![CDATA[<h6 id="在学习本书时，大师兄们会默认读者掌握了一些基本的电脑操作技能，以及化学的基本常识（结构化学，物理化学等）。本章列举出一些常用的计算工具和软件，以及假设大家掌握的一些技能。如果没有达到基本的要求，那么请在学习前面几章的同时，抓紧提升自己的能力。-化学的基本知识如果没有掌握，不建议学习本书。"><a href="#在学习本书时，大师兄们会默认读者掌握了一些基本的电脑操作技能，以及化学的基本常识（结构化学，物理化学等）。本章列举出一些常用的计算工具和软件，以及假设大家掌握的一些技能。如果没有达到基本的要求，那么请在学习前面几章的同时，抓紧提升自己的能力。-化学的基本知识如果没有掌握，不建议学习本书。" class="headerlink" title="在学习本书时，大师兄们会默认读者掌握了一些基本的电脑操作技能，以及化学的基本常识（结构化学，物理化学等）。本章列举出一些常用的计算工具和软件，以及假设大家掌握的一些技能。如果没有达到基本的要求，那么请在学习前面几章的同时，抓紧提升自己的能力。 化学的基本知识如果没有掌握，不建议学习本书。"></a>在学习本书时，大师兄们会默认读者掌握了一些基本的电脑操作技能，以及化学的基本常识（结构化学，物理化学等）。本章列举出一些常用的计算工具和软件，以及假设大家掌握的一些技能。如果没有达到基本的要求，那么请在学习前面几章的同时，抓紧提升自己的能力。 化学的基本知识如果没有掌握，不建议学习本书。</h6><h2 id="1-心态"><a href="#1-心态" class="headerlink" title="1 心态"></a>1 心态</h2><h3 id="主动行动、思考"><a href="#主动行动、思考" class="headerlink" title="主动行动、思考"></a>主动行动、思考</h3><p>学习过程中要时刻抱着<strong>主动</strong>的心态去解决问题。</p>
<ul>
<li>遇到不会的问题,<strong>主动</strong>去查找解决方法;</li>
<li>遇到不懂的基础知识,<strong>主动</strong>去找教科书;</li>
<li>遇到什么好的资源,书籍,课件等,<strong>主动</strong>去网上搜索,下载;</li>
<li>本书中的练习，看到别人有意思的计算，<strong>主动</strong>去重复重复。</li>
<li>没事就<strong>主动</strong>去官网溜达,</li>
<li>VASP计算出错，<strong>主动</strong>去google或者官网的论坛找答案!</li>
</ul>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h4><ul>
<li>上面说的<strong>主动</strong>是对于你自己来说的，别碰到不会的就主动求助别人，这样你很难得到提升。</li>
<li>去google搜索遇到的问题，也就意味着你要学会科学上网。</li>
<li>如果遇到热心帮你解决问题的人，好好准备你的问题，千万不要一个劲的追问，因为这样显得你不动脑子，非常惹人烦。</li>
</ul>
<h2 id="2-操作系统"><a href="#2-操作系统" class="headerlink" title="2  操作系统"></a>2  <strong>操作系统</strong></h2><p>做计算，有三个操作系统可以选择：</p>
<ul>
<li><p>Windows 系统：会使用Windows系统:会开机，打字，安装软件;</p>
</li>
<li><p>Linux 系统，强烈推荐，大师兄本人一直用的是Ubuntu，但不局限于Ubuntu系统，自己喜欢什么就用什么。</p>
</li>
<li><p>Mac系统，兼顾Windows和Linux，一般比较贵，经济条件允许，也可以。</p>
</li>
</ul>
<h5 id="给重点照顾对象：Windows用户的第一个提醒："><a href="#给重点照顾对象：Windows用户的第一个提醒：" class="headerlink" title="给重点照顾对象：Windows用户的第一个提醒："></a>给重点照顾对象：Windows用户的第一个提醒：</h5><p>Windows用户在进行计算的时候，只要计算出错了，就要本能地记起第一个解决的办法： dos2unix 。 这个命令干什么的不要紧，先死死记住即可。</p>
<h2 id="3-文本编辑工具"><a href="#3-文本编辑工具" class="headerlink" title="3 文本编辑工具"></a>3 <strong>文本编辑工具</strong></h2><p>文本编辑工具主要用来编辑，查看VASP的输入（出）文件，要求会打开文件，打字，保存文件。</p>
<h3 id="1）vim"><a href="#1）vim" class="headerlink" title="1）vim"></a>1）<a href="https://www.vim.org/">vim</a></h3><p>这个<strong>必须要学会</strong>，linux下面自带。原因是绝大多数的计算都是在linux下面进行的，学会vim的基本操作可以极大提高你的文字处理能力和工作效率。关于VIM的使用介绍，自己百度下或者搜一搜相关的视频，学习下。</p>
<h3 id="2-notepad"><a href="#2-notepad" class="headerlink" title="2) notepad++"></a>2) <a href="https://notepad-plus-plus.org/">notepad++</a></h3><ul>
<li>这个是对于Windows用户来说的，要求会创建文件，输入内容并保存文件，<strong>这个软件或者类似的必须学会使用!</strong></li>
</ul>
<p>原因在于：Windows下面自带的记事本保存的文件与linux下的文件格式不匹配，提交任务的时候经常出问题，用notepad++则不会出现这个问题。</p>
<p><strong>因此</strong>，Windows的记事本杜绝使用。为了安全，即使用了notepad++，Windows用户在进行计算的时候，也需要注意下面两点：</p>
<ul>
<li><p>Windows下面编辑的输入文件，如果想在linux服务器上运行，最好先执行: dos2unix 这个命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dos2unix  INCAR</span><br></pre></td></tr></table></figure>
</li>
<li><p>Windows用户计算出错了，一定要首先想到 dos2linux 这个命令来解决问题!!!</p>
</li>
</ul>
<h3 id="3）-Atom"><a href="#3）-Atom" class="headerlink" title="3） Atom"></a>3） <a href="https://atom.io/">Atom</a></h3><p>这个Atom是文本编辑工具，不是原子的意思。Windows，Linux，Mac系统均可使用。</p>
<h2 id="4-常用建模相关软件"><a href="#4-常用建模相关软件" class="headerlink" title="4 常用建模相关软件:"></a>4 <strong>常用建模相关软件:</strong></h2><p>本书默认大家已经在自己的电脑里安装了下面三个软件：</p>
<h3 id="1-Material-Studio"><a href="#1-Material-Studio" class="headerlink" title="1) Material Studio"></a><strong>1) Material Studio</strong></h3><ul>
<li>这个软件，百度里面一大堆下载链接，安装教程，大家自行下载安装即可。</li>
<li>本书默认大家已经安装成功，会不会使用暂且不要求；</li>
<li>不要问我从哪里下载，安装出现问题也不要找我解决。</li>
</ul>
<h3 id="2）-VESTA"><a href="#2）-VESTA" class="headerlink" title="2）**VESTA**"></a>2）**<a href="http://jp-minerals.org/vesta/en/">VESTA</a>**</h3><p>来自日本的良心软件，Linux，Windows，Mac系统均可使用。链接：<a href="http://jp-minerals.org/vesta/en/">http://jp-minerals.org/vesta/en/</a></p>
<ul>
<li><p>Windows下面安装就不再介绍了，下载程序，解压，双击图标即可运行，相信大家都能搞定。</p>
</li>
<li><p>Linux下安装: </p>
<ul>
<li><p>下载binary程序文件，本人解压后放到了&#x2F;opt&#x2F;VESTA-x86_64目录</p>
</li>
<li><p>编辑 ~&#x2F;.bashrc 文件，在文件最后，添加下面2行。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export VESTA=/opt/VESTA-x86_64 </span><br><span class="line">export PATH=&quot;$PATH:$VESTA&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>在终端里面进行的操作如下：第一行打开<del>&#x2F;.bashrc文件, 自己添加上面提到的两行即可，第二行更新下</del>&#x2F;bashrc文件，第三行运行VESTA。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ vim ~/.bashrc</span><br><span class="line">$ . ~/.bashrc</span><br><span class="line">$ VESTA</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3）p4vasp"><a href="#3）p4vasp" class="headerlink" title="3）p4vasp"></a>3）<a href="http://www.p4vasp.at/"><strong>p4vasp</strong></a></h3><ul>
<li>链接：<a href="http://www.p4vasp.at/">http://www.p4vasp.at/</a></li>
</ul>
<ul>
<li><p>Windows版本，好像很久没有更新了，点击此处下载，解压,双击图标即可运行。也可以在大师兄QQ群或者其他QQ群文件中下载。</p>
</li>
<li><p>Linux版本功能更加强大。可以</p>
<p>Ubuntu（18以及更老的版本）用户使用命令一键安装： <strong>sudo apt-get install p4vasp</strong></p>
<p>Ubuntu 20以及后续的安装有些麻烦。p4vasp已经不更新了，很多功能可以用其他的软件替代。如果坚持使用p4vasp，可以联系大师兄付费安装（50块钱）。</p>
</li>
</ul>
<h3 id="4）-ASE"><a href="#4）-ASE" class="headerlink" title="4） ASE"></a>4） <a href="https://wiki.fysik.dtu.dk/ase/index.html">ASE</a></h3><p>ASE 是Atomic Simulation Environment的缩写，可以实现搭建结构，读取VASP的输入和输出，以及一些后处理功能。如果p4vasp没办法安装，那么ASE必须要安装在你的电脑上。</p>
<h3 id="5）其他软件"><a href="#5）其他软件" class="headerlink" title="5）其他软件"></a>5）其他软件</h3><p>这里说的软件主要是针对VASP计算的模型搭建这一方面，有兴趣的也可以试试<a href="https://avogadro.cc/">Avogadro</a>. 值得一提的是，我们自己的国产建模软件那是相当得少，更别提计算软件了。而我们比较擅长的是写教程和后处理，然后发公众号割韭菜。</p>
<h2 id="5-服务器相关"><a href="#5-服务器相关" class="headerlink" title="5 服务器相关"></a>5 服务器相关</h2><p>VASP的计算就跟开车一样，设计到很多的内容，比如大街上的路怎么铺的？桥怎么建的？发动机怎么工作的？方向盘怎么工作的，刹车片什么材料做的？车身颜色怎么喷的？ 没有人会懂所有相关的知识。但是怎么打开车门，坐车里，启动发动机，踩油门，打方向盘，这是本教程所关心的，也就是类似驾校教练指导你学会如何开车，而不是关系如何去造车，去铺路。这里的车就是VASP。其他相关的不做详细介绍。</p>
<h3 id="1-知道怎么连接自己组内或者租赁的服务器"><a href="#1-知道怎么连接自己组内或者租赁的服务器" class="headerlink" title="1) 知道怎么连接自己组内或者租赁的服务器;"></a>1) 知道怎么连接自己组内或者租赁的服务器;</h3><h3 id="2-初步学习使用基本的linux命令"><a href="#2-初步学习使用基本的linux命令" class="headerlink" title="2) 初步学习使用基本的linux命令:"></a>2) 初步学习使用基本的linux命令:</h3><ul>
<li><p>进入目录 : cd </p>
</li>
<li><p>移动文件(夹): mv </p>
</li>
<li><p>复制文件: cp </p>
</li>
<li><p>复制文件夹用: cp -r ; 注意 cp 和 -r 之间有个或者N个空格</p>
</li>
<li><p>创建文件夹:mkdir     </p>
</li>
<li><p>删除文件: rm ;    </p>
</li>
<li><p>删除文件夹: rm  -r    </p>
</li>
<li><p>强制删除文件夹: rm -fr  或者 rm -rf  (f 和 r 的顺序可以颠倒 )        </p>
</li>
<li><p>显示目录下文件: ls 等命令;   </p>
</li>
<li><p>这里大师兄就不再啰嗦了，后面教程里会介绍一些命令的使用，老司机们自动略过，新手自行百度：linux 命令，你会得到铺天盖地的信息。</p>
</li>
</ul>
<h3 id="3-手上有可以正常运行的VASP程序"><a href="#3-手上有可以正常运行的VASP程序" class="headerlink" title="3) 手上有可以正常运行的VASP程序"></a>3) 手上有可以正常运行的VASP程序</h3><ul>
<li><p>组里面已经安装好vasp程序，或者使用超算中心的VASP程序，只要手上有可以正常运行的VASP即可。因为我们在本书里，<strong>不讨论</strong>：</p>
<ul>
<li>去哪里下载VASP? 怎么安装VASP? 去哪里下载VASP的pseudo potentials?</li>
</ul>
<ul>
<li>前面的问题可以在QQ群里面讨论，也可以付费求助别人解决。</li>
<li>对于VASP的pseudo potentials，也就是POTCAR。<ul>
<li>你老板买了VASP的版权，就直接问他要。</li>
<li>用的盗版VASP，找其他人要一份，但是发文章的时候会很麻烦。国内很多人都是找有版权的老师挂名，其实这是非常学术不道德的事情。一方面涉及到版权，一方面涉及到瞎几把挂名。</li>
<li>免费的可以用QE，CP2K，GPAW等开源的软件，没必要非得在VASP上面死磕。</li>
</ul>
</li>
</ul>
</li>
<li><p>知道怎么提交VASP任务？</p>
<ul>
<li>自己组里都有提交任务的脚本，如果没有的话,</li>
<li><ul>
<li><ol>
<li>找组里的师兄师姐帮忙;</li>
</ol>
</li>
</ul>
<ol>
<li>第一个啃螃蟹的人，找老师解决，求助服务器商，求助超算管理员；</li>
<li>自行动手解决。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="6-程序语言学习"><a href="#6-程序语言学习" class="headerlink" title="6 程序语言学习"></a>6 <strong>程序语言学习</strong></h2><p>建议大家学习两个语言: bash 和 python。主要是为了辅助计算，节省时间，并拓展自己的思维方式。</p>
<ul>
<li>bash语言：日常terminal里面常用的基本命令，比如cd，ls这些，以及结合基本的逻辑语法，可以让你写出一些简单的小脚本，提高自己的工作效率；</li>
<li>Python 语言：python是一款语法简单，很容易上手的程序，有着丰富的数据库支持，目前深受科研人员的喜爱。<strong>注意</strong>，这里我们不讨论类似：python是一门高级语言，运行的时候跟机器交互性差，需要时间比C++长这样的问题。因为这是专业程序员的事。不出意外，看这本书的大部分人，能够用python写个小脚本，方便地处理自己的任务和数据，就已经非常棒了，快和慢，对于我们来说，顶死了也就几秒的问题，完全可以接受。</li>
<li>学习程序语言，一方面可以极大地提高自己的工作效率，另一方面也可以改变自己看待事物的思维方式。  </li>
<li>如果不喜欢Python，当然也可以学习其他的程序语言，C++，R等。</li>
</ul>
<h2 id="7-吐槽"><a href="#7-吐槽" class="headerlink" title="7 吐槽"></a>7 吐槽</h2><p>速成思想，快餐文化害死人，图快的读者中，就有很多来自做实验的。现在大家普遍认为：实验+计算很好发文章。两者结合可以更深入地理解你的研究体系，发现并解决科研中有价值的科学问题。但很多老师却感觉计算就是动动鼠标，操作个软件的活，是个人就能做计算似的。在这种错误的理解，对计算难度过分低估，在高IF文章的诱惑下，安（suan）排（ji）自己的学生去搞计算。写到这里，很多脏话硬生生从嗓子眼憋回去了。骂是解决不了问题的。那么我们就理一理，一个实验的课题组，在没有任何计算背景的条件下，安（Po）排（Hai）一个学生做计算所遇到的问题吧：</p>
<ul>
<li><p>计算软件的选择：大千世界无奇不有，计算的软件也是多得数不过来，每个软件都有自己适用的体系，哪个更适合你的体系，你不会选择；</p>
</li>
<li><p>软件的购买：比如你决定了使用VASP，你需要找代理商购买软件（有些还很贵，舍不得买，用盗版的，发文章的时候还担心版权问题）；</p>
</li>
<li><p>服务器的购买：买了软件我们要安装啊。你可能说，这个容易，直接买几台电脑装上就可以了。这里的问题在于：用台电脑就可以算，就可以发文章的时代造就过去了，你可能被淘汰十几年了。所以，</p>
<ul>
<li>要买服务器，但服务器价格不菲，怎么选你也不知道；</li>
<li>不买服务器，可以买超算中心的机时啊。好吧，就当这一关也过了。</li>
</ul>
</li>
<li><p>软件安装：这也是个麻烦事。计算软件不是QQ，也不是360安全卫士，不是你下载个exe文件双击选择d盘就可以傻瓜式安装成功的。各种环境变量，依赖的库都是需要自己安装的。要不然那么多培训班上来就先给大家介绍软件是怎么安装的呢。</p>
</li>
<li><p>熟悉Linux系统：计算软件大部分都是在Linux系统下安装的，所以Linux系统的一些常用命令操作你得学会；而Linux的桌面之所以不如Windows，用户习惯是个难以突破的瓶颈，在没人陪伴的情况下，自己熟练Linux系统也是非常不易；</p>
</li>
<li><p>软件学习：这也是本书的重点，纯做计算的菜鸟，每天屁活都不干，就看本书，Linux系统下操练，有人指导的情况下差不多2个月能入门。对号入座，你一个做实验的，每天捣鼓设备，转转反应，就快累的嗝屁了，恨不得回到家或者宿舍就躺着歇会，还要跟朋友出去嗨，陪对象逛，当然还要玩把王者农药。真的能抽出时间来认真学习么？</p>
</li>
<li><p>有些体系对软件参数依赖性很强，没人指导，你不会设置，软件出错不会解决，计算结果不会分析，算对算错都不知道，迷迷糊糊就这样得到了一些结果。</p>
</li>
<li><p>计算的目的，肯定要跟实验对比啊？怎么对比，从哪方面下手，又没头绪，很多时候都是硬凑，结论反了也傻呵呵地跟别人说实验和理论吻合地很好，可以冲个大文章。</p>
</li>
<li><p>折腾完了，要投文章了。因为计算太烂，XJB乱扯结论而被直接拒掉的又有一批；</p>
</li>
<li><p>好不容易送审了， 最好去烧烧香，祈求不要落到做计算的人手里。真落到计算的人手里，算的太烂，也是很有可能因此丧命或者大修。</p>
</li>
<li><p>就当你运气好，大修了。审稿人抛出来的专业计算问题你可能又答不上来，怎么补数据都无从下手。</p>
</li>
<li><p>让你再幸运一把，补上数据，文章接受了。</p>
</li>
<li><p>那下一篇还这样弄么？ 可以，但经过上面的折腾，小硕士估计要毕业了，小博士也要滚蛋了。又得找下一个垫背的，也就是因为这样，上一批的不知对和错的经验就传授给了下一代。</p>
</li>
<li><p>总结：一个做实验的老师，不把自己在实验方面的专长传授给自己的学生，硬让人家自己去琢磨你什么都不懂的领域，最后造就了一个四不像的怪物出来，何为师道？</p>
</li>
</ul>
<p>这种情况到底怎么办？ 很多人在的课题组都是做实验的，老板头脑发热的时候，就安排做起了计算。但老板除了一颗乐观的心，屁都不懂啊。这时候的你，除非脑子很好用，否则就会陷入一种叫天天不应，叫地地不灵的境界。在这里,大师兄建议你：</p>
<ul>
<li>说服老板，找个计算靠谱的组，合作一下，避免自己直接算，自己专心做实验，计算可以跟国内相关领域的老师合作一下，各取所长。</li>
<li>说服不了，找个计算靠谱的组，让老板派你去交流学习一段时间，别自己在那里瞎捣鼓。</li>
<li>认真学习本书，看VASP的手册，以及各种网站上的教程，先摸索一阵子再算老板给你的体系。</li>
<li>总之，时间和精力的成本，自己心里要有个数。</li>
</ul>
<p>在这里还要吐槽2点：</p>
<ul>
<li>有些做实验的跟计算合作，挂名的时候把计算放到不起眼位置的人，随意挪动计算作者的顺序，甚至是放到了通讯位置上，但没加*。生活不易，给做计算的留条活口，也给自己留个好名声。</li>
<li>有些跟实验合作的计算工作者，随随便便优化个结构，做个漂亮的图就完事。只做锦上添花工作，而不深入研究课题机理。做计算的日子本来就难，请不要因为自己的不专业坏了计算的名声。</li>
<li>如果想合作，就双方正儿八经地合作，真正意义的合作至少是通过计算解决了课题中的难点，机理，有助于组里课题的下一步进行，更高级点是实验验证了计算的假设，不过能做到这种程度的也没多少课题组。而对于这种良性的合作，实验和计算都给挂个一作，双方老板都挂个通讯，也无可厚非。</li>
<li>不想合作，非让自己的学生做计算。这种情况就不要怕花钱，派学生到做计算的课题组学习上一两个月，然后再回来继续搞。如果有需要，也可以派出去参加参加一些高质量的培训班，暑期学校等，来弥补自己在学生指导方面的不足。</li>
</ul>
<p>虽然书名叫The hard Way，这本书还是给了很多人一种DFT极品快餐的感觉；更会越来越”毁了”专业做计算的，让各种做实验的做计算的扰乱市场。虽然有这种负面的作用，但我还是想尽自己可能，稍微提高我们做计算的平均水平。因此，<strong>认真声明一下</strong>：本教程的初衷是给专门做计算菜鸟准备的。对于那些以为靠本书就可以快速入门的筒子们（不管是做计算还是做实验的），劝你们还是趁早放弃本书的学习，科研的路上，从来就没有速成二字。</p>
<h2 id="8-计算-x3D-转行？"><a href="#8-计算-x3D-转行？" class="headerlink" title="8 计算 &#x3D; 转行？"></a>8 计算 &#x3D; 转行？</h2><ul>
<li>很多人吐槽计算化学是个坑告诉你，既然选择了这条路，就准备改行吧。请避开这些负能量的说法，拿出自己的主见。无论放弃或者坚持，都要拿出你自己的判断力出来，请不要再听别人在你耳边瞎磨。也就是我的人生我做主。</li>
<li>每一行的人都会说自己这一行是个坑，不管你怎么跳，都是坑。引用我老婆的原话：之前带两个孩子的时候，感觉自己每天都很累，现在孩子父母帮忙看着，自己工作了，但每天还是很累。美好的生活，累总是一路同行。</li>
<li>个人的理解是，学习理论计算可以使你的视野更加开阔，思维方式更加灵活，对事物本质的把握和理解上，比别人要更胜一筹。也就是一眼就能找到问题的关键所在。不论是否继续相关的研究，转行与否，对今后的发展总会有所帮助。当然，我这个穷酸书生说的话，大家也可以一笑了之。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a><strong>总结:</strong></h2><ul>
<li><p>初学者学习本书,所必须具有的技能:</p>
</li>
<li><ul>
<li>熟练使用一个操作系统；</li>
<li>会编辑文本，写入和保存文件；</li>
<li><ul>
<li><strong>Windows 用户Notepad++必须掌握</strong>,</li>
<li>linux用户可以vim或者其他编辑器，比如Atom</li>
</ul>
</li>
<li>安装好或者会初步使用一款建模软件。-<ul>
<li>**p4vasp **安装在Windows和Ubuntu系统上；</li>
<li><strong>VESTA</strong> 安装在Windows，Ubuntu，Mac系统上；</li>
<li><strong>Materials Studio</strong> 安装在Windows上。</li>
</ul>
</li>
<li>会连接服务器，使用的vasp程序并且会提交任务<ul>
<li>这个大师兄帮不了你，自行找服务器商或者其他售后人员解决。</li>
</ul>
</li>
</ul>
</li>
<li><p>所具有的心态：</p>
<ul>
<li>主动去面对遇到的问题和困难，冰冻三尺,非一日之寒，遇到问题，主动解决，日积月累就会收获良多；</li>
<li>对自己要有自信，即使自己是彻头彻底的小白,也不必要担心。相对于那些积累了很多错误经验的人来说，什么都不知道则具有更好的可塑性。</li>
<li>不要盲目相信他人，有自己的理解。如果你在网上搜索问题的答案，会找到很多人的回答，但实际熵很多人水平都可能没有你高，而你却把他们的话当成真理一般去相信，这是致命的。</li>
</ul>
</li>
<li><p>大师兄的要求：</p>
<ul>
<li><p>新手认真阅读序言里面推荐的那本参考书；</p>
</li>
<li><p>尽可能多地浏览VASP官网，对某些参数有疑惑，认真查阅手册；</p>
</li>
<li><p>最重要的是不要偷懒，遇到不会的东西或者困难，立刻记下来或者去解决，否则明天你就会忘掉；</p>
</li>
<li><p>好东西要学会分享，可以在QQ群里分享自己的心得，帮助其他正在入门的小师弟，妹们。</p>
</li>
</ul>
</li>
</ul>
<p>在BB了这么多废话之后，感觉时候再强调下本书的重点了：The Hard Way. The Hard Way 在本人的眼里，类似于书山有路勤为径，学海无涯苦作舟的感觉，类似于经过无数瞎折腾终于尝到一点点小胜利甜头的感觉，类似于苦尽甘来，柳暗花明又一村的感觉。所以：Hard Way是本书的重点，也是痛苦学习的一个过程。别人耗费精力和时间开发出来的软件，短时间就精通是不可能的事情。所以，也别指望着一口气吃成个胖子，耐住寂寞。 </p>
<p>本人学习和使用VASP已经快10年了，该教程差不多也5岁了。我进入课题组之前，不会用Ubuntu系统，也不会用脚本，也不会用python写脚本，也没用过VASP。我的VASP入门，是花了一个月看了Davide Sholl的书后，老板又手把手花了一个多月的时间学会的，学习的资料是老版本的Hand on Session系列。每天做的是系列中的练习，准备老板布置的作业，思考老板预留的问题，然后第二天听老板解释每个参数的含义，里面的关键点。而真正操作起来进入课题的时候，又有组里细心的博后专门帮忙指导答疑，也有很多人可以进行讨论学习。写这么多并不是在秀自己遇到了一个多好的老板，多好的课题组。在这样的环境中，经过了四年的学习，好几个课题的实战，才变成你们感觉很牛逼的大师兄（其实我只是经验比你们多一点点而已）。而这本书，也是本人这四年来学习到的精华，每一节都要花费差不多4个小时的样子才能完成，或者更多。而这四年的精华，岂能让你把这本书看一遍就掌握了?  到现在为止，瞎BB了76节。每节你花一天的时间去学习，加上其他参考书的学习，也需要2个月的时间。而2个月，对一个新手来说，完全在承受范围之内，<strong>请相信时间的力量</strong>。这里，我们澄清下对新手的定义：全职搞计算的菜鸟。所以，Hard Way 就是需要你花掉每一个整天的时间，一点点认真琢磨，反复操练，绝对不是什么速成。而现在我们搞科研都很浮躁，什么都喜欢图快，我们也有句古话：欲速则不达。因此，打算朝夕之内就学会VASP的读者，本书可能真的不适合你。</p>
<h2 id="致谢："><a href="#致谢：" class="headerlink" title="致谢："></a><strong>致谢：</strong></h2><p>本教程在写作的过程中，得到了很多人的支持。 有些地方可能描述不清，当然书里面也肯定避免不了错误的出现，也收到了很多人的建议和批评指正。在这里，向他们表示诚挚的谢意。很多人认为，通过这个教程，学到了很多东西，但请不要过分把功劳归在我身上。引用佛系的观点：<strong>因果，完全是自作自受</strong>。你自己学习了，自己认真练习了，水平的提高完全是你自己辛苦付出的结果。<strong>教程就在这里，你学或者不学，都跟我没有关系。</strong>私以为，收获最大的还是本人。一方面把自己多年的学习的经验整理总结出来，另一方面，很多当时一知半解的地方，在写作的过程中，通过查阅资料，认真分析得到了解决。</p>
<p>教程的宗旨在于快速带领大家入门VASP的使用，这里大师兄想起了金庸笔下的打狗棒法， 本书传授的只是招式，而心法口诀则是你扎实的科研基础功，是自己这些年（高中，大学，硕士，博士）通过坚持不懈学习来积累获得的，对次，本人确实无能为力，而这一点也恰恰是我们最欠缺的部分，希望可以引起大家的重视，在等待任务结束的时候，多多补习自己的基础知识。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
  </entry>
  <entry>
    <title>Ex01 VASP基本输入文件的准备（壹）</title>
    <url>/2017/10/14/ex01/</url>
    <content><![CDATA[<p>基本的输入文件，指的是VASP计算必不可少的输入文件，对新手来说先记住这四个文件的名字：INCAR，KPOINTS，POSCAR，POTCAR。具体是干嘛用的？不懂的话不要紧，后面我们会结合例子，慢慢介绍这几个文件的准备工作。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>准备输入文件， 脑子里要有下面几个概念:</p>
<ul>
<li><p>Rubbish in，Rubbish out!  程序只负责算，对错由你决定！错误主要有3类：</p>
<ul>
<li>模型错误：也就是建模这一块出错了，主要对应的是POSCAR；</li>
<li>计算参数：INCAR，KPOINTS，POTCAR</li>
<li>提交任务的脚本或者命令出错。</li>
</ul>
</li>
<li><p>遇到不懂的参数： (思考 + 看官网)！ (思考 + 看官网)！ (思考 + 看官网)！</p>
</li>
<li>重要的话说三遍，尽量不要去看网上那些乱七八糟的教程。如果英语不好，那么这是一个锻炼你阅读能力的好机会。通过查阅官网解决问题，可以保证你的血统纯正，进而提高你的杀伤力。</li>
<li>所有的输入文件都只是文本而已。这句话的意思是：所有的输入文件都可以通过文本编辑器打开，比如：</li>
<li><ul>
<li>Linux下面可以用Vim</li>
<li>Windows下用Notepad++</li>
<li>杜绝使用Windows自带的文本编辑器：记事本，写字板。</li>
</ul>
</li>
<li>所有的输入文本没有尾缀，Windows用户可能习惯了带各种各样尾缀的文件，但是vasp里面的输入文件，没有尾缀且都是文本。 比如你使用Notepad++这个文本编辑器写了一个输入文件，直接并保存成 INCAR就可以了。如果不小心保存成了 INCAR.txt，那么直接将尾缀.txt删除即可。</li>
<li>再次强调:对于Windows用户，本书中指的文本编辑器是:Notepad++。免费的软件，大家自己下载并安装。 请不要用写字板，记事本等编辑VASP的输入文件。如果你不听话，还是喜欢用它们，那么:<ul>
<li>出错，自己负责，有时候你会死的很惨，折腾很久可能都找不到哪里出错了；</li>
<li>出错，自己检查有没有在提交任务前运行：dos2linux 这个命令转换下格式</li>
</ul>
</li>
<li>一步一步按照本书的练习进行操作，有问题，先记下来，如果后面没有得到解答，去<strong>《序言》</strong>找联系方式咨询大师兄。</li>
</ul>
<h3 id="VASP输入和输出文件"><a href="#VASP输入和输出文件" class="headerlink" title="VASP输入和输出文件"></a>VASP输入和输出文件</h3><ul>
<li><p>有了上面的概念，我们就可以准备输入文件了。下面是官网列出VASP的输入和输出文件，in 代表输入，out代表输出。先声明一下：大家不要被下面这么多文件吓傻了，脑子里有个印象就行，很多文件可能穷奇你一生的计算都用不到，而且你以后会花很多时间在删这些乱七八糟的文件上面。对于新手的话，大家先简单过目一下即可。可以理解为，从未开过车的你，一下子钻到车里，首先要做的就是熟悉车内部的环境，具体什么功能、怎么回事，后面慢慢摸索。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INCAR      in    **</span><br><span class="line">STOPCAR    in</span><br><span class="line">stout      out</span><br><span class="line">POTCAR     in     **</span><br><span class="line">KPOINTS    in     **</span><br><span class="line">IBZKPT     out</span><br><span class="line">POSCAR     in     **</span><br><span class="line">CONTCAR    out</span><br><span class="line">CHGCAR     in/out</span><br><span class="line">CHG        out</span><br><span class="line">WAVECAR    in/out</span><br><span class="line">TMPCAR     in/out</span><br><span class="line">EIGENVAL   out</span><br><span class="line">DOSCAR     out</span><br><span class="line">PROCAR     out</span><br><span class="line">OSZICAR    out</span><br><span class="line">PCDAT      out</span><br><span class="line">XDATCAR    out</span><br><span class="line">LOCPOT     out</span><br><span class="line">ELFCAR     out</span><br><span class="line">PROOUT     out</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于VASP计算来说，前面这一大堆中的 INCAR ， KPOINTS， POSCAR 和POTCAR 是必不可少的输入文件，必须有!</p>
<ul>
<li>INCAR 告诉VASP算什么，怎么算。</li>
<li>KPOINTS 包含计算的K点信息（K点是什么，这个问题很抽象，脑子里先记住，计算的时候必须有这个东西）。</li>
<li>POSCAR是计算模型结构的文字描述，也就是各个原子在xyz方向的坐标信息。</li>
<li>POTCAR对应的是计算过程中每个原子的平面波基组，描述体系中对应的原子核和电子的相关信息。</li>
<li>提交任务的脚本或者命令，需要你自己准备，没有在列表里面。</li>
</ul>
</li>
</ul>
<p><strong>注意</strong></p>
<p>最新版的VASP中可以在INCAR中设置KPOINTS。但在涉及到计算能带的特殊K点时候，INCAR中就不可以直接设置了。所以，在本书中，KPOINTS是认为必须有的。请不要再纠结这个问题，也不要专门找我争论这个问题。如果你认为可以没有，那就是可以没有。至少本书中，我们会介绍KPOINTS文件的准备工作。</p>
<p>这一节，我们主要通过VASP官网中O原子的计算实例，来学习INCAR的文件准备工作。记住前面我们说的话，INCAR是纯文本。Windows用户，不要用记事本或者写字板打开。推荐使用<a href="https://notepad-plus-plus.org/">Notepad++</a>。</p>
<h3 id="简单说明"><a href="#简单说明" class="headerlink" title="简单说明"></a>简单说明</h3><p>INCAR主要是告诉VASP我们要算什么以及计算的细节，INCAR准备的原则是：<strong>越简单越好</strong>，<strong>不知道的，不理解的就不往里面放</strong>。 下面是给新手们的一些建议：</p>
<ul>
<li><p>INCAR 中有很多参数，改变参数来控制计算细节，从而得到我们期望的结果。所以，记住：Rubbish in， Rubbish out。自己算什么，心里要有数。</p>
</li>
<li><p>网上很多人发INCAR的教程，列了一堆参数进去，甚至长达两页，有些连默认值也放在里面了，恨不得把所有参数全部放进去。不过，请记住：那些令人眼花缭乱的只是唬人装逼用的，在实际计算中会严重拖你的后腿，占了那么多行，修改起来也费劲。</p>
</li>
<li><p>熟知各个参数的数值意义，以及在不同计算任务中的设置至关重要。</p>
</li>
<li><p>有人会说，那么多参数，怎么能记得过来？ 放心，完全可以的。</p>
<ul>
<li><p>一方面，对于特定的体系，所需要的参数不同。如果你的课题比较稳定，那么你应该不会接触太多的参数。比如你专注于体系的能带结构，那么算过渡态的参数你就不会需要。</p>
</li>
<li><p>另一方面，这些计算参数又不是一天两天能记住的，是一个长期积累的过程。随着时间的增长和个人经验的增加，自然而然地就记住了。</p>
</li>
</ul>
</li>
</ul>
<h3 id="INCAR-的输入工作"><a href="#INCAR-的输入工作" class="headerlink" title="INCAR 的输入工作"></a>INCAR 的输入工作</h3><p>打开编辑器，把下面几行挨个输入进去: （#以及后面的就不要输入了）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SYSTEM = O atom       # 氧元素符号，不是零!</span><br><span class="line">ISMEAR = 0            # 是零，不是氧元素符号，对于分子或者原子，用0.</span><br><span class="line">SIGMA = 0.01          # 对于分子或者原子，用0.01</span><br></pre></td></tr></table></figure>
<p><strong>INCAR的注意事项：</strong></p>
<ul>
<li><strong>#</strong>后面写的是汉语，是给大家展示用的。 大家在写INCAR的时候，最好不要把汉语写进去，有可能会出错！</li>
<li><p><strong>#</strong>号后面的内容对计算不会造成影响，主要作为注释用，解释这个参数干嘛用的，可以不用输入；</p>
</li>
<li><p>每个参数后面跟着等号 <strong>=</strong> ， </p>
</li>
<li><p>等号（<strong>=</strong>）前后可以有空格，也可以没有。<code>ISMEAR=0</code> 和 <code>ISMEAR = 0</code> 是一样的，</p>
</li>
<li><p>写INCAR的时候，<strong>不要使用 tab</strong>，用空格替换tab；</p>
</li>
<li><p>官网有些旧的文件可能用的不是 # 号，而是 !， ! 可能会出错。最好的办法就是记住参数是干嘛用的，# 和 ！ 都不写。</p>
</li>
</ul>
<h3 id="INCAR的详解"><a href="#INCAR的详解" class="headerlink" title="INCAR的详解"></a>INCAR的详解</h3><h4 id="SYSTEM"><a href="#SYSTEM" class="headerlink" title="SYSTEM"></a>SYSTEM</h4><p>SYSTEM 后面是该计算的说明。你的这个任务算的是什么，目的是什么，体系是什么？等等，这些都可以<strong>随便</strong>写在里面，<strong>随便</strong>的意思就是可以任意写。</p>
<ul>
<li>SYSTEM = O atom 和 SYSTEM = I LOVE BigBro  和 SYSTEM = VASP， 除了多出几个字符外，对计算没有什么影响。</li>
<li>情诗，骂人的话也可以写在 = 后面。但不建议大家在这一行里写一堆乱七八糟的东西，另外还是得避免把中文写在这里；</li>
<li>当然，这一行有或者没有，对计算结果不会有任何影响，看着不爽也可以直接删除。</li>
</ul>
<h4 id="ISMEAR"><a href="#ISMEAR" class="headerlink" title="ISMEAR"></a>ISMEAR</h4><p>ISMEAR这一项，目前需要记住的是：</p>
<ul>
<li>1）<strong>不同的值对应的是不同的展宽方法</strong>；</li>
<li>2）<strong>对于分子，原子的计算用0</strong>。</li>
</ul>
<p>下面是VASP官网的一些解释，新手暂时看不懂不要紧，把需要记住的这两条死死记住就可以了。</p>
<ul>
<li>对于半导体和绝缘体体系，ISMEAR的值取绝对不能大于0， 一般用0；</li>
<li>对所有体系，如果想获取更加精确能量的时候用-5，但这时候如果K点数目小于3，程序则会罢工；</li>
<li>K 点少，半导体或者绝缘体，那么只能用 ISMEAR = 0；</li>
<li>在DOS能带计算中，使用ISMEAR= -5 用于获取精确的信息。 </li>
<li>对于金属来说，ISMEAR的取值一般为&gt;=0 的数值（0,1,2）；</li>
<li>保守地说，ISMEAR = 0 (Gaussian Smearing) 可以满足大部分的体系（金属，导体，半导体，分子）；</li>
<li>如果不知道怎么取ISMEAR，直接用0是一个很保险的做法。也可以测试不同的值对计算的影响，但是新手的话，即使测试完了，也不知道根据什么去判断对结果的影响。</li>
</ul>
<h4 id="SIGMA"><a href="#SIGMA" class="headerlink" title="SIGMA:"></a>SIGMA:</h4><p>SIGMA的取值和ISMEAR息息相关，也就是和ISMEAR这个参数同时出现，设定。下面是一些基本的介绍：</p>
<ul>
<li><p>如果用了ISMEAR = -5； SIGMA的值可以忽略，也可以不管。（对于所有体系都适用)；</p>
</li>
<li><p>对于金属： ISMEAR = 1 或者0，非金属: ISMEAR= 0 的时候，一般取 SIGMA = 0.10 即可，默认值是0.20。不放心的话，用0.05。</p>
</li>
<li><p>对于气体分子，原子体系（也就是你把分子或者原子放到一个box里面）：死死记住下面组合就可以了， ISMEAR = 0; SIGMA = 0.01。</p>
</li>
</ul>
<p>不过很多人都不放心，为了保险想测试一番。标准是： SIGMA的取值要保证OUTCAR 中的 entropy T*S 这一项，平均到每个原子上，要小于 1-2 meV。检查的时候可以用这个命令: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep &#x27;entropy T&#x27;  OUTCAR </span><br></pre></td></tr></table></figure>
<p><strong>注意1：</strong>这里有两个单引号，不要输入的时候漏掉。</p>
<p>用这个命令，得出的能量除以体系中原子的数目（也就是平均到每个原子上），然后再和 0.001 eV 比较。如果小于，SIGMA取值OK，如果大于，再换个小点的数值进行测试。</p>
<p><strong>注意2：</strong>这里的说的entropy，是因为ISMEAR展宽这个计算方法引入的，跟我们物理化学书里面的entropy完全是两码事。后面我们会介绍如何通过频率分析计算物理化学里面的Entropy。千万别把这个数值当成频率所对应的entropy。</p>
<h3 id="INCAR的保存"><a href="#INCAR的保存" class="headerlink" title="INCAR的保存"></a>INCAR的保存</h3><p>输入完上面的几行，我们就可以保存INCAR文件了。这里需要注意的是：INCAR后面没有尾缀，<strong>所以：INCAR.txt是错误的。</strong>为避免这个问题：</p>
<ul>
<li><p>Notepad++ 保存的时候，文件名为: INCAR，保存类型选择 Alltypes (<em>.</em>)。</p>
</li>
<li><p>用Vim的筒子们直接将前面的内容保存成INCAR即可。</p>
</li>
<li><p>将INCAR.txt 通过<code>mv</code>命令重命名为INCAR。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv INCAR.txt INCAR -f</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>前面说了很多，对新手，可能会犯晕。不过不用担心，<strong>只要记住关键三点，我们就圆满完成本节的任务</strong>：</p>
<ul>
<li><p>INCAR是纯文本没有尾缀; </p>
</li>
<li><p>算原子或者分子时：ISMEAR = 0， SIGMA = 0.01</p>
</li>
<li><p>Windows用户请使用Notepad++作为文本编辑器，不要使用自带的记事本或者写字板，如果使用了，计算前务必要通过<code>dos2unix</code>转换一下格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dos2unix INCAR </span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上一节，我们学习了INCAR的简单准备工作。这一节，我们学习另外一个输入文件的写法：<strong><em>KPOINTS</em></strong></p>
<h3 id="简单说明-1"><a href="#简单说明-1" class="headerlink" title="简单说明"></a>简单说明</h3><p>KPOINTS文件在计算中的作用，一方面决定了计算的精度，同时也影响计算所需要的时间。精度高，时间长，精度低，时间短。所以：合理设置KPOINTS文件，可以保证我们使用最少的时间，来获取准确可靠的结果。</p>
<h3 id="KPOINTS的输入和保存"><a href="#KPOINTS的输入和保存" class="headerlink" title="KPOINTS的输入和保存"></a>KPOINTS的输入和保存</h3><p>打开编辑器，把下面几行输入进去: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">K-POINTS      #  第一行随便写都行，但不能没有</span><br><span class="line"> 0             # 零，格子自动生成</span><br><span class="line">Gamma         #  gamma点centered </span><br><span class="line">1 1 1         #  1*1*1格子</span><br><span class="line">0 0 0         #  S1 S2 S3， 一般保持 0 0 0 不变。</span><br></pre></td></tr></table></figure>
<p><strong>详解:</strong></p>
<ul>
<li><p>该KPOINTS 文件里面，共有5行，#号以及后面的不用输入；</p>
</li>
<li><p>同INCAR的注释一样，不要在每一行后面使用 ! 来进行注释，要使用 #，且最好不要写中文。 </p>
</li>
<li><p>第一行：可以随便写内容，但不能没有;</p>
</li>
<li><p>第二行：数字0，不是字母O，0 在这里表示的是自动生成K点。你可能注意到了，0前面有个空格，不过没关系，对计算不影响，可以删掉，也可以再加一个空格，后面的同样如此。 但是避免用tab输入，VASP有时候不识别tab键输入的空白部分，导致计算出错；</p>
</li>
<li><p>第三行：VASP只认第一个字母，大小写均可。在这里Gamma和gamma，Gorge，gorge效果是一样的，当然这一行也可以直接写字母G或者g。</p>
<ul>
<li>G表示的是以gamma点为中心生成网格。</li>
<li>另外一种是原始的Monkhorst-Pack 网格，两者的区别是 M 或者 m 在 G的基础上在三个方向上平移了1/（2N）个单位。</li>
<li>G，也叫 gamma centered Monkhorst-Pack Grid；所以，gamma centered 只是MP网格的一种特殊情况。</li>
</ul>
</li>
<li><p>第四行，在xyz三个方向上生成对应数目的K点，本例是111;</p>
<ul>
<li>对于原子或者分子的计算，K点取一个gamma点就够了（1 1 1），也就是这个KPOINTS文件可以用于绝大多数的原子或者分子计算，不用再修改；</li>
<li>但如果你要用ISMEAR = -5 来计算能量，那么就需要把 1 1 1 改成 2 2 2或者3 3 3。</li>
</ul>
</li>
<li><p>第五行，一般都写成 0 0 0 ，不用动即可；</p>
</li>
<li><p>按照前面INCAR的方式保存文件，名字为KPOINTS。</p>
</li>
</ul>
<h3 id="KPOINTS的建议"><a href="#KPOINTS的建议" class="headerlink" title="KPOINTS的建议"></a>KPOINTS的建议</h3><p>K点在VASP计算中非常重要，大师兄给的一个建议是：</p>
<ul>
<li><p>一直用gamma centered，也就是第三行保持G不变。因为M平移之后，网格的对称性和晶胞的对称性会出现不匹配的情况，从而导致计算出错，尤其是对于六角晶系hexagonal的结构，必须用gamma centered!这一点，vasp官网说的很明确；其他的建议后续慢慢展开讨论。</p>
</li>
<li><p>如非六角晶系的计算，如果已经设置的M算起来了，继续用M算就行，没必要改成G再重新算一遍；</p>
</li>
<li>前面看不懂，没事。<strong>记住这一点，本节就圆满完成任务</strong>：气体分子，原子计算的时候，使用gamma点即可。</li>
</ul>
<p>这一节，我们学习VASP计算中模型的文件：<strong><em>POSCAR</em></strong></p>
<h3 id="简单说明-2"><a href="#简单说明-2" class="headerlink" title="简单说明"></a>简单说明</h3><p>POSCAR 里面包含了你要进行计算的模型结构信息。也就是你要研究的对象。POSCAR有自己固定的格式，每一行都有特定的含义，认真掌握这些，对于搭建模型非常有帮助。对于本节的例子：O原子的计算中，我们要把O原子放到一个格子里面，格子大小为：8 $\times$ 8 $\times$ 8 $\AA{^3}$。那么POSCAR应该这样写。</p>
<h4 id="POSCAR的输入"><a href="#POSCAR的输入" class="headerlink" title="POSCAR的输入"></a>POSCAR的输入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O atom in a box </span><br><span class="line">1.0             # universal scaling parameters </span><br><span class="line">8.0 0.0 0.0     # lattice vector a(1) </span><br><span class="line">0.0 8.0 0.0     # lattice vector a(2)  </span><br><span class="line">0.0 0.0 8.0     # lattice vector a(3)  </span><br><span class="line">O               # O element， not zero</span><br><span class="line">1               # number of atoms </span><br><span class="line">Cartesian       # positions in cartesian coordinates </span><br><span class="line">0 0 0           #</span><br></pre></td></tr></table></figure>
<p><strong>详解：</strong></p>
<ul>
<li><p>第一行：同样随便写，但不能不写；</p>
</li>
<li><p>第二行：Scale factor，称为缩放系数，这里是1.0；</p>
</li>
<li><p>第三到五行：是组成格子的三条边的坐标信息；从原点出发，在xyz轴上分别取8$\AA$。这个很容易理解；</p>
</li>
<li><p>第六行：体系中的元素，这里我们算的是氧原子，所以写：O，即氧的元素符号。需要注意的有以下几点：</p>
<ul>
<li>vasp4.xx版本里面没有这一行，不过现在几乎没人用4.X的版本了；</li>
<li>O的符号和数字0容易混淆，一定要注意；</li>
<li>第一个元素符号要顶格写，前面不要有空格，有可能会出错；</li>
<li>如果计算文件夹里面，已经有与结构相一致的POTCAR，那么POSCAR里面即使删了这一行有不会影响计算，VASP会读取POTCAR中的元素信息，但输出文件CONTCAR中会把该行自动加上。（新手跳过）</li>
</ul>
</li>
<li><p>第七行：与第六行中元素相对应的原子数目，这里我们只有1个氧原子，所以写成1；</p>
</li>
<li><p>第八行：体系中原子的坐标系，可以为笛卡尔坐标，也可以为分数坐标系。注意的有以下几点：</p>
<ul>
<li>这一行同KPOINTS的第三行一样，即只认第一个字母；</li>
<li>C或者c代表笛卡尔坐标， D或者d代表分数坐标系；</li>
<li>VASP输出文件CONTCAR里面采用的是分数坐标系。</li>
</ul>
</li>
<li><p>第九行：体系中原子的坐标信息。这里我们把O原子放到了原点（0.0 0.0 0.0）的位置，大家也可以随便放一个位置，比如：（4.0 5.0 6.0），（1.1 2.5 6.5）都是可以的。由于周期性的存在，不管你怎么放，相邻两个格子之间氧原子的距离都是一样的。</p>
</li>
<li>写完之后，和INCAR，KPOINTS文件一样，直接保存成POSCAR即可。</li>
</ul>
<h5 id="两点说明"><a href="#两点说明" class="headerlink" title="两点说明"></a>两点说明</h5><ul>
<li><p>第二行中的Scale factor还可以写成其他的数字，例如：写成2.0，则后面的格子以及原子坐标相关的数值都要除以2。一般来说，写成1.0即可，这样比较直观，清晰;</p>
</li>
<li><p>笛卡尔和分数坐标系的区别是从原子的坐标行开始的（这个例子里面是第8行），即坐标前面的都保持完全一致。 也就是说，如果想从笛卡尔转换成分数坐标，我们只需将Cartesian改成Direct，然后修改后面的原子坐标，而Cartesian行前面的部分保持不变。</p>
</li>
</ul>
<h3 id="本节重点："><a href="#本节重点：" class="headerlink" title="本节重点："></a>本节重点：</h3><ul>
<li>学会写O原子在格子里面这个模型的POSCAR；</li>
<li>知道每一行所代表的含义。</li>
</ul>
<p>这一节，我们学习VASP计算中的赝势文件：<strong><em>POTCAR</em></strong></p>
<h3 id="简单说明-3"><a href="#简单说明-3" class="headerlink" title="简单说明"></a>简单说明</h3><p>如果组里安装了VASP，则在某个目录下，一定会有对应的一套对应的赝势文件，本书默认大家已经知道去哪里找，不讨论从哪里下载POTCAR（小窍门：一般各个VASP相关的QQ群中，都会有打包的POTCAR文件）。在该目录下， 一般来说，会有LDA，PBE，和PW91这三个文件夹，主流的计算一般都是用PBE。当你进入PBE的文件夹后，就会找到各个元素所对应的POTCAR文件了。</p>
<p><strong>POTCAR中各项的含义</strong></p>
<p>POTCAR中有很多信息，对于大部分的参数，本人也是只认识字母，不知具体含义，所以只能介绍一下在实际计算中会用到的一些参数。我们用Fe的POTCAR中前面的几行作为一个例子，简单介绍一下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PAW_PBE Fe 06Sep2000</span><br><span class="line">8.00000000000000000</span><br><span class="line">parameters from PSCTR are:</span><br><span class="line">  VRHFIN =Fe:  d7 s1</span><br><span class="line">  LEXCH  = PE</span><br><span class="line">  EATOM  =   594.4687 eV,   43.6922 Ry</span><br><span class="line"></span><br><span class="line">  TITEL  = PAW_PBE Fe 06Sep2000</span><br><span class="line">  LULTRA =        F    use ultrasoft PP ?</span><br><span class="line">  IUNSCR =        1    unscreen: 0-lin 1-nonlin 2-no</span><br><span class="line">  RPACOR =    2.000    partial core radius</span><br><span class="line">  POMASS =   55.847; ZVAL   =    8.000    mass and valenz</span><br><span class="line">  RCORE  =    2.300    outmost cutoff radius</span><br><span class="line">  RWIGS  =    2.460; RWIGS  =    1.302    wigner-seitz radius (au A)</span><br><span class="line">  ENMAX  =  267.883; ENMIN  =  200.912 eV</span><br><span class="line">  RCLOC  =    1.701    cutoff for local pot</span><br><span class="line">  LCOR   =        T    correct aug charges</span><br><span class="line">  LPAW   =        T    paw PP</span><br><span class="line">  EAUG   =  511.368</span><br><span class="line">  DEXC   =    -.022</span><br><span class="line">  RMAX   =    2.817    core radius for proj-oper</span><br><span class="line">  RAUG   =    1.300    factor for augmentation sphere</span><br><span class="line">  RDEP   =    2.442    radius for radial grids</span><br><span class="line">  QCUT   =   -4.437; QGAM   =    8.874    optimization parameters</span><br></pre></td></tr></table></figure>
<p>依个人的学习经验，VRHFIN， LEXCH，TITEL，ZVAL，ENMAX是用到最多的几个参数。</p>
<ul>
<li>VRHFIN 用来看元素的价电子排布，如果你元素周期表倒背如流，可以忽略这个参数；</li>
<li>LEXCH 表示这个POTCAR对应的是GGA-PBE泛函；如果INCAR中不设定泛函，则默认通过这个参数来设定。</li>
<li>TITEL 就不用说了，指的是哪个元素，以及POTCAR发布的时间；</li>
<li>ZVAL 指的是实际上POTCAR中价电子的数目，尤其是做Bader电荷分析的时候，极其重要。</li>
<li>ENMAX 代表默认的截断能。与INCAR中的ENCUT这个参数相关。</li>
</ul>
<p>当然，如果你进入文件夹，使用ls命令后，会发现：即使对于同一个元素来说，也可能会有很多不同的情况。比如：</p>
<ul>
<li>与GW 计算的对应的POTCAR，则标注为：Fe_GW 这样。（GW计算本人没接触过，这里就没有办法继续下去了）；</li>
<li>根据价电子的处理方式，分成了诸如：Fe，Fe_pv，Fe_sv的这样的情况。v是valence的缩写。pv代表把内层的p电子作为价电子来处理。sv代表则是把更内层的s电子也作为价电子来处理。具体到自己体系中的元素，可以结合元素周期表，以及ZVAL关键词所对应的价电子数目，来进行推断。</li>
<li>此时，我们就需要学习一个非常有用的Linux命令了： grep。 下面是我们使用grep命令，来获取所有与Fe相关POTCAR的价电子信息。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls Fe*</span><br><span class="line">Fe:</span><br><span class="line">POTCAR  PSCTR</span><br><span class="line"></span><br><span class="line">Fe_GW:</span><br><span class="line">POTCAR  PSCTR</span><br><span class="line"></span><br><span class="line">Fe_pv:</span><br><span class="line">POTCAR  PSCTR</span><br><span class="line"></span><br><span class="line">Fe_sv:</span><br><span class="line">POTCAR  PSCTR</span><br><span class="line"></span><br><span class="line">Fe_sv_GW:</span><br><span class="line">POTCAR  PSCTR</span><br><span class="line"></span><br><span class="line">$ grep ZVAL Fe*/POTCAR</span><br><span class="line">Fe/POTCAR:   POMASS =   55.847; ZVAL   =    8.000    mass and valenz</span><br><span class="line">Fe_GW/POTCAR:   POMASS =   55.847; ZVAL   =    8.000    mass and valenz</span><br><span class="line">Fe_pv/POTCAR:   POMASS =   55.847; ZVAL   =   14.000    mass and valenz</span><br><span class="line">Fe_sv/POTCAR:   POMASS =   55.847; ZVAL   =   16.000    mass and valenz</span><br><span class="line">Fe_sv_GW/POTCAR:   POMASS =   55.847; ZVAL   =   16.000    mass and valenz</span><br></pre></td></tr></table></figure>
<ul>
<li>还有把内层d轨道考虑到价电子层里面去的，比如：Ge_d。</li>
<li>某些元素，还有一些以 _h， _s 结尾的，应该是 hard和soft的缩写。带h的POTCAR中截断能比普通的要高出很多。带s的截断能要小很多。这里我们就可以通过grep 结合 ENMAX来查看一下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ grep ENMAX Ge*/POTCAR</span><br><span class="line">Ge/POTCAR:   ENMAX  =  173.807; ENMIN  =  130.355 eV</span><br><span class="line">Ge_d/POTCAR:   ENMAX  =  310.294; ENMIN  =  232.720 eV</span><br><span class="line">Ge_d_GW/POTCAR:   ENMAX  =  375.434; ENMIN  =  281.576 eV</span><br><span class="line">Ge_GW/POTCAR:   ENMAX  =  173.807; ENMIN  =  130.355 eV</span><br><span class="line">Ge_h/POTCAR:   ENMAX  =  410.425; ENMIN  =  307.818 eV</span><br><span class="line">Ge_sv_GW/POTCAR:   ENMAX  =  410.425; ENMIN  =  307.818 eV</span><br></pre></td></tr></table></figure>
<p><strong>POTCAR的选择</strong></p>
<p>既然对于同一个元素，存在那么多的POTCAR类型，计算的时候我们改怎么选择呢？这里大师兄只能给的建议是：如果没有特别的需求，直接采用VASP官网推荐的即可。参考链接：</p>
<p><a href="https://cms.mpi.univie.ac.at/vasp/vasp/Recommended_PAW_potentials_DFT_calculations_using_vasp_5_2.html">https://cms.mpi.univie.ac.at/vasp/vasp/Recommended_PAW_potentials_DFT_calculations_using_vasp_5_2.html</a></p>
<p>我们在计算的时候，根据体系中的元素，将这些元素的POTCAR结合起来，组成一个新的POTCAR，这个结合的步骤，我们需要用到Linux的另一个命令：cat。比如VASP官网的例子，体系中含有Al， C，H三种元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat ~/pot/Al/POTCAR ~/pot/C/POTCAR ~/pot/H/POTCAR &gt;POTCAR</span><br></pre></td></tr></table></figure>
<p>通过这一行命令就可以把Al，C，H各自的POTCAR结合在一起。OUTCAR中的元素顺序一定要和POSCAR保持一致,否则计算会出错，为了避免计算出错，还有一些高级的方法，这个在后面会慢慢讲解。</p>
<p>本节讲的是O原子的计算，官网推荐的氧原子POTCAR，默认的截断能是400，价层有6个原子。直接把O这个文件夹中的POTCAR直接复制到INCAR所在的目录即可。</p>
<p><strong>POTCAR检查常用的Linux命令：</strong></p>
<p>查看POTCAR中的元素:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep  TIT POTCAR</span><br></pre></td></tr></table></figure>
<p>查看POTCAR的截断能: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep  ENMAX POTCAR</span><br></pre></td></tr></table></figure>
<p>查看POTCAR中元素的价电子数目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep  ZVAL POTCAR</span><br></pre></td></tr></table></figure>
<p>举一反三，只要找到了关键词，我们就可以通过grep命令来进行查看。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>这一节，我们简单介绍了一下POTCAR中的内容，选取规则，以及通过grep命令和关键词进行查看。如果你能独立完成下面的几点，就圆满完成了本节的学习：</p>
<ul>
<li>VRHFIN， LEXCH，TITEL，ZVAL，ENMAX 这几个参数的大体意思；</li>
<li>初步了解：Fe_sv，Fe_pv， Ge_d,  Ge_gw，C_s, C_h 这些标记的含义；</li>
<li>查看VASP官网，了解VASP推荐的POTCAR；</li>
<li>使用grep来获取POTCAR中有价值的信息。</li>
</ul>
<p>通过本节（Ex01）的学习，大家初步了解VASP四个主要输入文件的是怎么制作的，一些简单参数的含义，以及每个文件所对应的格式和细节。本节我们分成了很多小节，每节内容都很多，但对新手来说，信息量可能有些大。但不需要一次性全部掌握，因为在后面的学习中，我们会逐渐深入。自己在课题进行的过程中，也会加深自己的理解。但书中要求掌握的部分，必须要牢牢记住。</p>
<p>本书的名字为：The Hard Way。意思是，学习VASP并不是一蹴而就的，需要一个长时间的积累过程。所以，新手切勿急躁，很多内容看不懂不要紧，务必要静下心来浏览一遍，自己跟着说明亲自去实践，切不可复制粘贴。 本节所讲解的东西，都务必去VASP官网找对应的说明，认真阅读，反复思考。养成潜心学习官网教程的良好习惯，从而远离网络上那些错误的信息。尤其是对于新手来说，很多都不懂的时候，没有自己的主见，别人一说就被牵着鼻子走了。</p>
<p><strong>相关的参考资料：</strong></p>
<ol>
<li>Vim使用练习：自己搜资料学习，百度里面很多，学会怎么输入，保存。</li>
<li><p>VASP文件: <a href="http://cms.mpi.univie.ac.at/vasp/guide/node50.html">http://cms.mpi.univie.ac.at/vasp/guide/node50.html</a></p>
</li>
<li><p>INCAR:    <a href="http://cms.mpi.univie.ac.at/vasp/guide/node91.html">http://cms.mpi.univie.ac.at/vasp/guide/node91.html</a></p>
</li>
<li><p>KPOINTS1:   <a href="http://cms.mpi.univie.ac.at/vasp/guide/node55.html">http://cms.mpi.univie.ac.at/vasp/guide/node55.html</a></p>
</li>
<li><p>KPOINTS2:  <a href="https://cms.mpi.univie.ac.at/vasp/vasp/Automatic_k_mesh_generation.html">https://cms.mpi.univie.ac.at/vasp/vasp/Automatic_k_mesh_generation.html</a></p>
</li>
<li>POSCAR1:   <a href="http://cms.mpi.univie.ac.at/vasp/guide/node59.html">http://cms.mpi.univie.ac.at/vasp/guide/node59.html</a></li>
<li>POSCAR2:  <a href="https://cms.mpi.univie.ac.at/vasp/vasp/POSCAR_file.html">https://cms.mpi.univie.ac.at/vasp/vasp/POSCAR_file.html</a></li>
<li>POTCAR1:   <a href="http://cms.mpi.univie.ac.at/vasp/guide/node54.html">http://cms.mpi.univie.ac.at/vasp/guide/node54.html</a></li>
<li>POTCAR2:   <a href="https://cms.mpi.univie.ac.at/vasp/vasp/Recommended_PAW_potentials_DFT_calculations_using_vasp_5_2.html">https://cms.mpi.univie.ac.at/vasp/vasp/Recommended_PAW_potentials_DFT_calculations_using_vasp_5_2.html</a></li>
<li>ISMEAR1:   <a href="http://cms.mpi.univie.ac.at/vasp/guide/node124.html">http://cms.mpi.univie.ac.at/vasp/guide/node124.html</a></li>
<li>ISMEAR2:   <a href="http://cms.mpi.univie.ac.at/vasp/vasp/Number_k_points_method_smearing.html">http://cms.mpi.univie.ac.at/vasp/vasp/Number_k_points_method_smearing.html</a></li>
</ol>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>VASP 输入文件</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex02 做计算常用的批量处理方法（一）</title>
    <url>/2017/10/20/ex02/</url>
    <content><![CDATA[<h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p>前面一节大家已经学习了怎么制作文本格式的输入文件。回顾一下我们所学的东西：</p>
<ul>
<li><p>VASP必须有的输入文件都有哪些？  INCAR、KPOINTS、POSCAR、POTCAR</p>
</li>
<li><p>这些文件用什么编辑器修改或者制作？</p>
</li>
<li>文本内部格式都有哪些需要的注意事项？</li>
<li>目前学到的INCAR中各个参数代表的含义？</li>
<li>KPOINTS， POSCAR文本中每一行所代表的含义？</li>
<li>POTCAR中几个参数的含义。</li>
</ul>
<h3 id="批量处理"><a href="#批量处理" class="headerlink" title="批量处理"></a>批量处理</h3><p>在提交VASP任务之前，我们先学习一下在Linux系统中常用的批量处理任务文件的办法。本书的宗旨是：稳中求快，欲速则不达。因此，不是所谓的速成教材，更不是10分钟学会XXX的理想手册。每一节的内容，都需要认真阅读，亲自上手操作练习。如果耐不住性子，请放弃本书的学习。而大师兄VASP多年的经验告诉我，批量处理在新手学习上有着非常重要的作用，因为很多参数他们不知道怎么去选择，但是，这种情况其实很好处理，只需要测试下就可以了。</p>
<h4 id="大家常用的测试方法"><a href="#大家常用的测试方法" class="headerlink" title="大家常用的测试方法"></a>大家常用的测试方法</h4><p>在VASP官网上，亦或者百度里面搜索的VASP教程里面，你可以找到很多个测试参数的小脚本，大部分都是这样的：参考链接：<a href="https://cms.mpi.univie.ac.at/wiki/index.php/Cd_Si">https://cms.mpi.univie.ac.at/wiki/index.php/Cd_Si</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line">BIN=/path/to/your/vasp/executable</span><br><span class="line">rm WAVECAR SUMMARY.dia</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span>  5.1 5.2 5.3 5.4 5.5 5.6 5.7 ; <span class="keyword">do</span></span><br><span class="line">cat &gt;POSCAR &lt;&lt;!</span><br><span class="line">cubic diamond</span><br><span class="line">   <span class="variable">$i</span> </span><br><span class="line"> 0.0    0.5     0.5</span><br><span class="line"> 0.5    0.0     0.5</span><br><span class="line"> 0.5    0.5     0.0</span><br><span class="line">  2</span><br><span class="line">Direct</span><br><span class="line"> -0.125 -0.125 -0.125</span><br><span class="line">  0.125  0.125  0.125</span><br><span class="line">!</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;a= <span class="variable">$i</span>&quot;</span> ; mpirun -n 2 <span class="variable">$BIN</span></span><br><span class="line">E=`awk <span class="string">&#x27;/F=/ &#123;print $0&#125;&#x27;</span> OSZICAR` ; <span class="built_in">echo</span> <span class="variable">$i</span> <span class="variable">$E</span>  &gt;&gt;SUMMARY.dia</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">cat SUMMARY.dia</span><br></pre></td></tr></table></figure>
<p>然而，很多新手对linux的基本命令还不是很熟悉，更不用说脚本了。由于对于本书所默认的Linux基础为0的读者来说，上面的脚本会有些难度。因此，本节需要学习在linux系统下（确切点是在一个Terminal，终端里），一些基本的命令以及大师兄本人常用的批量处理任务文件的一个办法。</p>
<p>这时候你要问了，师兄，你的这个方法和VASP官网中的那个比起来，哪个更好啊？</p>
<p>其实本质是一样的。只是操作思路稍微有些区别。这个没有最好的，要根据你所要达到的目标，目前对程序的理解水平来定的。但是，你必须要学会一种，一个好的开始对于大家的后程发力和高效解决日常任务非常重要。</p>
<h4 id="Linux里面的一些基本命令"><a href="#Linux里面的一些基本命令" class="headerlink" title="Linux里面的一些基本命令"></a>Linux里面的一些基本命令</h4><p>首先：教给大家常用的查看（进入）目录，查看文件的几个相关的命令: ls，  cat，和  grep。</p>
<p>通过这几个命令复习并查看上一节我们制作的输入文件: INCAR， KPOINTS， POSCAR 和POTCAR。</p>
<p>大师兄在超算中心的一些具体的基本操作。大家可以照着命令自己练习下面的几个命令。先敲一遍，看下输出结果。（老司机自动跳过）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[iciq-lq@ln3%th2 ~]$ ls</span><br><span class="line">bin  LVASPTHW</span><br><span class="line">[iciq-lq@ln3%th2 ~]$ <span class="built_in">cd</span> LVASPTHW/</span><br><span class="line">[iciq-lq@ln3%th2 LVASPTHW]$ ls</span><br><span class="line">ex01</span><br><span class="line">[iciq-lq@ln3%th2 LVASPTHW]$ <span class="built_in">cd</span> ex01/</span><br><span class="line">[iciq-lq@ln3%th2 ex01]$ ls</span><br><span class="line">INCAR  KPOINTS  POSCAR  POTCAR</span><br><span class="line">[iciq-lq@ln3%th2 ex01]$ <span class="built_in">pwd</span> </span><br><span class="line">/THFS/home/iciq-lq/LVASPTHW/ex01</span><br><span class="line">[iciq-lq@ln3%th2 ex01]$ </span><br><span class="line">[iciq-lq@ln3%th2 ex01]$ cat INCAR  </span><br><span class="line">SYSTEM = O atom </span><br><span class="line">ISMEAR = 0       </span><br><span class="line">SIGMA = 0.01      </span><br><span class="line">[iciq-lq@ln3%th2 ex01]$ cat KPOINTS </span><br><span class="line">K-POINTS  </span><br><span class="line"> 0  </span><br><span class="line">Gamma</span><br><span class="line">1 1 1</span><br><span class="line">0 0 0 </span><br><span class="line">[iciq-lq@ln3%th2 ex01]$ cat POSCAR  </span><br><span class="line">O atom <span class="keyword">in</span> a box </span><br><span class="line">1.0            </span><br><span class="line">8.0 0.0 0.0   </span><br><span class="line">0.0 8.0 0.0  </span><br><span class="line">0.0 0.0 8.0 </span><br><span class="line">O          </span><br><span class="line">1         </span><br><span class="line">Cartesian</span><br><span class="line">0 0 0           <span class="comment">#</span></span><br><span class="line">[iciq-lq@ln3%th2 ex01]$ </span><br><span class="line">[iciq-lq@ln3%th2 ex01]$ grep TIT POTCAR  </span><br><span class="line">   TITEL  = PAW_PBE O 08Apr2002</span><br><span class="line">[iciq-lq@ln3%th2 ex01]$ </span><br><span class="line">[iciq-lq@ln3%th2 ex01]$ grep EMAX POTCAR </span><br><span class="line">[iciq-lq@ln3%th2 ex01]$ grep ENMAX POTCAR </span><br><span class="line">   ENMAX  =  400.000; ENMIN  =  300.000 eV</span><br><span class="line">[iciq-lq@ln3%th2 ex01]$ </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>详解:</strong> </p>
<p>1） ls 命令：列出来当前目录下的所有文件和文件夹；</p>
<p>2） cd： 进入文件夹所在的目录；</p>
<p>3） pwd：显示当前所在的绝对目录。</p>
<p>4）  cat 后面加上文件名，就可以在输出里面查看该文件的内容：cat 和文件名之间有空格， 可以是一个，也可以是N个。（上一节，我们也提到使用cat命令来生成VASP的POTCAR）</p>
<p>5） 对于一个大文件来说，里面有很多行， 用cat就不方便查看了， 我们可以用grep这个命令提取出来所需要的信息，比如上一节的POTCAR文件，复习下上节的操作：</p>
<ul>
<li>例子1：我们想知道POTCAR中包含的元素，可以用: grep TIT POTCAR ， </li>
</ul>
<p>TIT就是POTCAR中的一个固定的字符，通过提取这个字符，获取我们需要的结果，这里我们知道了 POTCAR中含有O元素;</p>
<ul>
<li><p>例子2：通过使用：grep ENMAX POTCAR  可以获取POTCAR中O元素的截断能是400 eV;</p>
</li>
<li><p><strong>注意：</strong>grep 后面提取的字符，最好在文件中是唯一存在的或者只出现几次。否则我们不容易得到期望的结果; 大家可以运行下面这两个命令，感受下结果;</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep EMAX POTCAR</span><br><span class="line">grep  PBE POTCAR  </span><br><span class="line">grep  0  POTCAR  （可以是0，也可以是字母O）</span><br></pre></td></tr></table></figure>
<p>6） 查看文件的命令还有 more，例如下面的操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[iciq-lq@ln3%th2 ex01]$ ls</span><br><span class="line">INCAR  KPOINTS  POSCAR  POTCAR</span><br><span class="line">[iciq-lq@ln3%th2 ex01]$ </span><br><span class="line">[iciq-lq@ln3%th2 ex01]$ more  INCAR  </span><br><span class="line">SYSTEM = O atom </span><br><span class="line">ISMEAR = 0       </span><br><span class="line">SIGMA = 0.01      </span><br><span class="line">[iciq-lq@ln3%th2 ex01]$ more POSCAR  </span><br><span class="line">O atom <span class="keyword">in</span> a box </span><br><span class="line">1.0            </span><br><span class="line">8.0 0.0 0.0   </span><br><span class="line">0.0 8.0 0.0  </span><br><span class="line">0.0 0.0 8.0 </span><br><span class="line">O          </span><br><span class="line">1         </span><br><span class="line">Cartesian</span><br><span class="line">0 0 0           <span class="comment">#</span></span><br><span class="line">[iciq-lq@ln3%th2 ex01]$ </span><br></pre></td></tr></table></figure>
<p>7)  或者less， 运行less 命令 后，会显示文件的内容，</p>
<ul>
<li><p>如果要退出 敲一下 q 键即可;</p>
</li>
<li><p>如果想编辑文件，再敲一下键盘上的v键，则可以直接进入vim 的编辑界面。退出时和vim的退出方法是一样的。</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本节的内容虽名为详解，实为简介！如果想学的更加深入还要靠自己百度查找相关的Linux命令学习手册，ppt等，平时多加操练。但，请不要让我推荐参考书给你。百度搜索关键词： Linux命令 即可。到现在，我们讲到的Linux基本命令有： ls，cd，pwd，cat，grep，more，less 以及vim 这个编辑器。如何才能圆满达到本节的要求呢？</p>
<p>1） 熟练操作使用这些命令；</p>
<p>2） 搜索百度，尝试一些教程相关的学习；</p>
<p>3） 养成遇到不会的命令，就自己<strong>主动</strong>认真搜索学习的习惯。</p>
<p>上一小节，我们学习了一些基本的linux操作，今天我们学习下文件以及文件夹的操作命令：mkdir, cp，mv以及一个简单的for循环。</p>
<p><strong>文件（夹）的操作命令：</strong></p>
<p>1 mkdir 是创建文件夹的一个命令，后面紧跟着你要创建的文件夹的名字。mkdir的使用，有很多敲门。大家可以百度关键词查找： mkdir 窍门，小诀窍 等等。创建一个名字为：ex02的文件夹，然后进入，再创建一个birbro的文件夹: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq$ ls</span><br><span class="line">bin  LVASPTHW</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq$ </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq$ cd LVASPTHW/</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW$ ls</span><br><span class="line">ex01</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW$ mkdir ex02</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW$ cd ex02</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex02$ ls</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex02$ mkdir bigbro </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex02$ ls</span><br><span class="line">bigbro</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex02$</span><br></pre></td></tr></table></figure>
<p>2 cp这个命令适用于文件以及文件夹的复制。比如：</p>
<p>2.1） 将bigbro 这个文件夹复制名为: bigbra</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex02$ cp bigbro bigbra </span><br><span class="line">cp: omitting directory `bigbro&#x27;</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex02$ cp bigbro bigbra -r </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex02$ ls</span><br><span class="line">bigbra  bigbro</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex02$ </span><br></pre></td></tr></table></figure>
<ul>
<li><p>如果复制文件夹的时候，如上图，出现<strong>cp: omitting directory</strong>这个错误，在cp命令后，或者前面命令的结尾加上-r即可。</p>
</li>
<li><p>复制文件的时候，不用加 -r。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp -r  bigbro bigbra</span><br><span class="line">cp bigbro bigbra -r</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>2.2） 将ex01中的四个输入文件复制到bigbra这个文件夹中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex02$ cp ../ex01/</span><br><span class="line">INCAR    KPOINTS  POSCAR   POTCAR   </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex02$ cp ../ex01/* bigbr</span><br><span class="line">bigbra/ bigbro/ </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex02$ cp ../ex01/* bigbra/</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex02$ ls *</span><br><span class="line">bigbra:</span><br><span class="line">INCAR  KPOINTS  POSCAR  POTCAR</span><br><span class="line"></span><br><span class="line">bigbro:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>学会用tab键来提高自己在终端输入的速度，最上面2个cp的命令都是tab的结果。<ul>
<li>第一次使用tab，可以列出来ex01中所有的文件；</li>
<li>第二次使用tab，可以列出来当前目录下所有以b开头的文件夹；</li>
</ul>
</li>
<li>学会用*来查看某个目录下所有的内容。</li>
</ul>
<p>3 mv 是Linux中： 转移、重命名文件（夹）的一个命令，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex02$ mv bigbra bigbro</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex02$ ls</span><br><span class="line">bigbro</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex02$ cd bigbro/</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex02/bigbro$ ls</span><br><span class="line">bigbra</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex02/bigbro$ mv bigbra/ 0.01</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex02/bigbro$ ls </span><br><span class="line">0.01</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex02/bigbro$ cd ../</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex02$ ls</span><br><span class="line">bigbro</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex02$ mv bigbro/0.01/ .</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex02$ </span><br></pre></td></tr></table></figure>
<ul>
<li>把bigbra 文件移动到bigbro里面；</li>
<li><p>进入bigbro文件夹；</p>
</li>
<li><p>将bigbra文件夹重命名为： 0.01</p>
</li>
<li>返回上一层的目录；</li>
<li>将bigbro中的0.01移动到当前的目录下（当前的目录，命令中用点.来代替。）；</li>
</ul>
<p><strong>问题来了：</strong></p>
<p>现在我们需要完成下面的任务：</p>
<p>1）创建从0.02，0.03到0.10，共9个文件夹，</p>
<p>2）每个文件夹中都有与0.01文件夹中相同KPONTS, POSCAR，POTCAR</p>
<p>3）每个文件夹中都有INCAR，但INCAR中SIGMA这个参数的取值和文件夹的名字一样，其他参数和0.01的相同。</p>
<p>为实现这个小目标，我们可以这样做：将0.01复制成0.02,0.03…0.10，然后挨个修改里面的INCAR文件。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp 0.01 0.02</span><br><span class="line">cp 0.01 0.03</span><br><span class="line">......</span><br><span class="line">cp 0.01 0.10</span><br><span class="line">vi 0.02/INCAR</span><br><span class="line">vi 0.03/INCAR</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<ul>
<li>小窍门：运行完第一个命令后，敲一下键盘的向上箭头，就会出现刚刚运行的命令，直接修改最后一个数字即可。</li>
</ul>
<p><strong>神奇的for循环</strong></p>
<p>但大师兄不想挨个创建这9个文件夹，也不想挨个编辑修改INCAR文件中的SIGMA数值。想必大家都不想这么做，因此，在这里教给大家使用一个for循环来快速实现我们的小目标。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex02$ ls</span><br><span class="line">0.01  bigbro</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex02$ rm bigbro/ -fr </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex02$ for i in &#123;2..9&#125;; do cp 0.01 0.0$i ; done </span><br><span class="line">cp: omitting directory `0.01&#x27;</span><br><span class="line">cp: omitting directory `0.01&#x27;</span><br><span class="line">cp: omitting directory `0.01&#x27;</span><br><span class="line">cp: omitting directory `0.01&#x27;</span><br><span class="line">cp: omitting directory `0.01&#x27;</span><br><span class="line">cp: omitting directory `0.01&#x27;</span><br><span class="line">cp: omitting directory `0.01&#x27;</span><br><span class="line">cp: omitting directory `0.01&#x27;</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex02$ for i in &#123;2..9&#125;; do cp 0.01 0.0$i -r ; done </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex02$ ls </span><br><span class="line">0.01  0.02  0.03  0.04  0.05  0.06  0.07  0.08  0.09</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex02$ </span><br></pre></td></tr></table></figure>
<p>上面我们先删掉了bigbro文件夹；</p>
<p>然后使用for循环，发现没有加-r，复制的时候出错了</p>
<p>加上-r之后，for循环顺利的完成了小目标</p>
<p><strong>for循环详解:</strong></p>
<p>1）  {2..9} 是为了获取从2到9的所有数字， 有以下几点需要注意:</p>
<ul>
<li><p>for i in {2..9} 和 for i in 2 3 4 5 6 7 8 9 效果是一样的</p>
</li>
<li><p>用的是花括号</p>
</li>
<li><p>2和9中间有两个点 ..  </p>
</li>
<li><p>两个点之间没有空格， 2，9 与两个点之间也没有空格。</p>
</li>
<li>不要用中文输入法敲命令。</li>
</ul>
<p>2）大家还可以练习下面这几个命令来看一下效果:  echo是打印输出的命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &#123;1..100&#125; </span><br><span class="line">echo &#123;A..Z&#125;</span><br><span class="line">echo &#123;a..z&#125;</span><br><span class="line">echo &#123;a..z&#125;&#123;1..10&#125;&#123;A..Z&#125;</span><br></pre></td></tr></table></figure>
<p>3） for i in {2..9} : 翻译过来就是:对于从2到9的任意数字 i， i在这里是一个变量；我们给 i 赋值，值的范围是 从2到9 ; 两点需要注意:</p>
<ul>
<li><p>i 只是个人喜好而已， 你也可以用 for a in  XXX ; for b in XXX;  </p>
</li>
<li><p>in 后面是一个 集合; 怎么选取这个集合决定了for循环的威力;</p>
</li>
</ul>
<p>4）  for i in XXX  这个句字后面跟着一个分号，如果没有便会出错。分号前后可以有空格，也可以没有，为了让自己写的东西更加直观，建议加上空格; </p>
<p>5） do 翻译过来就是: 我们要实现什么任务，目的; do 后面跟一个空格， 或者几个空格 </p>
<p>6） cp 0.01  0.0$i   -r</p>
<ul>
<li><p>cp 0.01 把 0.01 这个文件夹复制成 0.0$i 文件夹;</p>
</li>
<li><p>$i 被替换成for后面变量 i 的值;</p>
</li>
</ul>
<p>7） 复制完成后，后面跟着一个分号;  </p>
<p>8） done 完成任务。</p>
<p>9）大家可以尝试着其他类似的命令： for i in XXX; do XXX ; done  比如: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for bigbro in &#123;A..Z&#125;; do echo bigbro is $bigbro ; done</span><br></pre></td></tr></table></figure>
<p>这个例子只是为了说明：</p>
<ul>
<li>for 后面的变量如果你用 i 表示，那么后面就用$i 来引用；</li>
</ul>
<ul>
<li>如果用bigbro 来表示，后面则用$bigbro; </li>
<li>$和后面的变量之间(bigbro)没有空格。（你可以加上空格，看看有什么错误出现！）</li>
</ul>
<p><strong>思考下：</strong></p>
<p>对于一个文件A，我们的目的是将A重命名为B。有下面2种操作可供选择：</p>
<p>第一种） mv A B </p>
<p>第二种） cp A B 然后 rm A </p>
<p>从结果上来说，这两种做法都是可以的。这里大师兄想告诉你的是：</p>
<p>i） 尽量找最简单的方法（第一种）实现所期望的目的；</p>
<p>ii） 如果不知道最简单的方法， 那么可以尝试其他方式来解决（第二种）。</p>
<p><strong>小结:</strong></p>
<p>通过本小节的学习：一方面我们熟悉文件（夹）创建，复制，移动以及重命名的linux命令：mkdir， mv， cp。另一方面，初步掌握for循环来实现批量处理的效果。请大家务必多加操练，以及完成扩展练习。至少图中的例子要练习一遍，能看懂什么意思。本节的for循环，我们只完成了一半的任务，每个文件夹中的INCAR还没有修改，下一节我们介绍另一个批量处理的方法来实现这个目的。</p>
<p>此外， linux的命令操作有很多的小技巧，大家一定要多多去网上搜集，加以练习，这对于提高工作效率非常有帮助。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>Linux 基本操作</tag>
        <tag>批量处理</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex04 做计算常用的批量处理方法（五）</title>
    <url>/2017/10/24/ex04/</url>
    <content><![CDATA[<p>前面2节，我们学习了使用sed命令结合for循环，来对INCAR进行批量操作。同样，我们也可以对KPOINTS文件进行类似的批处理操作。本节，我们借对KPOINTS文件的操作，一方面，学习几个小窍门，另一方面回顾上一节的学习内容以及KPOINTS文件。</p>
<h4 id="KPOINTS文件"><a href="#KPOINTS文件" class="headerlink" title="KPOINTS文件"></a>KPOINTS文件</h4><p>前面我们学习到，KPOINTS文件只有简单的几行，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">K-POINTS  </span><br><span class="line">0  </span><br><span class="line">Gamma</span><br><span class="line">1 1 1</span><br><span class="line">0 0 0 </span><br></pre></td></tr></table></figure>
<p>目前，对于大家来说，需要掌握的有以下点：</p>
<ul>
<li><p>会自己闭着眼把这几行写出来；</p>
</li>
<li><p>第三行的gamma代表的是gamma centered的意思；</p>
</li>
<li>第四行中的1 1 1 俗称gamma点。很多时候，在QQ群里面提问题，别人说用gamma点算一下，指的就是1 1 1；</li>
<li><p>除了使用gamma点，我们还可以使用其他的数值，比如2 2 2，3 3 3， 1 2 3 等，数值越大，计算量也就越大。具体的要根据你自己的体系以及组里的计算能力来确定，这个我们后面会介绍；</p>
</li>
<li><p>对于气体分子或者原子的计算来说，也就是把它们放到一个格子的体系，使用gamma点就足够了。</p>
</li>
</ul>
<p>本节，我们主要对KPOINTS的文件的第四行进行批量操作，将1 1 1改成 2 2 2， 3 3 3 等。首先浏览下面的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW$ ls</span><br><span class="line">ex01  ex02  ex03</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW$ mkdir ex04 &amp;&amp; cd ex04</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04$ for i in &#123;1..6&#125;; do cp ../ex03/0.01/ $&#123;i&#125;$&#123;i&#125;$&#123;i&#125; -r ; done </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04$ ls </span><br><span class="line">111  222  333  444  555  666</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04$ cat 333/KPOINTS  -n </span><br><span class="line">     1	K-POINTS  </span><br><span class="line">     2	 0  </span><br><span class="line">     3	Gamma</span><br><span class="line">     4	1 1 1</span><br><span class="line">     5	0 0 0 </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04$ for i in &#123;1..6&#125;; do sed -i &#x27;4s/1 1 1/$i $i $i/g&#x27; $i/KPOINTS ; done </span><br><span class="line">sed: can&#x27;t read 1/KPOINTS: No such file or directory</span><br><span class="line">sed: can&#x27;t read 2/KPOINTS: No such file or directory</span><br><span class="line">sed: can&#x27;t read 3/KPOINTS: No such file or directory</span><br><span class="line">sed: can&#x27;t read 4/KPOINTS: No such file or directory</span><br><span class="line">sed: can&#x27;t read 5/KPOINTS: No such file or directory</span><br><span class="line">sed: can&#x27;t read 6/KPOINTS: No such file or directory</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04$ cat 333/KPOINTS  -n </span><br><span class="line">     1	K-POINTS  </span><br><span class="line">     2	 0  </span><br><span class="line">     3	Gamma</span><br><span class="line">     4	1 1 1</span><br><span class="line">     5	0 0 0 </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04$ for i in &#123;1..6&#125;; do sed -i &#x27;4s/1 1 1/$i $i $i/g&#x27; $&#123;i&#125;$&#123;i&#125;$&#123;i&#125;/KPOINTS ; done </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04$ cat 333/KPOINTS  -n </span><br><span class="line">     1	K-POINTS  </span><br><span class="line">     2	 0  </span><br><span class="line">     3	Gamma</span><br><span class="line">     4	$i $i $i</span><br><span class="line">     5	0 0 0 </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04$ </span><br></pre></td></tr></table></figure>
<p><strong>详解：</strong></p>
<ul>
<li><p>第三行：我们使用了 mkdir  ex04 &amp;&amp; cd ex04 这个命令。 &amp;&amp; 的作用是将两个命令连起来运行，如果&amp;&amp;前面的命令运行成功，则继续后面的命令。这里我们先运行了mkdir ex04的命令，然后通过cd进入新建的ex04这个文件夹目录下。但如果前面的命令运行不成功，我们还想运行第二个命令，那么可以用 ||这个将两个命令联系起来。百度自己搜索：&amp;&amp;  和 ||的使用，多多练习，可以提高你敲命令的工作效率。</p>
</li>
<li><p>我们使用for循环，将ex03中的0.01文件夹复制成111， 222， 333等。这里我们在调用for 循环中的变量i的时候，使用的是${i}。为什么要加花括号呢？ 这是为了避免$i和后面的连在一起，从而导致调用失败。比如下面的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04$ for i in &#123;1..6&#125;; do echo $iA; done </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04$ for i in &#123;1..6&#125;; do echo $&#123;i&#125;A; done </span><br><span class="line">1A</span><br><span class="line">2A</span><br><span class="line">3A</span><br><span class="line">4A</span><br><span class="line">5A</span><br><span class="line">6A</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04$ </span><br></pre></td></tr></table></figure>
</li>
<li><p>后面的命令中，我们得到了这样的错误：sed: can’t read 1/KPOINTS: No such file or directory。原因是我们的问价夹中有3个数字，我们需要调用$i三次，但写$i/KPOINTS就会引用一次，导致sed的命令对象不正确。</p>
</li>
<li>改正之后，我们发现INCAR中的1 1 1 全部被替换成$i $i $i了。这里是大师兄故意犯了的错误：将双引号变成了单引号。到现在，单引号和双引号的区别，相信大家在练习完之后能大体知道个所以然了。</li>
</ul>
<p>上面的练习中，我们没有成功将 1 1 1改成文件夹对应的数字，那么改怎么做呢？ 有下面2个方法：</p>
<p><strong>方法1：</strong> 将ex04的文件夹全部删掉，然后从新来过，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04$ ls </span><br><span class="line">111  222  333  444  555  666</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04$ rm * -fr</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04$ ls</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04$ for i in &#123;1..6&#125;; do cp ../ex03/0.01/ $&#123;i&#125;$&#123;i&#125;$&#123;i&#125; -r ; done </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04$ ls </span><br><span class="line">111  222  333  444  555  666</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04$ for i in &#123;1..6&#125;; do sed -i &quot;4s/1 1 1/$i $i $i/g&quot; $&#123;i&#125;$&#123;i&#125;$&#123;i&#125;/KPOINTS ; done </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04$ cat 333/KPOINTS  -n </span><br><span class="line">     1	K-POINTS  </span><br><span class="line">     2	 0  </span><br><span class="line">     3	Gamma</span><br><span class="line">     4	3 3 3</span><br><span class="line">     5	0 0 0 </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04$ </span><br></pre></td></tr></table></figure>
<p><strong>方法2：</strong>将错就错，在错误的基础上，把$i $i $i 批量替换成文件夹对应的数字：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04$ ls</span><br><span class="line">111  222  333  444  555  666</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04$ cat 222/KPOINTS  </span><br><span class="line">K-POINTS  </span><br><span class="line"> 0  </span><br><span class="line">Gamma</span><br><span class="line">$i $i $i</span><br><span class="line">0 0 0 </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04$ for i in &#123;1..6&#125; ; do sed -i &quot;s/\$i \$i \$i/$i $i $i/g&quot; $i$i$i/KPOINTS ; done </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04$ cat 222/KPOINTS  </span><br><span class="line">K-POINTS  </span><br><span class="line"> 0  </span><br><span class="line">Gamma</span><br><span class="line">2 2 2</span><br><span class="line">0 0 0 </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04$ </span><br></pre></td></tr></table></figure>
<ul>
<li><p>这里我们没有用${i}，而是直接$i$i$i连在一起用了。说明这个时候，花括号有或者没有，对命令行影响不大。</p>
</li>
<li><p>sed 操作的难点在于区别$i是调用的参数还是要被替换的字符上。例子中我们用一个反斜杠 \ 将$i转义成字符，进而避免将其按照变量来处理。说白了，就是让$ 这个符号变成一个纯文字符号，而不再发挥调用变量的作用。这一部分的知识，大家自行百度搜索：Linux 转义符 进行学习。</p>
</li>
</ul>
<p>再举个例子：如果被替换的内容中含有 /  , 直接输入则会被认为是分隔符,因此我们需要将其作为分隔符的作用去掉。怎么做呢? 输入\/ (一个反斜杠加单斜杠,中间没有空格),这样的话 / 就会被当成字符来处理啦! 大家好好琢磨下面的这个命令，我们要把big/bro中的/替换为\。如果你能理解了，转义符就基本入门了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04$ echo big/bro </span><br><span class="line">big/bro</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04$ echo big/bro | sed &#x27;s/\//\\/g&#x27;</span><br><span class="line">big\bro</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04$ </span><br></pre></td></tr></table></figure>
<ul>
<li>这里我们用了一个|，中文名字叫管道符，它的作用是将前面命令的输出结果传递给后面的命令，用作操作对象。百度自行搜索：Linux 管道符</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在本节的操作中，我们可以学到很多知识，私以为对于一个新手来说，这一节的内容难度有些大，需要认真操作，思考，查阅相关的资料。简单总结一下，本节需要掌握的内容有：</p>
<ul>
<li><p>&amp;&amp;，||  和 | 的用法 </p>
</li>
<li><p>${i} 中什么时候用花括号，什么时候不用</p>
</li>
<li><p>sed 中的单引号，双引号的区别;</p>
</li>
<li><p>转义符在字符处理中的作用。</p>
</li>
<li><p>如何避免命令出错，以及出错后改怎么改正。</p>
</li>
</ul>
<p>前面的四点都是死死的基本Linux操作，而最后一点则是考验大家智商的时候。做计算，肯定避免不了会敲错命令，犯各种各样的错误。在避免出错方面，我们要认真掌握命令操作的关键点以及总结前面错误的经验；在错误的改正方面，我们要多多动脑子，及时想办法补救。众多补救的办法中，提前将操作的对象进行备份是最为有效的。比如，在前面例子中，由于在ex03中有备份的文件，即使在ex04目录犯错后，我们大不了全部删除，重新再来一遍。所以，在大家没有进行计算前，先提个醒：<strong>一定要时刻牢记备份自己的文件</strong>。</p>
<p>$\require{mediawiki-texvc}$</p>
<p>前面我们对INCAR，KPOINTS进行了批量操作，这一节，我们介绍对输入文件进行批量操作的最后一部分：POSCAR。 在这里，大师兄需要指出的是，批量操作的方式有很多种，大家千万不要仅仅局限在本书的例子里面，自己主动去思考这些命令的运行方式，将其运行的范围扩展，最后才能做到随心所欲，达到无招胜有招的境界。如果只跟着大师兄的教程去练习而不主动思考的话，时间长了思维就会被限制了。</p>
<p>此外，大师兄给的例子是都可以正确执行的，虽然易错的地方已经指出来了，但更希望大家主动去尝试自己理解不清楚的参数，主动去犯错，得到错误的结果时，印象会更加深刻些。有句古话说的好:纸上学来终觉浅，绝知此事要躬行。所以，行动是很有必要的。大家在此基础上多加尝试，尽可能多的犯错误，知道什么样的输入对应什么样的错误。</p>
<h3 id="POSCAR-批处理练习"><a href="#POSCAR-批处理练习" class="headerlink" title="POSCAR 批处理练习:"></a>POSCAR 批处理练习:</h3><p>前面我们将O原子放到了一个8$\times$ 8$\times$8 $\AA{^3}$ 的格子里。现在我们要创建不同大小的正方形格子，每个格子边长分别为8,10,12,14,16$\AA$。重复下面的操作，完成POSCAR的批量练习，并思考这些命令是怎么工作的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04$ mkdir poscar</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04$ cd poscar/</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04/poscar$ for i in $(seq 8 2 16); do cp -r ../../ex03/0.01 $&#123;i&#125;$&#123;i&#125;$&#123;i&#125; ; done </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04/poscar$ ls </span><br><span class="line">101010  121212  141414  161616  888</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04/poscar$ cat -n 888/POSCAR </span><br><span class="line">     1	O atom in a box </span><br><span class="line">     2	1.0            </span><br><span class="line">     3	8.0 0.0 0.0   </span><br><span class="line">     4	0.0 8.0 0.0  </span><br><span class="line">     5	0.0 0.0 8.0 </span><br><span class="line">     6	O          </span><br><span class="line">     7	1         </span><br><span class="line">     8	Cartesian</span><br><span class="line">     9	0 0 0           #</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04/poscar$ for i in $(seq 8 2 16); do sed -i &quot;3,5s/8/$i/g&quot; $&#123;i&#125;$&#123;i&#125;$&#123;i&#125;/POSCAR ; done </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04/poscar$ cat -n 888/POSCAR      </span><br><span class="line">1	O atom in a box </span><br><span class="line">     2	1.0            </span><br><span class="line">     3	8.0 0.0 0.0   </span><br><span class="line">     4	0.0 8.0 0.0  </span><br><span class="line">     5	0.0 0.0 8.0 </span><br><span class="line">     6	O          </span><br><span class="line">     7	1         </span><br><span class="line">     8	Cartesian</span><br><span class="line">     9	0 0 0           #</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04/poscar$ cat -n 101010/POSCAR </span><br><span class="line">     1	O atom in a box </span><br><span class="line">     2	1.0            </span><br><span class="line">     3	10.0 0.0 0.0   </span><br><span class="line">     4	0.0 10.0 0.0  </span><br><span class="line">     5	0.0 0.0 10.0 </span><br><span class="line">     6	O          </span><br><span class="line">     7	1         </span><br><span class="line">     8	Cartesian</span><br><span class="line">     9	0 0 0           #</span><br></pre></td></tr></table></figure>
<p><strong>命令详解:</strong></p>
<ul>
<li><p>seq 命令用来打印一系列的数字， 在这个例子中 seq 8 2 16 获取8到16之间的数字，间隔为2; 其中， 8  2 16 三个数字间需要用空格分开；看到这里你会想到之前我们使用的花括号 {}，对的，如果间隔是1的话， {1..9} 和 seq 1 1 9 以及 seq 1 9 是一样的; seq 1 9 中省略的是 seq 1 1 9 中间的 1，  因为它是默认值。但是这里我们数字的间隔是2，使用花括号则不能实现我们的目的。</p>
</li>
<li><p>for 循环的精髓:  for i in  $(seq 8 2 16);  </p>
<p>提醒1)：for循环这部分结束后，要跟一个是分号，不是冒号!!!</p>
<p>提醒2): $ 和 后面的括号之间没有空格!!! </p>
<p>大家可以主动把分号改成冒号或者在$后面加个空格，看看会出什么错。</p>
<p>在这里，调用seq 8 2 16这个命令的输出，我们用 到了$()  这个组合。它的作用是: 调用一个命令或者函数的输出，进而转化为for循环的对象集合。for i in $(seq 8 2 6) 等于for i in 8 10 12 14 16 。 </p>
</li>
<li><p>此外，你还会见到一些人使用 ` ` 这个符号(反单引号);  `seq 8 2 16`  的效果等于 $(seq 8 2 16)。所以，当你见到 ` ` 时，不要害怕，因为你知道里面是在调用一个命令或者函数，和 $() 效果是一样的。Linux下面有很多奇奇怪怪的字符，当你知道他们的意思时就见怪不怪了。</p>
</li>
<li><p>sed 命令，这里我们使用了 sed –i “3,5s/8/$i/g”  </p>
<p>3,5s 的意思是：选择第三行到第五行中所有的8；然后将它们替换成$i； </p>
</li>
</ul>
<p>有很多筒子不知道怎么一次性选择三行中的内容，便运行了这和循环命令三次:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed –i “3s/8.0/$i/g”</span><br><span class="line">sed –i “4s/8.0/$i/g”</span><br><span class="line">sed –i “5s/8.0/$i/g”</span><br></pre></td></tr></table></figure>
<p>效果是一样的，但3,5s这样更简洁，优美。希望大家可以认真学习sed的使用，达到炉火纯青的地步。后面我们也会在计算过程中继续介绍sed是如何发挥作用的。</p>
<p><strong>为什么说这是 for 循环的精髓呢?</strong></p>
<p>从for循环的语法上看，有两个主要部分：</p>
<p>1）第一个是选取对象，也就是for i in XXX 语句中的 XXX 部分;</p>
<p>2）另一个是去执行的动作， do YYY ; </p>
<p>对于do YYY 我们根据自己的要求或者要现实的目的，把命令填到YYY这一块就可以了。但是，对于前面的集合选取，这就需要大家脑洞大开了。最简单的是根据自己的任务要求选取合适的范围直接输入，比如 for i in 1 2 3 4 5 ;</p>
<p>再复杂些，我们使用一个函数，命令或者更高级的命令操作来得到所需范围，如本例中 for i in $(seq 8 2 16)。这个随着计算的进行，你的体会也就越来越深刻。</p>
<p>当我们准备计算输入文件，查看计算亦或者整理计算结果时，首先要对这些文件或者文件夹进行选择，即把需要处理的对象放在一起。为了保证for循环变量范围的高效选择，养成一个良好的计算习惯非常重要：那就是保持计算在不同目录下的一致性；也就是目录要规范，文件系统有序而整齐，根据不同的计算等级或者类型进行创建。如果文件夹一个套一个，随意创建，毫无规则可言，那么在用for循环的时候，工作效率就会大大地打折扣。</p>
<p> 在这里教给大家另外一个linux 命令：tree 来查看当前目录下的文件夹级别信息，用以给for循环提供合适的变量; (tree 和 tree -d， 尝试下有什么不同)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04$ ls</span><br><span class="line">kpoints  poscar</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04$ tree -d </span><br><span class="line">.</span><br><span class="line">├── kpoints</span><br><span class="line">│   ├── 111</span><br><span class="line">│   ├── 222</span><br><span class="line">│   ├── 333</span><br><span class="line">│   ├── 444</span><br><span class="line">│   ├── 555</span><br><span class="line">│   └── 666</span><br><span class="line">└── poscar</span><br><span class="line">    ├── 101010</span><br><span class="line">    ├── 121212</span><br><span class="line">    ├── 141414</span><br><span class="line">    ├── 161616</span><br><span class="line">    └── 888</span><br><span class="line"></span><br><span class="line">13 directories</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04$ </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04$ cd kpoints/</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04/kpoints$ ls</span><br><span class="line">111  222  333  444  555  666</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04/kpoints$ tree  </span><br><span class="line">.</span><br><span class="line">├── 111</span><br><span class="line">│   ├── INCAR</span><br><span class="line">│   ├── KPOINTS</span><br><span class="line">│   ├── POSCAR</span><br><span class="line">│   └── POTCAR</span><br><span class="line">├── 222</span><br><span class="line">│   ├── INCAR</span><br><span class="line">│   ├── KPOINTS</span><br><span class="line">│   ├── POSCAR</span><br><span class="line">│   └── POTCAR</span><br><span class="line">├── 333</span><br><span class="line">│   ├── INCAR</span><br><span class="line">│   ├── KPOINTS</span><br><span class="line">│   ├── POSCAR</span><br><span class="line">│   └── POTCAR</span><br><span class="line">├── 444</span><br><span class="line">│   ├── INCAR</span><br><span class="line">│   ├── KPOINTS</span><br><span class="line">│   ├── POSCAR</span><br><span class="line">│   └── POTCAR</span><br><span class="line">├── 555</span><br><span class="line">│   ├── INCAR</span><br><span class="line">│   ├── KPOINTS</span><br><span class="line">│   ├── POSCAR</span><br><span class="line">│   └── POTCAR</span><br><span class="line">└── 666</span><br><span class="line">    ├── INCAR</span><br><span class="line">    ├── KPOINTS</span><br><span class="line">    ├── POSCAR</span><br><span class="line">    └── POTCAR</span><br><span class="line"></span><br><span class="line">6 directories, 24 files</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex04/kpoints$ </span><br></pre></td></tr></table></figure>
<p>上面例子给出了一个非常清晰的文件目录结构。如果你在服务器上运行，发现下面的错误。且自己没有root权限安装tree这个命令，那么自动跳过这个练习或者在自己电脑的Linux系统上进行操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> tree</span><br><span class="line">-bash: tree: command not found</span><br></pre></td></tr></table></figure>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>本节我们学习了:</p>
<p>1) seq 命令获取数字序列的方法;</p>
<p>2) 使用 $() 将括号里面命令的输出转为for循环变量的方法;</p>
<p>3) sed 一次性选择多行的方法。</p>
<p>4) 保持文件系统有序而整齐，提高for 循环处理任务的效率。</p>
<p>前面这几节没有直接进入计算部分，是因为我们的一句古话：工欲善其事必先利其器。进行理论计算，学会最基本的相关操作知识非常重要。从前面这几节的学习，你会发现：懂得使用一个命令，可以节省很多时间; 但如果你懂得如何进一步发挥这个命令的作用，那么它会更加节省你的时间。省下来的时间你可以去看书，运动，谈恋爱…等等。想想都是很美好的事情。记得本人刚读博士的时候，组里的一个博后给我说：如果你想偷懒，那么就必须多动脑! 大家可以在运行完命令后，仔细体会下这句话的思想。而大家主动学习怎么去偷懒是最重要的。当然基本的命令操作只是科研中的一个小利器而已，真正的利器在于你扎实的理论化学基本功。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>批量处理</tag>
        <tag>for 循环</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex03 做计算常用的批量处理方法（三）</title>
    <url>/2017/10/22/ex03/</url>
    <content><![CDATA[<p>前面练习中我们在0.01的文件夹基础上，通过一个命令，复制得到了从0.02到0.09的文件夹。但是， 所有文件夹中的输入文件都是一样的，我们还需要把INCAR中的SIGMA参数值 SIGMA = 0.01 改成与文件夹对应的数值。 首先我们可以逐个进行编辑，但太浪费时间，这也不是大师兄的风格。Ex03练习分为2小节：</p>
<ul>
<li>新命令 sed 的学习</li>
<li>for + sed 组合</li>
</ul>
<p>最终我们会结合for循环和sed命令，来学会批量处理输入文本的另一个方法。<strong>还是要强调一下：</strong>大家要主动，多去网上找资料，并系统性的学习linux下面的基本命令。光指望着本书中的这么一点，是很难提高的。</p>
<h3 id="复习上一节的功课"><a href="#复习上一节的功课" class="headerlink" title="复习上一节的功课"></a>复习上一节的功课</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW$ ls</span><br><span class="line">ex01  ex02</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW$ mkdir ex03 </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW$ cp ex02/0.01 ex03 -r </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW$ cd ex03/0.01/</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex03/0.01$ cat INCAR  </span><br><span class="line">SYSTEM = O atom </span><br><span class="line">ISMEAR = 0       </span><br><span class="line">SIGMA = 0.01      </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex03/0.01$ cat INCAR  -n </span><br><span class="line">     1	SYSTEM = O atom </span><br><span class="line">     2	ISMEAR = 0       </span><br><span class="line">     3	SIGMA = 0.01      </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex03/0.01$ </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的操作依次为：</p>
<ul>
<li><p>新建ex03文件夹</p>
</li>
<li><p>将ex02中的0.01 复制到ex03中</p>
</li>
<li>进入ex03/0.01的目录中</li>
<li>使用cat 查看0.01中INCAR的内容</li>
<li>使用cat -n 查看INCAR中的内容，该选项在输出中给每一行标出了行数，方便我们查看。</li>
</ul>
<p><strong>注意:</strong> </p>
<p>1）Linux 下面的命令都有很多的选项，用以丰富我们的不同需求，比如上面的 cat -n，可以使用 man cat 这个命令查看 cat 的其他选项。使用这个命令后，如果想退出，敲 q 键即可;</p>
<p>2）另外，我们也可以使用 cat –help 来查看，效果与man cat 一样。</p>
<p><strong>sed 命令修改INCAR</strong></p>
<p>前面我们提到，可以使用vim打开INCAR然后修改SIGMA的参数。除了vim当然还有文本编辑器等其他的工具。但这些工具都有个缺点，就是得把文件打开后才能修改。下面我们使用sed命令，不打开文本，直接对里面的内容进行替换操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex03/0.01$ sed &#x27;3s/0.01/0.02/g&#x27; INCAR </span><br><span class="line">SYSTEM = O atom </span><br><span class="line">ISMEAR = 0       </span><br><span class="line">SIGMA = 0.02      </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex03/0.01$ cat INCAR  </span><br><span class="line">SYSTEM = O atom </span><br><span class="line">ISMEAR = 0       </span><br><span class="line">SIGMA = 0.01      </span><br></pre></td></tr></table></figure>
<p><strong>精解：</strong></p>
<p>1)     单引号中是我们的操作， 3s 表示的是选择第三行，因为我们知道 0.01 在第三行中出现，s 是substitute 的缩写<br>2)    3s 后面跟一个斜杠 /  用来和后面被替换的内容分开，这里0.01 表示选择第三行的0.01;</p>
<p>3)    0.01后面再用一个斜杠，将其和替换后的数字分开(0.01  0.02  0.03 等)，表示将0.01替换为斜杠后面的内容;</p>
<p>4)    再加一个斜杠，后面的g 代表 global ，意思是全部替换。</p>
<p>5)    输入完毕后，我们选择要执行该命令的对象(要替换的文件)，也就是当前目录下INCAR 文件。</p>
<p>6)     命令的意思就是：我们用sed命令，将INCAR中的第三行的0.01全部替换成0.02。</p>
<p>从上面实例中最后的cat INCAR命令结果不难发现，实际上我们并没有将INCAR文件中的0.01替换成0.02。也就是说这个命令只是输出了替换后的结果，但没有更新INCAR文件。那怎么样才可以更新INCAR文件呢？ 我们可以这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex03/0.01$ sed &#x27;3s/0.01/0.02/g&#x27; INCAR &gt; INCAR_new</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex03/0.01$ cat INCAR_new </span><br><span class="line">SYSTEM = O atom </span><br><span class="line">ISMEAR = 0       </span><br><span class="line">SIGMA = 0.02      </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex03/0.01$ mv INCAR_new  INCAR </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex03/0.01$ cat INCAR  </span><br><span class="line">SYSTEM = O atom </span><br><span class="line">ISMEAR = 0       </span><br><span class="line">SIGMA = 0.02      </span><br></pre></td></tr></table></figure>
<p>箭头（&gt;）的意思是：我们将命令的输出存到一个新的文件INCAR_new中，</p>
<p>通过mv命令之前的INCAR替换掉。</p>
<p>但，这样做也太麻烦了，更简单一点，如下：</p>
<p>前面例子的INCAR中SIGMA的值已经不是0.01了，我们先从ex02/0.01中复制一个过来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex03/0.01$ cp ../../ex02/0.01/INCAR  .</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex03/0.01$ cat INCAR  -n </span><br><span class="line">     1	SYSTEM = O atom </span><br><span class="line">     2	ISMEAR = 0       </span><br><span class="line">     3	SIGMA = 0.01      </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex03/0.01$ sed -i &#x27;3s/0.01/0.02/g&#x27; INCAR </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex03/0.01$ cat INCAR  -n </span><br><span class="line">     1	SYSTEM = O atom </span><br><span class="line">     2	ISMEAR = 0       </span><br><span class="line">     3	SIGMA = 0.02      </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex03/0.01$ </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>详解：</strong></p>
<p>sed –i 是sed 的命令和其附加选项， -i 表示直接对源文件进行编辑，也就是说编辑之后源文件被新文件替换掉。因此，使用这个参数的时候要小心，小心，再小心。要格外小心！！！</p>
<ul>
<li>最保险的做法就是运行前，先对操作的对象进行备份：如下：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex03/0.01$ cp INCAR  INCAR_back</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex03/0.01$ sed -i &#x27;3s/0.01/0.02/g&#x27; INCAR </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex03/0.01$ ls</span><br><span class="line">INCAR  INCAR_back  KPOINTS  POSCAR  POTCAR</span><br></pre></td></tr></table></figure>
<ul>
<li>其次是，先不加 -i 运行下sed命令，确保输出的是正确结果后，然后再加上 -i 运行.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex03/0.01$ cp INCAR_back  INCAR </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex03/0.01$ sed &#x27;3s/0.01/0.02/g&#x27; INCAR</span><br><span class="line">SYSTEM = O atom </span><br><span class="line">ISMEAR = 0       </span><br><span class="line">SIGMA = 0.02      </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex03/0.01$ sed -i &#x27;3s/0.01/0.02/g&#x27; INCAR</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex03/0.01$ cat INCAR  -n </span><br><span class="line">     1	SYSTEM = O atom </span><br><span class="line">     2	ISMEAR = 0       </span><br><span class="line">     3	SIGMA = 0.02    </span><br></pre></td></tr></table></figure>
<p><strong>小结:</strong></p>
<p>sed 是一个非常强大的命令，对于做计算的我们来说，熟练正确地使用sed可以极大的提高我们的工作效率，大家务必硬着头皮掌握这个命令。这个网站列举了一些基本的用法：</p>
<p><strong><a href="http://man.linuxde.net/sed">http://man.linuxde.net/sed</a></strong> </p>
<p>大家参照着进行练习，也可以百度里面搜索一些其他的 sed 使用技巧，如果你有认为很好的sed 技巧，也可以发邮件分享给大师兄（lqcata@gmail.com）。</p>
<p>本节我们学习2个批量操作：</p>
<ul>
<li>通过sed单个命令进行批量操作</li>
<li>以及sed + for循环的批量操作</li>
</ul>
<p>1  sed 批量将0.01到0.09中所有INCAR中的0.01替换成0.05。到现在为止，相信大家都可以看懂下面的命令操作。就不再啰嗦解释了。有一点需要注意的是grep 命令中的星号，检查输入输出的时候用*非常方便。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex03$ ls</span><br><span class="line">0.01</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex03$ </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex03$ for i in &#123;2..9&#125;; do cp 0.01 0.0$i -r ; done </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex03$ ls </span><br><span class="line">0.01  0.02  0.03  0.04  0.05  0.06  0.07  0.08  0.09</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex03$ grep SIGMA */INCAR</span><br><span class="line">0.01/INCAR:SIGMA = 0.01</span><br><span class="line">0.02/INCAR:SIGMA = 0.01</span><br><span class="line">0.03/INCAR:SIGMA = 0.01</span><br><span class="line">0.04/INCAR:SIGMA = 0.01</span><br><span class="line">0.05/INCAR:SIGMA = 0.01</span><br><span class="line">0.06/INCAR:SIGMA = 0.01</span><br><span class="line">0.07/INCAR:SIGMA = 0.01</span><br><span class="line">0.08/INCAR:SIGMA = 0.01</span><br><span class="line">0.09/INCAR:SIGMA = 0.01</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex03$ sed -i &#x27;3s/0.01/0.05/g&#x27; */INCAR</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex03$ grep SIGMA */INCAR</span><br><span class="line">0.01/INCAR:SIGMA = 0.05</span><br><span class="line">0.02/INCAR:SIGMA = 0.05</span><br><span class="line">0.03/INCAR:SIGMA = 0.05</span><br><span class="line">0.04/INCAR:SIGMA = 0.05</span><br><span class="line">0.05/INCAR:SIGMA = 0.05</span><br><span class="line">0.06/INCAR:SIGMA = 0.05</span><br><span class="line">0.07/INCAR:SIGMA = 0.05</span><br><span class="line">0.08/INCAR:SIGMA = 0.05</span><br><span class="line">0.09/INCAR:SIGMA = 0.05</span><br></pre></td></tr></table></figure>
<p>2 for 循环结合sed </p>
<p>前面我们使用sed命令，将文件夹中所有的0.01替换成了0.05。但我们的目标是，每个文件夹中的SIGMA值与文件夹相同。既然我们知道了sed可以对单个文件进行操作，那么我们也可以结合for循环，来实现一个批量操作的目的。命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex03$ ls</span><br><span class="line">0.01  0.02  0.03  0.04  0.05  0.06  0.07  0.08  0.09</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex03$ for i in *; do sed -i &quot;3s/0.05/$i/g&quot; $i/INCAR ; done  </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex03$ grep SIGMA */INCAR</span><br><span class="line">0.01/INCAR:SIGMA = 0.01</span><br><span class="line">0.02/INCAR:SIGMA = 0.02</span><br><span class="line">0.03/INCAR:SIGMA = 0.03</span><br><span class="line">0.04/INCAR:SIGMA = 0.04</span><br><span class="line">0.05/INCAR:SIGMA = 0.05</span><br><span class="line">0.06/INCAR:SIGMA = 0.06</span><br><span class="line">0.07/INCAR:SIGMA = 0.07</span><br><span class="line">0.08/INCAR:SIGMA = 0.08</span><br><span class="line">0.09/INCAR:SIGMA = 0.09</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>这里我们用的是双引号 “ “ ，sed 命令中你会见到大部分都用单引号 ‘ ‘ 。但如果这里使用单引号，则所有的 0.01 都会被替换成 $i (单引号中的$i 是纯字符)，因为单引号中的所有内容都会被当做字符来处理，也就是里面是什么就输出什么。使用双引号，则可以读取变量 $i 的值，下面的例子大家一看就知道怎么回事了:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex03$ abc=bigbro</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex03$ echo abc</span><br><span class="line">abc</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex03$ echo &#x27;$abc&#x27;</span><br><span class="line">$abc</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex03$ echo $abc</span><br><span class="line">bigbro</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex03$ echo &quot;$abc&quot;</span><br><span class="line">bigbro</span><br></pre></td></tr></table></figure>
<p>这里单引号中的内容被原封不动地打印出来了。而双引号的话，则可以顺利地把变量调用起来。</p>
<ul>
<li>for i in <em>;  这里的 </em> 指的是当前目录下所有的文件以及文件夹，本例中没有文件，只有从0.01， 0.02， 0.03 到 0.09 的文件夹；所以： for i in  *  =   for i in 0.01  0.02 0.03  0.04  0.05 0.06  0.07  0.08 0.09</li>
</ul>
<p>1.5.2 使用sed 命令将INCAR中的 0.05 (所有文件夹中的都是0.05)替换成文件夹的数字;  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -i &quot;3s/0.05/$i/g&quot; $i/INCAR </span><br></pre></td></tr></table></figure>
<p>当$i的值为0.01的时候，我们就把0.01/INCAR中的0.05替换为0.01；为0.02的时候，就把0.02/INCAR中的0.05替换为0.02，依次类推，直至for循环完成。</p>
<p>1.6 该命令瞬间运行完成，我们使用grep SIGMA 来查看下这些文件夹中的INCAR参数 ，圆满完成任务!</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在ex03的练习中，我们并不着急去提交任务，反正已经走了计算的路，以后提交任务的机会还多着呢，也不差这一两天的学习时间。先从简单到复杂些，逐渐掌握Linux的一节操作命令，对以后的学习帮助很大。</p>
<p>1) 学会 man command 或者 command –help 查看命令的具体参数;</p>
<p>2) 大量使用sed 命令进行操作练习;</p>
<p>3) 知道 * 在for循环中代表的含义</p>
<p>3) 熟知单引号和双引号的使用，以及区别</p>
<p>4) 主动搜索相关的Linux命令的相关知识，积极操练。</p>
<p>5) 学会从单一操作，通过for循环转化成批量操作的思路。</p>
<ul>
<li>for i in XXX; do YYY; done </li>
<li>XXX就是我们要操作的范围或者对象</li>
<li>YYY就是单一的一个操作。</li>
</ul>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>批量处理</tag>
        <tag>for 循环</tag>
        <tag>sed</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex05 VASP任务的提交</title>
    <url>/2017/10/26/ex05/</url>
    <content><![CDATA[<p>前面我们已经准备好了VASP的四个输入文件，学习了一系列的批量操作，那么该如何让vasp 算起来呢？每个课题组都会有自己不同的任务提交系统，大家可以向自己的师兄师姐学习提交任务的方法。此外，超算中心也是大家经常接触到的，本节通过吕梁超算中心资源（天河二号）的计算平台，介绍下具体的提交方法，任务的查看等基本操作。</p>
<h3 id="任务提交"><a href="#任务提交" class="headerlink" title="任务提交"></a>任务提交</h3><p>首先通过下面的命令，浏览一下具体的提交流程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW$ ls</span><br><span class="line">ex01  ex02  ex03  ex04</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW$ cp ex03/0.01 ex05</span><br><span class="line">cp: omitting directory `ex03/0.01&#x27;</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW$ cp ex03/0.01 ex05 -r </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW$ cd ex05/</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex05$ ls</span><br><span class="line">INCAR  KPOINTS  POSCAR  POTCAR</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex05$ cp ~/bin/job_check/job_sub  .</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex05$ cat job_sub </span><br><span class="line">#!/bin/bash</span><br><span class="line">export LD_LIBRARY_PATH=/THFS/opt/intel/composer_xe_2013_sp1.3.174/mkl/lib/intel64:$LD_LIBRARY_PATH</span><br><span class="line">yhrun -p gsc -n 24 /THFS/opt/vasp/5.4.4/vasp.5.4.4/bin/vasp_std </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex05$ yhbatch -p gsc -N 1 -J test job_sub </span><br><span class="line">Submitted batch job 983800</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li><p>提交任务的脚本，为~/bin/job_check目录下的job_sub文件。 脚本名字大家随便起，目录可以随便放，只要用的时候能保证找到即可。</p>
<ul>
<li>脚本里面指定了一些库的位置</li>
<li>使用的队列：这里是gsc，具体以自己购买的为准</li>
<li>-n 24 是指定每个节点的核数</li>
</ul>
</li>
<li><p>提交任务的命令为： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yhbatch -p gsc -N 1 -J test job_sub </span><br></pre></td></tr></table></figure>
<p>这里大家需要修改的主要有下面几个地方：</p>
<ul>
<li>gsc 是你计算的队列，这个在购买机时的时候，超算管理员会告诉你用哪个队列；对应的写上就可；</li>
<li>-N 后面的1是我们所用节点的个数，一个节点24个核（脚本里面已经指定了）</li>
<li>test是计算的任务名字，这个大家随便起；以第一眼能通过这个名字能辨别出是什么任务为佳；</li>
<li>job_sub就是脚本名，如果你把job_sub改成bigbro了，那么上面的命令行中，job_sub就需要改成bigbro了。</li>
</ul>
</li>
<li><p>网上也有很多实用的教程，大家可以多多浏览，比如： <a href="https://github.com/JiangLiNSCC/TH2-demos/wiki/%E5%A4%A9%E6%B2%B3%E4%BA%8C%E5%8F%B7%E7%AE%80%E6%98%8E%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C">天河二号简明使用手册</a>；也可以在超算的使用QQ群中交流，比如：国防科大吕梁超算中心QQ群：<strong>204521798</strong>。</p>
</li>
</ul>
<h3 id="任务查看"><a href="#任务查看" class="headerlink" title="任务查看"></a>任务查看</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex05$ ls</span><br><span class="line">CHG  CHGCAR  CONTCAR  DOSCAR  EIGENVAL  IBZKPT  INCAR  job_sub  KPOINTS  OSZICAR  OUTCAR  PCDAT  POSCAR  POTCAR  REPORT  slurm-983800.out  vasprun.xml  WAVECAR  XDATCAR</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex05$ yhq</span><br><span class="line">             JOBID    PARTITION                       NAME             USER ST       TIME  NODES NODELIST(REASON)</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex05$ tail OUTCAR</span><br><span class="line">                            User time (sec):        1.991</span><br><span class="line">                          System time (sec):        3.501</span><br><span class="line">                         Elapsed time (sec):        5.931</span><br><span class="line"></span><br><span class="line">                   Maximum memory used (kb):      104300.</span><br><span class="line">                   Average memory used (kb):           0.</span><br><span class="line"></span><br><span class="line">                          Minor page faults:         8571</span><br><span class="line">                          Major page faults:            0</span><br><span class="line">                 Voluntary context switches:         3090</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex05$</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>在上面的操作中，我们使用ls命令，发现目录下多了一堆文件出来，这说明任务运行了。前面已经给大家提了个醒，这些文件大部分都没用，所以不用被它们所吓倒，我们后面会一一解释。</p>
</li>
<li><p>由于只有一个O原子，任务很快就算完了。所以使用yhq这个命令查看运行状态时，也就得不到结果了。</p>
</li>
<li><p>判断一个任务是否算完，通过一个tail命令就可以完成。如果你发现和上面命令类似的结果，就说明任务算完了。</p>
</li>
<li><p>这里tail的命令用来输出某个文件最后的几行，如果想输出文件最前面的几行（通过-n 来实现），可以使用head文件，简单的操作实例如下，自己百度学习下其他相关的用法，熟练掌握。大师兄就不再啰嗦了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex05$ tail -n 5 OUTCAR</span><br><span class="line">                   Average memory used (kb):           0.</span><br><span class="line"></span><br><span class="line">                          Minor page faults:         8571</span><br><span class="line">                          Major page faults:            0</span><br><span class="line">                 Voluntary context switches:         3090</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex05$ head -n 6 OUTCAR</span><br><span class="line"> vasp.5.4.4.18Apr17-6-g9f103f2a35 (build Sep 22 2017 10:53:27) complex</span><br><span class="line"></span><br><span class="line"> executed on             LinuxIFC date 2018.11.12  03:58:57</span><br><span class="line"> running on   24 total cores</span><br><span class="line"> distrk:  each k-point on   24 cores,    1 groups</span><br><span class="line"> distr:  one band on NCORES_PER_BAND=   1 cores,   24 groups</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex05$ tail -n 5 OUTCAR | head -n 2</span><br><span class="line">                   Average memory used (kb):           0.</span><br><span class="line"></span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex05$</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本节我们通过超算中心简单展示了VASP任务的提交过程，本节需要掌握的内容主要有：</p>
<ul>
<li>会提交任务；</li>
<li>会查看任务；</li>
<li>知道VASP任务结束后，怎么通过tail命令判断。</li>
<li>学会使用：tail 和 head 这2个命令。</li>
</ul>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>超算中心</tag>
        <tag>吕梁</tag>
        <tag>天河二号</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex06 VASP的输出文件（一）</title>
    <url>/2017/10/27/ex06/</url>
    <content><![CDATA[<p>上一节，我们在天河II号顺利提交了VASP的计算，并看到了一堆的输出文件。我们就从简单的开始，一步一步给大家介绍VASP的输出文件，以及里面的细节部分。由于大家还处在一个刚刚接触VASP的阶段。我们先根据目前的计算，挑容易的，重要的进行介绍。最简单的非<code>CONTCAR</code>莫属了。</p>
<h3 id="CONTCAR-和-POSCAR的区别"><a href="#CONTCAR-和-POSCAR的区别" class="headerlink" title="CONTCAR 和 POSCAR的区别"></a><code>CONTCAR</code> 和 <code>POSCAR</code>的区别</h3><p>在VASP的输入文件中，我们用<code>POSCAR</code>来存储模型的结构信息。当我们使用VASP优化完成之后，就会得到一个新的结构，而<code>CONTCAR</code>就是用来存储新结构的文件。当然啦，我们这里只有一个O原子，不存在优化这一说法，但VASP只要算上了，就会有CONTCAR出现，不优化的的结果就是：<code>CONTCAR</code>和<code>POSCAR</code>的结构是一模一样的。但<code>CONTCAR</code>和<code>POSCAR</code>里面的内容可以一样，也可以不一样。在这里，大师兄把自己的个人经验都写在里面，新手看不懂的话不要紧，先记住这里有<code>CONTCAR</code>的相关注意信息，以后用的时候过来直接看即可。如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex05$ cat -n POSCAR </span><br><span class="line">     1	O atom <span class="keyword">in</span> a box </span><br><span class="line">     2	1.0            </span><br><span class="line">     3	8.0 0.0 0.0   </span><br><span class="line">     4	0.0 8.0 0.0  </span><br><span class="line">     5	0.0 0.0 8.0 </span><br><span class="line">     6	O          </span><br><span class="line">     7	1         </span><br><span class="line">     8	Cartesian</span><br><span class="line">     9	0 0 0           <span class="comment">#</span></span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex05$ cat -n CONTCAR </span><br><span class="line">     1	O atom <span class="keyword">in</span> a box                         </span><br><span class="line">     2	   1.00000000000000     </span><br><span class="line">     3	     8.0000000000000000    0.0000000000000000    0.0000000000000000</span><br><span class="line">     4	     0.0000000000000000    8.0000000000000000    0.0000000000000000</span><br><span class="line">     5	     0.0000000000000000    0.0000000000000000    8.0000000000000000</span><br><span class="line">     6	   O </span><br><span class="line">     7	     1</span><br><span class="line">     8	Direct</span><br><span class="line">     9	  0.0000000000000000  0.0000000000000000  0.0000000000000000</span><br><span class="line">    10	 </span><br><span class="line">    11	  0.00000000E+00  0.00000000E+00  0.00000000E+00</span><br></pre></td></tr></table></figure>
<p>对于当前的这个例子来说，主要的不同点在于：</p>
<ul>
<li>坐标的小数点位数。对比<code>POSCAR</code>和<code>CONTCAR</code>中：第1-5、9行的内容。</li>
<li>缩进部分：<ul>
<li><code>POSCAR</code>中，我们每一行都是顶格写的。</li>
<li><code>CONTCAR</code>中，从第二行开始，每一行的开头部分都是以空格开始的。此时，就必须要给大家强调一点：<code>CONTCAR</code>中开头的是空格，不是tab。第3-5行，你别看前面都空了那么多，都是一个个的空格，而不是tab。</li>
<li>这个一定要死死记住：<code>CONTCAR</code>或者<code>POSCAR</code>中，每一行中只有空格可以用来分割不同的内容或者开头，绝对不要用tab。否则你任务出错，花很多天都不一定能检查出来这个原因。</li>
</ul>
</li>
<li>体系的坐标系也发生了变化： 第8行。<code>POSCAR</code>中，我们使用的是笛卡尔坐标系，也就是<strong>Cartesian</strong>或者任何以大写的<code>C</code>，小写的<code>c</code>开头。但<code>CONTCAR</code>中则变成了分数坐标系，也就是<strong>Direct</strong>。 这个给我们的启示就是：<ul>
<li>如果想把体系从<strong>Cartesian</strong>转化为<strong>Direct</strong>，我们可以算一个单点。（单点的意思不明白，不要紧，后面我们会介绍）</li>
<li>我们的<code>POSCAR</code>可以使用<strong>Cartesian</strong>， 也可以使用<strong>Direct</strong>，这个看大家自己的习惯。本人喜欢用<strong>Cartesian</strong>，看起来更加直观一些。</li>
<li>由于我们的<code>O</code>原子在坐标系的原点（0,0,0）的位置，所以<strong>Direct</strong>和<strong>Cartesian</strong>看不出来区别。</li>
</ul>
</li>
<li>在<code>CONTCAR</code>中，还多了一行内容（第11行），这一行主要描述的是体系中原子在xyz三个方向移动相关的信息。因为我们体系只有一个原子，所以也就只多了一行。<ul>
<li>以后当你在优化结构的时候，体系中有多少原子，就会多出多少行出来，但全部都是0。</li>
<li>如果你跑的是分子动力学，那么这些行中就不是0了，代表的是分子移动的速度</li>
<li>如果你用<code>dimer</code>方法算过渡态的时候，那么这些行中是与过渡态结构相关的振动方式。</li>
<li>总结下：如果你不跑分子动力学，不用<code>dimer</code>方法算过渡态， 那么多出来的这些行都会是0，是可有可无的，对计算无任何影响。看着不爽，直接删掉即可。</li>
</ul>
</li>
</ul>
<h3 id="CONTCAR-的作用"><a href="#CONTCAR-的作用" class="headerlink" title="CONTCAR 的作用"></a><code>CONTCAR</code> 的作用</h3><p>这里新手暂时不要求，大师兄可能会将其移到其他的章节，只需要记住本书里面有<code>CONTCAR</code>的用法，以后再找下即可。通过上面的学习，我们知道，<code>CONTCAR</code>和<code>POSCAR</code>一样，就是用来保存优化结构的。可能有些地方与我们自己手动写的<code>POSCAR</code>有些不同（比如每行开始的空格），但只要你不用tab，这都是无关痛痒的事情。下面我们介绍一下<code>CONTCAR</code>的2个用法。</p>
<p>1） 计算完成之后，<code>CONTCAR</code>中是最后一步优化的结果。我们可以通过一些可视化的软件打开<code>CONTCAR</code>，检查计算的对不对。这个也是大家以后做计算最基本的工作。</p>
<p>2） 如果你的计算半路由于各种各样的原因给停掉了，服务器不稳定，断电，自己手欠误删任务或者将计算的文件夹位置移动了，都会导致计算失败。这个时候，我们就需要<strong>续算</strong>，<code>CONTCAR</code>的作用就展示出来了。续算又分为三种情况：</p>
<p>A）第一个离子步没有算完，任务就挂掉了。这种情况，<code>CONTCAR</code>是不会更新的，我们再次用原来的输入文件提交一次就行了。</p>
<p>B）我们的计算已经完成了大于或者等于1的离子步，但小于INCAR中设置的NSW的数值。这个时候CONTCAR的内容已经是离任务死掉最近的结构了。我们只需要将其复制成POSCAR，然后再次提交任务即可。具体操作如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv POSCAR POSCAR_0</span><br><span class="line">mv OUTCAR OUTCAR_0</span><br><span class="line">cp CONTCAR POSCAR </span><br></pre></td></tr></table></figure>
<p>师兄，你不是说只把CONTCAR复制成POSCAR就可以了吗？ 为什么前面还多了一个<code>mv</code>的命令?</p>
<p>在这里，大师兄要教给你做计算一个超级重要的原则：<strong>时时刻刻都要努力提高或者保证计算可重复性。</strong></p>
<p>因为我们的任务是从之前的<code>POSCAR</code>（标记为A）开始的，中途断掉了，直接把<code>CONTCAR</code>（标记为C_A）复制成<code>POSCAR</code>（标记为B）的话，我们就会损失掉前面优化的过程。相当于我们直接搭建了这个B这个结构进行优化计算。而实际上，我们后面的计算的性质是续算，而不是从头直接计算。虽然结果大部分情况都是一样的。所以在将<code>CONTCAR</code>复制成<code>POSCAR</code>计算之前，我们要尽可能把任务停掉前的计算过程保存记录下来。这就类似于写实验记录本，我们要从开始搭建设备到开展反应一系列的详细信息都记录在上面。而不能从半路直接跳着写。这也是很多人在做计算的时候，任务死掉后续算所忽略的一个很严肃的问题。</p>
<p>下面是大师兄本人在续算的时候所用到的一个保存前面计算的小脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">mv POSCAR POSCAR-$1</span><br><span class="line">mv OUTCAR OUTCAR-$1</span><br><span class="line">mv OSZICAR OSZICAR-$1</span><br><span class="line">mv vasprun.xml vasprun.xml-$1</span><br><span class="line">mv CONTCAR POSCAR</span><br></pre></td></tr></table></figure>
<p>通过这个脚本，我们扩展到第三种情况。</p>
<p>C）我们的计算达到的<code>INCAR</code>中所设置的<code>NSW</code>的数值。比如设置的<code>NSW = 1000</code>，实际上跑了<code>1000</code>步，任务停下来了，也就是所谓的结构优化没有收敛。这种情况我们需要做的又有2个步骤：</p>
<p>I）首先，要检查<code>CONTCAR</code>中的结构是不是正确的，如果结构跑乱了，体系中原子乱飞，有很大可能会导致不收敛的情况。如果是结构乱了，我们就要找原因去解决。主要还是在以下三个方向下功夫：</p>
<ul>
<li>初始结构是否合理</li>
<li><code>POSCAR</code>中的元素顺序与<code>POTCAR</code>中的是不是一致</li>
<li>是不是用的<code>gamma</code>点，然后把体系放开了。</li>
</ul>
<p>II）如果前面检查的结构没问题，这种情况，可能是因为你设置的NSW值太小导致的，或者体系是在是太难收敛，比如过渡态优化的情况。那么我们就需要继续算了。此时，为了保证计算的可重复性，我们必须要将上一步的计算保存记录下来。比如下面，大师兄本人的一个过渡态的优化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qli@tekla2:~/test$ ls</span><br><span class="line">CONTCAR    DOSCAR    EIGENVAL  INCAR    OSZICAR    OSZICAR-2  OUTCAR    OUTCAR-2  PCDAT   POSCAR-1  POSCAR-3  REPORT  sub16  vasprun.xml</span><br><span class="line">CONTCAR-1  DOSCAR-1  IBZKPT    KPOINTS  OSZICAR-1  OSZICAR-3  OUTCAR-1  OUTCAR-3  POSCAR  POSCAR-2  POTCAR    sub12   sub28</span><br><span class="line">qli@tekla2:~/test$ grep NSW INCAR</span><br><span class="line">NSW = 800</span><br><span class="line">qli@tekla2:~/test$ tail OSZICAR -n 3 </span><br><span class="line">RMM:   8    -0.339073663363E+03    0.17227E-04   -0.45367E-05  3703   0.126E-02    0.104E-02</span><br><span class="line">RMM:   9    -0.339073663179E+03    0.18447E-06   -0.78164E-06  2696   0.541E-03</span><br><span class="line"> 800 F= -.34272018E+03 E0= -.34270858E+03  d E =0.159932E-02</span><br><span class="line">qli@tekla2:~/test$ ls</span><br><span class="line">CONTCAR    DOSCAR    EIGENVAL  INCAR    OSZICAR    OSZICAR-2  OUTCAR    OUTCAR-2  PCDAT   POSCAR-1  POSCAR-3  REPORT  sub16  vasprun.xml</span><br><span class="line">CONTCAR-1  DOSCAR-1  IBZKPT    KPOINTS  OSZICAR-1  OSZICAR-3  OUTCAR-1  OUTCAR-3  POSCAR  POSCAR-2  POTCAR    sub12   sub28</span><br><span class="line">qli@tekla2:~/test$ save_calculations.sh 4</span><br><span class="line">qli@tekla2:~/$ ls</span><br><span class="line">CONTCAR-1  DOSCAR-1  IBZKPT  KPOINTS    OSZICAR-2  OSZICAR-4  OUTCAR-2  OUTCAR-4  POSCAR    POSCAR-2  POSCAR-4  REPORT  sub16  vasprun.xml-4</span><br><span class="line">DOSCAR     EIGENVAL  INCAR   OSZICAR-1  OSZICAR-3  OUTCAR-1   OUTCAR-3  PCDAT     POSCAR-1  POSCAR-3  POTCAR    sub12   sub28</span><br><span class="line">qli@tekla2:~/test$ vi INCAR</span><br><span class="line">qli@tekla2:~/ru_chbr/ads/high_coverage_br/1Br/ch3br/ts_c-br/test$ qsub sub12</span><br><span class="line">Your job 215093 (&quot;freq-4B2&quot;) has been submitted</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>详解：</strong></p>
<ul>
<li>前面的脚本名字为： <code>save_calculations.sh</code></li>
<li>在使用这个脚本前，大师兄已经算过3次了，每次都跑到了800步，没有收敛，而第四次依然没有收敛，就需要用脚本将当前第四次的计算记录下来下来；</li>
<li>脚本使用方法：<code>save_calculation.sh  N</code>  N为第几次算，这里用了4，然后就会得到相应的<code>POSCAR-4</code>， <code>OSZICAR-4</code>， <code>OUTCAR-4</code>等文件，记录第四次计算的细节；</li>
<li>保存之后，我们就可以提交任务继续苦苦等待了。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>到这里，CONTCAR的基本介绍以及作用差不多就讲完了。新手们看到后可能会很困惑，因为里面很多内容是大师兄临时加进去给有经验的人写的。只要记住一句话就完成本节的学习任务：CONTCAR的作用跟POSCAR一样，存储的是模型被优化过的结构信息。</p>
<p>上一节，我们学习了<code>CONTCAR</code>的一些基本内容。本着从简到易，从最常用到最不常用的原则，这一节，我们学习VASP的另外一个简单，但又很重要的的输出文件：<code>OSZICAR</code>。 </p>
<p>首先，推荐一个QE学习的视频：<a href="https://www.bilibili.com/video/av36194036">https://www.bilibili.com/video/av36194036</a> （用良心带人入坑）</p>
<h3 id="OSZICAR-的含义"><a href="#OSZICAR-的含义" class="headerlink" title="OSZICAR 的含义"></a><code>OSZICAR</code> 的含义</h3><p>师兄，<code>OSZICAR</code>是什么的缩写？为什么起这么一个名字？</p>
<p>不好意思，这个我真不知道。也没有认真去考证过。目前只能告诉大家先把这个名字记住。</p>
<h3 id="什么是优化？"><a href="#什么是优化？" class="headerlink" title="什么是优化？"></a>什么是优化？</h3><p>在介绍<code>OSZICAR</code>的内容和功能之前，有必要先给大家澄清一个计算中常见的词：优化。</p>
<p>计算一个体系，我们有<code>2</code>个优化过程：</p>
<ul>
<li>电子结构的优化： 可以理解为对某一固定的几何结构，迭代求解薛定谔方程来获得体系能量极小值的一个过程。这个迭代过程，每一次迭代求解都可以认为是电子结构的一个优化。（通常被大伙称为：电子步）</li>
<li>几何结构的优化：可以理解为在电子结构优化的结果上，获取原子的受力情况，然后根据受力情况，调节原子的位置，再进行电子结构优化，获取新的受力情况，然后再调节原子位置，一直重复这样的过程，直至找到体系势能面上一个极小值的过程。（通常被大伙称为：离子步）</li>
</ul>
<p>思考一下，我们的<code>O</code>原子，我们只可能对它进行电子结构的优化，因为它的几何结构不会发生变化。</p>
<h3 id="OSZICAR是干什么的？"><a href="#OSZICAR是干什么的？" class="headerlink" title="OSZICAR是干什么的？"></a><code>OSZICAR</code>是干什么的？</h3><p>当VASP迭代求解<code>O</code>原子电子结构的时候，整个过程就会记录在OSZICAR中。下面我们就看一下VASP官网对<code>OSZICAR</code>的解释说明：<a href="https://cms.mpi.univie.ac.at/wiki/index.php/OSZICAR">https://cms.mpi.univie.ac.at/wiki/index.php/OSZICAR</a></p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">Information about convergence speed and about the current step is written to stdout and to the **OSZICAR** <span class="keyword">file</span>. Always keep a copy of the **OSZICAR** <span class="keyword">file</span>, it might give important information.</span><br></pre></td></tr></table></figure>
<p>也就是说：<code>OSZICAR</code>是用来记录优化过程一些信息的文件。这里的优化过程既包括电子结构，又包括几何结构。</p>
<h3 id="OSZICAR长什么样子？"><a href="#OSZICAR长什么样子？" class="headerlink" title="OSZICAR长什么样子？"></a><code>OSZICAR</code>长什么样子？</h3><p>在Linux的终端中，使用Vim打开<code>OSZICAR</code>，你会得到类似下面的信息：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">       N       E                     dE             d eps       ncg     rms          rms（c）</span><br><span class="line">DAV:   <span class="number">1</span>     <span class="number">0.324969965196E+02</span>    <span class="number">0.32497E+02</span>   -<span class="number">0.10270E+03</span>    <span class="number">48</span>   <span class="number">0.977E+01</span></span><br><span class="line">DAV:   <span class="number">2</span>     <span class="number">0.501749892771E+00</span>   -<span class="number">0.31995E+02</span>   -<span class="number">0.31995E+02</span>    <span class="number">72</span>   <span class="number">0.202E+01</span></span><br><span class="line">DAV:   <span class="number">3</span>    -<span class="number">0.182605770767E-01</span>   -<span class="number">0.52001E+00</span>   -<span class="number">0.50521E+00</span>    <span class="number">48</span>   <span class="number">0.521E+00</span></span><br><span class="line">DAV:   <span class="number">4</span>    -<span class="number">0.203547758465E-01</span>   -<span class="number">0.20942E-02</span>   -<span class="number">0.20860E-02</span>    <span class="number">96</span>   <span class="number">0.333E-01</span></span><br><span class="line">DAV:   <span class="number">5</span>    -<span class="number">0.203547873947E-01</span>   -<span class="number">0.11548E-07</span>   -<span class="number">0.11210E-07</span>    <span class="number">48</span>   <span class="number">0.844E-04</span>    <span class="number">0.307E-01</span></span><br><span class="line">DAV:   <span class="number">6</span>    -<span class="number">0.213726161828E-01</span>   -<span class="number">0.10178E-02</span>   -<span class="number">0.17884E-03</span>    <span class="number">48</span>   <span class="number">0.111E-01</span>    <span class="number">0.155E-01</span></span><br><span class="line">DAV:   <span class="number">7</span>    -<span class="number">0.214708381542E-01</span>   -<span class="number">0.98222E-04</span>   -<span class="number">0.23522E-04</span>    <span class="number">48</span>   <span class="number">0.459E-02</span></span><br><span class="line">   <span class="number">1</span> F= -<span class="number">.21470838E-01</span> E0= -<span class="number">.13757722E-01</span>  d E =-<span class="number">.154262E-01</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>第一行中各项的含义：（没汉语解释的，大师兄也翻译不出来）</p>
<p>1） <code>N</code> 代表电子结构的迭代步数，通常被大家称为电子步。</p>
<p>2） <code>E</code> 代表当前电子步的体系能量;</p>
<p>3） <code>dE</code>当前电子步和上一步体系能量的差值;</p>
<p>4） <code>d eps</code> the change in the band structure energy; </p>
<p>5）<code>ncg</code> the number of evaluations of the Hamiltonian acting onto a wavefunction; </p>
<p>6） <code>rms</code>  the norm of the residuum of the trialwavefunctions （i.e. their approximate error）</p>
<p>7） <code>rms (c)</code> the difference between input and output charge density.</p>
</li>
<li><p>第二行中<code>DAV</code>的含义：</p>
<p>1） <code>Blocked Davidson algorithm</code>的缩写。看不懂不要紧，简单点：就是一个电子迭代求解的自洽算法。在对电子结构迭代求解的过程，前人们发展出了很多不同的算法。就好比是，从北京到南京，有很多种出行选择一样，可以坐火车，汽车，乘飞机，也可以步行，骑马，骑驴，骑自行车，等等。每一种出行方式都是一种算法。大家可以根据自己的情况，选择适合自己的出行方式。所以，对自己的研究方向，也需要找一个适合自己体系的合适的算法。</p>
<p>2） 除了<code>DAV</code>，今后你还会看到<code>RMM</code> （residual minimization scheme） 和 <code>CG</code> （conjugate-gradient algorithm）等等。选择不同的算法，第二行以及后面显示的也会有所区别。这点大家掌握即可。具体到每个算法怎么回事，当你计算算起来了，有余力，慢慢开始学习量化基础知识的时候再仔细琢磨。</p>
<p>3） 前面我们说了，要找一个适合自己体系的算法，是选<code>DAV</code>，<code>RMM</code>还是<code>CG</code>，亦或是其他的呢？ 这个可以在<code>INCAR</code>中通过参数<code>ALGO</code>设置，参考链接： <a href="https://cms.mpi.univie.ac.at/wiki/index.php/ALGO">https://cms.mpi.univie.ac.at/wiki/index.php/ALGO</a> 。一般来说，使用<code>ALGO = Fast</code>可以满足大部分的需求。可以理解为北京到南京出行，大家最常用的火车。</p>
<p>4） 师兄：这个氧原子的计算中，我们没有在<code>INCAR</code>中设置<code>DAV</code>这个算法相关的参数啊，为什么<code>OSZICAR</code>中还会出现<code>DAV</code>呢？</p>
<p>原因在于：同很多软件一样，<code>VASP</code>也有很多<code>默认的参数</code>，这就避免了当你不设置某个参数的时候进行不下去的尴尬局面，当然，有些相关的参数，你不设置的时候VASP也会罢工，这个我们以后再说。此时的计算，对于电子结构收敛的算法来说，默认的是<code>DAV</code>这个方法，也就是INCAR中： <code>ALGO = N</code>。</p>
<p>5）划重点：</p>
<p>我们知道<code>VASP</code>的<code>INCAR</code>设置中，有很多相应的参数。而新手恰恰在学习的过程中，由于不能在短时间了解这些参数的具体含义，使用方法，从而导致了不知道怎么去选择的情况。而就是在这种情况下，选择了胡搞。也就是<code>INCAR</code>中参数，认识的写上去，不认识的也写上去。这也恰恰是新手在计算过程中容易出错的一个主要原因。前面我们说了<code>VASP</code>有很多默认的参数，而新手在学习的时候，不能图快，要一步一个脚印地走。看见一个参数，就好好琢磨琢磨，争取理解透了，或者知道这个参数大体上怎么回事。如果你不认识的参数，千万不要写上去，使用默认的就可以。</p>
</li>
<li><p>最后一行：</p>
<p>1） <code>F</code>前面的 1 代表几何结构优化的次数（也称为离子步的步数），本练习只有1步。</p>
<p>2） <code>F =</code> 是体系的总能量, 与<code>OUTCAR</code>中 <code>free energy  TOTEN</code> 后面的值相等；（<code>OUTCAR</code>还没讲，暂且记住）</p>
<p>3） <code>E0</code> 后面的能量对应<code>OUTCAR</code>中 <code>energy (sigma-&gt;0)</code>后面的能量（下图到数第一行）。</p>
</li>
</ul>
<h3 id="OSZICAR-的作用"><a href="#OSZICAR-的作用" class="headerlink" title="OSZICAR 的作用"></a><code>OSZICAR</code> 的作用</h3><p>Always keep a copy of the <strong>OSZICAR</strong> file, it might give important information. 官网既然这么说，这表明OSZICAR确实很重要，重要在哪里呢？ </p>
<ul>
<li><p>整个体系的优化过程都记录下来了。（当然后面我们要讲的<code>OUTCAR</code>也以更加详细的方式将优化过程记下来了）但<code>OSZICAR</code>可以更加直观地观测我们体系优化过程中能量的变化过程。</p>
</li>
<li><p>通过<code>OSZICAR</code>获取体系的能量，也就是<code>E0</code>后面的那一项。<strong>很多人在使用<code>VASP</code>的时候，不知道该选择哪个能量</strong>，这里大师兄就告诉你：选择<code>E0</code>后面的即可。不管你有什么疑问，不管别人怎么跟你争论，都不要管，先老老实实记住：我们选<code>E0</code>后面的这个能量。随着你的学习，很多疑问自己就解开了。命令使用方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex05$ grep E0 OSZICAR  </span><br><span class="line">   1 F= -.21470838E-01 E0= -.13757722E-01  d E =-.154262E-01</span><br></pre></td></tr></table></figure>
</li>
<li><p>后面的学习中，我们会经常讲解<code>OSZICAR</code>相关的内容，由于时间的原因，也主要是因为新手才刚刚接触计算，就不做过多的解释。</p>
</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>这一节，我们需要了解和学习的内容主要有以下几个方面：</p>
<p>1） <code>VASP</code>计算中的优化：几何和电子结构优化大体有个了解</p>
<p>2）<code>OSZICAR</code>中各项的含义，争取多理解几个；</p>
<p>3）<code>DAV</code>对应的<code>INCAR</code>中<code>ALGO</code>是怎么设置的；一般来说<code>ALGO=FAST</code>可以满足大部分人的计算需求；</p>
<p>4）知道<code>VASP</code>有默认的参数，自己不要画蛇填足。保持<code>INCAR</code>干净整洁，不知道的，模糊不清的参数坚决不往<code>INCAR</code>里面写。</p>
<p>5）知道怎么从<code>OSZICAR</code>中获取体系的能量。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>CONTCAR</tag>
        <tag>续算</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex07 VASP的输出文件（三）</title>
    <url>/2017/10/29/ex07/</url>
    <content><![CDATA[<p><code>CONTCAR</code>、<code>OSZICAR</code>我们已经大体了解了一下，这一节我们我们学习VASP的另一个极其重要的输出文件：<code>OUTCAR</code>。前面我们介绍到<code>OSZICAR</code>中包含了体系结构优化，电子结构迭代收敛的简单信息。<code>OUTCAR</code>中也包含这些信息，而且比<code>OSZICAR</code>的内容更加详细。此外，计算的参数设置（<code>INCAR</code>中有的，以及默认的），K点的设置，赝势的基本信息，<code>VASP</code>的版本，体系的几何结构以及电子性质相关的内容，计算的时间等，也都包含在<code>OUTCAR</code>中。所以说，<code>OUTCAR</code>是关于我们当前计算的一个非常全面的，多方位的信息汇总。</p>
<p>信息太多，VASP官网也没有对<code>OUTCAR</code>一个很详细地描述，大部分都是穿插在INCAR的计算参数中介绍的。这是因为（本人自己瞎猜的）：</p>
<ul>
<li><code>VASP</code>可以计算的性质很多，每一个特定的任务都有其对应的输出内容，这就导致了<code>OUTCAR</code>的复杂多样性，比如说优化结构、频率、声子谱，能带、<code>DOS</code>等计算等，这些都会有特定的输出，需要用户根据自己的计算内容去学习；</li>
<li>另外一个原因就是里面的条目太多了，每一项单独解释都需要花费大量的时间。</li>
</ul>
<p>信息多，就会容易让人眼花缭乱，不知所措。本节，我们就理一理思路，揭开<code>OUTCAR</code>神秘的面纱，让大家心里不至于那么恐慌。之前我们说过，<code>VASP</code>有很多输出文件，日常用的也就那么几个，有些估计等你文章发表了都不一定能用上。这也同样适用于<code>OUTCAR</code>中的信息，虽然多，但大部分基本用不到。</p>
<p>首先要告诉大家的是，<code>VASP</code>各个输出部分之间用很长的横杠分割（——————————-），当你看到横杠的时候，就知道要进入结果的下一个部分内容了。举个<code>OUTCAR开头</code>的例子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> vasp.5.4.4.18Apr17-6-g9f103f2a35 (build Sep 22 2017 10:53:27) complex</span><br><span class="line"></span><br><span class="line"> executed on             LinuxIFC date 2018.11.12  03:58:57</span><br><span class="line"> running on   24 total cores</span><br><span class="line"> distrk:  each k-point on   24 cores，    1 groups</span><br><span class="line"> distr:  one band on NCORES_PER_BAND=   1 cores，   24 groups</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<p><code>VASP</code>的版本信息，在多少个核上运行。所以，如果你不知道，自己的任务是VASP哪个版本计算的，也不知道如何去<code>VASP</code>的安装目录查找版本信息，可以运行一下，然后在<code>OUTCAR</code>的开头去找。可以看到，后跟着一堆<code>-</code>，说明要进入下一部分内容（计算体系，参数）的描述了。分别是：<code>POTCAR</code>，<code>POSCAR</code>，<code>KPOINTS</code>，以及<code>INCAR</code>的信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> -----------------------------------------------------------------------------</span><br><span class="line">|                                                                             |</span><br><span class="line">|           W    W    AA    RRRRR   N    N  II  N    N   GGGG   !!!           |</span><br><span class="line">|           W    W   A  A   R    R  NN   N  II  NN   N  G    G  !!!           |</span><br><span class="line">|           W    W  A    A  R    R  N N  N  II  N N  N  G       !!!           |</span><br><span class="line">|           W WW W  AAAAAA  RRRRR   N  N N  II  N  N N  G  GGG   !            |</span><br><span class="line">|           WW  WW  A    A  R   R   N   NN  II  N   NN  G    G                |</span><br><span class="line">|           W    W  A    A  R    R  N    N  II  N    N   GGGG   !!!           |</span><br><span class="line">|                                                                             |</span><br><span class="line">|      For optimal performance we recommend to set                            |</span><br><span class="line">|        NCORE= 4 - approx SQRT( number of cores)                             |</span><br><span class="line">|      NCORE specifies how many cores store one orbital (NPAR=cpu/NCORE).     |</span><br><span class="line">|      This setting can  greatly improve the performance of VASP for DFT.     |</span><br><span class="line">|      The default，   NCORE=1            might be grossly inefficient         |</span><br><span class="line">|      on modern multi-core architectures or massively parallel machines.     |</span><br><span class="line">|      Do your own testing !!!!                                               |</span><br><span class="line">|      Unfortunately you need to use the default for GW and RPA calculations. |</span><br><span class="line">|      (for HF NCORE is supported but not extensively tested yet)             |</span><br><span class="line">|                                                                             |</span><br><span class="line"> -----------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"> POTCAR:    PAW_PBE O 08Apr2002</span><br><span class="line">   VRHFIN =O: s2p4</span><br><span class="line">   LEXCH  = PE</span><br><span class="line">   EATOM  =   432.3788 eV，   31.7789 Ry</span><br><span class="line"></span><br><span class="line">   TITEL  = PAW_PBE O 08Apr2002</span><br><span class="line">   LULTRA =        F    use ultrasoft PP ?</span><br><span class="line">   IUNSCR =        1    unscreen: 0-lin 1-nonlin 2-no</span><br><span class="line">   RPACOR =    1.200    partial core radius</span><br><span class="line">   POMASS =   16.000; ZVAL   =    6.000    mass and valenz</span><br><span class="line">   RCORE  =    1.520    outmost cutoff radius</span><br><span class="line">   RWIGS  =    1.550; RWIGS  =    0.820    wigner-seitz radius (au A)</span><br><span class="line">   ENMAX  =  400.000; ENMIN  =  300.000 eV</span><br><span class="line">   ICORE  =        2    local potential</span><br><span class="line">   LCOR   =        T    correct aug charges</span><br><span class="line">   LPAW   =        T    paw PP</span><br><span class="line">   EAUG   =  605.392</span><br><span class="line">   DEXC   =    0.000</span><br><span class="line">   RMAX   =    1.553    core radius for proj-oper</span><br><span class="line">   RAUG   =    1.300    factor for augmentation sphere</span><br><span class="line">   RDEP   =    1.550    radius for radial grids</span><br><span class="line">   RDEPT  =    1.329    core radius for aug-charge</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>基本上每次运行的时候，（即使你的输入是正确的），<code>VASP</code>都会输出一个大大的<code>WARNING</code>来吓唬你，不用担心，无视即可。但如果你的计算失败了，这个警告信息<strong>或许</strong>（个人感觉基本没用）对你排查错误可能会有所帮助。 <code>WARNING</code>下面是<code>POTCAR</code>的基本信息，如果你想通过<code>OUTCAR</code>查看<code>POTCAR中</code>的元素时，可以使用下面的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep POTCAR OUTCAR</span><br><span class="line">grep TIT OUTCAR</span><br><span class="line">grep ENMAX OUTCAR</span><br><span class="line">grep ZVAL OUTCAR # </span><br></pre></td></tr></table></figure>
<p><code>ZVAL</code>是该<code>POTCAR</code>中对应元素的价电子，这里氧原子含有6个外层价电子。你可以自行对比下<code>POTCAR</code>中的内容。再往下，就是<code>POSCAR</code>的内容：坐标格式，原子位置，以及晶胞的形状大小。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> ion  position               nearest neighbor table</span><br><span class="line">   1  0.000  0.000  0.000-</span><br><span class="line"></span><br><span class="line">  LATTYP: Found a simple cubic cell.</span><br><span class="line"> ALAT       =     8.0000000000</span><br><span class="line"></span><br><span class="line">  Lattice vectors:</span><br><span class="line"></span><br><span class="line"> A1 = (   8.0000000000，   0.0000000000，   0.0000000000)</span><br><span class="line"> A2 = (   0.0000000000，   8.0000000000，   0.0000000000)</span><br><span class="line"> A3 = (   0.0000000000，   0.0000000000，   8.0000000000)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Analysis of symmetry for initial positions (statically):</span><br><span class="line">=====================================================================</span><br><span class="line"> Subroutine PRICEL returns:</span><br><span class="line"> Original cell was already a primitive cell.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Routine SETGRP: Setting up the symmetry group for a</span><br><span class="line"> simple cubic supercell.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Subroutine GETGRP returns: Found 48 space group operations</span><br><span class="line"> (whereof 48 operations were pure point group operations)</span><br><span class="line"> out of a pool of 48 trial point group operations.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">The static configuration has the point symmetry O_h .</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Analysis of symmetry for dynamics (positions and initial velocities):</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>体系的对称性以及点群操作相关的信息，在这里我们的体系是立方体，为<code>O_h</code>的点群，有48个对称操作。群论的知识大师兄早已原封不动地还给老师了，在这里就不再详细介绍了…</p>
<p>K点信息：想查看K点个数：<code>grep irreducible OUTCAR</code>  或者 <code>grep irre OUTCAR</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> Subroutine IBZKPT returns following result:</span><br><span class="line"> ===========================================</span><br><span class="line"></span><br><span class="line"> Found      1 irreducible k-points:</span><br><span class="line"></span><br><span class="line"> Following reciprocal coordinates:</span><br><span class="line">            Coordinates               Weight</span><br><span class="line">  0.000000  0.000000  0.000000      1.000000</span><br><span class="line"></span><br><span class="line"> Following cartesian coordinates:</span><br><span class="line">            Coordinates               Weight</span><br><span class="line">  0.000000  0.000000  0.000000      1.000000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<p><strong>下一部分就是<code>INCAR</code>的参数：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SYSTEM =  O atom</span><br><span class="line">POSCAR =  O atom in a box</span><br><span class="line"></span><br><span class="line">Startparameter for this run:</span><br><span class="line">  NWRITE =      2    write-flag &amp; timer</span><br><span class="line">  PREC   = normal    normal or accurate (medium， high low for compatibility)</span><br><span class="line">  ISTART =      0    job   : 0-new  1-cont  2-samecut</span><br><span class="line">  ICHARG =      2    charge: 1-file 2-atom 10-const</span><br><span class="line">  ISPIN  =      1    spin polarized calculation?</span><br><span class="line">  LNONCOLLINEAR =      F non collinear calculations</span><br><span class="line">  LSORBIT =      F    spin-orbit coupling</span><br><span class="line">  INIWAV =      1    electr: 0-lowe 1-rand  2-diag</span><br><span class="line">  LASPH  =      F    aspherical Exc in radial PAW</span><br><span class="line">  METAGGA=      F    non-selfconsistent MetaGGA calc.</span><br><span class="line"></span><br><span class="line">Electronic Relaxation 1</span><br><span class="line">  ENCUT  =  400.0 eV  29.40 Ry    5.42 a.u.  13.05 13.05 13.05*2*pi/ulx，y，z</span><br><span class="line">  ENINI  =  400.0     initial cutoff</span><br><span class="line">  ENAUG  =  605.4 eV  augmentation charge cutoff</span><br><span class="line">  NELM   =     60;   NELMIN=  2; NELMDL= -5     # of ELM steps</span><br><span class="line">  EDIFF  = 0.1E-03   stopping-criterion for ELM</span><br><span class="line">  LREAL  =      F    real-space projection</span><br><span class="line">  NLSPLINE    = F    spline interpolate recip. space projectors</span><br><span class="line">  LCOMPAT=      F    compatible to vasp.4.4</span><br><span class="line">  GGA_COMPAT  = T    GGA compatible to vasp.4.4-vasp.4.6</span><br><span class="line">  LMAXPAW     = -100 max onsite density</span><br><span class="line">  LMAXMIX     =    2 max onsite mixed and CHGCAR</span><br><span class="line">  VOSKOWN=      0    Vosko Wilk Nusair interpolation</span><br><span class="line">  ROPT   =    0.00000</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>计算参数详情（默认的参数值以及代表的意义也列出来了，这个地方大家仔细看下， 一些不常见的参数，<code>VASP</code>会自动采用默认值。上面给我们的启示就是：不懂就不要写，默认就可，很多默认的参数也没必要在<code>INCAR</code>里面再额外写一遍！<strong>强调一下</strong>，不知道的参数，不要瞎往<code>INCAR</code>里面放！新手的话经常会加一些乱七八糟的参数，导致计算错误。）</p>
<p>在统计完任务的基本输入后，<code>VASP</code>会总结一下本计算的文字描述，任务类型，体系大小，K点数目，计算所需的内存等信息。然后开始进入正式的计算部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> Static calculation</span><br><span class="line"> charge density and potential will be updated during run</span><br><span class="line"> non-spin polarized calculation</span><br><span class="line"> Variant of blocked Davidson</span><br><span class="line"> Davidson routine will perform the subspace rotation</span><br><span class="line"> perform sub-space diagonalisation</span><br><span class="line">    after iterative eigenvector-optimisation</span><br><span class="line"> modified Broyden-mixing scheme， WC =      100.0</span><br><span class="line"> initial mixing is a Kerker type mixing with AMIX =  0.4000 and BMIX =      1.0000</span><br><span class="line"> Hartree-type preconditioning will be used</span><br><span class="line"> using additional bands           21</span><br><span class="line"> reciprocal scheme for non local part</span><br><span class="line"> use partial core corrections</span><br><span class="line"> calculate Harris-corrections to forces</span><br><span class="line">   (improved forces if not selfconsistent)</span><br><span class="line"> use gradient corrections</span><br><span class="line"> use of overlap-Matrix (Vanderbilt PP)</span><br><span class="line"> Gauss-broadening in eV      SIGMA  =   0.01</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  energy-cutoff  :      400.00</span><br><span class="line">  volume of cell :      512.00</span><br><span class="line">      direct lattice vectors                 reciprocal lattice vectors</span><br><span class="line">     8.000000000  0.000000000  0.000000000     0.125000000  0.000000000  0.000000000</span><br><span class="line">     0.000000000  8.000000000  0.000000000     0.000000000  0.125000000  0.000000000</span><br><span class="line">     0.000000000  0.000000000  8.000000000     0.000000000  0.000000000  0.125000000</span><br><span class="line"></span><br><span class="line">  length of vectors</span><br><span class="line">     8.000000000  8.000000000  8.000000000     0.125000000  0.125000000  0.125000000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> k-points in units of 2pi/SCALE and weight: K-POINTS</span><br><span class="line">   0.00000000  0.00000000  0.00000000       1.000</span><br><span class="line"></span><br><span class="line"> k-points in reciprocal lattice and weights: K-POINTS</span><br><span class="line">   0.00000000  0.00000000  0.00000000       1.000</span><br><span class="line"></span><br><span class="line"> position of ions in fractional coordinates (direct lattice)</span><br><span class="line">   0.00000000  0.00000000  0.00000000</span><br><span class="line"></span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"></span><br><span class="line"> total amount of memory used by VASP MPI-rank0    35846. kBytes</span><br><span class="line">=======================================================================</span><br><span class="line"></span><br><span class="line">   base      :      30000. kBytes</span><br><span class="line">   nonl-proj :        746. kBytes</span><br><span class="line">   fftplans  :       1114. kBytes</span><br><span class="line">   grid      :       3834. kBytes</span><br><span class="line">   one-center:          3. kBytes</span><br><span class="line">   wavefun   :        149. kBytes</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于O原子的计算来说，就是一个离子步内，电子步的迭代。这里我们只展示一个电子步的迭代信息即可，剩下的格式是一样的。大家在自己查看的时候注意能量在不同迭代步数中的变化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--------------------------------------- Iteration      1(   1)  ---------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    POTLOK:  cpu time    0.0240: real time    0.0324</span><br><span class="line">    SETDIJ:  cpu time    0.0030: real time    0.0040</span><br><span class="line">     EDDAV:  cpu time    0.0320: real time    0.0397</span><br><span class="line">       DOS:  cpu time    0.0020: real time    0.0020</span><br><span class="line">    --------------------------------------------</span><br><span class="line">      LOOP:  cpu time    0.0610: real time    0.0781</span><br><span class="line"></span><br><span class="line"> eigenvalue-minimisations  :    48</span><br><span class="line"> total energy-change (2. order) : 0.3249700E+02  (-0.1026971E+03)</span><br><span class="line"> number of electron       6.0000000 magnetization</span><br><span class="line"> augmentation part        6.0000000 magnetization</span><br><span class="line"></span><br><span class="line"> Free energy of the ion-electron system (eV)</span><br><span class="line">  ---------------------------------------------------</span><br><span class="line">  alpha Z        PSCENC =         0.27139542</span><br><span class="line">  Ewald energy   TEWEN  =       -91.92708002</span><br><span class="line">  -Hartree energ DENC   =      -281.84385743</span><br><span class="line">  -exchange      EXHF   =         0.00000000</span><br><span class="line">  -V(xc)+E(xc)   XCENC  =        26.06853627</span><br><span class="line">  PAW double counting   =       346.54947689     -348.34814756</span><br><span class="line">  entropy T*S    EENTRO =        -0.00000000</span><br><span class="line">  eigenvalues    EBANDS =       -50.53652309</span><br><span class="line">  atomic energy  EATOM  =       432.26319604</span><br><span class="line">  Solvation  Ediel_sol  =         0.00000000</span><br><span class="line">  ---------------------------------------------------</span><br><span class="line">  free energy    TOTEN  =        32.49699652 eV</span><br><span class="line"></span><br><span class="line">  energy without entropy =       32.49699652  energy(sigma-&gt;0) =       32.49699652</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>每一电子步完成后，输出结果同时在<code>OSZICAR</code>中更新一行。</p>
<p>其中各项的具体含义：</p>
<p>alpha Z and the Ewald energy define the electrostatic  interaction of the ions in a compensating electron gas. The alpha Z component deals with the divergent parts (G=0). The following parts are the Hartree and exchange correlation energy as defined in the Kohn-Sham Hamiltonian. The entropy part stems from the smearing (using the free energy as variational parameter， electronic entropy)， EBANDS from Kohn-Sham eigenvalues， and EATOM is the reference energy for the potential (which is defined in the POTCAR file). </p>
<p>（摘自：<a href="https://cms.mpi.univie.ac.at/vasp-forum/viewtopic.php?t=273）">https://cms.mpi.univie.ac.at/vasp-forum/viewtopic.php?t=273）</a></p>
<p>迭代结束，输出主要的结果：费米能级以及能带信息。</p>
<p><code>Band 1</code> 对应的是2个 2s 电子，</p>
<p><code>Band 2-4</code> 对应的是4个2p电子。固体物理中，费米能级对应的是最高电子占据轨道的能量，也就是<code>HOMO</code>，大家可以对比下<code>band 2-4</code>的能量和费米能级的能量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> average (electrostatic) potential at core</span><br><span class="line">  the test charge radii are     0.7215</span><br><span class="line">  (the norm of the test charge is              1.0000)</span><br><span class="line">       1 -83.5438</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> E-fermi :  -8.9011     XC(G=0):  -0.8049     alpha+bet : -0.1463</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> k-point     1 :       0.0000    0.0000    0.0000</span><br><span class="line">  band No.  band energies     occupation</span><br><span class="line">      1     -23.8440      2.00000</span><br><span class="line">      2      -8.9041      1.33333</span><br><span class="line">      3      -8.9041      1.33333</span><br><span class="line">      4      -8.9041      1.33333</span><br><span class="line">      5      -0.4682      0.00000</span><br><span class="line">      6       1.8628      0.00000</span><br><span class="line">      7       1.8628      0.00000</span><br><span class="line">      8       1.8628      0.00000</span><br><span class="line">      9       1.9954      0.00000</span><br><span class="line">     10       2.0322      0.00000</span><br><span class="line">     11       2.0322      0.00000</span><br><span class="line">     12       4.0245      0.00000</span><br><span class="line">     13       4.0245      0.00000</span><br><span class="line">     14       4.0245      0.00000</span><br><span class="line">     15       4.1983      0.00000</span><br><span class="line">     16       4.1983      0.00000</span><br><span class="line">     17       4.1983      0.00000</span><br><span class="line">     18       4.4039      0.00000</span><br><span class="line">     19       4.4039      0.00000</span><br><span class="line">     20       4.4555      0.00000</span><br><span class="line">     21       4.4555      0.00000</span><br><span class="line">     22       4.4555      0.00000</span><br><span class="line">     23       4.7550      0.00000</span><br><span class="line">     24       6.4902      0.00000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>费米能级的获取：<code>grep E-fermi OUTCAR</code></p>
<p>各个方向力的大小，体系的坐标（和<code>CONTCAR</code>是一样的），以及体系的能量。下面第一行的意思是达到了我们设置的收敛标准，迭代停止了。（后面我们会详细介绍收敛相关的事项，大家先有个印象。）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">------------------------ aborting loop because EDIFF is reached ----------------------------------------</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"></span><br><span class="line">  FORCE on cell =-STRESS in cart. coord.  units (eV):</span><br><span class="line">  Direction    XX          YY          ZZ          XY          YZ          ZX</span><br><span class="line">  --------------------------------------------------------------------------------------</span><br><span class="line">  Alpha Z     0.27140     0.27140     0.27140</span><br><span class="line">  Ewald     -30.64236   -30.64236   -30.64236     0.00000     0.00000     0.00000</span><br><span class="line">  Hartree    93.90340    93.90340    93.90340    -0.00000    -0.00000    -0.00000</span><br><span class="line">  E(xc)     -27.94710   -27.94710   -27.94710     0.00000     0.00000     0.00000</span><br><span class="line">  Local    -147.84573  -147.84573  -147.84573     0.00000    -0.00000     0.00000</span><br><span class="line">  n-local   -20.54959   -20.54959   -20.54959    -0.00000    -0.00000    -0.00000</span><br><span class="line">  augment     5.55385     5.55385     5.55385    -0.00000     0.00000    -0.00000</span><br><span class="line">  Kinetic   126.51138   126.51138   126.51138     0.00000     0.00000     0.00000</span><br><span class="line">  Fock        0.00000     0.00000     0.00000     0.00000     0.00000     0.00000</span><br><span class="line">  -------------------------------------------------------------------------------------</span><br><span class="line">  Total      -0.74475    -0.74475    -0.74475     0.00000    -0.00000     0.00000</span><br><span class="line">  in kB      -2.33051    -2.33051    -2.33051     0.00000    -0.00000     0.00000</span><br><span class="line">  external pressure =       -2.33 kB  Pullay stress =        0.00 kB</span><br><span class="line"></span><br><span class="line"> VOLUME and BASIS-vectors are now :</span><br><span class="line"> -----------------------------------------------------------------------------</span><br><span class="line">  energy-cutoff  :      400.00</span><br><span class="line">  volume of cell :      512.00</span><br><span class="line">      direct lattice vectors                 reciprocal lattice vectors</span><br><span class="line">     8.000000000  0.000000000  0.000000000     0.125000000  0.000000000  0.000000000</span><br><span class="line">     0.000000000  8.000000000  0.000000000     0.000000000  0.125000000  0.000000000</span><br><span class="line">     0.000000000  0.000000000  8.000000000     0.000000000  0.000000000  0.125000000</span><br><span class="line"></span><br><span class="line">  length of vectors</span><br><span class="line">     8.000000000  8.000000000  8.000000000     0.125000000  0.125000000  0.125000000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  FREE ENERGIE OF THE ION-ELECTRON SYSTEM (eV)</span><br><span class="line">  ---------------------------------------------------</span><br><span class="line">  free  energy   TOTEN  =        -0.02147084 eV</span><br><span class="line"></span><br><span class="line">  energy  without entropy=       -0.00604461  energy(sigma-&gt;0) =       -0.01375772</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的能能量有好几个，很多人不知道该用哪一个。前面我们讲解<code>OSZICAR</code>的时候，告诉大家要使用E0后面的那个数值，那么在<code>OUTCAR</code>中与<code>E0</code>对应（相同）的是<code>energy(sigma-&gt;0) =</code> 后面的那个。所以，在今后的学习中，我们不要再提问使用OUTCAR中的哪个能量的问题了。提取能量的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep  without OUTCAR | tail -n 1</span><br><span class="line">grep &#x27;  without&#x27; OUTCAR | tail -n 1  # 本人常用的是这个</span><br><span class="line">grep sigma OUTCAR | tail -n 1 </span><br></pre></td></tr></table></figure>
<p>之所以用<code>tail -n 1</code>是为了保证我们取的是最后一步的能量。O原子肯定就一步，但以后优化结构的时候，就有很多步了。这里有一点需要注意的是：前面出现了一个<code>entropy</code>，也就是熵。但这个<code>Entropy</code>是采用<code>ISMEAR</code>方法而导致的，与物理化学中的熵这个概念不一样，如果你要计算熵，则需要通过计算频率，然后通过公式求解。看不懂不要紧：记住这里的<code>Entropy</code>不是物化书中的就OK。</p>
<p>再往下是实际计算的内存和时间等信息，看到下面，说明计算正常结束了。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> writing wavefunctions</span><br><span class="line">     LOOP+:  cpu time    2.0037: real time    2.1098</span><br><span class="line">    4ORBIT:  cpu time    0.0000: real time    0.0000</span><br><span class="line"></span><br><span class="line"> total amount of memory used by VASP MPI-rank0    35846. kBytes</span><br><span class="line">=======================================================================</span><br><span class="line"></span><br><span class="line">   base      :      30000. kBytes</span><br><span class="line">   nonl-proj :        746. kBytes</span><br><span class="line">   fftplans  :       1114. kBytes</span><br><span class="line">   grid      :       3834. kBytes</span><br><span class="line">   one-center:          3. kBytes</span><br><span class="line">   wavefun   :        149. kBytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> General timing and accounting informations for this job:</span><br><span class="line"> ========================================================</span><br><span class="line"></span><br><span class="line">                  Total CPU time used (sec):        5.492</span><br><span class="line">                            User time (sec):        1.991</span><br><span class="line">                          System time (sec):        3.501</span><br><span class="line">                         Elapsed time (sec):        5.931</span><br><span class="line"></span><br><span class="line">                   Maximum memory used (kb):      104300.</span><br><span class="line">                   Average memory used (kb):           0.</span><br><span class="line"></span><br><span class="line">                          Minor page faults:         8571</span><br><span class="line">                          Major page faults:            0</span><br><span class="line">                 Voluntary context switches:         3090</span><br></pre></td></tr></table></figure>
<p>分析完前面的内容，大家会发现：具体到里面各项的含义以及各个细节上，还有很多值得讨论的地方，比如群论，薛定谔方程求解过程，<code>POTCAR</code>的相关信息等。对于新手来说，看完本节，能大体浏览下来，知道各个部分包含什么内容就很不错了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本练习中，带领大家粗略浏览了一遍<code>OUTCAR</code>各部分的信息。大家在浏览的时候时刻要思考：</p>
<ul>
<li>这部分包含的什么内容，具有什么物理或者化学意义？  </li>
<li>怎么用<code>grep 关键词</code>获取有用的信息等。 </li>
<li>怎么获取体系的能量；知道用众多能量中的哪一个。</li>
<li>如何将<code>OUTCAR</code>的内容与计算的输入和输出文件关联起来。</li>
<li>由于计算内容的多样性，对于<code>OUTCAR</code>的详细解释，需要很多的时间和精力去完成补充。一次性解释清楚是不可能的事情，所以在后续的计算过程中，我们还会结合具体的例子进行讲解。</li>
</ul>
<p> 一般来说，等你计算上手之后，<code>OUTCAR</code>里面的很多内容，可能等课题结束或者毕业了，都不会用到。更进一步说，你可能都不需要打开<code>OUTCAR</code>了。因此，完全不用担心里面的很多内容不理解。但，这不是我们偷懒的理由，如果你想把<code>VASP</code>学好，学精，这些都需要自己下功夫去琢磨，理解。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>OUTCAR</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex08 氧原子能量的正确计算</title>
    <url>/2017/10/30/ex08/</url>
    <content><![CDATA[<h1 id="本节提要"><a href="#本节提要" class="headerlink" title="本节提要"></a>本节提要</h1><p>前面的扩展练习中,要求大家结合自己的化学知识,判断计算结果是否正确。相比很多同学已经知道了氧原子含有磁性,我们在计算用需要考虑进去。在本节练习中,大师兄教给你如何分分析氧原子在轨道中的占据情况,判断计算是否合理,并正确进行氧原子能量的计算。</p>
<h1 id="氧原子轨道"><a href="#氧原子轨道" class="headerlink" title="氧原子轨道"></a>氧原子轨道</h1><p>氧原子的电子构型是 $1s^2 2s^2 2p^4$ ,轨道占据情况如图:</p>
<p><img src="/2017/10/30/ex08/oxygen_occupation.jpg" alt=""></p>
<p>所以氧原子含有两个单电子,具有磁性,且磁矩为2 $μ_B$。</p>
<h1 id="计算结果"><a href="#计算结果" class="headerlink" title="计算结果"></a>计算结果</h1><p>我们看一下前面的计算结果:</p>
<h2 id="OSZICAR"><a href="#OSZICAR" class="headerlink" title="OSZICAR"></a>OSZICAR</h2><p><img src="/2017/10/30/ex08/OSZICAR.jpg" alt="OSZICAR"></p>
<h2 id="能量信息"><a href="#能量信息" class="headerlink" title="能量信息:"></a>能量信息:</h2><p><img src="/2017/10/30/ex08/TOTEN.jpg" alt="能量信息"></p>
<h2 id="电子占据情况-OUTCAR-中查看"><a href="#电子占据情况-OUTCAR-中查看" class="headerlink" title="电子占据情况: (OUTCAR 中查看)"></a>电子占据情况: (OUTCAR 中查看)</h2><p><img src="/2017/10/30/ex08/occupation.jpg" alt="电子占据情况"></p>
<ul>
<li>Band1 含有两个电子, 对应的 $2s^2$ ;</li>
<li>Band 2-4 为三个简并态,每个能带上有 1.33 个电子, 对应的 $2p^4$ 。</li>
</ul>
<p>但在这里,电子的占据是不正确的:</p>
<ul>
<li>因为 $2p_x$ 轨道上含有两个电子, 而不是把 $2p_x$ 上的一个电子平均分配到 3 个 p 轨道上;</li>
<li>此外,通过这个电子的占据情况,我们不能正确得到氧原子的磁矩信息。</li>
</ul>
<p>那么怎么解决这个问题呢?</p>
<h1 id="分两步解决问题"><a href="#分两步解决问题" class="headerlink" title="分两步解决问题"></a>分两步解决问题</h1><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步:"></a>第一步:</h2><p>由于氧原子具有磁性, 自旋极化计算要进行考虑, 在 VASP 计算中, 需要在 <code>INCAR</code> 中添加一项: <code>ISPIN = 2</code></p>
<p><code>ISPIN</code> 的取值为 <code>1</code> 或 <code>2</code>:<br>​    1. 代表不考虑自旋极化,是VASP的默认值;<br>​    2. 代表打开自旋极化该选项,计算中考虑。</p>
<h2 id="自旋极化什么时候该加呢"><a href="#自旋极化什么时候该加呢" class="headerlink" title="自旋极化什么时候该加呢?"></a>自旋极化什么时候该加呢?</h2><p>需要考虑自旋极化一般来说有以下几种：（新手记住前面4个即可。）</p>
<ul>
<li>单原子的计算,</li>
<li>O$_2$ 分子(基态为三重态)</li>
<li>自由基相关的计算</li>
<li>含Fe,Co, Ni 的体系</li>
<li>要计算的体系具有磁性：顺磁，铁磁，反铁磁等，要打开自旋极化。</li>
<li>当关注体系的电子性质时，且自己不知道加或者不加的时候，建议加上。</li>
</ul>
<p>如果你不知道自己的体系是否要考虑自旋极化，可以简单做这样的一个测试：</p>
<ul>
<li>测试1：不加自旋极化，正常算，得到结果1；</li>
<li>测试2：加上自旋极化，并在INCAR中添加： <code>LORBIT = 11</code> </li>
<li>测试2中OUTCAR的末尾会输出各个原子的磁矩信息：<ul>
<li>如果体系中原子的磁矩不为0，那么需要考虑自旋极化，</li>
<li>如果体系所有原子的磁矩都为0，那么就不需要考虑自旋极化，而且此时，你会发现测试1 和 2的结果中：结构和能量是一样的。</li>
</ul>
</li>
</ul>
<p>添加该选项后,重新计算,结果如下:</p>
<h3 id="INCAR"><a href="#INCAR" class="headerlink" title="INCAR"></a>INCAR</h3><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">SYSTEM = O</span><br><span class="line">ISMEAR = <span class="number">0</span></span><br><span class="line">SIGMA = <span class="number">0.01</span></span><br><span class="line">ISPIN = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="OSZICAR-1"><a href="#OSZICAR-1" class="headerlink" title="OSZICAR"></a>OSZICAR</h3><p><img src="/2017/10/30/ex08/OSZICAR_2.jpg" alt="OSZICAR"></p>
<p>可以看出, 加了自旋极化后, <strong>电子迭代步数增加了</strong>, 这是因为体系中的电子被强制分成了 $\alpha$ 和 $\beta$ 两种, 并分别进行计算, 因此增加了计算量。</p>
<p>体系的磁矩大小在 $OSZICAR$ 中查看, 对应右下角的 <code>mag=</code>  该项, 从这里我们可以看到, 磁矩信息与我们已知的 2 $\mu_B$ 吻合, 这一点是合理的, 正确的。</p>
<h3 id="OUITCAR-中的能量信息"><a href="#OUITCAR-中的能量信息" class="headerlink" title="OUITCAR 中的能量信息:"></a>OUITCAR 中的能量信息:</h3><p><img src="/2017/10/30/ex08/OUTCAR_2.jpg" alt="OUTCAR"></p>
<p> 考虑自旋极化后,体系的能量降低了。</p>
<hr>
<p> 我们重点通过查看体系的电子占据情况, 判断该计算是否合理: </p>
<p><img src="/2017/10/30/ex08/occupation_2.jpg" alt="OUTCAR"></p>
<p>从图中可以看出,结果由两个 <code>spin</code> 组成: spin component 1 和 2:<br>spin component 1 中含有 4 个电子, 另一个中含有 2 个电子:</p>
<p><img src="/2017/10/30/ex08/spin_2.png" alt="OUTCAR"></p>
<p>参考该图,可以看出 spin component 1 为自旋向上的 $\alpha$ 电子, 另一个是自旋向下的 $\beta$ 电子。</p>
<p>但是:</p>
<pre><code>1. Spincomponent 1中,能带2-4中3个alpha 电子的能量是一样的。这不正确，因为其中一个2px轨道中的alpha电子已经成对,能量要比py 和 pz 低;描述失败!
2. spincomponent 2 中,另一个beta电子还是平均分配在了三个能带上面。
</code></pre><p>电子占据依然不合理。</p>
<p>上面的结果是由于体系的高对称性导致的简并所造成的。 $8 \times 8 \times 8$ 的立方体格子, 在这里具有高阶的点群对称性: $O_h$, 见 <code>OUTCAR</code></p>
<p><img src="/2017/10/30/ex08/OUTCAR_3.jpg" alt="OUTCAR"></p>
<p>在 GGA 泛函中, 为了获得体系更低的能量,对于原子来说,通常会采用一种 <code>symmetry broken solution</code> 的处理方法。 但是在 VASP 计算中, 体系的对称性则是通过晶胞来获得, 即把这个晶胞当成一个原子来处理, 因此我们需要手动改变晶胞的形状来消除对称性造成的简并结果。 (此处的解释可能有些牵强, 有兴趣的可以查找与 symmetry broken solution 相关的文献)</p>
<hr>
<p>INCAR, KPOINTS, POTCAR等均保持不变。修改POSCAR, 如下:</p>
<h3 id="POSCAR"><a href="#POSCAR" class="headerlink" title="POSCAR"></a>POSCAR</h3><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">O</span><br><span class="line"><span class="number">1.0</span></span><br><span class="line"><span class="number">7.5</span> <span class="number">0.0</span> <span class="number">0.0</span></span><br><span class="line"><span class="number">0.0</span> <span class="number">8.0</span> <span class="number">0.0</span></span><br><span class="line"><span class="number">0.0</span> <span class="number">0.0</span> <span class="number">8.9</span></span><br><span class="line">O</span><br><span class="line"><span class="number">1</span></span><br><span class="line">Cartesian</span><br><span class="line"><span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span></span><br></pre></td></tr></table></figure>
<p>通过改变格子在三个方向的大小, 降低对称性。 大师兄还尝试了三斜的格子, 结果和这个是一致的。 (有兴趣的可以尝试下)</p>
<h3 id="POSCAR-1"><a href="#POSCAR-1" class="headerlink" title="POSCAR"></a>POSCAR</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">O</span><br><span class="line"><span class="number">1.0</span></span><br><span class="line">	<span class="number">7.5</span>		<span class="number">7.6</span>		<span class="number">0.0</span></span><br><span class="line">	<span class="number">0.0</span>		<span class="number">8.2564</span>		<span class="number">8.2</span></span><br><span class="line">	<span class="number">8.5</span>		<span class="number">0.0</span>		<span class="number">8.9</span></span><br><span class="line">O</span><br><span class="line">	<span class="number">1</span></span><br><span class="line">Cartesian</span><br><span class="line">	<span class="number">0.0</span>		<span class="number">0.0</span>		<span class="number">0.0</span></span><br></pre></td></tr></table></figure>
<hr>
<p>下面我们看一下改变晶胞为7.5 x 8.0 x 8.9后的计算结果:</p>
<h3 id="OSZICAR-2"><a href="#OSZICAR-2" class="headerlink" title="OSZICAR"></a>OSZICAR</h3><p><img src="/2017/10/30/ex08/OSZICAR_3.jpg" alt="OSZICAR"></p>
<p><code>OSZICAR</code> 中电子迭代步数又增加了, 这是因为对称性的降低增加了计算量。</p>
<p>磁矩为 $2\mu_B$ ,这一点跟前面一样,正确!</p>
<hr>
<p>体系的对称性: 从 $O<em>h$ 降低到了 $D</em>{2h}$</p>
<h3 id="OSZICAR-3"><a href="#OSZICAR-3" class="headerlink" title="OSZICAR"></a>OSZICAR</h3><p><img src="/2017/10/30/ex08/OUTCAR_4.jpg" alt="OSZICAR"></p>
<hr>
<p>能量信息:</p>
<h3 id="TOTEN"><a href="#TOTEN" class="headerlink" title="TOTEN"></a>TOTEN</h3><p><img src="/2017/10/30/ex08/TOTEN_4.jpg" alt="TOTEN"></p>
<p>跟前面能量相比, 可以看出, 对称性降低后, <strong>体系的能量进一步降低了</strong>。</p>
<hr>
<p>电子占据情况:</p>
<h3 id="OUTCAR"><a href="#OUTCAR" class="headerlink" title="OUTCAR"></a>OUTCAR</h3><p><img src="/2017/10/30/ex08/occupation_4.jpg" alt="TOTEN"></p>
<hr>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><ol>
<li>在 $\alpha$ 电子(spin component 1)中, 能带1 是 $2s$ 中的 $\alpha$ 电子; 能带2-3为两个简并轨道, 对应 $p_y$ 和 $p_z$ 电子, 能带 4 位于 $p_x$ 中的 $\alpha$ 电子。 这里能带 4 的能量应该比 2 和 3 要低, 但结果恰恰相反, 描述不合理;</li>
<li>在 $\beta$ 电子(spin component 2)中, 能带 1 是 $2s$ 的 $\beta$ 电子, 能带 2 为 $p_x$ 中的 $\beta$ 电子, 此时该 $\beta$ 电子占据了一个轨道, 而不是分布在三个 $p$ 轨道上, 结果是合理的。</li>
</ol>
<ul>
<li><p>计算到这里, 已经是 VASP 官网对于单原子能量最为完整和准确的计算了。 虽然上面 $p_x$ 的 $\alpha$ 电子比 $p_y$ 和 $p_z$能量高, 至少电子的轨道电子占据情况是正确的, 且磁矩和简并的错误已经消除。 由此可见, VASP对于单原子的电子占据情况(至少对于 O 原子来说), 虽然取得了部分理想结果, 但还是有不足的地方。</p>
</li>
<li><p>此外,体系的对称性可以通过 <code>ISYM</code> 来控制( 扩展阅读 <a href="http://cms.mpi.univie.ac.at/vasp/guide/node115.html">ISYM</a> ), <code>ISYM = 0</code> 的时候, 不考虑对称性进行计算.</p>
</li>
<li><p>大师兄也尝试过了将 <code>ISYM = 0</code> 应用在 $8 \times 8 \times 8$ (test3)以及 $7.5 \times 8.0 \times 8.9$ (test4) 的格子里进行计算。 对于电子占据情况来说, 均得到了与前面 $7.5 \times 8.0 \times 8.9$ 一致的结果。 但是使用 $7.5 \times 8.0 \times 8.9$ 所得到的能量更低(test4 的能量比 test3 低)。</p>
</li>
<li><p>使用 $7.5 \times 8.0 \times 8.9$ 格子时, <code>ISYM = 0</code> (test4) 和采用默认值, 得到的能量结果是相同的, 因此, 改变晶胞的对称性在计算单原子能量的时候是必须的, 单独通过 <code>ISYM</code> 这一项不考虑对称性是远远不够的。</p>
</li>
</ul>
<h1 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h1><ol>
<li><code>ISYM</code>: <a href="http://cms.mpi.univie.ac.at/vasp/guide/node115.html">http://cms.mpi.univie.ac.at/vasp/guide/node115.html</a></li>
<li>重现本节所有练习, 并自己认真分析结果, 查看电子占据情况, 体系的磁性, 以及能量信息。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>知道什么时候使用自旋极化计算,怎么进行自旋极化计算;</li>
<li>知道为什么自旋极化后计算量增加了;</li>
<li>知道在哪里查看体系的磁性信息;</li>
<li>知道为什么对称性降低后计算量增加了;</li>
<li>会分析单原子中电子轨道的占据情况;判断结果是否合理;</li>
<li>知道通过改变晶格大小调节体系的对称性从而消除简并对能量的影响;</li>
<li>知道ISYM这一个参数,在计算单原子能量中,ISYM的作用远远不及改变晶格大小;</li>
<li>知道vasp也存在自己局限性,不要完全相信。</li>
</ol>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>单点能</tag>
        <tag>磁性</tag>
        <tag>轨道占据</tag>
        <tag>氧</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex09 学会收敛点!</title>
    <url>/2017/12/02/ex09/</url>
    <content><![CDATA[<p>前面一节我们学会了正确计算氧原子的能量并分析电子在轨道中的占据情况，这一节稍作总结补充。</p>
<h3 id="复习上节内容"><a href="#复习上节内容" class="headerlink" title="复习上节内容"></a>复习上节内容</h3><p>在VASP计算的O原子的电子结构讨论中，来自不莱梅大学的群友，画了一幅画，大家可以看下:</p>
<p><img src="/2017/12/02/ex09/ex09-01.jpeg" alt=""></p>
<p>VASP的结果分析完毕后如下:</p>
<p><img src="/2017/12/02/ex09/ex09-02.jpeg" alt=""></p>
<p>看画填数，照猫画虎：<img src="/2017/12/02/ex09/ex09-03.jpeg" alt=""></p>
<p><img src="/2017/12/02/ex09/ex09-04.jpeg" alt=""></p>
<p>由此可见，VASP对于氧原子的描述不是很准确（不理解的请看上一节的详细描述)。而这一点，VASP官网你是找不到的。因此，在计算的时候，对于自己的体系有一个清晰的化学物理印象很重要。VASP的结果也要有针对的去判断。有的时候，即使计算收敛了，但没有体现出任何正确的物理或者化学意义，那就是单纯的数学收敛，结果是不可取的。VASP是一个计算的工具，如何正确分析和判断它的输出才是关键的。这一点我们在后面的学习中也会反复强调。</p>
<h3 id="VASP是怎么判断收敛的"><a href="#VASP是怎么判断收敛的" class="headerlink" title="VASP是怎么判断收敛的?"></a>VASP是怎么判断收敛的?</h3><p>我们看一下VASP的迭代计算过程：</p>
<p>​                                               <img src="/2017/12/02/ex09/ex09-05.jpeg" alt=""></p>
<ul>
<li><p>首先，它会猜一个初始的电子密度，然后据此计算体系的势能，求解KS方程，并给出体系的总能量以及对应的电子密度，也就是我们之前说的电子步的优化。</p>
</li>
<li><p>将最新一步的结果与前面进行对比，当前后两者的差值达到我们预设的收敛标准时，计算结束。</p>
</li>
<li><p>这个预设的收敛标准在VASP中通过两个参数来描述：EDIFF 和 EDIFFG。</p>
</li>
<li><p>EDIFF 控制电子步（自洽）的收敛标准。在O原子的计算中，由于我们不需要优化，直接进行静态计算，完全由EDIFF控制计算的收敛情况。EDIFFG后面我们再介绍。</p>
</li>
</ul>
<p><img src="/2017/12/02/ex09/ex09-06.jpeg" alt=""></p>
<p> 从图中可以看出：第19步和18步的能量差为：-0.3484 E-04，停止迭代，开始输出结果。这是因为VASP计算中EDIFF的默认值是 1 x 10-4。</p>
<h3 id="鱼和熊掌的关系"><a href="#鱼和熊掌的关系" class="headerlink" title="鱼和熊掌的关系"></a>鱼和熊掌的关系</h3><p><strong>那么：</strong></p>
<p><strong>是不是精度越高，计算越准确呢？ 这是肯定的！</strong></p>
<p><strong>是不是计算都需要这么高的精度呢？ 这肯定不是的！</strong></p>
<p>精度高（鱼：&lt;・)))&gt;&lt;&lt;）意味着需要更多的迭代次数，也就是需要更多的计算时间（熊掌）。下图是收敛标准从默认值的1E-4 降低到1E-7后的收敛情况：单迭代次数从19增加到了27，相当于增加了原来1/2的工作量。所以，精度太高，计算量会增加。应了那句流行语：请在wifi下观看，土豪随意。</p>
<p> <img src="/2017/12/02/ex09/ex09-07.jpeg" alt=""></p>
<p>我们看一下扩展阅读的内容:</p>
<p><img src="/2017/12/02/ex09/ex09-08.jpeg" alt=""></p>
<p>第一点：官网说（红色方框中内容）：如果我们把收敛标准设置成0，那么迭代会永远进行下去。大师兄很感兴趣，便设置：<code>EDIFF = 0</code>测试了一番，结果如下:</p>
<p><img src="/2017/12/02/ex09/ex09-09.jpeg" alt=""></p>
<p>可以看到，在45步迭代之后，精度收敛到1E-12，VASP便停止了，而不是所谓的always! VASP又把俺们给骗了!</p>
<p>骗归骗，但计算量的增加确是铁打的事实，从1E-4的19步，增加到了45步。</p>
<p>思考另外一个问题：既然精度从默认值1E-4提高到1E-12 (8个数量级)，那么我们算出来的氧原子能量有什么变化呢？看下图:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex09$ ls</span><br><span class="line">0  4  7</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex09$ ta.sh</span><br><span class="line">0        -1.89224598</span><br><span class="line">4        -1.89218308</span><br><span class="line">7        -1.89224603</span><br></pre></td></tr></table></figure>
<p>图中的0， 4， 7 分别代表EDIFF为 0，  1E-4和 1E-7 的情况，我们可以看出，这三个计算结果中，能量随着EDIFF的减小变化甚微。当然，这也与我们简单的测试体系有关系。倘若计算N多个原子的体系时，不同的精度间的差值会有所增大。上面图中使用了一个小脚本：<code>ta.sh</code>，内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> *; <span class="keyword">do</span></span><br><span class="line"><span class="keyword">if</span> [ -e <span class="variable">$i</span>/OUTCAR ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> -e  <span class="variable">$i</span> <span class="string">&quot;\t&quot;</span> $(grep <span class="string">&#x27;  without&#x27;</span> <span class="variable">$i</span>/OUTCAR |tail -n 1 | awk <span class="string">&#x27;&#123;print $7&#125;&#x27;</span>)</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h3 id="如何看VASP的说明书"><a href="#如何看VASP的说明书" class="headerlink" title="如何看VASP的说明书"></a>如何看VASP的说明书</h3><p>那么我们再看一遍VASP官网的说明，注意底部的Mind部分:</p>
<p><img src="/2017/12/02/ex09/ex09-10.jpeg" alt=""></p>
<p>大家在浏览VASP官网的时候，凡是带有<code>Mind</code>，<code>Important</code>字样的，它们后面的文字一定要认真阅读，把握其中的含义。因为这都是大家常见的疑难点以及易错的地方。收敛速度跟<code>EDIFF</code>的值成指数关系，在大多数的情况下，<code>1E-4</code>足以胜任，没有必要采用其他的数值，如果大伙感觉不放心，大师兄建议<code>1E-5</code>即可。</p>
<h3 id="几何优化的收敛标准"><a href="#几何优化的收敛标准" class="headerlink" title="几何优化的收敛标准"></a>几何优化的收敛标准</h3><p>目前还没有介绍几何优化，先简单介绍下EDIFFG这个参数，大家知道即可，后面学习到了再回来看。</p>
<p>我们优化几何结构的时候，当结构前后变化达到我们设定的要求时，便停止优化。而这个设定的要求，就是通过EDIFFG来控制。</p>
<ul>
<li>对于优化，我们可以使用力作为收敛标准，此时EDIFFG为负值。一般来说取值在-0.01到-0.05之间(-0.01对于力收敛来说已经是一个很严格的要求了)。</li>
<li><p>当然，对于较大的体系，我们也可以使用能量作为标准：此时，EDIFFG 为正值，一般取值范围在0.0001-0.001即可。</p>
<p><strong>注意:</strong></p>
</li>
</ul>
<p>不要把正负值弄错了。大师兄见过一个群友这么设置的: EDIFFG = -0.0001。然后在群里咨询为什么他的计算不收敛。这就好比在没有WiFi的时候，装成土豪看视频，卡里的钱扣完了，视频才看到一半…..前面说到，<code>EDIFFG = -0.01</code>的时候收敛就已经够费劲了， 你再加个0，莫不是要算到天荒地老？</p>
<h5 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h5><p>EDIFF，EDIFFG 是控制收敛标准的两个参数。前者负责电子自洽过程(单个离子步内)，取值为1E-4或者1E-5即可，没有特殊要求，不建议设置的太低。后者负责结构优化的过程(可正可负)。对于EDIFFG，默认值采用能量收敛，标准为:EDIFFx10。</p>
<h3 id="扩展训练"><a href="#扩展训练" class="headerlink" title="扩展训练:"></a>扩展训练:</h3><p>1 EDIFF: <a href="https://cms.mpi.univie.ac.at/wiki/index.php/EDIFF">https://cms.mpi.univie.ac.at/wiki/index.php/EDIFF</a></p>
<p>2 在1的页面中，左侧框中搜索<code>EDIFFG</code>，查找相关参数;</p>
<p>3 继续查询之前了解的相关参数，学会使用改网址;</p>
<p>4  根据前面所学，进行O$_2$分子的静态计算，并分析其轨道结果，判断是否合理。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>重温了一下上节的结果，不要完全相信程序的结果，物理，化学意义更为重要;</li>
<li>初步了解VASP的迭代过程，</li>
<li>必须掌握EDIFF在电子步中的作用，取值大小与收敛速度的联系，也就鱼和熊掌的关系；</li>
<li>死死记住EDIFFG代表的含义，取值可正可负及其默认值;</li>
<li>经常浏览VASP官网，尤其是Mind，Note， Important等后面的部分;（眼睛要尖！）</li>
<li>建议大家浏览VASP的Wiki版网页(左下方原文链接)，搜索相关参数，里面的公式较之前模糊的形式，有了很大的改进。</li>
<li>目前VASP官网国内上不去，掌握科学上网的技巧也是做科研的必须技能。</li>
</ul>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>收敛</tag>
        <tag>单点能</tag>
        <tag>轨道占据</tag>
        <tag>氧</tag>
        <tag>怎么看VASP手册</tag>
        <tag>鱼和熊掌</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex11 O$_2$单点计算和优化结果分析</title>
    <url>/2017/12/03/ex11/</url>
    <content><![CDATA[<p>前面几节，我们讲解了O分子单点计算和O$_2$的POSCAR和POTCAR的准备。这一节我们主要讲解一下：</p>
<p>1）O$_2$的分子结构分析</p>
<p>2）如何初步进行构型优化计算。</p>
<h3 id="O-2-的单点计算"><a href="#O-2-的单点计算" class="headerlink" title="O$_2$ 的单点计算"></a>O$_2$ 的单点计算</h3><p>首先解释下什么是单点计算：顾名思义就是不优化结构，直接算个能量，电子相关的性质。你也可能会听到很多人说静态计算，或者自冾计算。其实都一样的：几何结构计算前后不发生变化。</p>
<p>首先提交O$_2$ 静态计算任务，运行，等待结束。如果你的任务出错，请跟大师兄的输入文件进行对比、改正，直至计算正常结束。如下图：</p>
<p><img src="/2017/12/03/ex11/ex11-1.jpeg" alt=""></p>
<p>任务结束后查看OSZICAR:</p>
<p>从OSZICAR最后，得到体系的磁矩为2μB，你应该知道这个磁矩是怎么回事，由哪两个电子贡献。</p>
<p><img src="/2017/12/03/ex11/ex11-2.jpeg" alt=""></p>
<p>如果不知道，看下图O$_2$的分子轨道结构：</p>
<p><img src="/2017/12/03/ex11/ex11-3.jpeg" alt=""></p>
<p>看完该图，相信大家对于O$_2$的成键方式有了一个更加深刻的印象。我们对比下VASP的输出结果。首先分析α电子的排布情况：</p>
<p> <img src="/2017/12/03/ex11/ex11-4.jpeg" alt=""></p>
<p>在这里，你会发现能带3和4 是简并的，应该是π(p2x）和π(p2y） 轨道中的α电子。能带 5 对应的应该是σ(2pz) 的电子。在O$_2$分子的电子构型中，两个O原子的2pz轨道以头碰头的方式形成一个σ键，其能量要比2px（2py）以肩并肩方式形成的π键能量要低。但是，能带5的能量（-13.3126）比3和4的（-13.3870）要高些，这与O$_2$的电子构型不一致，表明VASP的单点计算结果是不可靠的。</p>
<p>再看一下β电子的排布情况：</p>
<p><img src="/2017/12/03/ex11/ex11-5.jpeg" alt=""></p>
<p>能带4和5对应的是应该是π（2px） 和π（2py） 轨道中的β电子。且总的轨道能量与前面图中一致，这说明VASP对β电子的描述是合理的。</p>
<p>为什么出现这样的情况呢？难道跟前面O原子的计算一样，VASP又算不准啦？</p>
<p>不是的，VASP怎么着也是个老牌的，响当当的计算程序，总不能让人每天指着鼻子骂算不准！</p>
<p>这里的主要原因是：来自于实验的键长值未必就是计算程序所认可的。也就是说，实验值和理论值之间存在偏差，实验的结构不能直接用来计算其性质，只可以作为一个理想的初始值。所以，O$_2$的分子结构需要优化一下。</p>
<h3 id="VASP-优化分子结构"><a href="#VASP-优化分子结构" class="headerlink" title="VASP 优化分子结构"></a>VASP 优化分子结构</h3><p>VASP优化分子结构的时候，需要用到一个参数：<code>IBRION</code>。引用官网的话：IBRION determines how the ions are updated and moved. 也就是说IBRION 这个参数决定了结构的优化过程。当你去官网查看的时候（google 搜索VASP IBRION这两个关键词），会发现IBRION有很多值。</p>
<p><img src="/2017/12/03/ex11/ex11-6.jpeg" alt=""></p>
<p>想要正确进行计算，你就需要去硬着头皮去了解各个值的含义了，这个过程必须自己去做，只听别人的建议去设置参数，而不自己去主动学习的，你的能力永远不会得到提升！！！</p>
<p>一般来说，优化结构的时候有3个选择：</p>
<p>IBRION=3：你的初始结构很差的时候；</p>
<p>IBRION=2：共轭梯度算法，很可靠的一个选择，一般来说用它基本没什么问题。</p>
<p>IBRION=1：用于小范围内稳定结构的搜索。</p>
<p>如果你的体系遇到结构不收敛的时候，首先检查自己的结构是否合理，也就是物理化学意义是否清晰。如果结构没问题，可以尝试下换下IBRION的参数。</p>
<p> 下面，我们在INCAR中加上IBRION参数（IBRION=2），其他输入文件保持不变，重新进行计算：</p>
<p><img src="/2017/12/03/ex11/ex11-7.jpeg" alt=""></p>
<p>如果是用上图中的INCAR，你会发现任务很快就算完了。而且只有一步，难道输入的结构就是VASP计算出来的的稳定结构吗？有这种可能，但几率极低。</p>
<p>如果我们仔细查看下OUTCAR中的电子构型，发现它的信息和前面的单点计算一样。这说明，vasp并没有优化，而是又运行了一次单点计算。</p>
<p>为什么呢？ 这是因为另一个参数：<code>NSW</code>。</p>
<p>NSW 控制几何结构优化的步数。也就是VASP进行多少离子步。</p>
<p>官网查看下NSW选项，发现默认值是0，也就是没有进行优化。（默认值，也叫缺省值，英文里面是 Default。 意思是，如果你不输入这个参数，程序将默认使用XXX的数值）</p>
<p><img src="/2017/12/03/ex11/ex11-8.jpeg" alt=""></p>
<p>现在原因找到了，继续进行优化任务。问题来了：NSW怎么设置呢？</p>
<ul>
<li>首先，它必须是大于等于0的整数。</li>
<li>其次，一般来说，简单的体系200步内就可以正常结束。</li>
<li>不知道什么时候收敛，初始结构很差，或者设置了很严格的收敛标准，那么你就要增大一下NSW的取值了，比如NSW=500或者更大。</li>
<li>我们的这个O$_2$例子很简单，设置了NSW=10（你也可以设置为100,200或者500，不会影响计算结果的。）</li>
</ul>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">System = O</span><br><span class="line">ISMEAR = <span class="number">0</span></span><br><span class="line">SIGMA  = <span class="number">0.01</span></span><br><span class="line">ISPIN  = <span class="number">2</span></span><br><span class="line">MAGMOM = <span class="number">2</span>*<span class="number">2</span></span><br><span class="line"></span><br><span class="line">IBRION = <span class="number">2</span></span><br><span class="line">NSW = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>计算完成后，打开OSZICAR：</p>
<p><img src="/2017/12/03/ex11/ex11-10.jpeg" alt=""></p>
<p>可以看到，结构优化进行了3步便停止了（如果你设置了NSW=1000，那么也是3步后就结束）。其中，每一步内又包含了若干电子步。此时的你应该知道是什么参数控制优化的结束，如果不知道请查看前面Ex09中关于收敛的文章。思考一下： 同样优化200步，设置EDIFF=1E-7和EDIFF=1E-4会有什么区别呢？ </p>
<p>查看下OUTCAR： </p>
<p> <img src="/2017/12/03/ex11/ex11-11.jpeg" alt=""></p>
<p>你会发现，优化过后，OUTCAR中α电子的占据状态调整过来了，β电子的保持不变。这说明计算成功了，优化起作用了。</p>
<p>那么优化过后的结构怎么查看呢？键长又是多少呢？</p>
<p>下面我们要开始真正掌握VASP的输出文件了：CONTCAR。 CONTCAR是VASP的一个输出文件，它包含了VASP计算中最后一步几何优化的结构信息，也就是优化完的结果。它也是文本格式，可以直接打开查看，如图：</p>
<p><img src="/2017/12/03/ex11/ex11-12.jpeg" alt=""></p>
<p> 怎么才能知道优化完的<code>O-O</code>键长是多少呢？</p>
<p>1）通过坐标直接算：</p>
<p>此时，要注意CONTCAR输出的是Direct坐标，也就是分数坐标，需要转换成笛卡尔坐标。</p>
<p>xy两个方向不用考虑（都是0），z方向的坐标相减即可：键长保留四位就足够了。</p>
<p>(0.136785-( -0.001953))*8.9 = 1.2348 （$\AA$）</p>
<p>2)  使用可视化软件测量：</p>
<p>这样手动算，简单来说还可以，等复杂了就麻烦了，幸运的是，常用的建模软件中：p4vasp，VESTA，VMD，MS，ASE-gui等，都有测量键长的办法。这里简单讲解一下p4vasp 的用法。</p>
<h4 id="p4vasp的安装"><a href="#p4vasp的安装" class="headerlink" title="p4vasp的安装"></a>p4vasp的安装</h4><p>这个详见本书的附录2：<a href="https://www.bigbrosci.com/2017/11/18/A02/">https://www.bigbrosci.com/2017/11/18/A02/</a></p>
<p>1） Ubuntu 系统： <code>sudo apt-get install  p4vasp</code></p>
<p>2） Windows系统： 下载p4vasp的安装包，解压后直接打开即可。</p>
<p>下面是Windows下通过p4vasp读取CONTCAR的方法。Linux的也可以这样做，但终端里面：<code>p4v CONTCAR</code> 更高效直接。打开VASP后的界面如下： 注意图中： <code>System：</code>后面的三个问号部分，后面会进行对比：</p>
<p><img src="/2017/12/03/ex11/ex11-13.jpeg" alt=""></p>
<p>点击左侧栏中的 <code>Open</code> 选项。下图中，左侧点击进入CONTCAR所在的目录，进入后，在右侧会显示CONTCAR</p>
<p><img src="/2017/12/03/ex11/ex11-14.jpeg" alt=""></p>
<p><img src="/2017/12/03/ex11/ex11-15.jpeg" alt=""></p>
<p>双击右侧的CONTCAR, 你会发现之前的三个问号？？？部分发生了变化：</p>
<p>显示的 O 表明VASP读取CONTCAR成功。</p>
<p><img src="/2017/12/03/ex11/ex11-16.jpeg" alt=""></p>
<p>点击左侧的Show按钮，就可以查看结构了。</p>
<h5 id="可视化界面的基本操作"><a href="#可视化界面的基本操作" class="headerlink" title="可视化界面的基本操作"></a>可视化界面的基本操作</h5><p>鼠标左键按住不放，可以3维空间旋转结构；</p>
<p>鼠标中间摁住不放，可以上下，左右移动结构：</p>
<p>鼠标右键摁住不敢，动动鼠标可以缩放结构；</p>
<p>选择合适的观察位置：</p>
<p>1 把鼠标移动到你要选中的原子上，</p>
<p>2 通过空格（键盘上最长的键）用来选择或者取消选择原子：</p>
<p>3 选中两个氧原子后，如下图：</p>
<p><img src="/2017/12/03/ex11/ex11-17.jpeg" alt=""></p>
<p> 选中之后，点<code>Structure</code> –&gt;<code>Measure</code> 显示键长为1.234774 Å，和我们手动计算的结果一样。</p>
<p> 当然，也可以先点击：<code>Structure</code> –&gt;<code>Measure</code>，然后再选择感兴趣的原子。</p>
<h5 id="小结一下："><a href="#小结一下：" class="headerlink" title="小结一下："></a>小结一下：</h5><p>实验值为1.2075 Å，VASP计算结果为1.2348 Å。两者之间的差值为： 0.0289 Å，偏差为：(1.2348-1.2075)/1.2075 = 2.26%。对于理论和实验之间的偏差，如果小于5%，我们一般可以认为吻合的很好。有时候很多同学揪着VASP的计算结果与实验值的偏差不放，误差已经千分之几了，感觉心里还是不放心，有着一种不完全匹配不罢休的冲动。这大可不必放在心上，如果你的结果偏离实验值千分之几，直接用就可以了。</p>
<p> “To err is human; to describe the error properly is sublime.”<br>— Cliff Swartz, Physics Today 37 (1999),388.</p>
<p>对于其他的软件程序（MS，VESTA，VMD等），大家下载安装后，百度里面搜一搜教程，基本操作应该很快就能掌握。</p>
<h3 id="扩展练习："><a href="#扩展练习：" class="headerlink" title="扩展练习："></a>扩展练习：</h3><p>1 IBRION：<a href="https://cms.mpi.univie.ac.at/vasp/vasp/IBRION_tag_NFREE_tag.html">https://cms.mpi.univie.ac.at/vasp/vasp/IBRION_tag_NFREE_tag.html</a></p>
<p>2 NSW：<a href="http://cms.mpi.univie.ac.at/vasp/guide/node108.html">http://cms.mpi.univie.ac.at/vasp/guide/node108.html</a></p>
<p>3 CONTCAR：<a href="https://cms.mpi.univie.ac.at/wiki/index.php/CONTCAR">https://cms.mpi.univie.ac.at/wiki/index.php/CONTCAR</a></p>
<p>4 从头开始重现本节的所有操作；</p>
<p>5 尝试不同的初始键长，运行vasp，查看输出结果。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>1）学会结合自己所学的化学知识，分析双原子的电子构型；</p>
<p>2）知道IBRION + NSW进行结构优化；</p>
<p>3）知道什么参数控制结构优化的停止，以及单个离子步内电子步数；</p>
<p>4）学会使用可视化软件查看输出的几何结构；</p>
<p>5）知道理论结果和实验值之间没有100%吻合。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>磁性</tag>
        <tag>MAGMOM</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex10 O$_2$结构搭建以及POTCAR注意部分</title>
    <url>/2017/12/02/ex10/</url>
    <content><![CDATA[<p>前面O原子的能量计算已经告一段落，下面我们把体系变得更加复杂些：O${_2}$分子。扩展练习已经做的同学，相信现在已经完成了O${_2}$分子的静态计算。本节我们主要介绍一下:</p>
<ul>
<li>O${_2}$分子模型搭建的细节;</li>
<li>POTCAR和POSCAR的对应关系，注意事项。</li>
</ul>
<h3 id="搭建模型"><a href="#搭建模型" class="headerlink" title="搭建模型"></a>搭建模型</h3><p>O${_2}$分子模型的搭建其实很简单，将两个原子在一个直线上连起来就行了。 键长大小可以书本上查， 数据库里找，也可以去网上找些参考资料。大师兄推荐常见常用的数据库:</p>
<p>1）<a href="http://hbcponline.com">CRC hand book</a>:  </p>
<ul>
<li>网页版:  <a href="http://hbcponline.com/faces/contents/ContentsSearch.xhtml">http://hbcponline.com/faces/contents/ContentsSearch.xhtml</a>  </li>
</ul>
<p><img src="/2017/12/02/ex10/ex10-1.jpeg" alt=""></p>
<ul>
<li>PDF 电子书，这个网上到处都有，大家自己搜搜就能找见。具体在1403 页(本书有2661页，建议大家查询的时候先把左侧的目录展开，要不然实在是太痛苦!)</li>
</ul>
<p><img src="/2017/12/02/ex10/ex10-2.jpeg" alt=""></p>
<p><img src="/2017/12/02/ex10/ex10-3.jpeg" alt=""></p>
<p>2） NIST 数据库: <a href="http://cccbdb.nist.gov/exp2x.asp">http://cccbdb.nist.gov/exp2x.asp</a></p>
<p><img src="/2017/12/02/ex10/ex10-4.jpeg" alt=""></p>
<p>3) Wikipedia，谷歌和百度:</p>
<p>在谷歌或者百度里面直接搜索O$_2$、键长这两个关键词，就可以得出很多的链接，比如下面两个。</p>
<p><a href="https://zhidao.baidu.com/question/101615129.html">https://zhidao.baidu.com/question/101615129.html</a></p>
<p><a href="http://www.science.uwaterloo.ca/~cchieh/cact/c120/bondel.html">http://www.science.uwaterloo.ca/~cchieh/cact/c120/bondel.html</a> </p>
<p>大师兄你特么在逗我嘛？</p>
<p>氧气原子这么简单的分子，随便一翻，当然到处都能得到结果啦!</p>
<p>哈哈，没有逗你。在这里，大师兄想要告诉你的是：</p>
<ul>
<li>搜索的时候尽量用谷歌，而不用百度；</li>
<li>尽量搜英文，不要输汉语，这样你得到的信息会相对多一些。</li>
</ul>
<p>师兄，你又在逗我，谷歌我们访问不了，怎么用啊？ </p>
<p>没有逗你，现实是残酷的，没有google，科研会被百度严重拖后腿。虽然我也不想批评国产，谁让它不争气呢？</p>
<p>所以，科学上网的技巧，你要get到。</p>
<p><strong>划重点：</strong></p>
<p>前面介绍了一堆，主要目的有3个：</p>
<p>1) 给大家提供一个数据查询手册(CRC handbook)和数据库(NIST)。当然根据自己的研究方向，还有其他更加专业的数据库，随着学习的深入，后面会讲解。 此外，写论文的时候，如果实在不想找相关的参考文献，可以直接引用CRC hand book这本书（前提是你在这本书里面找到了相关的数据）</p>
<p>2) 查找数据库另一个重要的原因是：如果你的初始结构，比较理想，这会大大加速你的计算过程，还会避免一些意想不到的计算错误（后面的章节会具体介绍到）。</p>
<p>3）除了查找数据库，别人发的文章也是初始结构的重要或者主要来源。</p>
<h3 id="模型搭建"><a href="#模型搭建" class="headerlink" title="模型搭建"></a>模型搭建</h3><p>知道了键长信息后，开始结构搭建O$_2$的模型，我们知道它是直线型分子（算大师兄没说），其中一个原子在原点的位置上了，那么我们在三个方向上随便找个坐标就可以了。修改POSCAR如下:</p>
<p><img src="/2017/12/02/ex10/ex10-5.jpeg" alt=""></p>
<p>两点要注意：</p>
<ul>
<li><p>第7行原子个数：把1改成2 ，表示氧元素有2个原子。</p>
</li>
<li><p>第10行添加第二个氧原子的坐标：</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>方向</th>
<th>坐标</th>
</tr>
</thead>
<tbody>
<tr>
<td>沿x轴</td>
<td>1.2074   0.0   0.0</td>
</tr>
<tr>
<td>沿y轴</td>
<td>0.0   1.2074   0.0</td>
</tr>
<tr>
<td>沿z轴</td>
<td>0.0  0.0  1.2074</td>
</tr>
</tbody>
</table>
</div>
<p>上图中为沿着z轴方向。<strong>注意</strong>： </p>
<ul>
<li>xyz三个方向的数值之间可以有1个或者若干个空格，不要用tab分割数字；</li>
<li>在搭建模型的时候，脑子里要有一个立体的概念，原子在三维方向上的排列，移动变化等。 </li>
</ul>
<h3 id="关于POTCAR"><a href="#关于POTCAR" class="headerlink" title="关于POTCAR"></a>关于POTCAR</h3><p>大师兄，氧原子多了一个，POTCAR怎么办？是不是每个原子对应一个POTCAR啊?</p>
<p>不是的。POTCAR 是根据POSCAR中的元素顺序创建的(第6行)，与原子数目无关。</p>
<p>第6行是体系中的元素，只有O元素，所以我们的POTCAR还是用之前O原子练习的那个;</p>
<p>第7行是与上一行相对应的体系中元素的原子数。</p>
<p>但是！在你的POSCAR中，如果把O写了两遍，如下图：</p>
<p><img src="/2017/12/02/ex10/ex10-6.jpeg" alt=""></p>
<p>此时，第6行中有2个O，且第7行中有两个O的原子数目分别为1。 POTCAR中就要对应的两个O原子的Potentials!</p>
<h5 id="主动出错："><a href="#主动出错：" class="headerlink" title="主动出错："></a>主动出错：</h5><p>如果我们使用上图的POSCAR（O元素写了2次），且POTCAR中只有1个O原子的Potential。</p>
<p>提交任务后，瞬间完成。这么快就算完肯定不是因为你的服务器多么的牛逼! 而是因为出错了!!</p>
<p>那么我们需要找到错误的原因，怎么去找错误信息呢? </p>
<p>1) 查看OUTCAR</p>
<p><img src="/2017/12/02/ex10/ex10-7.jpeg" alt=""></p>
<p>VASP就这么几行，从这里看不出来是哪里错了。</p>
<p>2) 一般来说，VASP计算的时候，会生成两个额外的文件，一个是关于服务器集群计算error的，另一个是VASP运行的out文件。这个out和OUTCAR不太一样，记录着VASP的运行过程和出错信息。看大师兄的文件目录:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qli@bigbro:~/test$ ls</span><br><span class="line">CHGCAR   DOSCAR   e_Single.142845   INCAR   o_Single.142845  OUTCAR  POSCAR  PROCAR  sub12    WAVECAR  CHG      CONTCAR  EIGENVAL  IBZKPT   KPOINTS  OSZICAR   PCDAT   POTCAR  REPORT  vasprun.xml  XDATCAR</span><br><span class="line">qli@bigbro:~/test$ cat e_Single.142845</span><br><span class="line">qli@bigbro:~/test$</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>不同的组可能命名不一样，但一般都会有这两个文件。这里的e对应的是服务器的出错信息，o对应的是VASP的out文件。 首先打开查看下服务器出错文件：(图中cat 命令) 发现什么都没有输出，说明服务器没有出错。那我们打开一下 o_Single.142845 文件，如下图</p>
<p><img src="/2017/12/02/ex10/ex10-8.jpeg" alt=""></p>
<p>在这个文件里面最后一行，给出了错误的信息：</p>
<p>一般出现这个错误的时候，你就要去检查POSCAR和POTCAR中的元素是否对应了。</p>
<h5 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h5><p>本例中的错误该怎么解决呢？ 既然POSCAR和POTCAR不一致，解决的话，有2个办法：要么变POSCAR，要么变POTCAR。</p>
<p>1）变POSCAR：</p>
<ul>
<li>第六行中：把<code>O O</code>换成<code>O</code>; </li>
<li>第七行：氧原子数目改成2，就如刚开始的POSCAR。</li>
<li>POTCAR保持不变即可（POTCAR中只有1个O的Potential）:</li>
</ul>
<p>2）变POTCAR</p>
<ul>
<li>使其中的元素与POSCAR中的一致，也就是有两个氧元素的Potentials！</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qli@bigbro:~/test2$ grep TIT POTCAR</span><br><span class="line">   TITEL  = PAW_PBE O 08Apr2002</span><br><span class="line">qli@bigbro:~/test2$ mv POTCAR POTCAR1</span><br><span class="line">qli@bigbro:~/test2$ cat POTCAR1 POTCAR1  &gt; POTCAR</span><br><span class="line">qli@bigbro:~/test2$ grep TIT POTCAR</span><br><span class="line">   TITEL  = PAW_PBE O 08Apr2002</span><br><span class="line">   TITEL  = PAW_PBE O 08Apr2002</span><br></pre></td></tr></table></figure>
<p> 这样，再运行就不会出错了。</p>
<h3 id="POTCAR-的制备"><a href="#POTCAR-的制备" class="headerlink" title="POTCAR 的制备"></a>POTCAR 的制备</h3><p>前面的演示中，大师兄教给你了POTCAR的制备方法: 使用cat 命令将2个POTCAR1 连在一起然后输出新的POTCAR。如果看不明白，继续看下面的操作：</p>
<p>如果你的体系中含有其他的元素，比如: Fe C H O</p>
<p>那么你就要先准备这四个元素的POTCAR：POTCAR-Fe、POTCAR-C、POTCAR-H、POTCAR-O，</p>
<p>然后运行命令:cat POTCAR-Fe POTCAR-C POTCAR-H POTCAR-O &gt; POTCAR  就可以了。</p>
<h6 id="具体操作："><a href="#具体操作：" class="headerlink" title="具体操作："></a>具体操作：</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qli@bigbro:~/test2$ ls</span><br><span class="line">POTCAR-C  POTCAR-Fe  POTCAR-H  POTCAR-O </span><br><span class="line">qli@bigbro:~/test2$ grep TIT POTCAR*</span><br><span class="line">POTCAR-C:   TITEL  = PAW_PBE C 08Apr2002</span><br><span class="line">POTCAR-Fe:   TITEL  = PAW_PBE Fe 06Sep2000</span><br><span class="line">POTCAR-H:   TITEL  = PAW_PBE H 15Jun2001</span><br><span class="line">POTCAR-O:   TITEL  = PAW_PBE O 08Apr2002</span><br><span class="line">qli@bigbro:~/test2$ cat POTCAR-Fe POTCAR-C POTCAR-H POTCAR-O &gt; POTCAR</span><br><span class="line">qli@bigbro:~/test2$ grep TIT POTCAR</span><br><span class="line">POTCAR:   TITEL  = PAW_PBE Fe 06Sep2000</span><br><span class="line">POTCAR:   TITEL  = PAW_PBE C 08Apr2002</span><br><span class="line">POTCAR:   TITEL  = PAW_PBE H 15Jun2001</span><br><span class="line">POTCAR:   TITEL  = PAW_PBE O 08Apr2002</span><br></pre></td></tr></table></figure>
<p>这四个元素POTCAR数据从哪里找，在哪个目录下面？</p>
<p>这就得问问你们组里的师兄师姐们，或者老师了，网上也有很多。</p>
<h3 id="扩展练习"><a href="#扩展练习" class="headerlink" title="扩展练习:"></a>扩展练习:</h3><p>1 正确运行O$_2$分子的静态计算;</p>
<p>2 查找相关的O$_2$分子的轨道排布，并分析结果的合理性;</p>
<p>3 主动制作错误的POSCAR和POTCAR文件，运行查看结果和错误。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1 整理自己研究方向相关的数据库资料；知道去哪里查询信息；</p>
<p>2 学会怎么根据已知的结构参数搭一些简单的分子模型: CO，H$_2$O， N$_2$， H$_2$ 等;</p>
<p>3 知道去哪里找出错文件;</p>
<p>4 熟练掌握通过 cat命令制备POTCAR的方法;</p>
<p>5 必须掌握POSCAR和POTCAR的对应关系。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>POTCAR</tag>
        <tag>数据库</tag>
        <tag>O2</tag>
        <tag>Google</tag>
        <tag>VASP找错</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex12 VASP中MAGMOM的简单设定</title>
    <url>/2017/12/04/ex12/</url>
    <content><![CDATA[<p> 很多师弟师妹问到：”师兄， 我见上一节计算的时候打开自旋极化的时候，设置MAGMOM怎么没有讲啊？”</p>
<p>为了解答师弟师妹们的疑惑（主要是给师妹讲的），本节介绍一下INCAR中MAGMOM的设置以及易出错的地方。</p>
<h3 id="MAGMOM-的设定"><a href="#MAGMOM-的设定" class="headerlink" title="MAGMOM 的设定"></a>MAGMOM 的设定</h3><p>谈到自旋极化计算，避免不了的就是MAGMOM这个参数。通过MAGMOM我们可以指定体系中原子的初始磁矩。通俗点说，就是给VASP指条计算的明路。对于复杂体系来说，合理的初始值可以加快计算速度，并保持计算结果的正确性。但是对于一些简单的磁性体系，我们可以直接使用<code>ISPIN=2</code>, MAGMOM不必进行设置。</p>
<p><img src="/2017/12/04/ex12/ex12-1.jpeg" alt=""></p>
<p>我们通过上图可以知道：O$_2$ 分子的基态是三重态，也就是每个原子都有一点单电子，所以每个氧原子的初始的磁矩可以设置为1。但VASP对MAGMOM的要求不一定非得是1，也就是初始值是一个可以模糊也可以精确的数值。因为很多时候，我们不知道确切的磁矩是多少。如果我们已经知道磁矩是多少（比如O$_2$），可以直接写上去，也可以差不多写一个； 但如果不知道的话，就需要根据自己的假设，猜一个初始值了。</p>
<p>下面通过一个问题，先简单看下MAGMOM 应该怎么设置。 对于O$_2$分子的计算，以下几行中，MAGMOM设置错误的是第几行？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MAGMOM = 2 * 1 </span><br><span class="line">MAGMOM = 1 * 2 </span><br><span class="line">MAGMOM = 1  1 </span><br><span class="line">MAGMOM = 2  2</span><br><span class="line">MAGMOM = 3  3 </span><br><span class="line">MAGMOM = 2*1</span><br><span class="line">MAGMOM = 1*2</span><br><span class="line">MAGMOM = 1.5*2</span><br><span class="line">MAGMOM = 2*1.5</span><br></pre></td></tr></table></figure>
<p>有兴趣的可以尝试一下前面中的各个选项。<strong>答案</strong>是：1，2，7，8 行。当你用了1，2，7，8行中任何一个时，会得到这样的错误信息： </p>
<p><img src="/2017/12/04/ex12/ex12-2.jpeg" alt=""></p>
<p>（此时的你，应该知道从哪里找到的这个错误信息，不知道的请查看前面几节的内容）</p>
<p>显示的错误告诉我们MAGMOM设置的不合理。为什么会出错呢？ 我们看下官网MAGMOM的说明：</p>
<p><img src="/2017/12/04/ex12/ex12-3.jpeg" alt=""></p>
<p><strong>敲黑板：</strong></p>
<ul>
<li><p>首先：MAGMOM是一个实数的排列（real array）</p>
</li>
<li><p>其次：注意红色框框中的部分。默认值是，原子的个数乘以1.0，也就是原子个数在前面，MAGMOM的值在后面。</p>
</li>
<li><p>最后： *  前后没有空格，没有空格，没有空格！！！</p>
</li>
</ul>
<p>因此前面的问题中：</p>
<p>第1行存在1个错误：* 前后有空格</p>
<p>第2行存在2个错误：* 前后有空格，原子数目和MAGMOM值颠倒了</p>
<p>第7和8行存在1个错误：原子数目和MAGMOM值颠倒了</p>
<p>有的人会问，那其他行中，比如第5行设置的 3 3 难道也正确吗？ 正确的磁矩不应该是1 1 吗？</p>
<p>是的，这是正确的，看官网的话：</p>
<p>If one is searching for a spin polarised (ferro- or antiferromagnetic) solution, it is usually safest to start from larger local magnetic moments, because in some cases, the default values might not be sufficiently big. A safe default is usually the experimental magnetic moment multiplied by 1.2 or 1.5.</p>
<ul>
<li><p>MAGMOM并不要求严格按照我们已知的数据去输入</p>
</li>
<li><p>如果你知道体系的磁矩是多少，初始的时候可以设置的更大些，1.2或者1.5倍。</p>
</li>
<li><p>如果你设置的很大，通常情况下（MAGMOM = 5 5 或者MAGMOM = 2*5，或者更疯狂：MAGMOM = 2*10） ，VASP会自动矫正回来。但是大师兄建议1.5倍足够了。</p>
</li>
<li><p>如果你不知道体系的磁矩是多少，可以根据原子所处的化学环境， 根据成键情况，大体推测有多少个未成对电子，然后将未成对电子数目*1.5即可。</p>
</li>
<li><p>VASP的wiki版中：* 前面有空格，这是不对的。</p>
<p><img src="/2017/12/04/ex12/ex12-4.jpeg" alt=""></p>
</li>
</ul>
<p>当我们正确解决了POSCAR的结构搭建，懂得了POTCAR和POSCAR的关系，以及如何设置MAGMOM时，就可以计算O$_2$的单点能量了。当然，本例中MAGMOM不用设置，因为默认值就是1，如果你的体系很简单，那么直接ISPIN = 2 就可以了，MAGMOM可以不管。</p>
<h5 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h5><p>大师兄计算了一个复杂大分子在Ni(111)表面上的吸附情况。有56个Ni，17个C，20个H，以及6个O原子。前面已经学到，当体系中含有Ni的时候，要考虑自旋的情况。 Ni(111)表面是一个简单的自旋体系，完全可以使用默认值。因为体相的Ni磁矩为0.56 μB左右。默认值为1.0，已经足够大。为了让大家有一个更加清晰的印象。大师兄专门设置了一个MAGMOM。 如下图：</p>
<p><img src="/2017/12/04/ex12/ex12-5.jpeg" alt=""></p>
<p>INCAR 中MAGMOM的设置：</p>
<p><img src="/2017/12/04/ex12/ex12-6.jpeg" alt=""></p>
<p>通过该例子，相比大家对MAGMOM的设置以及该注意的地方已经熟练掌握了，当然还有非线性的MAGMOM设置，这个在后面详细描述。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1） 对于简单体系来说，MAGMOM可以采用默认值；</p>
<p>2） MAGMOM设置的时候，初始值不要求与实验值完全一致，一般取大些（1.5倍）比较好。</p>
<p>3） MAGMOM磁矩中*前后没有空格。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>磁性</tag>
        <tag>MAGMOM</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex13 论合理结构的重要性（一）</title>
    <url>/2017/12/05/ex13/</url>
    <content><![CDATA[<p>前面我们学会了O$_2$分子的优化，分析了其电子构型，并且知道了理论结果和实验结果间存在的偏差。这一节我们依然研究O$_2$分子的结构优化，虽然模型简单，但熟练掌握其中的技巧，对今后的计算工作，意义重大。</p>
<h3 id="测试Bad-结构"><a href="#测试Bad-结构" class="headerlink" title="测试Bad 结构"></a>测试Bad 结构</h3><p>首先，我们将O$_2$的初始键长设置为：1.5 Å。其他文件与Ex11中的保持不变。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O</span><br><span class="line">1.0</span><br><span class="line">7.5 0.0 0.0</span><br><span class="line">0.0 8.0 0.0</span><br><span class="line">0.0 0.0 8.9</span><br><span class="line">O</span><br><span class="line">2</span><br><span class="line">Cartesian</span><br><span class="line">0.0 0.0 0.0</span><br><span class="line">0.0 0.0 1.5</span><br></pre></td></tr></table></figure>
<p>然后提交命令进行计算，等待结束后。查看结果，并对比前面Ex11练习的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex13$ tail OSZICAR</span><br><span class="line">DAV:   1    -0.985412177027E+01   -0.57432E-02   -0.12528E+00   144   0.457E+00    0.433E-01</span><br><span class="line">DAV:   2    -0.985315825637E+01    0.96351E-03   -0.76431E-03   144   0.367E-01    0.166E-01</span><br><span class="line">DAV:   3    -0.985344344928E+01   -0.28519E-03   -0.78039E-04   120   0.129E-01    0.707E-02</span><br><span class="line">DAV:   4    -0.985368960614E+01   -0.24616E-03   -0.14892E-04   144   0.510E-02    0.268E-02</span><br><span class="line">DAV:   5    -0.985378634076E+01   -0.96735E-04   -0.12727E-05    96   0.167E-02</span><br><span class="line">   8 F= -.98537863E+01 E0= -.98537863E+01  d E =-.142913E+01  mag=     2.0000</span><br><span class="line">       N       E                     dE             d eps       ncg     rms          rms(c)</span><br><span class="line">DAV:   1    -0.985528191871E+01   -0.15923E-02   -0.11782E-01   168   0.140E+00    0.130E-01</span><br><span class="line">DAV:   2    -0.985521232023E+01    0.69598E-04   -0.82384E-04   120   0.126E-01</span><br><span class="line">   9 F= -.98552123E+01 E0= -.98552123E+01  d E =-.143055E+01  mag=     2.0000</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex13$ tail ../ex11/opt/OSZICAR</span><br><span class="line">DAV:   8    -0.985382407600E+01   -0.31391E-03   -0.20867E-05   120   0.151E-02    0.891E-03</span><br><span class="line">DAV:   9    -0.985418412704E+01   -0.36005E-03   -0.33607E-05   120   0.162E-02    0.520E-03</span><br><span class="line">DAV:  10    -0.985440719048E+01   -0.22306E-03   -0.20675E-05   120   0.115E-02    0.367E-03</span><br><span class="line">DAV:  11    -0.985450935523E+01   -0.10216E-03   -0.85511E-06   120   0.750E-03    0.174E-03</span><br><span class="line">DAV:  12    -0.985454505708E+01   -0.35702E-04   -0.14739E-06   120   0.339E-03</span><br><span class="line">   3 F= -.98545451E+01 E0= -.98545451E+01  d E =-.451963E-01  mag=     2.0000</span><br><span class="line">       N       E                     dE             d eps       ncg     rms          rms(c)</span><br><span class="line">DAV:   1    -0.985517058251E+01   -0.66123E-03   -0.43217E-02    96   0.851E-01    0.792E-02</span><br><span class="line">DAV:   2    -0.985515527518E+01    0.15307E-04   -0.49070E-04   168   0.969E-02</span><br><span class="line">   4 F= -.98551553E+01 E0= -.98551553E+01  d E =-.458065E-01  mag=     2.0000</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在本练习中，我们设置了键长为：1.5 $\AA$，距离稳定结构较大，用了9个离子步才收敛。在Ex11练习中，我们使用的是数据库中O$_2$的键长，只优化了4步就收敛了。由此可见，一个好的初始结构可以加快我们的计算。那么有多快呢？ 我们看一下OUTCAR中的时间信息，对比看下一目了然。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex13$ tail OUTCAR</span><br><span class="line">                            User time (sec):       <span class="number">20.196</span></span><br><span class="line">                          System time (sec):        <span class="number">7.877</span></span><br><span class="line">                         Elapsed time (sec):      <span class="number">144.523</span></span><br><span class="line"></span><br><span class="line">                   Maximum memory used (kb):      <span class="number">116704.</span></span><br><span class="line">                   Average memory used (kb):           <span class="number">0.</span></span><br><span class="line"></span><br><span class="line">                          Minor page faults:        <span class="number">72067</span></span><br><span class="line">                          Major page faults:            <span class="number">0</span></span><br><span class="line">                 Voluntary context switches:         <span class="number">3191</span></span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex13$ tail ../ex11/opt/OUTCAR</span><br><span class="line">                            User time (sec):        <span class="number">8.387</span></span><br><span class="line">                          System time (sec):        <span class="number">7.789</span></span><br><span class="line">                         Elapsed time (sec):       <span class="number">17.433</span></span><br><span class="line"></span><br><span class="line">                   Maximum memory used (kb):      <span class="number">114276.</span></span><br><span class="line">                   Average memory used (kb):           <span class="number">0.</span></span><br><span class="line"></span><br><span class="line">                          Minor page faults:        <span class="number">26287</span></span><br><span class="line">                          Major page faults:            <span class="number">3</span></span><br><span class="line">                 Voluntary context switches:         <span class="number">3202</span></span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex13$</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>判断计算是否结束以及结构是否收敛：上面大师兄用了2个命令：</p>
<p>1） tail OSZICAR</p>
<p>左下角显示了结构优化进行了多少步，这里是9步！注意，我们的INCAR 里面设置的NSW = 10。如果优化的步数小于我们设置的，说明结构已经收敛到了我们所期望的标准。</p>
<p>2） tail OUTCAR</p>
<p>会显示：VASP结束后计算的内存，时间等信息，如果你看到与上图中类似的信息，说明计算结束了。</p>
<h3 id="优化的小思考"><a href="#优化的小思考" class="headerlink" title="优化的小思考"></a>优化的小思考</h3><h5 id="思考1："><a href="#思考1：" class="headerlink" title="思考1："></a>思考1：</h5><p>上面的计算中，我们在INCAR中设置的<code>NSW =10</code>，实际计算用了9步，说明计算刚刚收敛了。但是：如果结构优化的步数等于NSW设置的步数，说明了什么，是什么原因？又该怎么办？</p>
<p>出现这种情况，说明可能还没有达到我们的收敛标准，可能是以下几个原因造成的： </p>
<p>1) NSW设置的偏小； 如果我们在本节例子中设置了<code>NSW=8</code>;</p>
<p>2) 初始结构不合理，计算需要更多的离子驰豫过程； </p>
<p>3) 设置的收敛标准太严格， 比如：-0.01 或者 -0.001； </p>
<p>4) 结构很复杂，每一离子步中的电子步骤收敛很困难。</p>
<p>除此之外，还有一种可能，即刚刚进行到NSW设置的步数时，计算恰好收敛了。比如本例中，我们设置了<code>NSW = 9</code>。但这种可能几率很低，但如果你计算的足够多，还是有机会碰到的。（碰到这种情况时，一定不要慌张，要立马出门去买彩票，中了奖后要记得和大师兄平分！）</p>
<h5 id="思考2："><a href="#思考2：" class="headerlink" title="思考2："></a>思考2：</h5><p>怎么判断上述这种特殊情况呢？</p>
<p>首先，我们要知道计算收敛结束后VASP所输出的内容，也要知道未收敛时VASP结束后输出的内容。目前，现在我们知道进行了9步的时候，该计算正常结束。那我们就可以设置NSW为一个较小的值（比如 NSW=5），然后查看下未收敛时候的结果，并进行对比分析！</p>
<p>结构收敛OUTCAR （NSW=10）：</p>
<p><img src="/2017/12/05/ex13/ex13-03.jpeg" alt=""></p>
<p>结构未收敛OUTCAR （NSW=2）：</p>
<p> <img src="/2017/12/05/ex13/ex13-04.jpeg" alt=""></p>
<p>通过对比，我们可以发现，结构收敛的结果里面多了这一行：　 </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">reached required accuracy - stopping structural energy minimisation</span><br></pre></td></tr></table></figure>
<p>因此我们在今后的计算中，可以通过这一行来判断计算是否收敛结束。怎么判断呢？前面我们讲到了通过分析OUTCAR并结合grep命令来提取信息的方法，这里我们稍微复习一遍。下图中大师兄尝试了几个grep命令： </p>
<p>看下输出结果:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex13/nsw10$ grep accuracy   OUTCAR</span><br><span class="line"> reached required accuracy - stopping structural energy minimisation</span><br><span class="line"> iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex13/nsw10$</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex13/nsw10$ grep stopping OUTCAR</span><br><span class="line">   EDIFF  = 0.1E-03   stopping-criterion <span class="keyword">for</span> ELM</span><br><span class="line">   EDIFFG = 0.1E-02   stopping-criterion <span class="keyword">for</span> IOM</span><br><span class="line"> reached required accuracy - stopping structural energy minimisation</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex13/nsw10$</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex13/nsw10$ grep structural OUTCAR</span><br><span class="line">Analysis of structural, dynamic, and magnetic symmetry:</span><br><span class="line"> reached required accuracy - stopping structural energy minimisation</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex13/nsw10$</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex13/nsw10$ grep <span class="string">&#x27;reached required accuracy&#x27;</span> OUTCAR</span><br><span class="line"> reached required accuracy - stopping structural energy minimisation</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex13/nsw10$</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex13/nsw10$ grep <span class="string">&#x27;reached required accuracy - stopping structural energy minimisation&#x27;</span> OUTCAR</span><br><span class="line"> reached required accuracy - stopping structural energy minimisation</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex13/nsw10$</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex13/nsw10$ grep reached OUTCAR</span><br><span class="line">------------------------ aborting loop because EDIFF is reached ----------------------------------------</span><br><span class="line">------------------------ aborting loop because EDIFF is reached ----------------------------------------</span><br><span class="line">------------------------ aborting loop because EDIFF is reached ----------------------------------------</span><br><span class="line">------------------------ aborting loop because EDIFF is reached ----------------------------------------</span><br><span class="line">------------------------ aborting loop because EDIFF is reached ----------------------------------------</span><br><span class="line">------------------------ aborting loop because EDIFF is reached ----------------------------------------</span><br><span class="line">------------------------ aborting loop because EDIFF is reached ----------------------------------------</span><br><span class="line">------------------------ aborting loop because EDIFF is reached ----------------------------------------</span><br><span class="line">------------------------ aborting loop because EDIFF is reached ----------------------------------------</span><br><span class="line"> reached required accuracy - stopping structural energy minimisation</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从图中可以看出来，选择不同的grep 参数，会得到不同的输出结果。一般来说，grep后面的内容越详细，得到的输出结果也就会越匹配。我们提取信息的首要原则是：<strong>精确匹配并提取最有价值的信息</strong>！</p>
<p>其中：grep ‘reached required accuracy’ OUTCAR 是大师兄常用的一个命令。</p>
<p>（要提取的内容通过单引号扩起来了。）</p>
<h3 id="bashrc"><a href="#bashrc" class="headerlink" title="~/.bashrc"></a>~/.bashrc</h3><p>那么你会问道：“大师兄，你是不是傻X啊，这么长的命令，光输入就费老大劲了，不嫌麻烦么？”</p>
<p>哈哈，大师兄不仅傻，更喜欢偷懒。每次检查的时候这样子输入肯定麻烦。但在linux下面，有个小窍门，可以极大极大极大地提高你的工作效率，那就是<code>~/.bashrc</code> 文件中的 <code>alias</code>：（注意前面的点 . ）</p>
<p>.bashrc 文件怎么用呢？它在哪里？ 怎么打开？</p>
<p>答：在home目录下，</p>
<p>1） 终端（terminal）里面直接输入 cd 这个命令，会自动返回到home 目录下面：</p>
<p>然后运行命令：<code>vi .bashrc</code></p>
<p>2） 当然，如果你不想跳转回去，也可以这样：vi  ~/.bashrc  波浪号代表home</p>
<p><img src="/2017/12/05/ex13/ex13-06.jpeg" alt=""></p>
<p>它怎么用?</p>
<p><a href="http://www.linuxidc.com/Linux/2015-02/113310.htm">http://www.linuxidc.com/Linux/2015-02/113310.htm</a>   （参考网址）</p>
<p>1）打开 .bashrc 文件：（大师兄的bashrc文件为例：）</p>
<p><img src="/2017/12/05/ex13/ex13-07.jpeg" alt=""></p>
<p>2） 将前面我们用到的命令写进 .bashrc 文件：</p>
<p><img src="/2017/12/05/ex13/ex13-08.jpeg" alt=""></p>
<p>注意的部分： </p>
<p>A) alias 和 gr 之间有空格；</p>
<p>B) gr 是大师兄随便想的，你也可以用自己想的其他字母；</p>
<p>C) gr之间没有空格；</p>
<p>D) gr后面紧跟着等号 = ， 中间没有空格；</p>
<p>E) 等号 = 后面紧跟着双引号，且等号= 和双引号之间没有空格；</p>
<p>F) 双引号之间，把我们的命令放进去，一定要确保命令在引号里面；</p>
<p>G)等号 = 后面可以用单引号，也可以用双引号，因为我们的命令中已经有单引号了，这里我们用的双引号，下面两者效果是一样的；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias gr=&quot;grep &#x27;reached required accuracy&#x27; OUTCAR&quot;</span><br><span class="line">alias gr=&#x27;grep &quot;reached required accuracy&quot; OUTCAR&#x27;</span><br></pre></td></tr></table></figure>
<p>注意：上图中两者任选一个即可，不要都放进去，否则会乱套。保存后退出。</p>
<p><img src="/2017/12/05/ex13/ex13-09.jpeg" alt=""></p>
<p>3)  source 一下 .bashrc 文件。下图中的几个命令效果是一样的！ </p>
<p><img src="/2017/12/05/ex13/ex13-10.jpeg" alt=""></p>
<p>在这里点 <code>.</code> 和 <code>source</code> 命令的效果一样。</p>
<p>4 运行命令：（敲一下gr，回车即可）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex13/nsw10$ ls</span><br><span class="line">CHG  CHGCAR  CONTCAR  DOSCAR  EIGENVAL  IBZKPT  INCAR  job_sub  KPOINTS  OSZICAR  OUTCAR  PCDAT  POSCAR  POTCAR  REPORT  slurm-1023075.out  vasprun.xml  WAVECAR  XDATCAR</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex13/nsw10$</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex13/nsw10$ gr</span><br><span class="line"> reached required accuracy - stopping structural energy minimisation</span><br></pre></td></tr></table></figure>
<p>当你看到这个信息的时候，说明优化任务就已经算完了。  在这里gr 命令就是前面 .bashrc 文件中alias 后面的那个命令。如果还不明白，看下面的例子。大师兄把.bashrc 文件中的 gr 替换成了bigbro , source 了一下后，运行 bigbro命令，得到了和前面一样的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias bigbro=&#x27;grep &quot;reached required accuracy&quot; OUTCAR&#x27;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex13/nsw10$ bigbro</span><br><span class="line"> reached required accuracy - stopping structural energy minimisation</span><br></pre></td></tr></table></figure>
<p><img src="/2017/12/05/ex13/ex13-11.jpeg" alt=""></p>
<p>5 ）注意：</p>
<p>避免你自己定义的命令名字和linux下面自带的命令重复。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias  cd=&quot;grep &#x27;reached required accuracy&#x27; OUTCAR&quot;</span><br></pre></td></tr></table></figure>
<p>但是可以这样设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias  cd=&quot;cd &amp;&amp; ls &quot;</span><br></pre></td></tr></table></figure>
<p>比如：在linux系统下，使用cp命令复制文件夹的时候，需要用到 cp -r A B 。有时候会忘记加 -r而出错，我们可以这样设置，<code>alias cp=&#39;cp -r &#39;</code>来避免出错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW$ cp ex13 ex14</span><br><span class="line">cp: omitting directory `ex13&#x27;</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW$ cp ex13 ex14 -r</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW$ vi ~/.bashrc</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW$ .  ~/.bashrc</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW$ cp ex13 ex15</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW$</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果你极其地讨厌一个人，可以在他的服务器下面这样设置！！！ 建议大家报复的时候可以采用这样温柔点的设置，这样，他每敲一次命令就会被你骂一次。（史上最狠报复，只适用于对付那些深深伤害了你的人！）大家只可以感受下这把刀的威力，切不可自作孽!</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias cd=&#x27;cd  ~&#x27;</span><br><span class="line">alias cp=&#x27;echo &quot;You are a XXX&quot; &#x27;</span><br><span class="line">alias ls=&#x27;echo &quot;You are a XXX&quot; &#x27;</span><br></pre></td></tr></table></figure>
<h3 id="扩展练习："><a href="#扩展练习：" class="headerlink" title="扩展练习："></a>扩展练习：</h3><p>1 分别设置O$_2$的初始键长为1.5和 0.9 Å，运行任务；</p>
<p>2 查看收敛情况；</p>
<p>3 查看结构信息和能量信息；</p>
<p>4 如果有不合理的地方，自己尝试解决。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>本节讲解了</p>
<p>1) 查看任务计算完成的日常做法，</p>
<p>2) 一个在日常计算中极为重要的处理问题的方法，以及简化日常命令的方式。</p>
<p>通过设置.bashrc文件中的alias 命令,我们便可以自己随心所欲地将计算中的长命令、复杂的命令转化为简单的命令,从而极大地提高了我们的工作效率,尤其是适用于那些:使用频繁的但又很复杂的命令。</p>
<p>3) 一个思想：如果我们已知一个结果，那么便可以通过调控不同的参数，然后再与已知结果进行对比，从而分析不同参数在计算中的作用。</p>
<p>这一个思想贯穿了本书的写作过程，对于大家加深对VASP的理解以及练习意义非凡。熟练运用这一种方法，你的洞察力和判断力会得到极大地提升。希望大家能认真思考下本节中提出的处理问题的思想，以及熟练运行alias简化自己的命令。</p>
<p> 4） 为了锻炼大家的判断力，请做下题：以最快的速度找到图中的小猫：</p>
<p><img src="/2017/12/05/ex13/ex13-12.jpeg" alt=""></p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>alias</tag>
        <tag>合理结构</tag>
        <tag>grep</tag>
        <tag>bashrc</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex14 论合理结构的重要性（二）</title>
    <url>/2017/12/06/ex14/</url>
    <content><![CDATA[<p>在ex13中，当初始值为1.5 $\AA$ 的时候，计算共进行了9步。对比下之前我们采用实验值（Ex11）作为初始结构计算时用了4步。从这里我们可以看出来，如果你一个合理的初始结构，可以加快优化的速度，减少机时，节约你的时间。当然，计算的具体时间可以通过OUTCAR尾部的信息查看。</p>
<h3 id="不同初始结构对结果的影响。"><a href="#不同初始结构对结果的影响。" class="headerlink" title="不同初始结构对结果的影响。"></a>不同初始结构对结果的影响。</h3><p>那么不同的初始结构，除了在时间上，对计算的结构还有影响吗？ 首先我们对比下Ex11和Ex13的结果。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW$ tail ex13/nsw10/CONTCAR</span><br><span class="line">     0.0000000000000000    8.0000000000000000    0.0000000000000000</span><br><span class="line">     0.0000000000000000    0.0000000000000000    8.9000000000000004</span><br><span class="line">   O</span><br><span class="line">     2</span><br><span class="line">Direct</span><br><span class="line">  0.0000000000000000  0.0000000000000000  0.0149145061380336</span><br><span class="line">  0.0000000000000000  0.0000000000000000  0.1536248197046605</span><br><span class="line"></span><br><span class="line">  0.00000000E+00  0.00000000E+00  0.00000000E+00</span><br><span class="line">  0.00000000E+00  0.00000000E+00  0.00000000E+00</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW$ tail ex11/opt/CONTCAR</span><br><span class="line">     0.0000000000000000    8.0000000000000000    0.0000000000000000</span><br><span class="line">     0.0000000000000000    0.0000000000000000    8.9000000000000004</span><br><span class="line">   O</span><br><span class="line">     2</span><br><span class="line">Direct</span><br><span class="line">  0.0000000000000000  0.0000000000000000 -0.0019537557431563</span><br><span class="line">  0.0000000000000000  0.0000000000000000  0.1367852164173130</span><br><span class="line"></span><br><span class="line">  0.00000000E+00  0.00000000E+00  0.00000000E+00</span><br><span class="line">  0.00000000E+00  0.00000000E+00  0.00000000E+00</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW$</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在Ex11和Ex13中，两个计算的能量和CONTCAR中的键长值也几乎相等，看下面的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW$ python</span><br><span class="line">Python 2.6.6 (r266:84292, Sep  4 2013, 07:46:00)</span><br><span class="line">[GCC 4.4.7 20120313 (Red Hat 4.4.7-3)] on linux2</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; 0.1536248197046605-0.0149145061380336</span><br><span class="line">0.13871031356662689</span><br><span class="line">&gt;&gt;&gt; 0.1367852164173130--0.0019537557431563</span><br><span class="line">0.13873897216046929</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="另一个bad结构的计算"><a href="#另一个bad结构的计算" class="headerlink" title="另一个bad结构的计算"></a>另一个bad结构的计算</h3><p>上次我们用了一个大于实验值的初始结构1.5$\AA$。下面我们看下小于实验值的初始情况：0.9 $\AA$ 。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex14$ cat POSCAR</span><br><span class="line">O</span><br><span class="line"><span class="number">1.0</span></span><br><span class="line"><span class="number">7.5</span> <span class="number">0.0</span> <span class="number">0.0</span></span><br><span class="line"><span class="number">0.0</span> <span class="number">8.0</span> <span class="number">0.0</span></span><br><span class="line"><span class="number">0.0</span> <span class="number">0.0</span> <span class="number">8.9</span></span><br><span class="line">O</span><br><span class="line"><span class="number">2</span></span><br><span class="line">Cartesian</span><br><span class="line"><span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.0</span></span><br><span class="line"><span class="number">0.0</span> <span class="number">0.0</span> <span class="number">0.9</span></span><br></pre></td></tr></table></figure>
<p>INCAR，KPOINTS，POTCAR等不变，提交任务，等待计算结束，查看结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex14$ tail OSZICAR</span><br><span class="line">DAV:  18     0.141396114006E+03    0.20879E-02   -0.88760E-04   144   0.130E-01    0.579E-01</span><br><span class="line">DAV:  19     0.141397297948E+03    0.11839E-02   -0.52751E-04    96   0.893E-02    0.455E-01</span><br><span class="line">DAV:  20     0.141388687914E+03   -0.86100E-02   -0.28657E-03   144   0.231E-01    0.206E+00</span><br><span class="line">DAV:  21     0.141395321236E+03    0.66333E-02   -0.62073E-03    96   0.361E-01    0.112E+00</span><br><span class="line">DAV:  22     0.141389669824E+03   -0.56514E-02   -0.95109E-03    96   0.429E-01    0.161E-01</span><br><span class="line">DAV:  23     0.141382943017E+03   -0.67268E-02   -0.22808E-03    96   0.216E-01    0.118E+00</span><br><span class="line">DAV:  24     0.141390086243E+03    0.71432E-02   -0.39635E-03    96   0.307E-01    0.825E-01</span><br><span class="line">DAV:  25     0.141385767811E+03   -0.43184E-02   -0.44984E-03    96   0.305E-01    0.480E-01</span><br><span class="line">DAV:  26     0.141385726226E+03   -0.41585E-04   -0.10329E-04    96   0.429E-02</span><br><span class="line">   5 F= 0.14138573E+03 E0= 0.14138680E+03  d E =0.141123E+03  mag=    -2.0000</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>计算共进行了5步，且最后的磁矩看起来是正确的。<strong>思考</strong>： 从这里得出的信息，能确定我们的计算结果是正确的吗？ </p>
<p>答： 不知道。因为我们还要要去查看一下结构。判断结构是否合理。如果结构不合理，则收敛的计算也是失败了。</p>
<p>用p4vasp打开CONTCAR后，如下图：</p>
<p><img src="/2017/12/06/ex14/ex14-1.jpeg" alt=""></p>
<p>师兄，这是神马情况，两个原子怎么跑这么远？</p>
<p>不用担心，这是因为周期性的原因。p4vasp中可以进行如下的操作：</p>
<p><img src="/2017/12/06/ex14/ex14-2.jpeg" alt=""></p>
<p>首先，点击左侧的Build按钮，然后再点击右侧的 To unit cell。这样你会发现结构调整到下图的样子：</p>
<p><img src="/2017/12/06/ex14/ex14-3.jpeg" alt=""></p>
<p>两个原子之间的距离还是很长（7.821 $\AA$），但实际键长不是这么长的。</p>
<p>而是8.9-7.821 = 1.079 $\AA$。</p>
<p>师兄你为什么这么算?</p>
<p>因为我们的体系是周期性的，也就是图中的格子在三维方向上可以无限重复，如果我们向左重复一个单元，那么在新的单元中右侧的氧原子与原来左侧的氧原子距离很短。已知格子在z方向的长度为8.9 $\AA$，减去7.821就是剩下的两个氧原子之间的键长了。</p>
<p>如果，你还不明白，进行下图的操作：</p>
<p><img src="/2017/12/06/ex14/ex14-4.jpeg" alt=""></p>
<p>点击左侧的Control 选项，然后在下面红色框中，将格子在三维方向上重复，效果如下：</p>
<p><img src="/2017/12/06/ex14/ex14-5.jpeg" alt=""></p>
<p>注意，该操作只是展示三维方向的结构，如果此时你保存结构，不管你在三维方向上重复了多少次，保存的结构则还是原来的尺寸大小。</p>
<p><img src="/2017/12/06/ex14/ex14-6.jpeg" alt=""></p>
<p>键长为1.0785 $\AA$。</p>
<h5 id="周期性的显示问题"><a href="#周期性的显示问题" class="headerlink" title="周期性的显示问题"></a>周期性的显示问题</h5><p>暂且抛开对错不说，由于周期性导致的原子不在一个格子里面的情况，在今后的计算中你会经常碰到。如果你遇到这种情况，不要立即在群里问：师兄，为什么优化之后，体系中的原子不见了？为什么之前左面原子不见了，右侧本来没有原子，优化完多了？</p>
<p> 归根结底都是周期性导致的显示问题。你需要做的就是把结构在三维方向上重复一下，查看结构是对还是错。</p>
<h5 id="结果对还是错？"><a href="#结果对还是错？" class="headerlink" title="结果对还是错？"></a>结果对还是错？</h5><p>现在我们分析下对错，已知O$_2$分子的键长为1.2075 $\AA$，因此该计算与实验值偏差为：（1.0785-1.2075）/1.2075 =10.68 %，这么大的偏差，是不可以忍受的。</p>
<p>检查一下能量： 为 -8.54642426 eV。 之前正确的能量为： -9.85498627eV。</p>
<p><img src="/2017/12/06/ex14/ex14-7.jpeg" alt=""></p>
<p>在第二版的改进中，大师兄又计算了这个任务一次，得到了另外一个结果：2个O原子距离很短。</p>
<p><img src="/2017/12/06/ex14/ex14-8.png" alt=""></p>
<p>查看能量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex14$ grep &#x27;  without&#x27; OUTCAR</span><br><span class="line">  energy  without entropy=        0.26254047  energy(sigma-&gt;0) =        0.26254047</span><br><span class="line">  energy  without entropy=       11.76187113  energy(sigma-&gt;0) =       11.76187113</span><br><span class="line">  energy  without entropy=      142.97353506  energy(sigma-&gt;0) =      142.97353506</span><br><span class="line">  energy  without entropy=  1359169.21650280  energy(sigma-&gt;0) =  1359169.21650280</span><br><span class="line">  energy  without entropy=      141.38788142  energy(sigma-&gt;0) =      141.38680382</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex14$</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>思考： 能量为什么会差这么多呢（1.11 eV 或者最新结果140多eV）？ </p>
<p>答： 我们需要知道体系的能量随键长的变化关系：如下图：</p>
<p> <img src="/2017/12/06/ex14/ex14-7.jpg" alt=""></p>
<p>图中X 处是O$_2$的稳定结构，两个原子间距离小于X处的键长时，它们之间的排斥力导致了体系的能量快速升高。</p>
<p>由于我们已经知道了正确的计算结果，通过分析后，这次的计算失败！但对于不知道结果的时候，怎么判断计算是否成功失败呢？首先根据VASP计算的收敛情况，也就是计算至少应该正常结束，其次，这是远远不够的，我们还要查看输出结构的几何构型，判断是否具有物理或者化学的意义，还要看每一步收敛的能量信息。这些就需要我们化学基础知识了。</p>
<h3 id="扩展练习及思考"><a href="#扩展练习及思考" class="headerlink" title="扩展练习及思考"></a>扩展练习及思考</h3><p>1 计算为什么会失败?</p>
<p>2 分析该计算中每一步收敛的情况，以及能量的变化。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>1 不合理的结构会增加计算时间；</p>
<p>2 不合理的结构会导致计算结果没意义；</p>
<p>3 知道怎么处理周期性结构中，原子不在一个晶格里面的情况；</p>
<p>4 学会判断计算结果的物理或者化学意义。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>p4vasp</tag>
        <tag>合理结构</tag>
        <tag>周期性</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex15 论合理结构的重要性（三）</title>
    <url>/2017/12/07/ex15/</url>
    <content><![CDATA[<p>继续前面一节，我们分析一下结构优化过程的细节问题，以及合理结构的重要性。</p>
<h3 id="哪里出错了？"><a href="#哪里出错了？" class="headerlink" title="哪里出错了？"></a>哪里出错了？</h3><p>查看每一离子步后的能量结果，注意命令中的单引号里面有两个空格！如果你看到这样的结果时，意味着大事不妙，结构优化失败了，SCF 也失败了！！！也就是结构没有优化好，离子步中电子步收敛也同样失败。</p>
<p>查看一下OSZICAR:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DAV:  52     0.142641482694E+03   -0.87447E-01   -0.50432E-03   120   0.175E-01    0.188E+00</span><br><span class="line">DAV:  53     0.142675598279E+03    0.34116E-01   -0.20261E-03   120   0.869E-02    0.185E+00</span><br><span class="line">DAV:  54     0.142703773182E+03    0.28175E-01   -0.26393E-03   144   0.121E-01    0.190E+00</span><br><span class="line">DAV:  55     0.142724228087E+03    0.20455E-01   -0.11280E-03   120   0.795E-02    0.193E+00</span><br><span class="line">DAV:  56     0.142809666479E+03    0.85438E-01   -0.29739E-02   120   0.433E-01    0.211E+00</span><br><span class="line">DAV:  57     0.142939449864E+03    0.12978E+00   -0.29353E-02   192   0.367E-01    0.196E+00</span><br><span class="line">DAV:  58     0.142943989012E+03    0.45391E-02   -0.90264E-04    96   0.810E-02    0.193E+00</span><br><span class="line">DAV:  59     0.142966025527E+03    0.22037E-01   -0.43114E-04   120   0.704E-02    0.196E+00</span><br><span class="line">DAV:  60     0.142973535062E+03    0.75095E-02   -0.53590E-05   144   0.234E-02</span><br><span class="line">   3 F= 0.14297354E+03 E0= 0.14297354E+03  d E =0.142711E+03  mag=     0.0441</span><br></pre></td></tr></table></figure>
<p>这里说明，第三步中电子收敛的步数达到了默认值，被强制停止了。每一个离子步中电子步数的最大值是由NELM这个参数控制的，VASP中默认值为60，也就是最大的电子收敛为60步，过了60步还不收敛就必须停止。自己VASP官网查看下相关的NELM参数。</p>
<p>下面两行如果你能看懂，说明优化的基本情况已经摸清了。</p>
<p>电子步（SCF）: <code>EDIFF</code> &lt;====&gt; <code>NELM</code></p>
<p>离子步（结构优化）：<code>EDIFFG</code> &lt;====&gt; <code>NSW</code></p>
<h3 id="电子步不收敛怎么办？"><a href="#电子步不收敛怎么办？" class="headerlink" title="电子步不收敛怎么办？"></a>电子步不收敛怎么办？</h3><p>遇到图中这种情况，大师兄分享一下自己的经验：</p>
<p>1） 首先检查自己的初始结构是不是合理的。这是关键点之一。如果合理，那么再进行下面的步骤：</p>
<p>2）如果第一个离子步中：<code>SCF</code>（也就是电子步）的计算不收敛，尝试下增加NELM的值；</p>
<ul>
<li>对于一般普通的体系可以设置<code>NELM = 100</code></li>
<li>对于一些电子结构比较难收敛的体系，可以设置更大一些：<code>NELM = 200</code></li>
<li>增加NELM后依然不收敛，尝试下改变<code>AMIX</code>，<code>BMIX</code>，官网推荐的参数如下：不过个人的感觉，调这些参数好像没什么用，效果甚微。</li>
</ul>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">AMIX = <span class="number">0.2</span></span><br><span class="line">BMIX = <span class="number">0.00001</span></span><br><span class="line">AMIX_MAG = <span class="number">0.8</span></span><br><span class="line">BMIX_MAG = <span class="number">0.00001</span></span><br></pre></td></tr></table></figure>
<p>3) 第一个离子步中的电子步收敛了，后面的不收敛，能量变的极大（本例），首先应该想到的是去检查结构，一般在结构不合理的时候会出现类似的情况；调整结构再提交任务。</p>
<p>4）如果前面几个离子步中电子步都不收敛，且能量变化正常，可以尝试着让任务再多算几步，后面跑着跑着可能就收敛了。</p>
<p>5）如果跑了很长时间，每一个离子步中的电子步都不收敛，可以尝试着换一个更加稳定的电子步迭代算法（ALGO参数）。这种情况：<code>ALGO = ALL</code>  结合 <code>NELM = 200</code> 可以解决大部分的问题。</p>
<p>6）但需要注意的是：<code>ALGO= ALL</code> 这个算法虽然稳定，但比较耗时。自己要权衡一下。可以尝试着两步走的战略：step1）先用<code>ALGO =ALL</code>的办法算一个单点，保存WAVECAR。step2）然后将ALGO改回原来的，读WAVECAR继续优化。</p>
<p>大师兄尝试了很多种办法，意图把初始结构从0.9 $\AA$一步直接计算正确，但是大部分时候都失败了！而且出现了各种各样的问题和错误的结果，因此，出现这种情况，第一直觉是去看结构而不是想着调节参数去怎么解决这个错误！！！从这里可以看到，如果你的初始结构不合理，会出现各种各样的问题，这也是大师兄们解决不了的。</p>
<h3 id="为什么会这样子"><a href="#为什么会这样子" class="headerlink" title="为什么会这样子"></a>为什么会这样子</h3><p>这是因为：两个氧原子之间距离在初始结构中很小，导致第一步估算之间的作用力过大，以至于后面没有办法再矫正过来。这里我们看一下<code>IBRION=2</code>时的计算步骤。</p>
<p> <img src="/2017/12/07/ex15/ex15-1.jpeg" alt=""></p>
<p>第一步，从初始结构出发，计算体系中离子间的作用力，</p>
<p>第二步，VASP尝试着把离子沿着前面估算的方向移动，尝试移动的大小由<a href="https://cms.mpi.univie.ac.at/wiki/index.php/POTIM"><code>POTIM</code></a>这一项决定，</p>
<p>第三步，计算尝试移动后能量和力的大小，据此加入一个矫正项来控制真实移动的大小；</p>
<p>第四部， 移动后，重新计算能量和力，重复前三步直至能量或者力收敛到我们设置的EDIFFG值。</p>
<p><code>IBRION = 2</code> 时，对<code>POTIM</code>的依赖性很强，因此我们计算的时候要设置一个合理值。在我们的计算中，由于初始的原子间距离很小，第一步计算时，得到的原子间的初始排斥力很强，第二步中，VASP默认的<code>POTIM</code>值是0.50，前面两步导致了尝试步中离子的移动过大，以至于后面没有办法矫正回来，最后导致O$_2$分子计算出错。</p>
<h3 id="POTIM-显神威"><a href="#POTIM-显神威" class="headerlink" title="POTIM 显神威"></a>POTIM 显神威</h3><p>大师兄，用0.9 $\AA$的时候可以调节POTIM来获得正确的结果吗？答案是肯定的。</p>
<p>如果想要正确计算的话，可以设置POTIM一个更小的值。<code>POTIM=0.1</code>，虽然从初始值算出来的力很大，我们通过POTIM强制VASP一点一点调节，来保证计算的准确。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SYSTEM = O atom</span><br><span class="line">ISMEAR = 0</span><br><span class="line">SIGMA = 0.01</span><br><span class="line">ISPIN = 2</span><br><span class="line">MAGMOM = 2*2</span><br><span class="line">IBRION = 2</span><br><span class="line">POTIM = 0.1</span><br><span class="line">NSW = 10</span><br></pre></td></tr></table></figure>
<p>提交任务，查看结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex15$ tail OSZICAR</span><br><span class="line">DAV:   3    -0.984191032147E+01   -0.12318E-01   -0.38005E-02    96   0.891E-01    0.516E-01</span><br><span class="line">DAV:   4    -0.984475378528E+01   -0.28435E-02   -0.74281E-03   144   0.367E-01    0.198E-01</span><br><span class="line">DAV:   5    -0.984632399820E+01   -0.15702E-02   -0.51626E-04    96   0.101E-01    0.914E-02</span><br><span class="line">DAV:   6    -0.984676440618E+01   -0.44041E-03   -0.15294E-04   144   0.511E-02    0.169E-02</span><br><span class="line">DAV:   7    -0.984690803808E+01   -0.14363E-03   -0.99478E-06   144   0.122E-02    0.829E-03</span><br><span class="line">DAV:   8    -0.984706391665E+01   -0.15588E-03   -0.95528E-06   120   0.898E-03    0.489E-03</span><br><span class="line">DAV:   9    -0.984722304729E+01   -0.15913E-03   -0.99988E-06   120   0.862E-03    0.292E-03</span><br><span class="line">DAV:  10    -0.984733039102E+01   -0.10734E-03   -0.63466E-06    96   0.690E-03    0.215E-03</span><br><span class="line">DAV:  11    -0.984738716468E+01   -0.56774E-04   -0.27665E-06    96   0.463E-03</span><br><span class="line">   7 F= -.98473872E+01 E0= -.98473872E+01  d E =-.101099E+02  mag=    -2.0000</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex15$ cat CONTCAR</span><br><span class="line">O</span><br><span class="line">   1.00000000000000</span><br><span class="line">     7.5000000000000000    0.0000000000000000    0.0000000000000000</span><br><span class="line">     0.0000000000000000    8.0000000000000000    0.0000000000000000</span><br><span class="line">     0.0000000000000000    0.0000000000000000    8.9000000000000004</span><br><span class="line">   O</span><br><span class="line">     2</span><br><span class="line">Direct</span><br><span class="line">  0.0000000000000000  0.0000000000000000 -0.0196261760084087</span><br><span class="line">  0.0000000000000000  0.0000000000000000  0.1207497715140281</span><br><span class="line"></span><br><span class="line">  0.00000000E+00  0.00000000E+00  0.00000000E+00</span><br><span class="line">  0.00000000E+00  0.00000000E+00  0.00000000E+00</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex15$ python</span><br><span class="line">Python 2.6.6 (r266:84292， Sep  4 2013， 07:46:00)</span><br><span class="line">[GCC 4.4.7 20120313 (Red Hat 4.4.7-3)] on linux2</span><br><span class="line">Type <span class="string">&quot;help&quot;</span>， <span class="string">&quot;copyright&quot;</span>， <span class="string">&quot;credits&quot;</span> or <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line">&gt;&gt;&gt;(0.1207497715140281--0.0196261760084087)*8.9</span><br><span class="line">1.2493459329496877</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>算出来的能量和磁矩等信息与之前正确计算的结果一致，键长也对上了。 说明我们修改<code>POTIM</code>生效了。这里<code>POTIM</code>的作用相信大家有了一个大体的了解。在<code>IBRION=2</code> 时（这是前提！！），如果初始结构很差，设置较小的<code>POTIM</code>可以有效的避免过度矫正。初始结构越好，<code>POTIM</code>的选择也就越随意。</p>
<h3 id="Python计算器"><a href="#Python计算器" class="headerlink" title="Python计算器"></a>Python计算器</h3><p>在上面的演示中，大师兄还教给你了一个终端里面的计算器，python！加减乘除非常好用，注意，使用python计算时，&gt;&gt;&gt; 和数字之间不能有空格，否则python会提示出错！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Python <span class="number">2.6</span><span class="number">.6</span> (r266:<span class="number">84292</span>， Sep  <span class="number">4</span> <span class="number">2013</span>， 07:<span class="number">46</span>:<span class="number">00</span>)</span><br><span class="line">[GCC <span class="number">4.4</span><span class="number">.7</span> <span class="number">20120313</span> (Red Hat <span class="number">4.4</span><span class="number">.7</span>-<span class="number">3</span>)] on linux2</span><br><span class="line"><span class="type">Type</span> <span class="string">&quot;help&quot;</span>， <span class="string">&quot;copyright&quot;</span>， <span class="string">&quot;credits&quot;</span> <span class="keyword">or</span> <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span> <span class="number">5</span> + <span class="number">2</span></span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>， line <span class="number">1</span></span><br><span class="line">    <span class="number">5</span> + <span class="number">2</span></span><br><span class="line">    ^</span><br><span class="line">IndentationError: unexpected indent</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span> (<span class="number">0.1207497715140281</span>--<span class="number">0.0196261760084087</span>)*<span class="number">8.9</span></span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>， line <span class="number">1</span></span><br><span class="line">    (<span class="number">0.1207497715140281</span>--<span class="number">0.0196261760084087</span>)*<span class="number">8.9</span></span><br><span class="line">    ^</span><br><span class="line">IndentationError: unexpected indent</span><br></pre></td></tr></table></figure>
<h3 id="扩展练习"><a href="#扩展练习" class="headerlink" title="扩展练习"></a>扩展练习</h3><p>1 阅读<code>IBRION</code> 参数说明：<a href="https://cms.mpi.univie.ac.at/vasp/vasp/IBRION_2.html">https://cms.mpi.univie.ac.at/vasp/vasp/IBRION_2.html</a> 知道优化过程的具体细节；</p>
<p>2 尝试不同的初始结构配合<code>POTIM</code>值，完成O$_2$的正确计算；</p>
<p>3 使用0.9 $\AA$作为初始结构，改变<code>POTIM</code>的参数值，直至计算正确；</p>
<p>4 尝试用0.9 $\AA$作为初始结构，<code>POTIM</code>采用默认值，调节其他自己认为会影响计算的参数，查看相关输出，如有错误，复制到<code>google</code>里面查找相关的原因。 </p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>体系的初始结构越合理，不仅仅是节约我们的时间，还会我们的计算过程越省心。从前面出现的问题可以看出来，结构不合理，对应出错的地方越多，我们也要绞尽脑汁去纠正。O$_2$分子的例子比较简单，我们简单通过<code>POTIM</code>实现了正确的计算。但是大家计算的体系比O$_2$ 分子复杂的多，处理起来也会更加棘手。所以需要在初始结构上下功夫。更严肃的说：初始结构就是我们的计算模型，如果模型不合理，后续的计算都会出错，甚至失败。</p>
<p>如果初始结构不合理，用<code>IBRION=2</code>的时候，<code>POTIM</code>可以很好的控制收敛，还是建议初始结构搭建的合理些，省时省力。认真学习化学基础知识，搭建好合理的初始模型才是王道，正应了那句古话：磨刀不误砍柴工！</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>p4vasp</tag>
        <tag>合理结构</tag>
        <tag>周期性</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex16 谁偷走的我的机时？（一）</title>
    <url>/2017/12/08/ex16/</url>
    <content><![CDATA[<p>前面O$_2$初始结构为0.9 $\AA$时，如果使用<code>BRION=2</code>，相对于初始结构为1.07$\AA$的时候，为避免过度矫正，我们需要设置一个更小的POTIM，大师兄尝试过了，<code>POTIM = 0.01</code> 的时候得到了正确的计算结果。到此，O$_2$分子的计算我们暂且告一段落。做计算，机时很重要，尤其是缺钱，捉襟见肘的时候，我们就更加需要珍惜，保证并提高自己的计算成功率，避免重复计算。这一节我们总结下前面讲到的影响计算时间的一些细节。大家在计算的时候知道如何把握时间，在有限的机时内获取更多的有效的计算结果。</p>
<hr>
<h3 id="1-体系的磁性-EX8"><a href="#1-体系的磁性-EX8" class="headerlink" title="1 体系的磁性 (EX8)"></a>1 体系的磁性 (EX8)</h3><p>考虑自旋后（<code>ISPIN=2</code>），VASP计算时会将电子分为两部分处理，一部分是$\alpha$电子，另一部分是$\beta$电子，我们在氧原子的自旋极化计算中提到过了，忘了的可以查看Ex8，Ex11中的内容。</p>
<p>补充一下：如果原子的<code>MAGMOM</code>为负值：应该这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MAGMOM = 10*-2 # 有10个原子，每个原子的初始磁矩为 -2</span><br></pre></td></tr></table></figure>
<p>注意： -2 不用括号（）括起来</p>
<hr>
<h3 id="2-对称性-EX8"><a href="#2-对称性-EX8" class="headerlink" title="2 对称性 (EX8)"></a>2 对称性 (EX8)</h3><p>体系的对称性降低，会增加相应的计算量。查看O原子计算时，改变晶胞大小，取消对称性前后的计算时间。</p>
<hr>
<h3 id="3-SIGMA的取值-EX1"><a href="#3-SIGMA的取值-EX1" class="headerlink" title="3  SIGMA的取值 (EX1)"></a>3  SIGMA的取值 (EX1)</h3><p>我们看一下VASP练习手册：handonsession-I 里面的一句话说明：</p>
<p><img src="/2017/12/08/ex16/ex16-1.jpg" alt=""></p>
<p>因此，设置一个较小的SIGMA值会使收敛变慢。大家对于ISMEAR的选择，一定要多看官网的说明！</p>
<hr>
<h4 id="3-1-半导体和绝缘体："><a href="#3-1-半导体和绝缘体：" class="headerlink" title="3.1 半导体和绝缘体："></a>3.1 半导体和绝缘体：</h4><p>1） K点小于4 的时候，用<code>ISMEAR=0</code>, <code>SIGMA</code>取值小一些；比如SIGMA=0.05; 此时用ISMEAR = -5 会出错；</p>
<p>2）K点数目大于4的时候，可以使用<code>ISMEAR= -5</code>；</p>
<p>3） 注意： 我们算的气体分子，是绝缘体，且只用了gamma点，所以我们参数的设置如下： </p>
<hr>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">ISMEAR=<span class="number">0</span> </span><br><span class="line">SIGMA=<span class="number">0.01</span> </span><br></pre></td></tr></table></figure>
<hr>
<h4 id="3-2-金属体系："><a href="#3-2-金属体系：" class="headerlink" title="3.2 金属体系："></a>3.2 金属体系：</h4><p>ISMEAR一般用<code>ISMEAR=0</code> 或者整数1，2即可。</p>
<p><code>SIGMA =0.1</code> 足够。</p>
<hr>
<h3 id="4-合理的初始结构-（Ex13-15）"><a href="#4-合理的初始结构-（Ex13-15）" class="headerlink" title="4 合理的初始结构 （Ex13-15）"></a>4 合理的初始结构 （Ex13-15）</h3><p>前面我们刚讲到，一个合理的初始结构，可以避免很多意外的错误以及快速得到正确的结果。</p>
<p>如果你的初始结构不合理导致的计算出错，首先应该去调整结构，最后才是去调节参数，比如上一节中<code>IBRION=2</code>时的POTIM值。</p>
<hr>
<h3 id="5-EDIFF-（Ex9）"><a href="#5-EDIFF-（Ex9）" class="headerlink" title="5 EDIFF （Ex9）"></a>5 EDIFF （Ex9）</h3><p>EDIFF 控制了电子迭代的收敛标准，如果你设置的标准比较严格，则每一个离子步需要更多的电子步数，需要的时间也会随着离子步的增加成线性关系增长。</p>
<hr>
<h3 id="6-EDIFFG-（Ex9）"><a href="#6-EDIFFG-（Ex9）" class="headerlink" title="6 EDIFFG （Ex9）"></a>6 EDIFFG （Ex9）</h3><p>EDIFFG控制了结构收敛的标准，同样严格的标准需要更多的结构优化步骤来实现。</p>
<hr>
<h3 id="扩展练习："><a href="#扩展练习：" class="headerlink" title="扩展练习："></a>扩展练习：</h3><p>1 本文所提到的内容，必须去官网查看，并认真阅读，如有不懂的，请在群里自由提问；</p>
<p>2 思考一下，还有其他因素影响我们的机时吗？</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>机时</tag>
        <tag>回顾</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex17 谁偷走的我的机时？（二）</title>
    <url>/2017/12/09/ex17/</url>
    <content><![CDATA[<p>这一节和后面几节，我们会复习一下前面学到的Linux批量操作知识，然后对一些影响计算时间的参数进行测试。 本节主要考虑<code>ENCUT</code>的影响。前面我们一直在说<code>EDIFF</code>和<code>EDIFFG</code>对计算时间的影响。为了给大家一个感性的认识，现在我们用O$_2$分子的计算作为测试例子，将结果展示出来。这两个参数主要是在计算精度上影响计算时间，很容易想到，精度越高，收敛的越慢，需要的时间对应的也会更长。</p>
<hr>
<h3 id="1-调节EDIFF和EDIFFG"><a href="#1-调节EDIFF和EDIFFG" class="headerlink" title="1 调节EDIFF和EDIFFG"></a>1 调节EDIFF和EDIFFG</h3><p><img src="/2017/12/09/ex17/ex17-1.jpeg" alt=""></p>
<p>左侧为之前计算的INCAR，右侧为提高精度后的INCAR。O$_2$的初始距离设置的为1.207$\AA$。提交计算，等待任务结束。前面我们知道VASP计算完成后，OUTCAR最后输出的是计算时间，内存等信息。我们现在查看一下：文件夹 0 对应的是之前的O$_2$计算，文件夹1 中是提高精度后的计算。</p>
<p><img src="/2017/12/09/ex17/ex17-2.jpeg" alt=""></p>
<p><strong>注意：</strong>grep User OUTCAR 后得出的结果被空格分成了4部分，时间信息在第4部分里面。User（1） time（2） （sec：）（3） 44.20 （4）</p>
<hr>
<p>讲解：</p>
<p>1.1）通过<code>tail OUTCAR</code> 这个命令，可以找到用grep命令查看时间的关键词：User 或者 Elapsed，这里我们采用User 后面的时间作为参考；</p>
<p>1.2）右下方黄色图框中的时间表面：提高了精度后，计算时间从44秒增加到78秒。</p>
<p>1.3）我们看一下，改变精度后体系的能量变化：</p>
<p><img src="/2017/12/09/ex17/ex17-3.jpeg" alt=""></p>
<p>从-9.8609降低到-9.8611，变化大小为： -0.0002 eV。 这么小的能量变化，我们可以认为忽略不计。</p>
<p>在这里，我们要认真思考收敛标准对于我们计算体系能量的影响，选取一个合适的标准而又不会浪费太多的机时。一般来说，结构优化的时候，<code>EDIFF=1E-5</code>, <code>EDIFFG =-0.01</code>至 <code>-0.03</code> 都是被认可的。</p>
<hr>
<h3 id="2-ENCUT-测试："><a href="#2-ENCUT-测试：" class="headerlink" title="2 ENCUT 测试："></a>2 ENCUT 测试：</h3><h4 id="2-1-制备ENCUT测试模板"><a href="#2-1-制备ENCUT测试模板" class="headerlink" title="2.1 制备ENCUT测试模板"></a>2.1 制备ENCUT测试模板</h4><p><img src="/2017/12/09/ex17/ex17-4.jpeg" alt=""></p>
<p>解释：  </p>
<p>2.1.1）新建测试目录 2 ，进入后，将前面的文件夹0复制过来，文件夹名为 400</p>
<p>2.1.2）使用sed命令，在INCAR中最后一行加入ENCUT参数，值设置为400</p>
<hr>
<h4 id="2-2-快速制作测试任务"><a href="#2-2-快速制作测试任务" class="headerlink" title="2.2 快速制作测试任务"></a>2.2 快速制作测试任务</h4><p><img src="/2017/12/09/ex17/ex17-5.jpeg" alt=""></p>
<p>图中的命令行为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in &#123;1..8&#125;; do cp 400 $((400+$i*50)); sed -i &quot;s/400/$((400+$i*50))/g&quot;  $((400+$i*50))/INCAR ; done</span><br></pre></td></tr></table></figure>
<p>复习前面学到的linux操作：</p>
<p>2.2.1）明白<code>&#123;1..8&#125;</code> 是怎么回事；</p>
<p>2.2.2） <code>$i</code> 变量的调用；</p>
<p>2.2.3）新学：<code>$((加减乘除))</code>，注意数学运算用2个括号 括起来；</p>
<p>2.2.4）sed 命令进行文本中某一项的替换；</p>
<p>2.2.5）运行完毕后，会获得一系列<code>ENCUT</code>值的文件夹，且每个里面INCAR已经对应地设置完毕。</p>
<hr>
<h4 id="2-3-批量提交任务"><a href="#2-3-批量提交任务" class="headerlink" title="2.3 批量提交任务"></a>2.3 批量提交任务</h4><p><img src="/2017/12/09/ex17/ex17-6.jpeg" alt=""><br>命令：<br><code>for i in *; do cd $i ; qsub sub4; cd $OLDPWD; done</code></p>
<p>讲解：</p>
<p>2.3.1）do后面执行的是，进入for循环中的文件夹，然后提交任务，（大师兄提交任务的命令是 qsub sub4， qsub 是命令，sub4是脚本名），任务提交后，返回原来的目录下（<code>cd $OLDPWD</code>），然后再进入下一个for循环中的文件夹，重复之前的操作，直至遍历所有for循环的变量文件夹；</p>
<p>2.3.2）图中的Single是任务的说明，这个在提交任务的脚本里面自己随意设置：<br><img src="/2017/12/09/ex17/ex17-7.jpeg" alt=""></p>
<hr>
<h4 id="2-4-批量查看结果的命令："><a href="#2-4-批量查看结果的命令：" class="headerlink" title="2.4 批量查看结果的命令："></a>2.4 批量查看结果的命令：</h4><p><img src="/2017/12/09/ex17/ex17-8.jpeg" alt=""></p>
<p>此处需要注意 * 的用法</p>
<p>我们只需要图中方框标出来的信息，其他的结果可以直接扔掉。为简化输出结果，这里大师兄用了另外一个强大的命令： awk</p>
<p><code>for i in *0; do echo -e  $i &quot;\t&quot; $(grep User $i/OUTCAR | awk &#39;&#123;print $4&#125;&#39;); done</code></p>
<p>2.4.1）  学会echo 命令：</p>
<p>2.4.2）  echo –e 后面加上”\t”后（双引号），可以直接输出 tab，方便导入excel；</p>
<p>2.4.3）  本例中，awk 后面用<code>&#123;&#125;</code>将打印的内容括起来；</p>
<p>2.4.4）  <code>print $4</code> 意思是输出前面结果的第4项；</p>
<p>2.4.5）  awk命令极其强大，强烈建议大家尝试着去网上查找资料，主动去学习；</p>
<p>2.4.6）将结果复制到excel里面作图。</p>
<h4 id="2-5-计算时间随着ENCUT增加的变化曲线"><a href="#2-5-计算时间随着ENCUT增加的变化曲线" class="headerlink" title="2.5 计算时间随着ENCUT增加的变化曲线"></a>2.5 计算时间随着ENCUT增加的变化曲线</h4><p><img src="/2017/12/09/ex17/ex17-10.jpeg" alt=""></p>
<p>从图中可以看出，<strong>计算时间随着ENCUT的增加也相应地增加了</strong>。因此，在保证计算准确度和ENCUT的值的选取，你要学会合理取值，加快自己的计算速度。此外，图表的比较形象直观，大家在今后的学习中，多多思考将自己的数据转化为图表的形式！可以很好的表达自己的计算结果。</p>
<p>设想一下，同学A和B把同样的数据结果给老师看，A单纯把数据列到表格里面，B做成了上图的形式，老师会喜欢谁？此外，我们也可以通过写一个简单的python脚本来实现作图的功能。</p>
<hr>
<h4 id="2-6-作图的-Python-脚本："><a href="#2-6-作图的-Python-脚本：" class="headerlink" title="2.6 作图的 Python 脚本："></a>2.6 作图的 Python 脚本：</h4><h5 id="2-6-1-获取数据，并保存成文件"><a href="#2-6-1-获取数据，并保存成文件" class="headerlink" title="2.6.1 获取数据，并保存成文件"></a>2.6.1 获取数据，并保存成文件</h5><p><img src="/2017/12/09/ex17/ex17-11.jpeg" alt=""></p>
<p>注意echo $i 后面的逗号，输出的文件 data.dat 中，逗号用于将两列数据分开。</p>
<p>2.6.1.1）图中圈出来的部分中， &gt; 代表将前面命令的输出保存到 data.dat 文件中；</p>
<p>2.6.1.2） data.dat 后缀可以随便写，<code>data.txt</code>， <code>data.out</code>, <code>data.export</code>, 也可以不写：<code>data</code> 。 因为输出后的都是文本格式，直接可以编辑打开。</p>
<p>2.6.1.3） 查看一下保存的数据结果</p>
<p><img src="/2017/12/09/ex17/ex17-12.jpeg" alt=""></p>
<h5 id="2-6-2-作图-脚本，-名为-plt-py"><a href="#2-6-2-作图-脚本，-名为-plt-py" class="headerlink" title="2.6.2 作图 脚本， 名为 plt.py"></a>2.6.2 作图 脚本， 名为 plt.py</h5><p>vim打开后，内容如下图：</p>
<p><img src="/2017/12/09/ex17/ex17-13.jpeg" alt=""></p>
<p>python程序学习参考书：<strong> learn python the hard way</strong>（免费），网上还有很多学习资料，这里就不介绍了。python读取data.dat 文件，根据 delimiter 后面的参数（此处为逗号）将数据分成若干列。</p>
<hr>
<h5 id="2-6-3-运行脚本：（python-plt-py）"><a href="#2-6-3-运行脚本：（python-plt-py）" class="headerlink" title="2.6.3 运行脚本：（python plt.py）"></a>2.6.3 运行脚本：（python plt.py）</h5><p><img src="/2017/12/09/ex17/ex17-14.jpeg" alt=""></p>
<h4 id="2-7-体系的能量随ENCUT的变化："><a href="#2-7-体系的能量随ENCUT的变化：" class="headerlink" title="2.7 体系的能量随ENCUT的变化："></a>2.7 体系的能量随ENCUT的变化：</h4><p><img src="/2017/12/09/ex17/ex17-15.jpeg" alt=""></p>
<p>获取图上结果的命令行：</p>
<p><code>for i in *0; do echo -e  $i &quot;\t&quot; $(grep User $i/OUTCAR | awk&#39;&#123;print $4&#125;&#39;) &quot;\t&quot; $(grep &#39; without&#39; $i/OUTCAR | tail -n 1 | awk &#39;&#123;print $4&#125;&#39;); done</code></p>
<p>作图过程如下：</p>
<h5 id="2-7-1-生成数据："><a href="#2-7-1-生成数据：" class="headerlink" title="2.7.1 生成数据："></a>2.7.1 生成数据：</h5><p><img src="/2017/12/09/ex17/ex17-16.jpeg" alt=""></p>
<p>前面的命令中， “\t” 改为 逗号，  done 后面 加上 &gt; data.dat， 重新运行一遍。 </p>
<h5 id="2-7-2-修改脚本如下："><a href="#2-7-2-修改脚本如下：" class="headerlink" title="2.7.2 修改脚本如下："></a>2.7.2 修改脚本如下：</h5><p><img src="/2017/12/09/ex17/ex17-17.jpeg" alt=""></p>
<p>增加了 一列（z）</p>
<hr>
<p>2.7.3 选择合适的画图区间：</p>
<p><img src="/2017/12/09/ex17/ex17-18.jpeg" alt=""></p>
<p>图中蓝色的O$_2$分子的能量随ENCUT值增加的变化，为一直线！</p>
<hr>
<p>大师兄问：结果对不对？</p>
<p>答：结果是对的，但不具有任何的合理性。</p>
<p>因为它不能体现出能量变化的趋势：因为 y 轴的取值范围太大了，而我们能量的变化又太小。这也是很多人在做模拟的时候容易犯的错误，看到一个直线，或者平滑的曲线，就如同哥伦布发现了新大陆一番。其实则不然，很多时候，真相往往被我们的粗糙的观测范围给掩盖了。</p>
<p>这个称之为作图骗人的一个Trick！很多人在发文章的时候将这一技巧运用的如火纯情。所以，当你看文献的时候，如果发现别人的结果也是一条直线或者平滑曲线，第一直觉是去看坐标轴的范围，而不是感觉别人的工作是多么地牛逼。</p>
<p>重新作图，这次只用ENCUT和O$_2$分子的能量，如下图：</p>
<p><img src="/2017/12/09/ex17/ex17-19.jpeg" alt=""></p>
<p>能量一直在降低， 结果对不对呢？对的，但变化却被过度放大了！</p>
<hr>
<p>很多新手看到这个图以为能量降低的很快，感觉自己的计算不收敛，因此还要继续往下做或者测试。其实则不然，在这里，我们还是需要主要 y 轴的取值范围。图中整个y轴的变化为0.016 eV。每两个点之间的变化仅仅为0.002 eV。这个变化我们也是可以接受的，虽然图中感觉下降的很厉害的样子。</p>
<p>上面两个图中，走了两个极端，一个极大，一个极小。所以，在我们处理数据时，一定要仔细观察坐标轴的取值范围。</p>
<hr>
<h4 id="2-8-小结一下："><a href="#2-8-小结一下：" class="headerlink" title="2.8 小结一下："></a>2.8 小结一下：</h4><p>但从数据上可以看出来，O$_2$分子的能量随着ENCUT值的增加还是会有些少许的波动。比如，从400到800 eV，能量降低了0.01 eV。大师兄，那我们该取哪个ENCUT值呢？</p>
<p>首先，我们要明确几个要点：</p>
<p>2.8.1）ENCUT值越大，计算的越精确，花费的时间也就越多；</p>
<p>2.8.2）ENCUT的取值仅仅通过一个例子的测试来确定，这是不对的；</p>
<ul>
<li>A)   在VASP的计算中，单个结构的能量所具有的意义不大，也就是说相对能量最重要！</li>
<li>B)   为什么A）中说相对能量最重要：这是因为：没有对比，就没有伤害！设想一下，你把一个O$_2$的能量算的再精确或者能量再低，而不去使用它，它也就是个数字而已，不具有任何的物理化学意义。</li>
<li>C)  B)中要表达的意思是，算出来的数值必须要应用到我们的物理化学概念中，也就是物理化学的概念体现在这些能量的使用过程中，也就是相对能量里面：比如，O$_2$的结合能， O$_2$的吸附能；某一化学反应的能量，反应能垒，表面能，功函数等等，无一不是多个能量的数学运算所的出来的。</li>
<li>D)   O$_2$的结合能示例：</li>
</ul>
<p>公式： EB = E(O$_2$) –2E(O)</p>
<p>O$_2$的结合能随着ENCUT值增加的变化情况：</p>
<p><img src="/2017/12/09/ex17/ex17-20.jpeg" alt=""></p>
<p>第一、二、三、四列分别为ENCUT，O原子能量，O$_2$分子能量和O$_2$分子中O的结合能。从图中，我们可以分析出来，ENCUT在450 eV时，O$_2$的结合能和ENCUT为800 eV的时候差别很小，因此我们可以选取450 eV进行计算。</p>
<p>注： O原子不同ENCUT的单点能，自己根据前面的过程，补充计算。</p>
<hr>
<p>2.8.3）ENCUT的取值与体系中所有的元素有关；</p>
<ul>
<li>A）体系中含有不同元素的时候，查看这些元素POTCAR中的ENMAX值，找出最大的那个；</li>
<li>B）ENCUT的最小值为所有元素中ENMAX的最大值！</li>
<li>C）也就是说，找到最大的ENMAX（max）， ENCUT值大于等于ENMAX（max）。</li>
</ul>
<p><img src="/2017/12/09/ex17/ex17-21.jpeg" alt=""></p>
<p>示例图中，<br>potcar.sh 为生成POTCAR的脚本，可在本书的附录中获取。ENCUT 的取值至少为 400 eV。</p>
<hr>
<p>2.8.4） ENCUT的值，也要查阅相关的参考文献进行确定。你的计算体系大家都用400 eV，你也可以设置该值或者稍微高一些。ENCUT很多人在刚开始做计算的时候，都会测试一个数值。如果不想测试，查找参考文献其实是一个很好的办法。</p>
<hr>
<h3 id="3-扩展练习："><a href="#3-扩展练习：" class="headerlink" title="3 扩展练习："></a>3 扩展练习：</h3><p>3.1 复习前面学到的批量操作方式；</p>
<p>3.2 熟练运用前面的操作，并理解命令的工作原理；</p>
<p>3.3 改变KPOINTS的大小，查看计算时间，能量的变化；</p>
<h3 id="4-总结："><a href="#4-总结：" class="headerlink" title="4 总结："></a>4 总结：</h3><p>1 EDIFF和EDIFFG对计算的影响通过实例强调了一次；</p>
<p>2 ENCUT 测试的操作流程；</p>
<p>3 ENCUT对计算时间和能量的影响结果分析；</p>
<p>4 通过excel 和python作图的两个方法；</p>
<p>5 能量和计算时间随ENCUT的变化；</p>
<p>6 看图时坐标轴的区间范围要注意；</p>
<p>7 总结ENCUT取值的一些注意事项。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>机时</tag>
        <tag>回顾</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex18 谁偷走的我的机时？（三）</title>
    <url>/2017/12/10/ex18/</url>
    <content><![CDATA[<h3 id="KPOINTS对计算时间的影响"><a href="#KPOINTS对计算时间的影响" class="headerlink" title="KPOINTS对计算时间的影响"></a>KPOINTS对计算时间的影响</h3><hr>
<p>继续前面的学习，本节讨论<code>KPOINTS</code>文件中K点的设置对计算时间的影响。本节图中的Linux命令不再详细介绍，大师兄默认大家已经基本掌握了其中的原理和窍门。VASP官网上还有其他的批量测试的脚本，大家现在也可以差不多能看懂了。比如Si计算的例子：<a href="https://cms.mpi.univie.ac.at/wiki/index.php/Fcc_Si">https://cms.mpi.univie.ac.at/wiki/index.php/Fcc_Si</a> </p>
<hr>
<h3 id="1-KPOINTS测试"><a href="#1-KPOINTS测试" class="headerlink" title="1 KPOINTS测试"></a>1 KPOINTS测试</h3><h4 id="1-1-准备测试模板"><a href="#1-1-准备测试模板" class="headerlink" title="1.1 准备测试模板"></a>1.1 准备测试模板</h4><p>新建文件夹: 3，将之前的文件夹0复制过来后重命名为 1。</p>
<h4 id="1-2-批量制备测试文件："><a href="#1-2-批量制备测试文件：" class="headerlink" title="1.2 批量制备测试文件："></a>1.2 批量制备测试文件：</h4><p><img src="/2017/12/10/ex18/ex18-1.jpeg" alt=""></p>
<p>命令： <code>for i in &#123;2..6&#125;; do cp 1 $i ; sed -i&quot;s/1 1 1/$i $i $i/g&quot; $i/KPOINTS ; done</code></p>
<p>文件夹1 代表KPOINTS为<code>1 1 1</code> ,6 代表KPOINTS为 <code>6 6 6</code>  其他的类推。</p>
<hr>
<h4 id="1-3-批量提交任务："><a href="#1-3-批量提交任务：" class="headerlink" title="1.3 批量提交任务："></a>1.3 批量提交任务：</h4><p><img src="/2017/12/10/ex18/ex18-2.jpeg" alt=""></p>
<p>备注：这里的qsuball 命令是把前面的批量命令放到 .bashrc 文件中了。不懂的请看Ex17的批量操作命令和Ex13中.bashrc文件中alias的使用方法。</p>
<hr>
<h3 id="2-测试结果分析"><a href="#2-测试结果分析" class="headerlink" title="2 测试结果分析"></a>2 测试结果分析</h3><h4 id="2-1-查看OUTCAR-中的K点信息"><a href="#2-1-查看OUTCAR-中的K点信息" class="headerlink" title="2.1 查看OUTCAR 中的K点信息"></a>2.1 查看OUTCAR 中的K点信息</h4><p><img src="/2017/12/10/ex18/ex18-3.jpeg" alt=""></p>
<p>图中，我们找出可以通过grep 查询的字符：irreducible  </p>
<hr>
<h4 id="2-2-批量查看所有测试的K点信息："><a href="#2-2-批量查看所有测试的K点信息：" class="headerlink" title="2.2 批量查看所有测试的K点信息："></a>2.2 批量查看所有测试的K点信息：</h4><p><img src="/2017/12/10/ex18/ex18-4.jpeg" alt=""></p>
<p><strong>命令 <code>grep irreducible 3/OUTCAR</code></strong></p>
<p>从图中可以看出：</p>
<p>1）K点<code>2 2 2</code> 和<code>3 3 3</code> 的计算中，生成的K点数目是一样的；类似地，<code>4 4 4</code> 和<code>5 5 5</code> 具有同样地K点数目；</p>
<p>2）不难理解，相同的K点数目，其计算时间也是一样的；</p>
<p>3）计算时间随K点数目的增加也增加了。</p>
<hr>
<p>师兄，为什么K点数目会存在奇数和偶数相同的关系？</p>
<p>原因在于K点生成的方法。当KPOINTS为偶数的时候，K点都在布里渊区的内部，而为奇数的时候，部分K点处在布里渊区的边界上。引用参考书中的一个表格和一段话：第三章第56-57页：</p>
<p><img src="/2017/12/10/ex18/ex18-5.jpeg" alt=""></p>
<p><img src="/2017/12/10/ex18/ex18-6.jpeg" alt=""></p>
<hr>
<h4 id="2-3-不同K点对能量的影响："><a href="#2-3-不同K点对能量的影响：" class="headerlink" title="2.3 不同K点对能量的影响："></a>2.3 不同K点对能量的影响：</h4><p><img src="/2017/12/10/ex18/ex18-7.jpeg" alt=""><br>先不画图了，直接看能量吧：</p>
<p>当K点为 <code>1 1 1</code> 和 <code>6 6 6</code> 的时候，O$_2$分子的能量差别为： 0.0015 eV。可以忽略不计。在这里，你可以清晰地知道：为什么算气相分子的时候 gamma点（1x1x1）足够了。</p>
<p>对于其他slab或者体相材料的计算，K点怎么选择呢？我们看下面这一段话：<br><img src="/2017/12/10/ex18/ex18-8.jpeg" alt=""></p>
<p>出处： <a href="https://wiki.fysik.dtu.dk/gpaw/exercises/surface/surface.html">https://wiki.fysik.dtu.dk/gpaw/exercises/surface/surface.html</a></p>
<hr>
<p>再参考一下Quantumwise 网站的说明：<br><img src="/2017/12/10/ex18/ex18-9.jpeg" alt=""><br>出处：<a href="http://quantumwise.com/forum/index.php?topic=2628.0">http://quantumwise.com/forum/index.php?topic=2628.0</a></p>
<p>再次强调一下：浏览网站说明的时候，要养成这样的一种习惯，凡是看到Note这个单次，就要跟打了鸡血一般！前面的东西看不懂不要紧，Note后面跟的都是重点易出错的地方。</p>
<hr>
<p>以上只是经验参数的说明，给我们提供一个大体的指导。这个参数在使用中，要注意我们前面提到的奇数和偶数的情况。而具体到我们的计算中，需要用什么数值，我们需要认真地测试检查一下，而不能直接就用图中的经验参数。</p>
<p>1）通过测试不同K点对体系能量的变化；（参考书中的例子）<br><img src="/2017/12/10/ex18/ex18-10.jpeg" alt=""></p>
<hr>
<p>2）查找参考文献的取值；</p>
<hr>
<p>3）此外，不同K点之间的数据不能混用。比如计算CO在一个 (3x3) Cu(111)表面上的吸附能：</p>
<script type="math/tex; mode=display">
E_{ads} = E_{CO + slab} – E_{slab} – E_{CO^{gas}}</script><p>等号后面的前两项，必须要用同一个K点下计算出来的能量，如果$E{CO+slab}$ 用<code>5x5x1</code> 的K点， E(slab) 采用 <code>3x3x1</code>的K点能量，得出的结果必然是错的。</p>
<hr>
<h3 id="2-4-来自VASP官方的提醒："><a href="#2-4-来自VASP官方的提醒：" class="headerlink" title="2.4 来自VASP官方的提醒："></a>2.4 来自VASP官方的提醒：</h3><p><img src="/2017/12/10/ex18/ex18-11.jpeg" alt=""></p>
<p>出处： <a href="https://www.vasp.at/vasp-workshop/slides/accuracy.pdf">https://www.vasp.at/vasp-workshop/slides/accuracy.pdf</a></p>
<p>1）常见错误（一）： 体系中ENCUT的取值不统一；</p>
<p>2）常见错误（二）：采用不同KPOINTS计算出来的结果。</p>
<p>3）在关于Accuracy的这个pdf文件中，最后一行大家要谨记：TEST，TEST，TEST ….</p>
<hr>
<h3 id="3-扩展练习："><a href="#3-扩展练习：" class="headerlink" title="3 扩展练习："></a>3 扩展练习：</h3><p>1 下载大师兄分享的压缩文件： 本节中所有的pdf文件和链接；大师兄QQ群文件下载，或者百度网盘：<a href="http://pan.baidu.com/s/1eSCGWeA">http://pan.baidu.com/s/1eSCGWeA</a></p>
<p>2 阅读参考书中第三章的内容，掌握K点的基本概念和一些选取的注意事项；</p>
<p>3 浏览本节中所有的网址。</p>
<hr>
<h3 id="4-总结："><a href="#4-总结：" class="headerlink" title="4 总结："></a>4 总结：</h3><p>1 K点数目越多，计算越准确，需要的时间也会相应地越多，大家要把握好准确度和时间的关系；</p>
<p>2 K点的确定，需要经验和测试相结合，经验为辅，测试为主。</p>
<hr>
<h2 id="5-补充："><a href="#5-补充：" class="headerlink" title="5 补充："></a>5 补充：</h2><p> VASP的新版本中，可以直接在INCAR中设置K点。也就是说，没有KPOINTS文件也可以正常计算，但这可能只适用于简单的K点情况，能带结算等需要制定K点路径的计算，我们还是需要KPOINTS文件的。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>KPOINTS</tag>
        <tag>机时</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex19 谁偷走的我的机时？（四）</title>
    <url>/2017/12/11/ex19/</url>
    <content><![CDATA[<h3 id="模型对计算时间的影响"><a href="#模型对计算时间的影响" class="headerlink" title="模型对计算时间的影响"></a>模型对计算时间的影响</h3><hr>
<p>上一节介绍的KPOINTS对计算的影响，相信大家已经认真阅读参考书的第三章部分了。本季我们讨论一下模型的大小对计算的影响。主要体现在晶胞的尺寸，对称性以及对K点的影响上。</p>
<hr>
<h3 id="1-测试工作："><a href="#1-测试工作：" class="headerlink" title="1 测试工作："></a>1 测试工作：</h3><p> 为了方便处理，我们把O$_2$计算的格子设置为长宽高均为8.0 $\AA$。</p>
<p><img src="/2017/12/11/ex19/ex19-1.jpeg" alt=""><br>重复之前KPOINTS的批处理操作，我们可以获得一系列不同大小格子的文件夹。如下图：<br><img src="/2017/12/11/ex19/ex19-2.jpeg" alt=""></p>
<p>命令：  <code>for i in $(seq 10 2 20); do cp 8 $i; sed –i &quot;3,5s/8.0/$i/g&quot; $i/POSCAR ;done</code></p>
<hr>
<h3 id="2-测试结果分析"><a href="#2-测试结果分析" class="headerlink" title="2 测试结果分析"></a>2 测试结果分析</h3><h3 id="2-1-模型大小对计算时间的影响"><a href="#2-1-模型大小对计算时间的影响" class="headerlink" title="2.1 模型大小对计算时间的影响"></a>2.1 模型大小对计算时间的影响</h3><p><img src="/2017/12/11/ex19/ex19-3.jpeg" alt=""></p>
<p>注意：在后面加入 <code>sort –n</code> 后输出的变化。</p>
<hr>
<p><img src="/2017/12/11/ex19/ex19-4.jpeg" alt=""></p>
<p><img src="/2017/12/11/ex19/ex19-5.jpeg" alt=""></p>
<p>从图中可以看出来，计算时间随着格子的大小，需要的计算时间增加的很快。</p>
<p>注意：在测试中，KPOINTS一直保持不变（因为只有一个Gamma点）。而在我们实际的计算操作中，使用1x1x1 KPOINTS的机会并不多。如果格子在某个方向增加了2倍，那么对应的改方向的K点就需要除以2。重复一下上节的经验指导。也就是在计算过程中，保持k<em>a保持不变。当然，k</em>a是我们提前测试好的。</p>
<p><img src="/2017/12/11/ex19/ex19-6.jpeg" alt=""></p>
<p>举例：</p>
<p>一个<code>10x10x10</code> $\AA^3$的体相材料，我们计算的时候K点设置为：<code>6x6x6</code>。</p>
<p>当我们将材料在x方向增加1倍，变为<code>20x10x10</code>  $\AA^3$。为保持一致的精确度，那么我们的K点需要设置为：<code>3x6x6</code>。</p>
<hr>
<p>这是因为倒易晶格矢量和实际的晶格矢量之间存在着倒数的关系：</p>
<p><img src="/2017/12/11/ex19/ex19-7.jpeg" alt=""></p>
<p>注： 类似的图，不加说明，均出自我们的参考书。也就是说，我们选取的晶格越大，倒易晶格矢量越小。用同等数目的K点分布到倒易晶格中，网格的密度也会越大，从而造成计算量的增加。</p>
<hr>
<h4 id="2-2-体系的对称性对计算速度的影响："><a href="#2-2-体系的对称性对计算速度的影响：" class="headerlink" title="2.2 体系的对称性对计算速度的影响："></a>2.2 体系的对称性对计算速度的影响：</h4><h5 id="2-2-1-K点保持不变："><a href="#2-2-1-K点保持不变：" class="headerlink" title="2.2.1 K点保持不变："></a>2.2.1 K点保持不变：</h5><p>这一点前面关于氧原子的计算就已经介绍到了，降低体系的对称性会增加额外的计算时间。如图：将<code>12x12x12</code> $\AA^3$ （计算需要186.86 s）的格子修改如下：</p>
<p><img src="/2017/12/11/ex19/ex19-8.jpeg" alt=""></p>
<p>计算结束后，查看时间，为194.9 s, 计算时间增加了8秒。</p>
<p><img src="/2017/12/11/ex19/ex19-9.jpeg" alt=""></p>
<h4 id="2-2-2-对称性对K点的影响："><a href="#2-2-2-对称性对K点的影响：" class="headerlink" title="2.2.2 对称性对K点的影响："></a>2.2.2 对称性对K点的影响：</h4><p>体系的对称性不仅仅提现在前面的计算中，更可以在计算中极大地减少K点的数目，从而加快计算，节省时间。这一点我们引用参考书中的一段话：</p>
<p><img src="/2017/12/11/ex19/ex19-10.jpeg" alt=""></p>
<h5 id="2-3-3-模型对称性与K点对称性的关系"><a href="#2-3-3-模型对称性与K点对称性的关系" class="headerlink" title="2.3.3 模型对称性与K点对称性的关系"></a>2.3.3 模型对称性与K点对称性的关系</h5><p>在这里，体系的对称性与K点对称性的匹配问题，尤其是对于hexagonal的结构来说，必须要使用 gamma centered points. 也就是第三行的第一个字母必须为G或者g。我们看一下官网的原话：</p>
<blockquote>
<p>We strongly recommend to use only Gamma centered grids forhexagonal lattices. Many tests we have performed indicate that the energy convergessignificantly faster with centered grids than with standard Monkhorst Pack grids. Grids generated with the “M” setting in the third line, in fact do not have full hexagonal symmerty.</p>
</blockquote>
<p>如果你不确定自己的体系，直接用G就可以了。</p>
<blockquote>
<p>For reasons of safety it might be a good choice to use only meshes with theirorigin at (switch “G” or “g” on third line or odd divisions) if the tetrahedron method is used.</p>
</blockquote>
<h3 id="3-扩展练习："><a href="#3-扩展练习：" class="headerlink" title="3 扩展练习："></a>3 扩展练习：</h3><p> 1 认真阅读： Density Functional Theory: A Practical Introduction: 第三章的前两节；</p>
<p>2 VASP官网查找K点相关的说明。</p>
<h3 id="4-总结："><a href="#4-总结：" class="headerlink" title="4 总结："></a>4 总结：</h3><p> 学习完本节，大家应该掌握的内容有： </p>
<p>4.1 晶格大小对计算时间的影响；</p>
<p>4.2 体系的对称性对计算时间的影响；</p>
<p>4.3 掌握K点和晶格大小的经验规则；</p>
<p>4.4 晶格对称性和K点对称性的一致性。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>机时</tag>
        <tag>模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex20 谁偷走的我的机时？（五）</title>
    <url>/2017/12/11/ex20/</url>
    <content><![CDATA[<h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><hr>
<p>前面几节讨论的都是一些涉及到模型以及计算细节对时间的影响。本节我们讨论一下服务器节点设置（并行）的影响。从字面上不难理解，并行就是多个节点同时计算同一个任务。好比之前用一匹马拉车，现在改用两匹，三匹或者更多的马拉同一辆车。一匹马拉车的时候，对马的要求是足够强壮，能拉得动还要跑得快。但你想跑的更快，就需要驾驭两匹或者多匹马，但这个时候对于驾驶马车的你就需要提出技术要求了：如何控制马儿之间的节奏。控制好了，并驾齐驱，得儿驾得儿驾，爽歪歪。控制不好结构，你跑你的，我跑我的，整体下来，马儿也累，马车行驶的反而更慢了，搞不好还会栽跟头。</p>
<hr>
<p>同样的道理，如果想加快计算速度，或者在最短的时间内获取最多的计算数据，我们就需要知道并行在计算中的作用。首先我们先测试一下，不同节点同时运行O$_2$分子计算所需要的时间。注意：本练习讨论的是多个节点下的并行！</p>
<hr>
<h3 id="1-测试活动："><a href="#1-测试活动：" class="headerlink" title="1 测试活动："></a>1 测试活动：</h3><p>为了观测更加明显，我们使用<code>8x8x8</code> $\AA^3$的格子，K点使用<code>3x3x3</code>， <code>ENCUT = 400</code> 。</p>
<p><img src="/2017/12/11/ex20/ex20-1.jpeg" alt=""></p>
<p>测试的服务器每个节点有4个核，每个核有两个进程。</p>
<p>文件夹用核数命名，4,8,12,16 分别代表使用了1,2,3,4个节点进行计算。</p>
<p>在这里，每个节点可以看成1匹马，4个核可以看作马的四条腿。每个核的两个进程可以看做每条腿的上下两部分。</p>
<hr>
<h4 id="1-1-设置计算的节点数目"><a href="#1-1-设置计算的节点数目" class="headerlink" title="1.1 设置计算的节点数目"></a>1.1 设置计算的节点数目</h4><p>使用多少个节点进行计算，在提交任务的脚本里面设置。每个课题组可能不太一样，也有通过命令设置的，不过都大同小异。大师兄晒一晒自己组里提交命令的脚本，如果和你们的不一样，不要纠结：</p>
<p><img src="/2017/12/11/ex20/ex20-2.jpeg" alt=""></p>
<p>这个任务的脚本里面，我们使用32个核（32条腿），也就是8个节点（8匹马）同时计算。提交所有的测试任务后，等待结束。</p>
<h3 id="2-测试结果分析："><a href="#2-测试结果分析：" class="headerlink" title="2  测试结果分析："></a>2  测试结果分析：</h3><h4 id="2-1-提取结果"><a href="#2-1-提取结果" class="headerlink" title="2.1 提取结果"></a>2.1 提取结果</h4><p><img src="/2017/12/11/ex20/ex20-3.jpeg" alt=""></p>
<p><code>for i in *; do echo -e $i &quot;\t&quot; $(grep Elapsed $i/OUTCAR  | awk &#39;&#123;print $4&#125;&#39;); done</code></p>
<p>这里复习上一节： <code>sort –n</code> 命令的用法，将数列从小到大排列。</p>
<p>注意：这里我们没有用之前的<code>User time</code>提取时间, 而是用的<code>Elapsed time</code>。这一项是计算真正花费的时间。所有的时间里面：<code>Total CPU time = User Time + System time</code>，一般来说， Elapsed time 总会比 Total CPU time 多上那么几秒。</p>
<p><code>User time</code> 和 <code>System time</code> 是干嘛的？怎么的出来的？大师兄也不知道具体的含义。希望知道的童鞋们给大师兄上上课。之前几节中，用<code>User time</code>的分析结果可靠吗？ 没问题的，大师兄检查了一下，前面的<code>System time</code>均为 2s左右，<code>Elapsed Time</code> 中绝大部分由<code>User time</code>来贡献。</p>
<hr>
<h4 id="2-2-作图分析"><a href="#2-2-作图分析" class="headerlink" title="2.2 作图分析"></a>2.2 作图分析</h4><p><img src="/2017/12/11/ex20/ex20-4.jpeg" alt=""></p>
<p>核数的单位为 个 ， 对应图中的拼音 ge（个数）</p>
<p>1  从4核到8核，计算时间并没有减少，反而增加了15s</p>
<p>2  从4核到12核，计算时间也仅仅减少了20s</p>
<p>3  从12核以后，增加核数，计算时间反而增加了。</p>
<p>从12核开始，增加的核数白白占了你的任务，缺丝毫没有提高计算速度。因此，增加核数反而成了计算的负担。这是因为并行计算的时候，不同核之间的数据传输浪费了大量的计算时间。这好比是你多安排了几匹马来拉车，但马儿们却彼此交流，各跑各的，不愿意拉车了。</p>
<hr>
<h4 id="2-3-既然是这样，VASP并行还有个卵用？"><a href="#2-3-既然是这样，VASP并行还有个卵用？" class="headerlink" title="2.3 既然是这样，VASP并行还有个卵用？"></a>2.3 既然是这样，VASP并行还有个卵用？</h4><p>答：并行是有用的，只不过我们需要调教这些不听话的马儿们，让他们服从我们的命令。这里我们就会需要一些其他的参数，NCORE和NPAR。 </p>
<p>NCORE：控制多少个核同时计算；<br>NPAR：如何把计算任务分配到计算资源上面计算。</p>
<p>它们之间的关系是：NCORE= 计算使用的核数 / NPAR</p>
<p>注意：这两个参数只能选取一个来使用:</p>
<hr>
<p>测试数据结果（给喜欢看表格的人准备的）</p>
<p><img src="/2017/12/11/ex20/ex20-5.jpeg" alt=""></p>
<p><img src="/2017/12/11/ex20/ex20-6.jpeg" alt=""></p>
<p>图中红色部分为前面计算的结果，</p>
<ul>
<li>蓝色为NCORE=4的结果（测试的服务器每个节点有4个核，所有的计算军用NCORE=4）；</li>
<li>绿色为NPAR=4的结果（所有的计算中均用的NPAR=4）；</li>
<li>黄色为NPAR=Core/4的结果，</li>
</ul>
<p>根据NPAR和NCORE的关系，该设置与NCORE=4等同，但是实际测试中蓝色和黄色为什么没有完全一样，我也说不清楚。</p>
<hr>
<p>1）使用NCORE以后，单节点运行也加快了；（单匹马儿被你调教的更听话了）</p>
<p>2）加入NCORE和NPAR参数后，计算时间明显提高了。在20核以后的计算中尤为明显；</p>
<p>3）如果你想用多个节点计算，NCORE或者NPAR，不要忘了加（二者选其一）。</p>
<p>４）可以肯定的是：NPAR和NCORE的乘积就是我们计算所用的核数，这一点大家要记在心里。</p>
<p>5) 在本测试中（这是前提！！），增加节点个数并未实现 1+1 = 2 的效果，1+N = 2 的效果也没有实现。但在多个节点的计算中，加入NCORE或者NPAR，节点数越多，效果越明显。</p>
<p>手册上解释说NPAR，或者NCORE的取值可以为总核数的开方值。很多人对此会有疑虑，大师兄的建议是：</p>
<ul>
<li><p><strong>测试，测试，测试!….</strong>测试一下自己的体系这是主要的，不要完全相信本测试的结果，体系不同，结果可能会差很多！！；</p>
</li>
<li><p>NPAR的取值可以设置为节点的数目，（默认值为计算的核数！）</p>
</li>
<li><p>NPAR实在不懂的话，直接设置NCORE=单节点的核数，单节点的核数/2，单节点的核数/4…….</p>
</li>
<li><p>个人使用经验是：NCORE = 单个节点核数 / 2 的时候，运行最省时间，设置也最方便。</p>
</li>
</ul>
<h3 id="3-扩展练习："><a href="#3-扩展练习：" class="headerlink" title="3 扩展练习："></a>3 扩展练习：</h3><p>1 阅读VASP官网关于NCORE，NPAR的内容；</p>
<p>2 对于自己的计算体系，测试这两个参数；</p>
<p>3 总结前面关于计算时间的影响因素</p>
<hr>
<h3 id="4-总结："><a href="#4-总结：" class="headerlink" title="4 总结："></a>4 总结：</h3><p>关于VASP计算时间的影响，我们暂且告一段落了，希望大家能在前面几节的学习中熟练掌握影响计算时间的这些因素，在实际的计算过程中合理把握，提高计算效率，节约机时。浪费的机时不仅仅属于你自己，也属于组里其他人的。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>机时</tag>
        <tag>并行</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex22 乙醇气相分子的优化</title>
    <url>/2017/12/14/ex22/</url>
    <content><![CDATA[<p>前面我们终于讲完了 $\rm{O_2}$ 分子优化的例子。相信大家对 <strong>VASP</strong> 计算已经有了一个初步的理解。这一节我们继续学习气相分子的优化。为了让大家进一步了解计算的过程，我们选取一个稍微复杂的分子作为例子：乙醇（$\rm{CH_3CH_2OH}$）。</p>
<hr>
<p>问：把大象装进冰箱需要几步？</p>
<p><img src="/2017/12/14/ex22/ex22-1.jpeg" alt=""></p>
<p>大师兄，这个问题我早就知道答案了。为啥还问这样低智商的问题？</p>
<p>大师兄要求的不是让你回答开冰箱门，装进去，关门的这三步。而是让你尝试回想一下：当你第一次接触这个问题的时候，你的反应是什么？</p>
<p>大师兄比较笨，我的第一反应是，这怎么可能？  冰箱那么点，大象那么大。</p>
<p><img src="/2017/12/14/ex22/ex22-2.jpeg" alt=""></p>
<p>当朋友告诉我答案的时候，才恍然大悟，这跟大小没关系。</p>
<p><img src="/2017/12/14/ex22/ex22-3.jpeg" alt=""></p>
<hr>
<p>同样的，怎么用 <strong>VASP</strong> 计算乙醇分子？很多童鞋就如同第一次被问到大象这个问题一样不知所措。答，也是三步！</p>
<p>1） 打开冰箱：准备 <strong>VASP</strong> 文件</p>
<p>2） 把大象塞进去：准备乙醇分子模型</p>
<p>3）关上冰箱：运行 <strong>VASP</strong></p>
<h2 id="1-打开冰箱："><a href="#1-打开冰箱：" class="headerlink" title="1. 打开冰箱："></a>1. 打开冰箱：</h2><p>我们可以直接用O$_2$分子计算的输入文件，</p>
<h3 id="1-1-复习一下前面学到的INCAR和KPOINTS的内容："><a href="#1-1-复习一下前面学到的INCAR和KPOINTS的内容：" class="headerlink" title="1.1 复习一下前面学到的INCAR和KPOINTS的内容："></a>1.1 复习一下前面学到的<code>INCAR</code>和<code>KPOINTS</code>的内容：</h3><p>1）乙醇分子是闭壳层的分子，没有磁性，不需要<code>ISPIN=2</code></p>
<p>2）气相分子计算，我们要用<code>ISMEAR=0</code>，<code>SIGMA</code>取值要小，<code>SIGMA=0.02</code>；</p>
<p><img src="/2017/12/14/ex22/ex22-4.jpeg" alt=""></p>
<p> <strong>#</strong> 表示注释，这个符号后面的内容，VASP在运行的时候不考虑。</p>
<hr>
<p><strong>示例 1 ：</strong><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ENCUT = 400</span><br><span class="line"><span class="comment"># ENCUT = 500</span></span><br></pre></td></tr></table></figure><br>和<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ENCUT = 400</span><br></pre></td></tr></table></figure><br>效果是一样的。</p>
<hr>
<p><strong>示例 2：# 的用法：</strong></p>
<p><img src="/2017/12/14/ex22/ex22-5.jpeg" alt=""></p>
<p><strong>VASP</strong> 计算中一些常见的错误，以及注意事项，你可以通过 # 写在<code>INCAR</code>里面，方便计算的时候进行设置。可以 # 开头，单起一行，也可以在参数的最后面加上注释。新手们刚刚开始，可以结合 <strong>VASP</strong> 官网参考书，把用到的INCAR参数注释下来，时间长了慢慢就掌握了。</p>
<p>3）气相分子计算，<code>K</code>点使用<code>Gamma</code>点就够了；</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">K-POINTS</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="built_in">Gamma</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2-把大象塞到冰箱里面-POSCAR的准备（本节重点）"><a href="#2-把大象塞到冰箱里面-POSCAR的准备（本节重点）" class="headerlink" title="2 把大象塞到冰箱里面 :POSCAR的准备（本节重点）"></a>2 把大象塞到冰箱里面 :POSCAR的准备（本节重点）</h2><p>前面我们学习到，一个好的初始结构会加快计算，获取准确的计算结果。因此我们需要去找一个合理的模型。对于气相分子的结构，一是手动搭建，大师兄推荐用 <code>GaussView</code>，另一个办法就是找数据库，大师兄推荐英国皇家学会的 <strong>ChemScpider</strong>。网址：<a href="http://www.chemspider.com">http://www.chemspider.com</a> </p>
<p><img src="/2017/12/14/ex22/ex22-7.jpeg" alt=""></p>
<p>下面我们把手动搭建乙醇分子的模型具体解释一下：</p>
<h3 id="2-1-打开网站"><a href="#2-1-打开网站" class="headerlink" title="2.1 打开网站"></a>2.1 打开网站</h3><p><img src="/2017/12/14/ex22/ex22-8.jpeg" alt=""></p>
<p>搜索框中输入： 分子名称<code>Ethanol</code> 或者 分子式<code>C2H6O</code>…. 点击搜索，等待结果：</p>
<p><img src="/2017/12/14/ex22/ex22-9.jpeg" alt=""></p>
<p>上面箭头指的两个地方随便点，效果是一样的，如下：</p>
<p><img src="/2017/12/14/ex22/ex22-10.jpeg" alt=""></p>
<p>分子默认显示 <code>2D</code> 的结构，点击箭头指的 <code>3D</code>，切换。第二个箭头所指的有对应结构的维基百科链接，翻墙的筒子们可以查阅下相关结构的知识。选择<code>3D</code>后，如下：</p>
<p><img src="/2017/12/14/ex22/ex22-11.jpeg" alt=""></p>
<p>点击箭头指的地方保存，浏览器会下载对应的 .mol 文件，文件名为该结构在数据库中的编号。</p>
<hr>
<p><code>.mol</code>文件也是纯文本，使用<code>Notepad++</code> 打开如下：看到这么多内容，不要害怕！</p>
<p><img src="/2017/12/14/ex22/ex22-12.jpeg" alt=""></p>
<p><strong>注： 不仅仅是 <code>.mol</code> 文件，很多结构文件都是文本格式，直接打开就是。</strong></p>
<p>从里面找到乙醇结构的 $x, y, z$ 坐标信息</p>
<p><img src="/2017/12/14/ex22/ex22-13.jpeg" alt=""></p>
<p>删除上图中除红色框之外的所有行，1-4行，以及 14 至最后一行，只保留 $x, y, z$ 坐标信息的那几行。</p>
<p><img src="/2017/12/14/ex22/ex22-14.jpeg" alt=""></p>
<p>手动写<code>POSCAR</code>，首先你要熟记的格式，知道<code>POSCAR</code>从头开始，往下每一行代表的内容。</p>
<p>我们的模型是把乙醇分子放到一个 $ 20 \times 20 \times 20~A^3 $ 的格子里面。输入完之后，坐标后面的元素符号以及那些 $0$ $0$ $0$ 可以删掉，也可以不管。</p>
<p><img src="/2017/12/14/ex22/ex22-15.jpeg" alt=""></p>
<p><strong>关键点1： .mol文件中，坐标那几行中的第 4 列写到<code>POSCAR</code>中的第 6, 7行！</strong></p>
<p><strong>关键点2： 注意坐标为 <code>Cartesian</code> 或者是 <code>Direct</code>. <code>Direct</code> 是分数坐标，其 $x, y, z$ 值都小于 1.</strong></p>
<hr>
<p>如果你想删掉图中坐标第3列后面的内容：大师兄推荐notepad++里面的列块模式：如下：</p>
<p><img src="/2017/12/14/ex22/ex22-16.jpeg" alt=""></p>
<p>点击之后，可能会弹出对话框，告诉你如何使用，列块模式</p>
<p><img src="/2017/12/14/ex22/ex22-17.jpeg" alt=""></p>
<hr>
<p><strong>方法1：</strong></p>
<p> 摁住 <code>Alt</code> 键，然后用鼠标选择文本，不同电脑可能不一样，大师兄这边同时摁住 <code>Ctrl</code> 和 <code>Alt</code> 两个键，然后用鼠标选择的。</p>
<hr>
<p><strong>方法2：</strong></p>
<p>同时摁住 <code>Alt</code>和<code>Shift</code>键，通过键盘上前后左右的箭头选择文本</p>
<p>大家可以尝试下，选中效果如图：</p>
<p><img src="/2017/12/14/ex22/ex22-18.jpeg" alt=""></p>
<p>然后点键盘上的<code>Delete</code>键删除.</p>
<p><img src="/2017/12/14/ex22/ex22-19.jpeg" alt=""></p>
<p>然后另存为<code>POSCAR</code>即可。</p>
<hr>
<p>我们可以使用 <strong>p4vasp</strong> 来查看一下模型的结构：如下图</p>
<p><img src="/2017/12/14/ex22/ex22-20.jpeg" alt=""></p>
<p>我靠，师兄，结构怎么跑到格子外面啦？前面 $\rm{O_2}$ 分子的学习中，你已经知道了这是因为周期性导致的显示问题。对计算不会产生影响。这个结构可以拿来直接用。</p>
<p>如果感觉不爽，想把结构放到中间，可以这么做：</p>
<p>数学上，把 $x, y, z$ 坐标<strong>统统加上 $10$ 即可</strong>；</p>
<p>软件使用上，我们讲一下 <strong>p4vasp</strong> 的操作方法：</p>
<p><img src="/2017/12/14/ex22/ex22-21.jpeg" alt=""></p>
<p>选择 <code>edit</code> –&gt; <code>Move atoms</code></p>
<p><img src="/2017/12/14/ex22/ex22-22.jpeg" alt=""></p>
<p><code>Move group</code> 是你要移动的原子，这里大师兄直接输入了 C H O 三个元素符号（中间有空格）表示选择所有元素的原子。然后在 <code>Vector</code> 中选择 $x, y, z$ 三个方向上移动的大小。你也可以写 $1$ $1$ $1$，然后点击 <code>Move</code> 按钮 $10$ 次。</p>
<p>如果你想通过选择原子来实现移动的话(不直接在 <code>Move group</code> 里面输入 C H O)，需要按照大师兄说的步骤走：</p>
<p><img src="/2017/12/14/ex22/ex22-23.jpeg" alt=""></p>
<p>1) 空格键结合鼠标选中所有的原子；鼠标指到原子上就点一下空格键</p>
<p>2) 选中原子后，主界面会显示一些数字，这些数字和 <code>POSCAR</code> 中元素的顺序是一致的；</p>
<p>3) 所有原子选中后，左下角的框中点击 <code>Get group</code>，会显示选择的那些原子；</p>
<p>4) 在 <code>Vector</code> 中选择 $x, y, z$ 三个方向上移动的大小，然后点击 <code>Move</code> 按钮。</p>
<p>上面一堆废话就此打住，结果就是这样子的：</p>
<p><img src="/2017/12/14/ex22/ex22-24.jpeg" alt=""></p>
<p>然后点击 file -&gt; Save system as -&gt; 选择目录 -&gt; 保存成<code>POSCAR</code></p>
<hr>
<h4 id="POTCAR"><a href="#POTCAR" class="headerlink" title="POTCAR"></a>POTCAR</h4><p><strong>POSCAR</strong> 讲完了，我们就要按照里面的元素顺序制备<code>POTCAR</code>了。</p>
<p>首先: 我们要准备 O C H 三个元素的<code>POTCAR</code>，去<code>POTCAR</code>的数据库中去找：</p>
<p>然后复制到当前目录下，三个元素的<code>POTCAR</code>分别命名为：<code>POTCAR-O</code>, <code>POTCAR-C</code>和 <code>POTCAR-H</code>， 把三个元素的<code>POTCAR</code>合并在一起，命令就是</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat POTCAR-O POTCAR-C POTCAR-H &gt;&gt; POTCAR</span><br></pre></td></tr></table></figure>
<h2 id="3-提交任务"><a href="#3-提交任务" class="headerlink" title="3 提交任务"></a>3 提交任务</h2><p>提交任务之前，需要再次检查自己的输入文件一遍，没有问题，提交直至结束。</p>
<h2 id="4-扩展练习："><a href="#4-扩展练习：" class="headerlink" title="4 扩展练习："></a>4 扩展练习：</h2><p>4.1 从头到尾，认真重复本节中大师兄的操作；</p>
<p>4.2 记住本节讲解的内容，自己重复一遍操作，直至自己通过文本编辑器会搭建结构模型；</p>
<p>4.3 运行乙醇计算的例子；</p>
<p>4.4 尝试使用 <strong>GaussView</strong>，<strong>Materials Studio (MS)</strong>，以及其他可视化界面搭建模型；</p>
<p>4.5 学会使用 <strong>VESTA</strong> 导出<code>POTCAR</code>格式的结构数据。</p>
<h2 id="5-总结："><a href="#5-总结：" class="headerlink" title="5 总结："></a>5 总结：</h2><p>本节，我们主要讨论了一下分子模型的数据库搜索和搭建工作。希望大家能够完全掌握本节的所有内容和细节。在计算中，你会遇到各种各样的结构文件，其实都是$xyz$坐标的衍生物而已。不要害怕，直接打开它们，学会提取里面有价值的信息。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>优化</tag>
        <tag>数据库</tag>
        <tag>乙醇</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex23 乙醇分子的振动频率计算(一)</title>
    <url>/2017/12/15/ex23/</url>
    <content><![CDATA[<p><img src="/2017/12/15/ex23/ex23-0.jpeg" alt=""></p>
<p>大师兄在本节开头放上这张图片的意思是，请大家再仔细体会<code>Rubbish in， Rubbish out</code>这句话，只有对我们要研究的体系有一定的理解，明白我们具体要计算什么内容，设置好输入文件的参数，才能得到我们需要的合理结果。接下来的几节会涉及到分子的振动频率计算，振动频率的可视化等内容，请大家跟着大师兄一起练习，掌握振动频率的基本计算和分析方法。</p>
<hr>
<h2 id="1-分子的振动"><a href="#1-分子的振动" class="headerlink" title="1 分子的振动"></a>1 分子的振动</h2><p>我们首先看回顾一下振动相关的基本知识，这里大师兄不具体解释，引用 $9$ 版 $Atkins$ 的《物理化学》书中的内容，书已上传至<strong>QQ群文件</strong>中，也可百度网盘下载: <a href="http://pan.baidu.com/s/1o8HlyOi">http://pan.baidu.com/s/1o8HlyOi</a>  全是英文，大家耐心阅读下。</p>
<hr>
<p>简谐振子、胡克定律、体系势能随着振动距离 $x$ 的关系</p>
<p><img src="/2017/12/15/ex23/ex23-1.jpeg" alt=""></p>
<p>简谐振动的薛定谔方程描述:</p>
<p><img src="/2017/12/15/ex23/ex23-2.jpeg" alt=""></p>
<p><img src="/2017/12/15/ex23/ex23-3.jpeg" alt=""></p>
<p>薛定谔方程的解：振动的量子化，振动频率</p>
<p><img src="/2017/12/15/ex23/ex23-4.jpeg" alt=""></p>
<p><img src="/2017/12/15/ex23/ex23-5.jpeg" alt=""></p>
<p>零点能的数学和物理两个方面的解释:</p>
<p><img src="/2017/12/15/ex23/ex23-6.jpeg" alt=""></p>
<hr>
<h2 id="2-频率计算的作用"><a href="#2-频率计算的作用" class="headerlink" title="2 频率计算的作用"></a>2 频率计算的作用</h2><p><strong>频率计算有什么用？为什么要算频率?</strong> 大师兄稍微总结了一下频率计算的意义，大体有以下几个方面，没有提到的用处，烦请大家指出来，以便补充。</p>
<p>2.1 确定结构是否稳定;</p>
<p>2.2 看振动方式和大小，用来和实验对比，棋博士最新的文章就是一个非常好的例子;</p>
<p>2.3 反应热，反应能垒，吸附能等的零点能矫正;</p>
<p>2.4  确认过渡态(有一个振动的虚频)</p>
<p>2.5 热力学中计算<code>entropy</code>，用于计算化学势，微观动力学中的指前因子和反应能垒。</p>
<hr>
<h2 id="3-怎么用VASP计算频率"><a href="#3-怎么用VASP计算频率" class="headerlink" title="3  怎么用VASP计算频率?"></a>3  怎么用VASP计算频率?</h2><p>3.1首先进行结构优化，获取稳定的构型，这个我们前面已经讲过了;</p>
<p>3.2 将原来的<code>CONTCAR</code>复制成<code>POSCAR</code> :<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp CONTCAR  POSCAR</span><br></pre></td></tr></table></figure></p>
<p>3.3 修改<code>INCAR</code></p>
<p><img src="/2017/12/15/ex23/ex23-7.jpeg" alt=""></p>
<p>修改后如下:  </p>
<p><img src="/2017/12/15/ex23/ex23-8.jpeg" alt=""></p>
<p>频率计算的<code>INCAR</code></p>
<ul>
<li><p><code>IBRION</code>的值改成<code>5</code></p>
</li>
<li><p><code>POTIM</code>用一个更小的值，我们这里用的 <code>0.02</code>，默认值是 <code>0.015</code></p>
</li>
<li><p><code>NSW</code> 设置成1，这个可以直接不管，继续采用优化时的<code>NSW</code>值，因为你设置成 <code>1， 2， 3， 4， 5， …， 1000</code> 都不会影响计算；但不能不设置（因为默认值是<code>0</code>，这时算个单点后任务便停止了。）</p>
</li>
<li><p><code>NFREE=2</code> 添加这一个参数，表明原子在某一方向上正反两个方向移动；</p>
</li>
<li><p><code>NCORE=4</code>这一项要注释掉！大师兄这边的服务器，并行计算频率时 VASP 会罢工，只进行一步静态计算，注释掉就正常进行了；</p>
</li>
<li><p>此外，<code>EDIFF</code>也要设置一个严格的值（频率计算时，默认值为<code>1E-6</code>，足够了！下一节会讲到）</p>
</li>
</ul>
<p>小结一下频率分析关键的参数:</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">IBRION=5</span><br><span class="line">NFREE=2</span><br><span class="line">POTIM=0.02</span><br></pre></td></tr></table></figure></h2><h2 id="4-扩展练习"><a href="#4-扩展练习" class="headerlink" title="4 扩展练习"></a>4 扩展练习</h2><p>4.1 按照本节的流程新建一个文件夹 <code>freq</code> : 该文件夹中包含乙醇分子优化后的结构 (将<code>CONTCAR</code>复制成<code>POSCAR</code>)，以及优化时的<code>POTCAR</code>，<code>INCAR</code>， <code>KPOINTS</code>以及提交命令的脚本文件;</p>
<p>4.2 修改乙醇分子优化的<code>INCAR</code>为频率计算的<code>INCAR</code>；需要修改哪些参数心里要清楚；</p>
<p>4.3 运行乙醇分子频率计算，并查看频率分析的<code>OUTCAR</code>，<code>OSZICAR</code>等输出文件；</p>
<p>4.4 查看 <strong>VASP</strong> 官网对于<code>IBRION=5</code> 的解释，搜索网上相关频率计算的文章，帖子，初步了解<code>NFREE</code>，<code>POTIM</code>所代表的含义；</p>
<p><a href="https://cms.mpi.univie.ac.at/wiki/index.php/IBRION">https://cms.mpi.univie.ac.at/wiki/index.php/IBRION</a></p>
<p>4.5 查找官网中频率计算的例子:</p>
<p>A) <a href="https://cms.mpi.univie.ac.at/wiki/index.php/CO_vibration">https://cms.mpi.univie.ac.at/wiki/index.php/CO_vibration</a></p>
<p>B) <a href="https://cms.mpi.univie.ac.at/wiki/index.php/H2O_vibration">https://cms.mpi.univie.ac.at/wiki/index.php/H2O_vibration</a></p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结:"></a>5 总结:</h2><p>5.1 熟悉频率计算初始文件的准备过程；</p>
<p>5.2 频率计算<code>INCAR</code>中的三个重要参数；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">IBRION = 5</span><br><span class="line">NFREE = 2</span><br><span class="line">POTIM = 0.02</span><br></pre></td></tr></table></figure>
<p>5.3 初步了解频率计算中各个参数的含义。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>乙醇</tag>
        <tag>频率</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex24 乙醇分子的振动频率计算(二)</title>
    <url>/2017/12/15/ex24/</url>
    <content><![CDATA[<p>按照前面一节介绍的方法，结构优化过程完毕后，准备频率计算的输入文件，提交任务等待结束。然后我们介绍一下频率计算的输出与POSCAR原子的固定。</p>
<h2 id="1-查看结果"><a href="#1-查看结果" class="headerlink" title="1 查看结果"></a>1 查看结果</h2><h3 id="1-1-查看OSZICAR，你会发现一共计算了55步。"><a href="#1-1-查看OSZICAR，你会发现一共计算了55步。" class="headerlink" title="1.1 查看OSZICAR，你会发现一共计算了55步。"></a>1.1 查看OSZICAR，你会发现一共计算了55步。</h3><p><img src="/2017/12/15/ex24/ex24-1.jpeg" alt=""></p>
<p>下面我们分析一下这$55$步是怎么回事：</p>
<p>A）乙醇分子$\rm{CH<em>{3}CH</em>{2}OH}$ 含有 $9$ 个原子，每个原子在 $x, y, z$三个方向上均有一个自由度，共 $9 \times 3 = 27$ 个</p>
<p>B）我们设置的<code>NFREE=2</code> ，也就是在每个方向上 <code>+POTIM</code> 和 <code>–POTIM</code>都移动并算一下，这样就有了 $27 \times 2 = 54$ 步：官网原文如下：大家自己去查阅<code>IBRION</code>和<code>NFREE</code>的相关内容。</p>
<blockquote>
<p>The parameter NFREEdetermines how many displacements are used for each direction and ion, andPOTIM determines the step size. The step size is defaulted to 0.015 ? (startingfrom VASP.5.1), if too large values are supplied in the input file. Expertiseshows that this is a very reasonable compromise.`</p>
<p>NFREE=2 usescentral differences, i.e., each ion is displaced by a small positive andnegative displacement, ±POTIM, along each of the cartesian directions.`</p>
</blockquote>
<p>C）还有一步：$55  -54 = 1$, 这一步指的是第一个离子步，为频率计算前的单点计算。</p>
<p>所以当你设置了<code>NFREE=2</code>的时候，频率计算需要 $1+N \times 6$ 步。$N$ 为体系中的振动的原子数。</p>
<h2 id="2-固定原子"><a href="#2-固定原子" class="headerlink" title="2 固定原子"></a>2 固定原子</h2><p>默认的是所有的原子在$x, y, z$三个方向上均可移动。但很多时候，我们只需要振动感兴趣的原子或者某一特定的方向就可以了，也就是说选择性计算频率。比如我们只想算乙醇的羟基振动峰，那么其他的原子就可以固定。VASP可以通过设置POSCAR来实现这个功能？首先我们看一下当前的<code>POSCAR</code>：</p>
<p><img src="/2017/12/15/ex24/ex24-2.jpeg" alt=""></p>
<p>左下角的<code>:set nu</code>  显示文本的行数，取消行数可以通过 <code>:set nonu</code></p>
<hr>
<p>如果想要选择性地固定某些原子，我们需要以下几个步骤：</p>
<p>1） 在第七行和第8行之间插入一行，内容为 <code>Selective Dynamics</code> ，前面讲过 <strong>VASP</strong> 只认第一个字母，也就是<code>S</code>是必须的，<code>Selective Dynamics</code> 和 <code>See</code>, <code>Sea</code>….等其他<code>S</code>开头的都是一个效果的。</p>
<p>2）  加入<code>Selective</code>之后，我们需要在每一行的坐标后面加上 <code>T</code> 或者<code>F</code>表示允许和禁止移动。这里我们需要加三个<code>T</code>或者<code>F</code>，表示在 $x, y, z$ 三个方向上选择性固定原子的移动，</p>
<p>三个方向都允许：<code>T T T</code></p>
<p>三个方向上都不允许: <code>F F F</code>  </p>
<p>$x$ 移动，$y$ 和 $z$ 方向上固定为： <code>T F F</code></p>
<p>$x$ 和 $y$ 方向上固定，$z$ 方向振动： <code>F F T</code></p>
<p>以此类推，其他的大家根据自己的情况固定。</p>
<hr>
<p>师兄，那么我们要做的就是在<code>POSCAR</code>中逐行写上<code>T T T</code>或者<code>F F F</code>就行了吧? </p>
<p>是的，下面大师兄教给你的是通过 <strong>Vim</strong> 的命令或者 <strong>p4vasp</strong> 实现这个功能。</p>
<hr>
<h3 id="2-1-通过-Vim-实现原子的固定和选择"><a href="#2-1-通过-Vim-实现原子的固定和选择" class="headerlink" title="2.1 通过 Vim 实现原子的固定和选择"></a>2.1 通过 <strong>Vim</strong> 实现原子的固定和选择</h3><p><strong>第一步</strong>：加入 <code>Select</code> 的关键字母<code>S</code>，并在坐标后面全部加上 <code>T T T</code></p>
<p><img src="/2017/12/15/ex24/ex24-3.jpeg" alt=""></p>
<p>图中<code>箭头1</code>：插入一行，告诉 <strong>VASP</strong> 我们要选择性的固定某些原子或者在某些方向上；</p>
<p>图中<code>方块2</code> <code>:10,18s</code>  中 <code>s</code> 代表替换（<code>substitute</code>）的意思，这里表示我们选中了第 $10$ 到 $18$ 行，$10$ 和 $18$ 之间有个逗号表示连续；<code>10,18s</code>后面用一个 <code>/</code> 分开，紧跟着你我们要替换的内容；</p>
<p><code>$</code> 在这里是末尾的意思，<code>$/T T T</code>我们要把每一行的最后替换成 <code>T T T</code></p>
<p>后面再用一个<code>/</code>分开，加上<code>g</code> 表示 global 全部替换的意思。</p>
<p>输入完毕后，回车，效果如下：</p>
<p><img src="/2017/12/15/ex24/ex24-4.jpeg" alt=""></p>
<p>每一行的末尾都加入了 <code>T T T</code>  箭头指的地方告诉我们：$9$ 行中的 $9$ 个地方发生了替换。</p>
<p>（自己复习下<code>sed</code>的用法，比较两者的区别）</p>
<hr>
<p><strong>第二步</strong>，下面我们要把OH之外的原子全部固定住：</p>
<p>通过 <strong>p4vasp</strong> 我们可以知道，OH 的两个原子为第一个（O）和最后一个（H），因此我们把第 $11$ 行到 $17$ 行中的所有<code>T</code>替换成<code>F</code>就可以了。我们可以使用 <code>:11,17s/T/F/g</code>来实现。最后效果如下：</p>
<p><img src="/2017/12/15/ex24/ex24-5.jpeg" alt=""></p>
<p>C）扩展：</p>
<p>如果所有的原子后面为： <code>T T T</code>，这与我们之前的计算效果是一样的（第 $8$ 行没有<code>S</code>，坐标后面没有<code>T T T</code>）。此外，固定之前要先找到哪些原子我们希望固定的，以及它们在坐标中的顺序。</p>
<hr>
<h3 id="2-2-使用p4vasp实现上述功能"><a href="#2-2-使用p4vasp实现上述功能" class="headerlink" title="2.2 使用p4vasp实现上述功能:"></a>2.2 使用p4vasp实现上述功能:</h3><p>基于 <strong>p4vasp</strong> 的可视化特性，直接用鼠标操作是很多<code>linux</code> 小白最喜欢看到的，下面我们主要讲解一下 <strong>p4vasp</strong> 的操作，请务必将 <strong>Vim</strong> 和 <strong>p4vasp</strong> 的操作关联起来，这样你会就会发现可视化和命令之间的微妙关系了。</p>
<h4 id="1）-打开p4vasp，导入POSCAR；"><a href="#1）-打开p4vasp，导入POSCAR；" class="headerlink" title="1） 打开p4vasp，导入POSCAR；"></a>1） 打开p4vasp，导入<code>POSCAR</code>；</h4><p><img src="/2017/12/15/ex24/ex24-6.jpeg" alt=""></p>
<p><code>System</code> 显示 ethanol 说明数据已导入。</p>
<h4 id="2）-鼠标系列操作"><a href="#2）-鼠标系列操作" class="headerlink" title="2）   鼠标系列操作"></a>2）   鼠标系列操作</h4><p>A）点一下 <code>Show</code> 按钮，显示乙醇分子结构；</p>
<p>B）  点击<code>Build</code>按钮：显示分子的坐标信息：这里的坐标顺序和<code>POSCAR</code>完全一致：</p>
<p><img src="/2017/12/15/ex24/ex24-7.jpeg" alt=""></p>
<p>C）  选择乙醇的羟基（使用空格键选择原子），下图中可以知道 O 和 H 在坐标顺序中为第一个和最后一个；</p>
<p><img src="/2017/12/15/ex24/ex24-8.jpeg" alt=""></p>
<p>D）选中右上角的<code>Selective Dynamics</code>，效果如图中箭头2指出来的部分，这个动作和我们之前在第八行插入<code>Selective Dynamics</code> 以及在坐标每一行加入<code>T T T</code>是等效的</p>
<p><img src="/2017/12/15/ex24/ex24-9.jpeg" alt=""></p>
<p>E）选中第二行坐标，摁住shift键，然后再点一下倒数第二行，选中整个区域后，点击右上方的 <code>Unselect</code> ， 这个动作等效于我们将 $11$ 到 $17$ 行中的<code>T</code>全部替换为<code>F</code>。</p>
<p><img src="/2017/12/15/ex24/ex24-10.jpeg" alt=""></p>
<p>F）操作完成后，左上角： <code>File --&gt; Save System As</code> 保存新的<code>POSCAR</code>即可。</p>
<hr>
<h2 id="4-扩展练习："><a href="#4-扩展练习：" class="headerlink" title="4 扩展练习："></a>4 扩展练习：</h2><p>4.1 掌握本节的两个<code>POSCAR</code>处理方法；</p>
<p>4.2 学会计算频率分析所需的步数；</p>
<p>4.3 浏览<code>OUTCAR</code>，查找频率输出结果</p>
<h2 id="5-总结："><a href="#5-总结：" class="headerlink" title="5 总结："></a>5 总结：</h2><p>通过对比手动敲命令修改<code>POSCAR</code>和使用 <strong>p4vasp</strong> 进行鼠标操作，这里大师兄希望大家能掌握以下三点：</p>
<p>1） 学会 <strong>Vim</strong> 的使用技巧，当然了，<strong>Vim</strong> 及其强大，完全掌握基本不可能，但最基本的操作要了解；</p>
<p>2） <strong>p4vasp</strong> 的操作要熟悉，不知道怎么操作的，导入一个计算文件，随便点点，找找感觉；</p>
<p>3） 在使用 <strong>p4vasp</strong> 的操作中，你要学会思考：怎么将鼠标操作转化为命令语言来实现，为将来写脚本做好准备，毕竟很多时候，我们用不了可视化界面，就只能手动修改格式了，结合命令，比可视化操作更快，还可以批量进行。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>p4vasp</tag>
        <tag>乙醇</tag>
        <tag>原子固定</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex25 乙醇分子的振动频率计算(三)</title>
    <url>/2017/12/16/ex25/</url>
    <content><![CDATA[<p>本节推荐一款可视化程序：<strong>Jmol</strong>，可以用来看分子结构以及振动频率。<strong>Jmol</strong> 是一款<code>Java</code>语言编写的，开源，<code>Linux</code>，<code>Windows</code>均可的使用的可视化软件。还记的我们从<code>ChemSpider</code>获取乙醇分子的情景吗？</p>
<p><img src="/2017/12/16/ex25/ex25-1.jpeg" alt=""></p>
<p><img src="/2017/12/16/ex25/ex25-2.jpeg" alt=""></p>
<p>对了！RSC的网页版中，乙醇分子的3D结构就是通过 <strong>Jmol</strong> 展示给大家的（3D图上方），并且我们下载的结构也是jmol格式的文件！可以通过 <strong>Jmol</strong> 直接打开。现在我们通过在电脑上运行Jmol，并查看分子的结构和振动频率。</p>
<hr>
<h2 id="1-Jmol在windows和linux下的安装："><a href="#1-Jmol在windows和linux下的安装：" class="headerlink" title="1. Jmol在windows和linux下的安装："></a>1. Jmol在windows和linux下的安装：</h2><h3 id="1-1-安装前准备（Java运行环境的安装）"><a href="#1-1-安装前准备（Java运行环境的安装）" class="headerlink" title="1.1 安装前准备（Java运行环境的安装）"></a>1.1 安装前准备（Java运行环境的安装）</h3><p><code>Windows</code>下：直接百度<code>Java Runtime Environment（JRE）</code>，安装软件。</p>
<p><img src="/2017/12/16/ex25/ex25-3.jpeg" alt=""></p>
<p>也可以官网下载：<a href="http://www.oracle.com/technetwork/java/javase/downloads/jre8-downloads-2133155.html">http://www.oracle.com/technetwork/java/javase/downloads/jre8-downloads-2133155.html</a></p>
<p><img src="/2017/12/16/ex25/ex25-4.jpeg" alt=""></p>
<p>注意两点：</p>
<p>1： 接受许可，</p>
<p>2：64位系统下载箭头所指的文件，然后安装即可。</p>
<p><code>Linux</code>下<code>Java</code>运行环境安装移步下方链接：</p>
<p><a href="https://linux.cn/article-3792-1.html">怎样在Ubuntu 14.04中安装Java</a>： <a href="https://linux.cn/article-3792-1.html">https://linux.cn/article-3792-1.html</a> </p>
<p>或者直接使用命令：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install default-jre</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="1-2-Jmol软件的下载和安装"><a href="#1-2-Jmol软件的下载和安装" class="headerlink" title="1.2 Jmol软件的下载和安装"></a>1.2 Jmol软件的下载和安装</h3><ul>
<li>Windows：</li>
</ul>
<p><a href="https://sourceforge.net/projects/jmol/files/Jmol/">https://sourceforge.net/projects/jmol/files/Jmol/</a></p>
<p>打开链接后，图中箭头指的地方下载最新版的（<code>Linux</code>其实和<code>Windows</code>下载的文件一模一样，见后面说明），也可以任选版本进行下载。</p>
<p><img src="/2017/12/16/ex25/ex25-5.jpeg" alt=""></p>
<p>等待几秒后会弹出下载的窗口，其他浏览器也应该一样。</p>
<p><img src="/2017/12/16/ex25/ex25-6.jpeg" alt=""></p>
<p><img src="/2017/12/16/ex25/ex25-7.jpeg" alt=""></p>
<p>解压缩后就算安装好了，可以直接运行。</p>
<hr>
<p>运行 <strong>Jmol</strong> 程序：</p>
<p><img src="/2017/12/16/ex25/ex25-8.jpeg" alt=""></p>
<p>上图中 <code>箭头1</code>所指为 <code>jmol.bat</code> 文件，<code>箭头2</code>所指为 <code>Java</code>的可执行文件：<code>jmol.jar</code>。在<code>Windows</code>下任选一个双击即可打开 <strong>Jmol</strong> 程序。建议将解压缩之后文件夹中的<code>jmol.bat</code>或者<code>jmol.jar</code> 文件右键发送到桌面快捷方式。打开后如下图：</p>
<p><img src="/2017/12/16/ex25/ex25-9.jpeg" alt=""></p>
<hr>
<ul>
<li><code>Linux</code>下安装 <strong>Jmol</strong> 的方法:</li>
</ul>
<p>在 <a href="https://sourceforge.net/projects/jmol/files/Jmol/">https://sourceforge.net/projects/jmol/files/Jmol/</a>下载 <strong>Jmol</strong>（和前面介绍的<code>Windows</code>下载的文件一模一样），解压后的文件复制到<code>usr/bin</code>中，打开文件时在命令行输入<code>jmol.sh 文件名</code>即可（<strong>注意</strong>，<code>jmol.sh</code>和<code>文件名</code>之间 <strong>有空格！</strong>）。将解压目录加入<code>.bashrc</code>路径中也可以实现，同时需要给<code>jmol.sh</code>加上可执行权限，即<code>chmod u+x jmol.sh</code>，打开文件的方法仍用<code>jmol.sh 文件名</code>。(QQ群友：连赞提供！)</p>
<p>大师兄在<code>Linux</code>系统下的操作如下：</p>
<p>a）下载和<code>Windows</code>版的过程一样，下载完毕后，解压，</p>
<p>b）终端里面进入解压后的文件夹：</p>
<p><img src="/2017/12/16/ex25/ex25-10.jpeg" alt=""></p>
<p>注意一下几点：</p>
<p>b.1) <code>jmol.sh</code>就是我们在<code>Linux</code>系统下面的命令（<code>Windows</code>里面我们用<code>jmol.bat</code> 和 <code>jmol.jar</code>）；</p>
<p>b.2) 首先赋予它可执行的权限：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod u+x  jmol.sh</span><br></pre></td></tr></table></figure><br>相反地，取消权限：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod u-x jmol.sh</span><br></pre></td></tr></table></figure></p>
<p>b.3) 这里大师兄电脑下，<code>jmol.sh</code>变成绿色的了（不同电脑显示会不同，不要纠结）</p>
<p>b.4) 尝试运行一下： <code>./jmol.sh  OK</code></p>
<p>b.5) 下面设置环境变量：打开 <code>~/.bashrc</code> 文件，并加入这一行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:~/Downloads/jmol-14.20.2:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>等号=前后没有空格, 后面紧跟着<code>$PATH</code>；</li>
<li>再往后是一个冒号，冒号前后也不能有空格，填上Jmol的解压目录！！！</li>
</ul>
<p>b.6) 保存<code>.bashrc</code> 文件并<code>source</code>一下:   <code>.  ~/.bashrc</code>  （注意前面的 <code>.</code> ）或者使用命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span>  ~/.bashrc</span><br></pre></td></tr></table></figure></p>
<p>c） 进入其他目录，运行 <strong>Jmol</strong> 命令：下图中<code>~/Destkop/freq</code> 目录下有我们关于乙醇频率的计算结果。</p>
<p><img src="/2017/12/16/ex25/ex25-12.jpeg" alt=""></p>
<p>大功告成！！！</p>
<p>此外，<code>sudo apt-get install jmol</code>这样安装的是<strong>旧版本</strong>，强烈不建议，原因如下：</p>
<p><strong>可能图片有些模糊，但不重要！旧版本的不支持 OUTCAR…安了也是白搞！！！</strong></p>
<p><img src="/2017/12/16/ex25/ex25-13.jpeg" alt=""></p>
<hr>
<h2 id="2-使用Jmol可视化分子振动"><a href="#2-使用Jmol可视化分子振动" class="headerlink" title="2 使用Jmol可视化分子振动"></a>2 使用Jmol可视化分子振动</h2><h3 id="2-1-载入振动文件到-Jmol"><a href="#2-1-载入振动文件到-Jmol" class="headerlink" title="2.1 载入振动文件到 Jmol"></a>2.1 载入振动文件到 Jmol</h3><p><code>Windows</code>：直接将频率计算得到的<code>OUTCAR</code>拖到<code>jmol.bat</code>就可以了</p>
<p><code>Linux</code>：直接 <code>jmol 文件名</code></p>
<p>两个系统下面均可使用左上角的 文件à打开à选择<code>OUTCAR</code>导入。</p>
<p>得到如下界面。但是分子并没有开始振动，只是显示了其结构。</p>
<p><img src="/2017/12/16/ex25/ex25-14.jpeg" alt=""></p>
<p>（该结构和<code>ChemSpider</code>上的一样！）</p>
<p>要查看振动模型，需要以下两步，<strong>选中振动模型</strong>和<strong>开启振动</strong>。这两步有多种方法可以实现，总结如下。</p>
<hr>
<h3 id="2-2-选择振动模型"><a href="#2-2-选择振动模型" class="headerlink" title="2.2 选择振动模型"></a>2.2 选择振动模型</h3><p>A）可以在工具—&gt;原子库选择器中选中要查看的振动模型</p>
<p><img src="/2017/12/16/ex25/ex25-15.jpeg" alt=""></p>
<p><strong>注意，先把右边的按钮拉倒底，然后双击Frequencies展开频率信息，</strong> 如下:</p>
<p><img src="/2017/12/16/ex25/ex25-16.jpeg" alt=""></p>
<p>B) 也可以直接右键—&gt;模型中选中</p>
<p><img src="/2017/12/16/ex25/ex25-17.jpeg" alt=""></p>
<hr>
<h3 id="2-3-开启振动"><a href="#2-3-开启振动" class="headerlink" title="2.3 开启振动"></a>2.3 开启振动</h3><p>A) 原子库选择器中<strong>最下方</strong>: <strong>振动—&gt;振动开</strong> 可实现， 点击后，原子就开始振动了。</p>
<p><img src="/2017/12/16/ex25/ex25-18.jpeg" alt=""></p>
<p><img src="/2017/12/16/ex25/ex25-19.jpeg" alt=""></p>
<p>B) 在<strong>菜单栏—&gt;工具—&gt;震动</strong> 中开启（原子库选择器选中时采用这种方式，需要先开启再选中）</p>
<p><img src="/2017/12/16/ex25/ex25-20.jpeg" alt=""></p>
<p>C) 也可以<strong>右键 —&gt; 振动 —&gt; 开启</strong></p>
<p><img src="/2017/12/16/ex25/ex25-21.jpeg" alt=""></p>
<hr>
<h3 id="2-4-查看不同振动"><a href="#2-4-查看不同振动" class="headerlink" title="2.4 查看不同振动"></a>2.4 查看不同振动</h3><p>A) 原子集选择器中的频率列表，双击其中的一个就显示其振动方式了。</p>
<p><img src="/2017/12/16/ex25/ex25-22.jpeg" alt=""></p>
<p>B) 要查看下一个振动还可以通过点击向右的这个箭头就可以了。</p>
<p><img src="/2017/12/16/ex25/ex25-23.jpeg" alt=""></p>
<p>以上就是本节关于 <strong>Jmol</strong> 可视化的介绍了，更多信息，请查看 <strong>Jmol</strong> 的<code>wiki</code>：<br><a href="http://wiki.jmol.org/index.php/Main_Page">http://wiki.jmol.org/index.php/Main_Page</a></p>
<h2 id="3-扩展练习："><a href="#3-扩展练习：" class="headerlink" title="3 扩展练习："></a>3 扩展练习：</h2><p>3.1 熟练掌握 <strong>Jmol</strong> 的软件安装，查看频率的基本操作。</p>
<p>3.2 通过在<code>Linux</code>系统下面安装 <strong>Jmol</strong>，尝试着安装其他软件；</p>
<p>3.3 分析各项频率值对应的分子或者原子的移动。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>本节主要介绍给大家一款除了 <strong>p4vasp</strong> 之外的另一款 <strong>VASP</strong> 可视化的软件，不仅仅局限在频率振动分析方面，查看<code>POSCAR</code>，<code>CONTCAR</code>也可以直接使用 <strong>Jmol</strong> 打开。该软件由连赞小朋友推荐，并编辑文中大部分内容，在此表示衷心的感谢。希望大家都可以熟练掌握这款软件。<code>Linux</code>下面可以直接用命令： <code>jmol 文件名</code>，打开查看结构，非常方便。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>乙醇</tag>
        <tag>振动频率</tag>
        <tag>Jmol</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex26 乙醇分子的振动频率计算(四)</title>
    <url>/2017/12/17/ex26/</url>
    <content><![CDATA[<p>前面我们学会了通过使用 <strong>Jmol</strong> 查看分子振动。但分子振动频率在<code>OUTCAR</code>是什么样子的呢？今天我们就分析一下<code>OUTCAR</code>文件中的频率信息，以及如何写脚本计算零点能矫正。</p>
<hr>
<h2 id="1-OUTCAR分析"><a href="#1-OUTCAR分析" class="headerlink" title="1 OUTCAR分析"></a>1 OUTCAR分析</h2><h3 id="1-1-回顾一下Jmol中的频率振动"><a href="#1-1-回顾一下Jmol中的频率振动" class="headerlink" title="1.1 回顾一下Jmol中的频率振动"></a>1.1 回顾一下Jmol中的频率振动</h3><p><img src="/2017/12/17/ex26/ex26-1.jpeg" alt=""></p>
<p><strong>Jmol</strong> 提取了<code>OUTCAR</code>中的振动信息，将每个振动模式的频率列了出来。</p>
<h3 id="1-2-OUTCAR中的信息："><a href="#1-2-OUTCAR中的信息：" class="headerlink" title="1.2 OUTCAR中的信息："></a>1.2 OUTCAR中的信息：</h3><p><img src="/2017/12/17/ex26/ex26-2.jpeg" alt=""></p>
<p>对比一下这两个振动频率和·中的前两个。</p>
<hr>
<p>1）<code>1 f =</code> 代表第一个振动模式，细心的你仔细观察，会发现每一行有四个单位的数值：<code>THz</code>, <code>2PiTHz</code>, <code>cm-1</code>,和 <code>meV</code>，这四个是完全等同的；</p>
<p>2）下面一行为坐标 X Y Z和每个原子在 $x, y, z$ 方向上的振动大小；</p>
<p>3）X Y Z下面的数字为结构的坐标信息（Cartesian坐标系），dx dy dz 为振动的具体数值；</p>
<p>4)后面的振动模式的频率和第一个的格式一样。</p>
<hr>
<h2 id="2-频率单位的换算"><a href="#2-频率单位的换算" class="headerlink" title="2 频率单位的换算"></a>2 频率单位的换算</h2><p>我们先讲一下这四个单位的换算公式：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Relevant    Formulas:</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">$ E =   hc / \lambda $</td>
</tr>
<tr>
<td style="text-align:left">$ \nu = c / \lambda $</td>
</tr>
<tr>
<td style="text-align:left">$\tilde{\nu} = 1 / \lambda $</td>
</tr>
<tr>
<td style="text-align:left">$ T =   1 / \nu $</td>
</tr>
<tr>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><strong>Definitions:</strong></td>
</tr>
<tr>
<td style="text-align:left">$E$ =   energy ($eV$)</td>
</tr>
<tr>
<td style="text-align:left">$\lambda$ =   wavelength  ($m$)</td>
</tr>
<tr>
<td style="text-align:left">$\tilde{\nu}$ =   wavenumber  ($m^{-1}$)</td>
</tr>
<tr>
<td style="text-align:left">$T$ =   period ($s$)</td>
</tr>
<tr>
<td style="text-align:left">$\nu$  =   frequency  ($s^{-1}$ or $\textrm{Hz}$)</td>
</tr>
<tr>
<td style="text-align:left">$h$ = Planck’s constant = $4.135667516 \times 10^{-15}~eV \cdot s$</td>
</tr>
<tr>
<td style="text-align:left">$c$ =   speed of  light = $ 299792458~m/s$</td>
</tr>
</tbody>
</table>
</div>
<p>以第一个振动为例：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">1f   =</th>
<th style="text-align:right"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">111.907</td>
<td style="text-align:right">$\textrm{THz}$</td>
</tr>
<tr>
<td style="text-align:left">703.134</td>
<td style="text-align:right">2PiTHz</td>
</tr>
<tr>
<td style="text-align:left">3732.82</td>
<td style="text-align:right">$cm^{-1} $</td>
</tr>
<tr>
<td style="text-align:left">462.811</td>
<td style="text-align:right">$meV$</td>
</tr>
</tbody>
</table>
</div>
<p>1） THz 和 2PiTHz 的换算： $2\pi$ 的关系：</p>
<script type="math/tex; mode=display">111.907230~(\rm{THz})  \times 2 \pi  = 703.133866~(\rm{2PiTHz})</script><p>2） THz 和 cm-1 的关系：$\nu = c / \lambda = c \tilde{\nu} $， $c$ 是光速，$\lambda$ 是波长，$\tilde{\nu}$ 是波数，单位是 $m^{-1}$。计算前先换算成标准单位： 1 THz = 1012 Hz, 1 $cm^{-1}$ = 100 $m^{-1}$，因此：</p>
<script type="math/tex; mode=display">111.907230 \times 1012~(\textrm{Hz}) = 299792458~(m/s) \times 3732.823294 \times 100 (m^{-1})</script><p>3）THz 和能量 eV 的关系：</p>
<p>$ E = h\nu $， $h$ 为普朗克常数：$4.135667516 \times 10^{-15}~eV \cdot s$ <strong>(注意此时：Plank constant 的单位！！！)</strong></p>
<script type="math/tex; mode=display">462.811270 (meV) = 0.4628 eV = 4.135667516 \times 10^{-15} (eV*s) *  111.907230 \times 1012 (Hz)</script><p>4） 波数（$cm^{-1}$）和能量（$meV$）的关系：<br>$E = hc / \lambda = h \tilde \nu $<br>$ 462.811270~meV = 0.4628~eV<br> = 4.135667516 \times 10^{-15}~(eV*s) \times 299792458~(m/s) \times 3732.823294 \times 100~(m^{-1}) $</p>
<p>大家根据上面的公式自己手动算一遍就明白了，还可以使用下面这个网址进行计算：<a href="http://halas.rice.edu/conversions">http://halas.rice.edu/conversions</a> 这里就不再多说了。</p>
<hr>
<h2 id="3-OUTCAR频率信息的提取："><a href="#3-OUTCAR频率信息的提取：" class="headerlink" title="3  OUTCAR频率信息的提取："></a>3  OUTCAR频率信息的提取：</h2><p>我们可以使用<code>grep</code>命令提取，有以下两个方式。在进行之前，首先强调一点：下面的解释<strong>只适用于</strong>NWRITE= 0、1或者2 的时候。因为NWRITE = 3 的时候，会额外再输出一次频率的信息。</p>
<h3 id="3-1-使用以下几个命令："><a href="#3-1-使用以下几个命令：" class="headerlink" title="3.1 使用以下几个命令："></a>3.1 使用以下几个命令：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep THz OUTCAR</span><br><span class="line">grep 2PiTHz OUTCAR</span><br><span class="line">grep cm-1 OUTCAR</span><br><span class="line">grep meV OUTCAR；</span><br></pre></td></tr></table></figure>
<p>这几个命令中，我们分别以振动的不同单位作为提取对象，便可以得到所有的振动信息（这里的所有指的是包含虚频）：以大师兄常用的 <code>grep cm-1 OUTCAR</code> 为例：</p>
<p><img src="/2017/12/17/ex26/ex26-3.jpeg" alt=""></p>
<p>黄色标出来的第一列：$9 \times 3 = 27$ 个振动模式，第二列是以<code>cm-1</code>为单位的振动频率大小，最后三行 <code>f/i=</code> 指的是虚频。</p>
<hr>
<p>前面我们提到过，虚频可以判断结构是否稳定。那这里，我们计算出的乙醇分子结构肯定不稳定喽？不一定。</p>
<p>因为频率计算和软件的数值积分有关（我也不清楚数值积分怎么进行的）；</p>
<p>计算过程中我们的设置对频率计算影响很大，<code>KPOINTS</code>, <code>ENCUT</code>, <code>EDIFF</code>, <code>POTIM</code>等都会影响计算的精度（下一节讨论）；综合这些因素，对于分子的振动频率来说（注意：声子谱不适用）一般低于 $100~cm^{-1}$ 的频率可以忽略。严格点可以降到 $50~cm^{-1}$，也就是说：如果你在计算中发现有个 $50~cm^{-1}$ 左右的虚频，完全可以不考虑。</p>
<hr>
<h3 id="3-2-grep-39-f-39-OUTCAR"><a href="#3-2-grep-39-f-39-OUTCAR" class="headerlink" title="3.2 grep &#39;f  =&#39; OUTCAR"></a>3.2 <code>grep &#39;f  =&#39; OUTCAR</code></h3><p><img src="/2017/12/17/ex26/ex26-4.jpeg" alt=""></p>
<p><strong>注意：图中虚频部分没有显示出来！严格按照我用的这个命令</strong></p>
<p>使用这个命令的时候，不提取虚频部分。查看虚频的时候，可以用之前的方式，也可以用这个命令：</p>
<p><img src="/2017/12/17/ex26/ex26-5.jpeg" alt=""></p>
<p>在零点能的计算时，虚频是不能考虑在内的，因为它不是分子的真实的振动模式。在我们这个例子中，虚频的出现是软件的误差所导致。在过渡态中，虚频代表的是反应方向。从另一个角度去分析：乙醇分子的零点能（下面讲到）为：$2.117~eV$，图中三个虚频对应的能量为：$0.76 + 2.31 + 8.14 = 11.11~meV = 0.01111~ eV$，所占比例为：$0.0111/2.117 = 0.5\% $ 这个可以忽略不计。</p>
<hr>
<h2 id="4-零点能校正"><a href="#4-零点能校正" class="headerlink" title="4 零点能校正"></a>4 零点能校正</h2><h3 id="4-1-明白什么是零点能：回顾频率计算第一节的内容："><a href="#4-1-明白什么是零点能：回顾频率计算第一节的内容：" class="headerlink" title="4.1 明白什么是零点能：回顾频率计算第一节的内容："></a>4.1 明白什么是零点能：回顾频率计算第一节的内容：</h3><p><img src="/2017/12/17/ex26/ex26-6.jpeg" alt=""></p>
<p><img src="/2017/12/17/ex26/ex26-7.jpeg" alt=""></p>
<h3 id="4-2-获取振动能量数据："><a href="#4-2-获取振动能量数据：" class="headerlink" title="4.2 获取振动能量数据："></a>4.2 获取振动能量数据：</h3><p><img src="/2017/12/17/ex26/ex26-8.jpeg" alt=""></p>
<p>分析下结构：</p>
<p><img src="/2017/12/17/ex26/ex26-9.jpeg" alt=""></p>
<p>上图输出共有11列（列之间用空格分开）：我们要的零点能在第10列，使用下面的命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep <span class="string">&#x27;f  =&#x27;</span> OUTCAR | awk <span class="string">&#x27;&#123;print $10&#125;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>如果想同时输出第 1 和 10 两列：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep <span class="string">&#x27;f  =&#x27;</span> OUTCAR | awk<span class="string">&#x27;&#123;print $1 &quot; &quot;$10&#125;&#x27;</span></span><br></pre></td></tr></table></figure><br><code>$1</code> 和 <code>$10</code> 之间有 2个 双引号：<strong>“ “</strong>，两个双引号里面有一个空格用来分开），否则两列会连在一起。</p>
<p><strong>注意！注意！注意！</strong></p>
<p><strong>这里我们提取的能量为：$h\nu$ ！！！</strong></p>
<p><strong>而零点能为 $1/2 h \nu$！！！</strong></p>
<h3 id="4-3-将所有振动的能量求和："><a href="#4-3-将所有振动的能量求和：" class="headerlink" title="4.3 将所有振动的能量求和："></a>4.3 将所有振动的能量求和：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@BigBroSci:~/Desktop/freq$ grep <span class="string">&#x27;f  =&#x27;</span> OUTCAR | awk <span class="string">&#x27;&#123;print $10&#125;&#x27;</span> | paste -sd+ | bc</span><br><span class="line">qli@BigBroSci:~/Desktop/freq$ 4233.962325</span><br></pre></td></tr></table></figure>
<p>输出的4233.96就是所有的 hv 之和。</p>
<p>1）不要忘记除以 $2$</p>
<p>2）此时单位是 $meV$，换算成 $eV$ 还需要除以 $1000$。</p>
<p>3）所以，我们的零点能是 $4233.962325/2/1000~ eV= 2.117~eV$</p>
<h3 id="4-4-写脚本"><a href="#4-4-写脚本" class="headerlink" title="4.4 写脚本"></a>4.4 写脚本</h3><p>将前面的命令写到一个文件里面就成为了脚本：怎么写呢？本人平时喜欢使用类似 $4233.962325$ 这个数字，除以 $2000$ 这一步在后面的工作中进行。因此只用到了<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep <span class="string">&#x27;f =&#x27;</span> OUTCAR | awk <span class="string">&#x27;&#123;print $10&#125;&#x27;</span> | paste -sd+ | bc</span><br></pre></td></tr></table></figure><br>这个命令。写脚本的具体操作：</p>
<p><img src="/2017/12/17/ex26/ex26-10.jpeg" alt=""></p>
<p>1）把这行命令写到一个文件中，文件名为 <code>fsum</code> （本人不喜欢 <code>.sh</code> 尾缀，加不加都一样）；</p>
<p>2）赋予可执行权限<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod u+x ~/bin/fsum</span><br></pre></td></tr></table></figure></p>
<p>3）移到 <code>~/bin</code> 文件夹<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv fsum ~/bin</span><br></pre></td></tr></table></figure></p>
<p>4）在任何一个频率计算的目录下运行：敲命令 <code>fsum</code> 即可；</p>
<p>5）不喜欢 <code>fsum</code> 这个命令，将文件名改成你自己喜欢的名字：</p>
<p>如果想在脚本里面直接完成除以 $2000$ 的任务，可以这么写：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hv_sum=$(grep<span class="string">&quot;f  =&quot;</span> OUTCAR | awk <span class="string">&#x27;&#123;print  $10&#125;&#x27;</span>| paste -sd+ | bc)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;scale =6; <span class="variable">$hv_sum</span>/2000&quot;</span> | bc</span><br></pre></td></tr></table></figure>
<p><img src="/2017/12/17/ex26/ex26-11.jpeg" alt=""></p>
<p>此时结果的单位为：$eV$。</p>
<hr>
<h2 id="5-扩展练习："><a href="#5-扩展练习：" class="headerlink" title="5 扩展练习："></a>5 扩展练习：</h2><p>5.1 <code>OUTCAR</code>中的频率输出要看明白是怎么回事；</p>
<p>5.2 频率的各个单位的换算要搞明白；</p>
<p>5.3 怎么提取信息，计算零点能要掌握；</p>
<p>5.4 怎么写脚本，从现在开始要练习了！</p>
<h2 id="6-总结："><a href="#6-总结：" class="headerlink" title="6 总结："></a>6 总结：</h2><p>本节我们主要讨论了一下<code>OUTCAR</code>中的频率结果，能量换算，如何提取振动能量，以及如何计算零点能，最后简单介绍了一下脚本的写法，打消大家对脚本的崇拜心理，自己稍加琢磨也会写出实用的脚本！</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>乙醇</tag>
        <tag>振动频率</tag>
        <tag>零点能</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex27 乙醇分子的振动频率计算(五)</title>
    <url>/2017/12/18/ex27/</url>
    <content><![CDATA[<p>通过前面读者的反馈，本节前面主要讲述一下零点能相关的注意事项以及频率计算的时间成本相关的知识。</p>
<h2 id="1-参考书籍："><a href="#1-参考书籍：" class="headerlink" title="1 参考书籍："></a>1 参考书籍：</h2><p>以下所提到的书籍都可以在<strong>QQ群文件</strong>和<strong>百度网盘</strong>里面下载：<a href="http://pan.baidu.com/s/1bKHMjG">http://pan.baidu.com/s/1bKHMjG</a></p>
<h3 id="1-1-Density-Functional-Theory：A-Practical-Introduction"><a href="#1-1-Density-Functional-Theory：A-Practical-Introduction" class="headerlink" title="1.1 Density Functional Theory：A Practical Introduction"></a>1.1 Density Functional Theory：A Practical Introduction</h3><p>大师兄极力推荐的菜鸟入门书！！！</p>
<p>1）不要网上随便下载（很多都是野鸡版，公式符号不全）</p>
<p>2）不要看中文版的；去看原汁原味的，困了就歇会，慢慢坚持看；</p>
<p>3）大师兄QQ群下载或者点击百度网盘链接；</p>
<p>4）第5章专门讨论的频率相关的问题！！！</p>
<p><img src="/2017/12/18/ex27/ex27-1.jpeg" alt=""></p>
<h3 id="1-2-Atkins的物理化学第9版"><a href="#1-2-Atkins的物理化学第9版" class="headerlink" title="1.2  Atkins的物理化学第9版"></a>1.2  Atkins的物理化学第9版</h3><p>前面几节我们都是用的这一部分作为参考，忘了的童鞋们返回继续重修；这本书网上已经可以下载第十版的pdf文件了。</p>
<p><img src="/2017/12/18/ex27/ex27-2.jpeg" alt=""></p>
<h3 id="1-3-Jens-K-Norskov-的-Fundamental-Concepts-in-Heterogeneous-Catalysis"><a href="#1-3-Jens-K-Norskov-的-Fundamental-Concepts-in-Heterogeneous-Catalysis" class="headerlink" title="1.3 Jens. K. Norskov 的 Fundamental Concepts in Heterogeneous Catalysis"></a>1.3 Jens. K. Norskov 的 Fundamental Concepts in Heterogeneous Catalysis</h3><p><img src="/2017/12/18/ex27/ex27-3.jpeg" alt=""></p>
<h2 id="2-频率计算的细节问题"><a href="#2-频率计算的细节问题" class="headerlink" title="2 频率计算的细节问题"></a>2 频率计算的细节问题</h2><p>当你阅读完前面推荐书中的频率部分后，应该会明白很多。本节的第二部分我们主要讨论下频率计算的一些大家有顾虑的细节问题：</p>
<h3 id="2-1-怎么进行零点能校正？"><a href="#2-1-怎么进行零点能校正？" class="headerlink" title="2.1 怎么进行零点能校正？"></a>2.1 怎么进行零点能校正？</h3><p>以乙醇的计算为例：</p>
<p>A）首先结构优化完毕后我们会得到分子的能量：$E_{0}$  （OSZICAR中的E0）</p>
<p>B）频率计算后我们会得到分子的零点能：$ZPE$</p>
<p>C）零点能校正之后的乙醇分子能量为： $E_{ZPE} =  E_0 + ZPE$</p>
<p>D）A 和 B 得出的结果直接相加即可，不要想太多。</p>
<h3 id="2-2-怎么计算过渡态和反应热的零点能校正？（菜鸟暂且跳过）"><a href="#2-2-怎么计算过渡态和反应热的零点能校正？（菜鸟暂且跳过）" class="headerlink" title="2.2 怎么计算过渡态和反应热的零点能校正？（菜鸟暂且跳过）"></a>2.2 怎么计算过渡态和反应热的零点能校正？（菜鸟暂且跳过）</h3><p>对一个反应：IS —&gt; TS —&gt; FS</p>
<p>IS: Initial State 反应物</p>
<p>TS: Transition State 过渡态</p>
<p>FS: Final State 产物</p>
<p>记住这几个定义，本书后面 IS, TS, FS 用的时候多着呢！</p>
<p>1）优化反应物 IS 和产物 FS 的结构，获得能量：$E(\textrm{IS})$, $E(\textrm{FS})$;</p>
<p>2）对反应物和产物进行频率计算，获得各自的零点能：$\textrm{ZPE(IS)}, \textrm{ZPE(FS)}$。</p>
<p>3）搜索过渡态，获得结构和能量 $E(\textrm{TS})$;</p>
<p>4）过渡态频率分析，获得零点能 $\textrm{ZPE(TS)}$</p>
<p><strong>不考虑零点能的反应能垒 ($E_a$) 和反应热 ($\Delta E$)：</strong></p>
<script type="math/tex; mode=display">E_a = E(\textrm{TS}) – E(\textrm{IS}) \\
 \Delta E = E(\textrm{FS}) –  E(\textrm{IS})</script><p>考虑零点能校正：</p>
<script type="math/tex; mode=display">
\begin{align}
E{a(\textrm{ZPE})} &= E_{\textrm{ZPE}}(\textrm{TS}) – E_{\textrm{ZPE}}(\textrm{IS}) \\     
     &= E(\textrm{TS}) + \textrm{ZPE(TS}) – E(\textrm{IS}) – \textrm{ZPE(IS}) \\
     &= E_a + \textrm{ZPE(TS)} – \textrm{ZPE(IS)}
\end{align}</script><p>同理:</p>
<p>$ \Delta E(\textrm{ZPE}) = \Delta E + \textrm{ZPE(FS)} – \textrm{ZPE(IS)} $</p>
<p>两个处理方式：</p>
<p>a. 先获取未校正的结果，然后把零点能各自相减；</p>
<p>b. 先将各个物种进行零点能校正，然后在计算反应能垒或者反应热</p>
<p>效果是一样的</p>
<p>2.2 频率计算的时候，是不是体系中所有的原子都放开？</p>
<p>不一定；这取决于你的体系，以及你想要关注的部分:</p>
<hr>
<p><strong>例子A:</strong></p>
<p>乙醇在Cu(111)表面上的吸附，计算吸附热的零点能校正</p>
<script type="math/tex; mode=display">
\ce{CH_3CH_2OH + Cu(111) -> Cu(111)-CH_3CH_2OH}</script><p>此时，Cu(111)表面我们在计算频率的时候是要固定住的！只振动乙醇分子即可。</p>
<hr>
<p><strong>例子B:</strong></p>
<p>计算CO在Cu(111)表面上的吸附：</p>
<p>同A，固定Cu(111) 表面，如果你只关心 CO 在垂直表面上的振动，那么CO的 $x, y$ 方向便可以固定住，在坐标后面为：<code>F F T</code></p>
<hr>
<p><strong>例子C:</strong></p>
<p>苯酚在Cu(111)表面上 O—H 键断裂活化能的零点能校正：</p>
<p>在这里我们拿苯酚作为例子，很多时候，计算的对象比较大，全部频率优化非常耗时，那我们就得选择性地固定住一部分，只关心关键的局域部分。这个例子中我们主要讨论零点能对 O—H 键断裂活化能的影响，因此我们可以把苯环的部分固定住，只放开 O 和 H 原子进行振动。</p>
<p>当然啦，这是一个简化的计算，肯定不如全部振动的结果好，但迫于计算时间的压力，这是一个折中的好办法。此外，由于在反应中苯环部分变化不大，所以即使我们全部放开，它对反应热和反应能垒的影响也很小，零点能部分相减的时候抵消了。在这里你要深刻体会到，意识到，<strong>把握到相对这两个字在理论计算中的巨大作用！！！</strong></p>
<hr>
<p>还有一点要注意的是：<code>IS</code>，<code>TS</code>和<code>FS</code>中，所固定和放开的原子必须一致！！！</p>
<p><strong>不要在<code>IS</code>中固定苯环，而在<code>TS</code>或者<code>FS</code>中放开，</strong> 这样计算出来的结果只能用脑残来形容了。(<em>ps. 本人犯的这种错误太多啦，已经不能用脑残来形容了！</em>)</p>
<hr>
<h2 id="3-影响频率计算的因素测试"><a href="#3-影响频率计算的因素测试" class="headerlink" title="3 影响频率计算的因素测试:"></a>3 影响频率计算的因素测试:</h2><p>前面提到过：<code>ENCUT</code>, <code>KPOINTS</code>, <code>POTIM</code>, <code>EDIFF</code>都会对频率计算产生影响。频率计算很多时候会有小的虚频出现，通俗点说就是数值噪音。我们可能会想到，凡是可以提高精度的办法是不是就可以降低噪音了呢？写到这里，大师兄突然想起初中的一个老师说过一句话：好记性不如烂笔头，意思是让我们多写，这样记得会比较快。还有一句名言：<strong>纸上学来终觉浅，绝知此事要躬行！学习 </strong>VASP<strong>，亲自上手实践及其重要，看遍官网，翻烂本书不去行动也是白搭，好听点说只能是纸上谈兵。</strong></p>
<p>下面的测试主要从零点能和虚频，和时间三个方面来判断：测试的命令为：</p>
<p>获取虚频命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep <span class="string">&#x27;f/i&#x27;</span>  */OUTCAR | awk <span class="string">&#x27;&#123;print $1 &quot;\t &quot; $2 &quot;\t&quot; $8 &quot;\t &quot; $9 &quot;\t&quot; $10 &quot;\t&quot; $11&#125;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>获取时间命令：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep Elapsed */OUTCAR | sort -n</span><br></pre></td></tr></table></figure></p>
<p>获取零点能：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> * ; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span> $(<span class="built_in">cd</span> <span class="variable">$i</span> ; fsum ; <span class="built_in">cd</span> <span class="variable">$OLDPWD</span>);<span class="keyword">done</span>  | sort –n</span><br></pre></td></tr></table></figure></p>
<h3 id="3-1-EDIFFG测试"><a href="#3-1-EDIFFG测试" class="headerlink" title="3.1  EDIFFG测试"></a>3.1  EDIFFG测试</h3><h4 id="3-1-1测试"><a href="#3-1-1测试" class="headerlink" title="3.1.1测试"></a>3.1.1测试</h4><p>$4, 5, 6, 7, 8$ 分别代表 <code>EDIFF=1E-4</code> 到 <code>-8</code> 的测试任务；</p>
<p><img src="/2017/12/18/ex27/ex27-4.jpeg" alt=""></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> * ; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span> $(<span class="built_in">cd</span> <span class="variable">$i</span> ; fsum ; <span class="built_in">cd</span> <span class="variable">$OLDPWD</span>); <span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>零点能的计算结果：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">EDIFF</th>
<th style="text-align:left">ZPE</th>
<th style="text-align:left">Unit</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">2.14344</td>
<td style="text-align:left">eV</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">2.12494</td>
<td style="text-align:left">eV</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">2.11698</td>
<td style="text-align:left">eV</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">2.11696</td>
<td style="text-align:left">eV</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">2.11696</td>
<td style="text-align:left">eV</td>
</tr>
</tbody>
</table>
</div>
<p>a. 可以看出来在<code>1E=-6</code>以后，零点能变化基本为 <code>0</code>了；我们可以用这个设置；</p>
<p>b. 虽然你测出来一个很好的参数值，很不幸，这是默认的。</p>
<p>c. 从时间上考虑，本人会选择 <code>EDIFF= 1E-5</code>，这比 <code>1E=-6</code> 快了将近一倍；</p>
<p>d. $5$ 和 $6$ 之间的误差为：$ 0.008/2.117 = 0.38\% $；</p>
<p>e. 此外，单个的零点能貌似没有什么用处，一般都是两个结构的零点能相减。这个操作也会抵消一部分的计算误差。</p>
<hr>
<h4 id="3-1-2-虚频"><a href="#3-1-2-虚频" class="headerlink" title="3.1.2 虚频"></a>3.1.2 虚频</h4><p><img src="/2017/12/18/ex27/ex27-5.jpeg" alt=""></p>
<p><strong>（这个命令只展示一次，后面测试结果全部用下面的表格）</strong></p>
<table><tr><th>EDIFF</th><th>Nth</th><th>WN</th><th>Unit</th><th>Energy</th><th>Unit</th></tr><tr><td rowspan="3">4</td><td>25</td><td>10.183435</td><td> cm<sup>-1</sup></td><td>1.262585</td><td>meV</td></tr><tr><td>26</td><td>43.891375</td><td> cm<sup>-1</sup></td><td>5.441839</td><td>meV</td></tr><tr><td>27</td><td>61.646745</td><td> cm<sup>-1</sup></td><td>7.643225</td><td>meV</td></tr><tr><td rowspan="3">5</td><td>25</td><td>6.773094</td><td> cm<sup>-1</sup></td><td>0.839757</td><td>meV</td></tr><tr><td>26</td><td>28.045092</td><td> cm<sup>-1</sup></td><td>3.477149</td><td>meV</td></tr><tr><td>27</td><td>52.28955</td><td> cm<sup>-1</sup></td><td>6.48308</td><td>meV</td></tr><tr><td rowspan="3">6</td><td>25</td><td>6.132037</td><td> cm<sup>-1</sup></td><td>0.760276</td><td>meV</td></tr><tr><td>26</td><td>18.62878</td><td> cm<sup>-1</sup></td><td>2.309675</td><td>meV</td></tr><tr><td>27</td><td>65.657693</td><td> cm<sup>-1</sup></td><td>8.140519</td><td>meV</td></tr><tr><td rowspan="3">7</td><td>25</td><td>6.03848</td><td> cm<sup>-1</sup></td><td>0.748676</td><td>meV</td></tr><tr><td>26</td><td>19.115009</td><td> cm<sup>-1</sup></td><td>2.36996</td><td>meV</td></tr><tr><td>27</td><td>65.726299</td><td> cm<sup>-1</sup></td><td>8.149025</td><td>meV</td></tr><tr><td rowspan="3">8</td><td>25</td><td>6.036457</td><td> cm<sup>-1</sup></td><td>0.748425</td><td>meV</td></tr><tr><td>26</td><td>19.156334</td><td> cm<sup>-1</sup></td><td>2.375084</td><td>meV</td></tr><tr><td>27</td><td>65.711053</td><td> cm<sup>-1</sup></td><td>8.147135</td><td>meV</td></tr></table>

<p>a. 改变收敛标准，并没有消除虚频，测试 $5$ 中，稍微降低了些，其他情况下，最大的仍然都再 <code>1500 px-1</code> 左右</p>
<p>b. $6$, $7$, $8$ 中的虚频基本一致，说明增加收敛标准，并没起到什么好的效果。</p>
<h4 id="3-1-3-时间"><a href="#3-1-3-时间" class="headerlink" title="3.1.3 时间"></a>3.1.3 时间</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">EDIFF</th>
<th style="text-align:left">Time</th>
<th style="text-align:left">Unit</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">1702.463</td>
<td style="text-align:left">s</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">2295.233</td>
<td style="text-align:left">s</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">4298.571</td>
<td style="text-align:left">s</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">5481.423</td>
<td style="text-align:left">s</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">5998.518</td>
<td style="text-align:left">s</td>
</tr>
</tbody>
</table>
</div>
<p>复习下谁偷走了我的机时中<code>EDIFF</code>的因素；增加<code>EDIFF</code>，计算时间变长了。（离子步数一致，每个离子步的收敛步数增多了） 一般来说<code>EDIFF</code>采用默认值或者<code>1E-5</code>都可以满足情况，任务比较繁重的时候议用<code>1E-5</code>。本节在后面的测试中，都采用 <strong>VASP</strong> 的默认<code>EDIFF</code>值进行（<code>1E-6</code>）</p>
<hr>
<h3 id="3-2-ENCUT测试"><a href="#3-2-ENCUT测试" class="headerlink" title="3.2 ENCUT测试"></a>3.2 ENCUT测试</h3><h4 id="3-2-1-零点能"><a href="#3-2-1-零点能" class="headerlink" title="3.2.1 零点能"></a>3.2.1 零点能</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">ENCU</th>
<th style="text-align:left">ZPE</th>
<th style="text-align:left">Unit</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">400</td>
<td style="text-align:left">2.11698</td>
<td style="text-align:left">eV</td>
</tr>
<tr>
<td style="text-align:left">500</td>
<td style="text-align:left">2.11448</td>
<td style="text-align:left">eV</td>
</tr>
<tr>
<td style="text-align:left">600</td>
<td style="text-align:left">2.11880</td>
<td style="text-align:left">eV</td>
</tr>
<tr>
<td style="text-align:left">700</td>
<td style="text-align:left">2.11971</td>
<td style="text-align:left">eV</td>
</tr>
<tr>
<td style="text-align:left">800</td>
<td style="text-align:left">2.11928</td>
<td style="text-align:left">eV</td>
</tr>
</tbody>
</table>
</div>
<p>从表中可以得出结论：增加<code>ENCUT</code>,对零点能的影响很小；</p>
<p>在计算的过程中，<code>ENCUT</code>要保持一致，一但选定后就不要再轻易改动，这个表的数据告诉我们，即使改动了<code>ENCUT</code>，对零点能的影响也很小，所以<code>ENCUT</code>的影响可以忽略。</p>
<h4 id="3-2-2-虚频："><a href="#3-2-2-虚频：" class="headerlink" title="3.2.2 虚频："></a>3.2.2 虚频：</h4><table><tr><th>ENCUT</th><th>Nth</th><th>WN</th><th>Unit</th><th>energy</th><th>unit</th></tr><tr><td rowspan="3">400</td><td>25</td><td>6.132038</td><td> cm<sup>-1</sup></td><td>0.760276</td><td>meV</td></tr><tr><td>26</td><td>18.62878</td><td> cm<sup>-1</sup></td><td>2.309675</td><td>meV</td></tr><tr><td>27</td><td>65.65769</td><td> cm<sup>-1</sup></td><td>8.140519</td><td>meV</td></tr><tr><td rowspan="4">500</td><td>24</td><td>0.489004</td><td> cm<sup>-1</sup></td><td>0.060629</td><td>meV</td></tr><tr><td>25</td><td>16.7313</td><td> cm<sup>-1</sup></td><td>2.074418</td><td>meV</td></tr><tr><td>26</td><td>23.491849</td><td> cm<sup>-1</sup></td><td>2.912619</td><td>meV</td></tr><tr><td>27</td><td>66.062971</td><td> cm<sup>-1</sup></td><td>8.190767</td><td>meV</td></tr><tr><td rowspan="4">600</td><td>24</td><td>0.288462</td><td> cm<sup>-1</sup></td><td>0.035765</td><td>meV</td></tr><tr><td>25</td><td>4.853849</td><td> cm<sup>-1</sup></td><td>0.601801</td><td>meV</td></tr><tr><td>26</td><td>6.324527</td><td> cm<sup>-1</sup></td><td>0.784142</td><td>meV</td></tr><tr><td>27</td><td>52.075614</td><td> cm<sup>-1</sup></td><td>6.456556</td><td>meV</td></tr><tr><td rowspan="3">700</td><td>25</td><td>0.747158</td><td> cm<sup>-1</sup></td><td>0.092636</td><td>meV</td></tr><tr><td>26</td><td>6.175845</td><td> cm<sup>-1</sup></td><td>0.765708</td><td>meV</td></tr><tr><td>27</td><td>32.540704</td><td> cm<sup>-1</sup></td><td>4.034535</td><td>meV</td></tr><tr><td rowspan="3">800</td><td>25</td><td>0.289332</td><td> cm<sup>-1</sup></td><td>0.035873</td><td>meV</td></tr><tr><td>26</td><td>7.356367</td><td> cm<sup>-1</sup></td><td>0.912074</td><td>meV</td></tr><tr><td>27</td><td>26.44812</td><td> cm<sup>-1</sup></td><td>3.27915</td><td>meV</td></tr></table>

<p>增加<code>ENCUT</code>可以减小虚频；从 $400$ 增加到 $800$ 后，最大的虚频波数从 $65~cm^{-1}$ 减小到 $26~cm^{-1}$， 但 A 中的结果是不是要求我们算频率的时候，必须要把 <code>ENCUT</code>增大呢？ 答：<strong>没必要！！</strong></p>
<p>因为前面零点能变化甚微，且虚频从 $65~cm^{-1}$ 减小到 $26~cm^{-1}$, 只能说是在误差范围内变化，我们是可以承受的，此时<code>ENCUT</code>在减小虚频中的作用，大家记住这一点就可以了。此外，增加<code>ENCUT</code>也会使得计算时间变长（见下图）。但是如果虚频大于$100~cm^{-1}$，且不是反应路径的时候，你就得小心了。</p>
<h4 id="3-2-3-时间"><a href="#3-2-3-时间" class="headerlink" title="3.2.3 时间"></a>3.2.3 时间</h4><p>命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep Elapsed */OUTCAR | sort –n</span><br></pre></td></tr></table></figure></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">ENCUT</th>
<th style="text-align:left">Time</th>
<th style="text-align:left">Unit</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">400</td>
<td style="text-align:left">1832.405</td>
<td style="text-align:left">s</td>
</tr>
<tr>
<td style="text-align:left">500</td>
<td style="text-align:left">2389.045</td>
<td style="text-align:left">s</td>
</tr>
<tr>
<td style="text-align:left">600</td>
<td style="text-align:left">3019.433</td>
<td style="text-align:left">s</td>
</tr>
<tr>
<td style="text-align:left">700</td>
<td style="text-align:left">4285.491</td>
<td style="text-align:left">s</td>
</tr>
<tr>
<td style="text-align:left">800</td>
<td style="text-align:left">11943.02</td>
<td style="text-align:left">s</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h3 id="3-3-PREC"><a href="#3-3-PREC" class="headerlink" title="3.3 PREC"></a>3.3 PREC</h3><p>这里我们设置了三个参数：<code>Normal</code>, <code>Accurate</code>和<code>High</code></p>
<h4 id="3-3-1-零点能变化甚微"><a href="#3-3-1-零点能变化甚微" class="headerlink" title="3.3.1 零点能变化甚微"></a>3.3.1 零点能变化甚微</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">PREC</th>
<th style="text-align:left">ZPE</th>
<th style="text-align:left">Unit</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">N</td>
<td style="text-align:left">2.11698</td>
<td style="text-align:left">eV</td>
</tr>
<tr>
<td style="text-align:left">A</td>
<td style="text-align:left">2.1147</td>
<td style="text-align:left">eV</td>
</tr>
<tr>
<td style="text-align:left">H</td>
<td style="text-align:left">2.11363</td>
<td style="text-align:left">eV</td>
</tr>
</tbody>
</table>
</div>
<h4 id="3-3-2-虚频"><a href="#3-3-2-虚频" class="headerlink" title="3.3.2 虚频"></a>3.3.2 虚频</h4><table><tr><th>PREC</th><th>Nth</th><th>Wavenumber</th><th>Unit</th><th>Energy</th><th>Unit</th></tr><tr><td rowspan="3">N</td><td>25</td><td>6.132037</td><td> cm<sup>-1</sup></td><td>0.760276</td><td>meV</td></tr><tr><td>26</td><td>18.62878</td><td> cm<sup>-1</sup></td><td>2.309675</td><td>meV</td></tr><tr><td>27</td><td>65.657693</td><td> cm<sup>-1</sup></td><td>8.140519</td><td>meV</td></tr><tr><td rowspan="3">A</td><td>25</td><td>5.493108</td><td> cm<sup>-1</sup></td><td>0.681059</td><td>meV</td></tr><tr><td>26</td><td>10.478293</td><td> cm<sup>-1</sup></td><td>1.299143</td><td>meV</td></tr><tr><td>27</td><td>65.861524</td><td> cm<sup>-1</sup></td><td>8.165791</td><td>meV</td></tr><tr><td rowspan="4">H</td><td>24</td><td>0.552665</td><td> cm<sup>-1</sup></td><td>0.068522</td><td>meV</td></tr><tr><td>25</td><td>16.954329</td><td> cm<sup>-1</sup></td><td>2.10207</td><td>meV</td></tr><tr><td>26</td><td>29.95621</td><td> cm<sup>-1</sup></td><td>3.714098</td><td>meV</td></tr><tr><td>27</td><td>68.287802</td><td> cm<sup>-1</sup></td><td>8.466611</td><td>meV</td></tr></table>

<p><code>PREC</code>同样对消除虚频不管用！！！！</p>
<h4 id="3-3-3-时间"><a href="#3-3-3-时间" class="headerlink" title="3.3.3 时间"></a>3.3.3 时间</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Prec</th>
<th style="text-align:left">Time</th>
<th style="text-align:left">Unit</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">N</td>
<td style="text-align:left">4298.571</td>
<td style="text-align:left">s</td>
</tr>
<tr>
<td style="text-align:left">A</td>
<td style="text-align:left">7596.994</td>
<td style="text-align:left">s</td>
</tr>
<tr>
<td style="text-align:left">H</td>
<td style="text-align:left">7962.539</td>
<td style="text-align:left">s</td>
</tr>
</tbody>
</table>
</div>
<p>通过前面的虚频和零点能，结合此时的时间，我们可以得出结论：</p>
<p><code>PREC = Normal</code> 完全够用了。</p>
<hr>
<h3 id="3-4-POTIM-参数"><a href="#3-4-POTIM-参数" class="headerlink" title="3.4  POTIM 参数"></a>3.4  POTIM 参数</h3><p><img src="/2017/12/18/ex27/ex27-6.jpeg" alt=""></p>
<h4 id="3-4-1-零点能："><a href="#3-4-1-零点能：" class="headerlink" title="3.4.1 零点能："></a>3.4.1 零点能：</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">POTIM</th>
<th style="text-align:left">ZPE</th>
<th style="text-align:left">eV</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0.001</td>
<td style="text-align:left">2.17125</td>
<td style="text-align:left">eV</td>
</tr>
<tr>
<td style="text-align:left">0.005</td>
<td style="text-align:left">2.12616</td>
<td style="text-align:left">eV</td>
</tr>
<tr>
<td style="text-align:left">0.015</td>
<td style="text-align:left">2.11769</td>
<td style="text-align:left">eV</td>
</tr>
<tr>
<td style="text-align:left">0.020</td>
<td style="text-align:left">2.11698</td>
<td style="text-align:left">eV</td>
</tr>
<tr>
<td style="text-align:left">0.050</td>
<td style="text-align:left">2.11671</td>
<td style="text-align:left">eV</td>
</tr>
<tr>
<td style="text-align:left">0.100</td>
<td style="text-align:left">2.12481</td>
<td style="text-align:left">eV</td>
</tr>
</tbody>
</table>
</div>
<p><code>POTIM</code>太小的时候，对零点能影响很大。（$0.001$ 和 $0.005$，$0.015$ 对比）</p>
<h4 id="3-4-2虚频"><a href="#3-4-2虚频" class="headerlink" title="3.4.2虚频"></a>3.4.2虚频</h4><table><tr><th>POTIM</th><th>Nth</th><th>Wavenumber</th><th>Unit</th><th>Energy</th><th>Unit</th></tr><tr><td rowspan="3">0.001</td><td>25</td><td>21.746998</td><td> cm<sup>-1</sup></td><td>2.696285</td><td>meV</td></tr><tr><td>26</td><td>39.656607</td><td> cm<sup>-1</sup></td><td>4.916794</td><td>meV</td></tr><tr><td>27</td><td>56.54809</td><td> cm<sup>-1</sup></td><td>7.011072</td><td>meV</td></tr><tr><td rowspan="4">0.005</td><td>24</td><td>0.675194</td><td> cm<sup>-1</sup></td><td>0.083713</td><td>meV</td></tr><tr><td>25</td><td>12.785399</td><td> cm<sup>-1</sup></td><td>1.585188</td><td>meV</td></tr><tr><td>26</td><td>36.264179</td><td> cm<sup>-1</sup></td><td>4.496187</td><td>meV</td></tr><tr><td>27</td><td>61.287932</td><td> cm<sup>-1</sup></td><td>7.598738</td><td>meV</td></tr><tr><td rowspan="3">0.015</td><td>25</td><td>5.626635</td><td> cm<sup>-1</sup></td><td>0.697614</td><td>meV</td></tr><tr><td>26</td><td>23.117605</td><td> cm<sup>-1</sup></td><td>2.866219</td><td>meV</td></tr><tr><td>27</td><td>59.01173</td><td> cm<sup>-1</sup></td><td>7.316525</td><td>meV</td></tr><tr><td rowspan="3">0.020</td><td>25</td><td>6.132037</td><td> cm<sup>-1</sup></td><td>0.760276</td><td>meV</td></tr><tr><td>26</td><td>18.62878</td><td> cm<sup>-1</sup></td><td>2.309675</td><td>meV</td></tr><tr><td>27</td><td>65.657693</td><td> cm<sup>-1</sup></td><td>8.140519</td><td>meV</td></tr><tr><td rowspan="4">0.050</td><td>24</td><td>0.327964</td><td> cm<sup>-1</sup></td><td>0.040662</td><td>meV</td></tr><tr><td>25</td><td>23.575077</td><td> cm<sup>-1</sup></td><td>2.922938</td><td>meV</td></tr><tr><td>26</td><td>24.337978</td><td> cm<sup>-1</sup></td><td>3.017526</td><td>meV</td></tr><tr><td>27</td><td>95.239085</td><td> cm<sup>-1</sup></td><td>11.80815</td><td>meV</td></tr><tr><td rowspan="5">0.100</td><td>23</td><td>1.574379</td><td> cm<sup>-1</sup></td><td>0.195198</td><td>meV</td></tr><tr><td>24</td><td>5.865037</td><td> cm<sup>-1</sup></td><td>0.727172</td><td>meV</td></tr><tr><td>25</td><td>20.89784</td><td> cm<sup>-1</sup></td><td>2.591003</td><td>meV</td></tr><tr><td>26</td><td>45.241296</td><td> cm<sup>-1</sup></td><td>5.609208</td><td>meV</td></tr><tr><td>27</td><td>168.238904</td><td> cm<sup>-1</sup></td><td>20.85897</td><td>meV</td></tr></table>

<p><code>POTIM</code>太大的时候，会搞出来超大号的虚频（$0.050$ 和 $0.100$）！</p>
<h4 id="3-4-3-时间"><a href="#3-4-3-时间" class="headerlink" title="3.4.3 时间"></a>3.4.3 时间</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">POTIM</th>
<th style="text-align:left">Time</th>
<th style="text-align:left">Unit</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">1530.591</td>
<td style="text-align:left">s</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">2065.911</td>
<td style="text-align:left">s</td>
</tr>
<tr>
<td style="text-align:left">15</td>
<td style="text-align:left">3845.977</td>
<td style="text-align:left">s</td>
</tr>
<tr>
<td style="text-align:left">20</td>
<td style="text-align:left">4298.571</td>
<td style="text-align:left">s</td>
</tr>
<tr>
<td style="text-align:left">50</td>
<td style="text-align:left">4829.897</td>
<td style="text-align:left">s</td>
</tr>
<tr>
<td style="text-align:left">100</td>
<td style="text-align:left">5191.23</td>
<td style="text-align:left">s</td>
</tr>
</tbody>
</table>
</div>
<p><code>POTIM</code> 越小，单个离子步收敛的越快，也就是需要更少的电子步！</p>
<p>综合前面的三个因素：<code>POTIM</code>太小或者太大都不好， <code>POTIM = 0.015</code>或者<code>0.020</code> 是很好的选择。 <code>0.015</code>是默认值。</p>
<hr>
<h3 id="3-5-POINTS"><a href="#3-5-POINTS" class="headerlink" title="3.5 POINTS"></a>3.5 POINTS</h3><p>这里用 $1$, $2$, $3$ 来分别代表 $1 \times 1 \times 1$， $2 \times 2 \times 2$ 和 $3 \times 3  \times 3$ 的 K 点。</p>
<h4 id="3-5-1-零点能："><a href="#3-5-1-零点能：" class="headerlink" title="3.5.1 零点能："></a>3.5.1 零点能：</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">KPOINTS</th>
<th style="text-align:left">ZPE</th>
<th style="text-align:left">Unit</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">2.11698</td>
<td style="text-align:left">eV</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">2.11678</td>
<td style="text-align:left">eV</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">2.11689</td>
<td style="text-align:left">eV</td>
</tr>
</tbody>
</table>
</div>
<h4 id="3-5-2-虚频："><a href="#3-5-2-虚频：" class="headerlink" title="3.5.2 虚频："></a>3.5.2 虚频：</h4><table><tr><th>KPOINTS</th><th>Nth</th><th>Wavenumber</th><th>Unit</th><th>Energy</th><th>Unit</th></tr><tr><td rowspan="3">1</td><td>25</td><td>6.132037</td><td> cm<sup>-1</sup></td><td>0.76028</td><td>meV</td></tr><tr><td>26</td><td>18.62878</td><td> cm<sup>-1</sup></td><td>2.30968</td><td>meV</td></tr><tr><td>27</td><td>65.657693</td><td> cm<sup>-1</sup></td><td>8.14052</td><td>meV</td></tr><tr><td rowspan="3">2</td><td>25</td><td>5.726298</td><td> cm<sup>-1</sup></td><td>0.70997</td><td>meV</td></tr><tr><td>26</td><td>19.193163</td><td> cm<sup>-1</sup></td><td>2.37965</td><td>meV</td></tr><tr><td>27</td><td>64.645347</td><td> cm<sup>-1</sup></td><td>8.015</td><td>meV</td></tr><tr><td rowspan="3">3</td><td>25</td><td>4.826986</td><td> cm<sup>-1</sup></td><td>0.59847</td><td>meV</td></tr><tr><td>26</td><td>19.138554</td><td> cm<sup>-1</sup></td><td>2.37288</td><td>meV</td></tr><tr><td>27</td><td>64.83042</td><td> cm<sup>-1</sup></td><td>8.03795</td><td>meV</td></tr></table>

<h4 id="3-5-3-时间"><a href="#3-5-3-时间" class="headerlink" title="3.5.3 时间"></a>3.5.3 时间</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">KPOINTS</th>
<th style="text-align:left">Time</th>
<th style="text-align:left">Unit</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">4298.571</td>
<td style="text-align:left">s</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">8997.709</td>
<td style="text-align:left">s</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">13480.847</td>
<td style="text-align:left">s</td>
</tr>
</tbody>
</table>
</div>
<p>综合前面三点： <code>Gamma</code>点足矣！</p>
<hr>
<h2 id="4-扩展阅读："><a href="#4-扩展阅读：" class="headerlink" title="4      扩展阅读："></a>4      扩展阅读：</h2><p>4.1 下载本节的练习，按照本节的顺序操作分析；</p>
<p>4.2 阅读 <strong>VASP</strong> 官网中关于原子和分子的例子，去尝试回答里面的问题；</p>
<p><a href="https://cms.mpi.univie.ac.at/wiki/index.php/Atoms_and_Molecules">https://cms.mpi.univie.ac.at/wiki/index.php/Atoms_and_Molecules</a></p>
<h2 id="5-总结："><a href="#5-总结：" class="headerlink" title="5. 总结："></a>5. 总结：</h2><p>分析完前面的测试，我们总结一下高效频率计算的关键点：</p>
<p>5.1 <code>IBRION = 5</code>  （告诉 <strong>VASP</strong> 我们要算频率）</p>
<p>5.2 <code>POTIM = 0.015</code></p>
<p>5.3 <code>NFREE = 2</code></p>
<p>5.4 <code>ENCUT</code>和原来一样</p>
<p>5.5 <code>PREC = Normal</code></p>
<p>5.6 <code>EDIFF = 1E-5</code> 或者 <code>1E-6</code></p>
<p>5.7 <code>KPOINTS</code>  <code>Gamma</code>点即可。</p>
<p>本节内容太多了，原因在于，这是菜鸟篇的最后一节！！！</p>
<p>大师兄本人亲自做了很多测试，原因只有一个，告诉大家如何把握计算结果与时间的关系。在最短的时间获取最多的有价值的结果，这是计算化学的一个精髓所在。体现了你对时间和生命的尊重，也体现了你对高效率生活的追求。在菜鸟的时候，可以尽情地去测试。</p>
<p>大师兄之所以用乙醇这个大分子去给大家展示，很多人直接用 $\rm{O_2}$，$\rm{CO}$ 或者水分子的计算作为例子。那样的简单例子不具有很强的代表性，当你把一个相对复杂的东西搞明白了，这些小分子的计算，就如同小儿科一般了。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>乙醇</tag>
        <tag>振动频率</tag>
        <tag>时间</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex32 Bulk的单点计算（Fe 单胞）</title>
    <url>/2018/02/01/ex32/</url>
    <content><![CDATA[<p>我们学习完了气相分子的相关计算后，下一步就是块体计算了，这也是VASP的强项所在，但块体的计算与气体分子的非常类似，如果前面掌握好了，后面的计算对你来说也就是轻而易举的事情了。</p>
<p>本着从简入繁的原则，我们先学习Bulk的单点计算（以Fe的单胞为例），姑且称之为本书中级篇的开始。大家需要学习并初步了解Material Studio和VESTA这两款软件。</p>
<ul>
<li><p>Material Studio下载链接：<a href="http://pan.baidu.com/s/1i5or3ZR">http://pan.baidu.com/s/1i5or3ZR</a>   对于这款软件怎么安装，大师兄就不指导了，网上全是相关的资料。本节默认大家已经安装好MS软件，并且可以打开界面。</p>
</li>
<li><p>VESTA下载官网：<a href="http://jp-minerals.org/vesta/en/download.html">http://jp-minerals.org/vesta/en/download.html</a> 只在官网下载，网上乱七八糟的版本不要去管！VESTA 下载后解压，直接打开就可以用了。注意：很多人问VESTA的使用说明，官网有，网上也有很多相关资料！大家耐着性子多练一天就能摸索个差不多了。</p>
</li>
</ul>
<h2 id="1-模型"><a href="#1-模型" class="headerlink" title="1 模型"></a>1 模型</h2><p> 1.1 课题的第一个难点</p>
<p>模型的选择，计算的准确性，以及结果分析的合理性，是一个课题是否成功的三个最主要的因素。Bulk的计算很简单，难点在于Bulk模型的获取。这也是一个课题最难的部分之一。很多人在计算的时候，模型不对，基本上这个课题就被一棍子打死了。这里大师兄提醒大家的是：模型，模型，模型！！！在进入计算的时候，一定要确保模型的合理性与正确性。这是计算中的第一个坎！</p>
<p>1.2 MS搭建Fe单胞的模型</p>
<p>A) 左上角<code>file</code>—&gt; <code>newproject</code>，输入Fe，点OK;</p>
<p>B) <code>file</code>—&gt; <code>import</code>—&gt; <code>Structures</code>—&gt;<code>metals</code>—&gt;<code>pure-metals</code>—&gt;找到Fe，选择打开即可;</p>
<p>C) <code>file</code>—&gt;<code>export</code>—&gt;选择cif格式 （此时导出的是Fe的单胞，conventional cell）</p>
<p>1.3 MS导出Fe原胞的模型：</p>
<p>A)和B)步骤与前面一样，</p>
<p>C) <code>Build</code> —&gt; <code>Symmetry</code>—&gt; <code>选择primitive cell</code></p>
<p>D) <code>file</code>—&gt;<code>export</code>—&gt;选择cif格式 （此时导出的是Fe的原胞，primitive cell）</p>
<p>1.4 VESTA 转换成VASP的格式</p>
<p>a) 打开VESTA软件，<code>file</code>—&gt;<code>open</code>—&gt;选择之前保存的cif文件</p>
<p>b) <code>file</code>—&gt; <code>export data</code> —&gt;保存类型选择VASP</p>
<p>c) 将保存的文件重新命名成<code>POSCAR</code>即可</p>
<p>1.5 需要掌握的知识：</p>
<p>a) 晶体学相关的基本知识，什么是primitive cell，什么是conventional cell?</p>
<p>b) MS和VESTA的基本操作</p>
<p>1.6 需要注意的部分（其他转换方法）：</p>
<p>a）可以使用<code>openbabel</code>转换：<a href="http://openbabel.org/wiki/Main_Page">http://openbabel.org/wiki/Main_Page</a></p>
<p>b）可以使用MS生成的.cell文件转化，可以根据POSCAR的格式手动复制，也可以通过脚本。</p>
<p>c）或者通过其他脚本进行转化,例如：<a href="http://theory.cm.utexas.edu/vasp/scripts.html">VTST</a>中的cif2pos.pl。<a href="http://theory.cm.utexas.edu/vasp/scripts.html">http://theory.cm.utexas.edu/vasp/scripts.html</a></p>
<p>d) 使用<a href="https://wiki.fysik.dtu.dk/ase/">ASE</a>: Atomic Simulation Environment的缩写。</p>
<h2 id="2-VASP计算文件的准备"><a href="#2-VASP计算文件的准备" class="headerlink" title="2 VASP计算文件的准备"></a>2 VASP计算文件的准备</h2><p> <strong>2.1 准备好INCAR文件：</strong></p>
<p>A）Fe带有磁性，ISPIN和MAGMOM需要设置</p>
<p>B）Fe是金属， ISMEAR=1， SIGMA=0.1</p>
<p>C）ENCUT=450， 统一起来，后面可能还需要计算其他元素，450是一个很安全的选择。</p>
<p>D）EDIFF控制电子步收敛的精度</p>
<p><img src="/2018/02/01/ex32/ex32-1.jpeg" alt=""></p>
<p><strong>2.2 准备KPOINTS文件：</strong></p>
<p>以单胞为例： a=b=c=2.8664 $\AA$，根据前面的经验，我们可以设置$11\times11\times11$的KPOINTS（Gamma）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">K-POINTS</span><br><span class="line"> 0</span><br><span class="line">Gamma</span><br><span class="line">  11 11 11</span><br><span class="line">  0 0 0</span><br></pre></td></tr></table></figure>
<p> <img src="/2018/02/01/ex32/ex32-2.jpeg" alt=""></p>
<p>2.3 准备好与POSCAR对应的POTCAR文件，提交任务的脚本</p>
<h2 id="3-提交任务"><a href="#3-提交任务" class="headerlink" title="3 提交任务"></a>3 提交任务</h2><p>3.1 提交任务之前，再次检查一遍我们的所有输入文件，确保无误；</p>
<p>3.2 提交任务进行计算；</p>
<p>3.3 大师兄的计算已经压缩放到百度网盘了，大家计算完毕后，与大师兄的进行对比。</p>
<p>链接：<a href="http://pan.baidu.com/s/1eRQHaX8">http://pan.baidu.com/s/1eRQHaX8</a></p>
<h2 id="4-扩展练习"><a href="#4-扩展练习" class="headerlink" title="4 扩展练习"></a>4 扩展练习</h2><p>4.1 分析Fe体相的磁矩，并查找实验值；</p>
<p>4.2 复习之前O$_2$分子的相关计算，分析实验结果；</p>
<p>4.3 怎么在OUTCAR中查看磁矩等相关信息； （VASP 哪一个参数？）</p>
<p>4.4 复习晶体学的相关知识；</p>
<p>4.5 学会MS，VESTA的基本练习；</p>
<p>4.6 掌握2种以上通过MS获取POSCAR的方法。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>本节的计算我们需要掌握一定的晶体学基础知识，基本的MS和VESTA操作，计算过程和O$_2$分子的例子极为相似，大家在学习的时候，可以将这两部分相互结合。本节我们采用的Fe单胞的例子，计算本身不难。难点在于自己课题中模型的选取。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>Bulk</tag>
        <tag>单胞</tag>
        <tag>原胞</tag>
        <tag>单点</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex33 晶格参数的确定（Birch-Murnaghan状态方程-1）</title>
    <url>/2018/02/02/ex33/</url>
    <content><![CDATA[<p>O$_2$分子的计算中，我们知道了，单纯从数据库中获取的结构，只能作为一个合理的初始值，与计算所得到的理论结构还有一定的差距，因此我们需要对该结构进行优化才可以获取稳定的晶格参数信息。有两个方法可以实现：</p>
<ul>
<li>1 Birch-Murnaghan状态方程拟合, </li>
<li>2 VASP计算中通过调节ISIF参数直接优化Bulk。</li>
</ul>
<p>下面两节我们先讨论一下第一个方法：BM方程拟合。</p>
<h2 id="1-什么是Birch-Murnaghan方程？"><a href="#1-什么是Birch-Murnaghan方程？" class="headerlink" title="1 什么是Birch-Murnaghan方程？"></a>1 什么是Birch-Murnaghan方程？</h2><p>BM方程为块体材料的体积随着外压变化的状态方程。大师兄参考了维基百科的说明，大家下载维基百科导出的PDF文件参考。在学习下面的内容前，请务必阅读这个文件，了解什么是Birch-Murnaghan方程。下载：<a href="http://pan.baidu.com/s/1bUSYbs">http://pan.baidu.com/s/1bUSYbs</a> </p>
<p><img src="/2018/02/02/ex33/ex33-1.jpeg" alt=""></p>
<p><img src="/2018/02/02/ex33/ex33-2.jpeg" alt=""></p>
<h2 id="2-如何通过BM方程获取晶格参数？"><a href="#2-如何通过BM方程获取晶格参数？" class="headerlink" title="2 如何通过BM方程获取晶格参数？"></a>2 如何通过BM方程获取晶格参数？</h2><p>首先，我们将BM方程中的体积转化为晶格参数（a）的函数：</p>
<p><img src="/2018/02/02/ex33/ex33-3.jpeg" alt=""></p>
<p>其中E(a)和E$_0$是晶格参数为a和a$_0$时bulk的能量，B$_0$，B$_0$’和V$_0$这些见BM方程的维基百科介绍。令$(1/a)^2 = x$，上图中的BM方程可以写成：</p>
<p> $y(x) = c_0 + c_1x + c_2x^2+c_3x^3 $ 的形式，</p>
<p>E$_0$, B$_0$,B$_0$’和V$_0$等写进c$_0$,c$_1$,c$_2$,和c$_3$这些常数里面，它们的具体形式此时并不重要，我们需要做的就是拟合这样的曲线去寻找使y(x)为最小值时的x取值。对y(x)这个方程求导数，dy(x)/dx = 0 的时候，便可以获取能量最低时的x值了，再由$(1/a)^2 = x$ 获得晶格参数。</p>
<p> dy(x)/dx = c$_1$+ 2c$_2$x + 3c$_3$x$^2$</p>
<p>令：dy(x)/dx = 0，即 c$_1$+ 2c$_2$x + 3c$_3$x$^2$ = 0</p>
<p>这是一个典型的二项式方程，求解很容易。</p>
<script type="math/tex; mode=display">
x = \frac{-2c_2\pm\sqrt{(2c_2)^2 - 4\times3C_3\times C_1}}{2\times3C_3}</script><p>x有两个值，其中负值被舍弃掉，最终：</p>
<script type="math/tex; mode=display">
x = \frac{-2c_2 + \sqrt{(2c_2)^2 - 4\times3C_3\times C_1}}{2\times3C_3}</script><h2 id="3-获取拟合的数据："><a href="#3-获取拟合的数据：" class="headerlink" title="3 获取拟合的数据："></a>3 获取拟合的数据：</h2><p>经过前面的分析，我们需要的就是获得的c$_1$，c$_2$ 和c$_3$值。可以设置一系列不同的晶格常数进行计算，得到对应的能量，然后将这些数据带入下面的方程中：$y(x) = c_0 + c_1x + c_2x^2+c_3x^3 $进行拟合。本节我们主要讨论一下如何进行该计算。看到这里，你第一反应是我们之前测试K点或者SIGMA值时的那些Linux批量操作。是的，我们也需要进行一个批量操作的计算。</p>
<p>3.1 分数坐标</p>
<p>如果我们改变了晶格常数，那么Fe原子的坐标也要发生相应的变化。此时，用分数坐标更加方便，VESTA中在cif转VASP格式的时候，会提醒你选择哪个形式的坐标，我们选择分数坐标：</p>
<p><img src="/2018/02/02/ex33/ex33-6.jpeg" alt=""></p>
<p>POSCAR如下图：</p>
<p><img src="/2018/02/02/ex33/ex33-7.jpeg" alt=""></p>
<p>注意：</p>
<p> 如果前面练习中，导出的为笛卡尔坐标形式的，你有两个选择：</p>
<p>A）重新按照前面的步骤，用VESTA导出为分数坐标形式；</p>
<p>B）将单点计算的结果直接复制过来（<code>cp  CONTCAR  POSCAR</code>），因为VASP的输出坐标为分数坐标形式，单点计算中，晶胞原子都没有动，CONTCAR可以直接使用。复制过来的POSCAR如下：</p>
<p><img src="/2018/02/02/ex33/ex33-8.jpeg" alt=""></p>
<p>3.2 获得分数坐标的POSCAR后，我们可以批量对晶格常数a,b,c进行批量操作，也可以对缩放系数进行批量操作，而原子的坐标不用去管。</p>
<p>3.3 本练习对缩放系数进行批量操作</p>
<p>我们取10个点，将1.0 替换成0.95, 0.96, 0.97, 0.98, 0.99, 1.01, 1.02, 1.03, 1.04, 1.05。此时，晶格常数为：<code>缩放系数</code>*<code>2.8664</code>.（记住，下一节用得到）</p>
<p>a) 准备缩放系数为1.0 的计算文件夹，命名为1.00，里面包含我们前面一节已经讲过的Bulk单点计算相关文件；</p>
<p>b) </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> 0.95 0.96 0.97 0.98 0.99 1.01 1.02 1.03 1.04 1.05; <span class="keyword">do</span> cp 1.00 <span class="variable">$i</span> ; sed -i <span class="string">&quot;2s/1.0/<span class="variable">$i</span>/g&quot;</span> <span class="variable">$i</span>/POSCAR ; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>注意：这里大师兄在自己电脑的<code>~/.bashrc</code>文件里面设置了：<code>alias cp=&#39;cp -r&#39;</code></p>
<p>思考： sed 命令后面用的是双引号（为什么？）如果这里看不懂的话，建议从Ex00开始学习。</p>
<p>d.) 批量提交命令： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> *; <span class="keyword">do</span> <span class="built_in">cd</span> <span class="variable">$i</span>; qsub sub4; <span class="built_in">cd</span> <span class="variable">$OLDPWD</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>其中，qsub sub4 是大师兄提交单个任务的命令。</p>
<p>3.4 数据提取：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> *; <span class="keyword">do</span> <span class="built_in">echo</span> -e <span class="variable">$i</span> <span class="string">&quot;\t&quot;</span> $(grep <span class="string">&#x27;  without&#x27;</span> <span class="variable">$i</span>/OUTCAR | tail -n 1| awk <span class="string">&#x27;&#123;print $7&#125;&#x27;</span>);  <span class="keyword">done</span> &gt; data</span><br></pre></td></tr></table></figure>
<p><img src="/2018/02/02/ex33/ex33-9.jpeg" alt=""></p>
<p>3.5 以上计算文件以及相关的命令已经上传到QQ群文件和百度网盘了，大家对比下计算结果。 <a href="http://pan.baidu.com/s/1dEJr9rb">http://pan.baidu.com/s/1dEJr9rb</a> </p>
<h2 id="4-扩展练习"><a href="#4-扩展练习" class="headerlink" title="4 扩展练习"></a>4 扩展练习</h2><p>4.1 完成本练习中的相关操作，并学习VASP官网批量操作的例子：</p>
<p><a href="https://cms.mpi.univie.ac.at/wiki/index.php/Fcc_Si">https://cms.mpi.univie.ac.at/wiki/index.php/Fcc_Si</a></p>
<p>注意：FCC Si的例子用的原胞，并且该网址最后图中曲线不是二次方程！！！虽然用二次方程拟合出来的结果差不多。</p>
<p>4.2 探索学习曲线拟合的方法；</p>
<p>4.3 学习并了解BM方程以及如何拟合，如何通过BM方程获取稳定的晶格参数；</p>
<p>4.4 对晶格参数进行批量操作，并计算。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>本节从BM方程开始，简单介绍了什么是BM方程，如何通过BM方程获取稳定晶胞对应的晶格参数，最后，又复习了一下本书前面几节的批量操作，下一节我们讲解一下如何通过python脚本对BM方程拟合。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>Bulk</tag>
        <tag>单胞</tag>
        <tag>BM方程</tag>
        <tag>批量</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex34 晶格参数的确定（Birch-Murnaghan状态方程-2）</title>
    <url>/2018/02/03/ex34/</url>
    <content><![CDATA[<p>前面一节，我们通过批量操作，获得了拟合BM方程的数据。这一节，我们通过这些数据，使用脚本进行拟合并获取Fe单胞的晶格参数。 本节的脚本和读取的数据文件，可在QQ群文件和百度网盘中下载，见底部。 </p>
<h2 id="1-脚本使用方法："><a href="#1-脚本使用方法：" class="headerlink" title="1 脚本使用方法："></a>1 脚本使用方法：</h2><p>在介绍脚本之前，先介绍一下脚本的使用方法：</p>
<p>首先：将前面一节得到的 data 文件和脚本放在一个目录下</p>
<p>其次：进入该目录，运行脚本的命令为（见下图）： </p>
<p>python   bm0.py </p>
<p>注意： bm0.py 为脚本名，你也可以随意写成 birch,  birch.py等。</p>
<p><img src="/2018/02/03/ex34/ex34-1.jpeg" alt=""></p>
<p>通过脚本，我们可以得到Fe单胞的晶格参数为： 2.8332 Å</p>
<h2 id="2-脚本的内容-1："><a href="#2-脚本的内容-1：" class="headerlink" title="2 脚本的内容-1："></a>2 脚本的内容-1：</h2><p>我们看一下bm0.py 这个脚本的内容：只有几行而已。大家先自己根据前面介绍的通过BM方程获得晶格参数的原理，阅读以下该脚本，看不懂不要紧，多看几遍。大体上了解是怎么回事。</p>
<p><img src="/2018/02/03/ex34/ex34-2.jpeg" alt=""></p>
<h2 id="3-脚本的内容-2："><a href="#3-脚本的内容-2：" class="headerlink" title="3 脚本的内容-2："></a>3 脚本的内容-2：</h2><p>前面的脚本没有任何的说明，阅读起来很是费力，大师兄把注释加上去了，并命名为: bm.py。大家再阅读一遍，看看有没有新的收获。</p>
<p><img src="/2018/02/03/ex34/ex34-3.jpeg" alt=""></p>
<p>图中的链接为：(左下角查看原文)</p>
<p><a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.polyfit.html">https://docs.scipy.org/doc/numpy/reference/generated/numpy.polyfit.html</a></p>
<p>该脚本运行效果如下图：</p>
<p><img src="/2018/02/03/ex34/ex34-4.jpeg" alt=""></p>
<p>脚本的工作原理下一节介绍，本节中大家只看脚本，分析里面的内容，自己结合前面一节琢磨是怎么回事。脚本和读取的data文件可以在QQ群中下载，也可以通过百度网盘，链接： <a href="http://pan.baidu.com/s/1o8cCdBG">http://pan.baidu.com/s/1o8cCdBG</a> </p>
<h2 id="4-扩展练习"><a href="#4-扩展练习" class="headerlink" title="4 扩展练习"></a>4 扩展练习</h2><p>4.1 查找文献，获取Fe的晶格常数的实验数据，与脚本获取的结果进行对比；</p>
<p>4.2 Windows用户使用notepad++或者其他文本编辑软件，自己将bm0.py脚本重新写一遍，然后运行，如果出错了，请与图中对比并修改，直至完美匹配为止！！！</p>
<p>4.3 Linux用户，使用vim或者其他文本编辑软件，进行4.2中的操作；</p>
<p>4.4 结合Ex33的介绍，初步了解本脚本的运行原理。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Bulk</tag>
        <tag>BM方程</tag>
        <tag>拟合</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex35 晶格参数的确定（Birch-Murnaghan状态方程-3）</title>
    <url>/2018/02/04/ex35/</url>
    <content><![CDATA[<p>通过上一节（Ex34）的脚本，我们可以拟合出稳定晶体结构的晶格参数，但是，这个脚本是怎么运行的呢？大家在浏览之后，有没有什么疑问？本节我们重点介绍一下：这个脚本的运行原理。</p>
<h2 id="1-数据"><a href="#1-数据" class="headerlink" title="1  数据"></a>1  数据</h2><p>首先我们看下读取的data文件：</p>
<p><img src="/2018/02/04/ex35/ex35-1.png" alt=""></p>
<p>A) 共两列，两列之间用<code>tab</code>分开；</p>
<p>B) 第一列为缩放系数，第二列为对应结构的能量。</p>
<p>C) 在本文例子中，晶格参数等于= <code>缩放系数</code> * <code>2.8664</code> $\AA$ （记住这个公式）</p>
<p>2  脚本内容： 浏览一遍即可，详解在下面： </p>
<p><img src="/2018/02/04/ex35/ex35-2.png" alt=""></p>
<p>详解：</p>
<p><strong>2.1  1-15行：准备部分</strong></p>
<p><img src="/2018/02/04/ex35/ex35-3.png" alt=""></p>
<p>A) 1-4 行为脚本的一些基本说明，为养成一个良好的写脚本习惯，以及避免后期不必要的麻烦，第一行必须要放进去。如果你用bash写的话，把python替换为bash即可，其他部分不用动，例如： #!/usr/bin/env bash。</p>
<p>B）2-3行注释，解释了一下脚本干什么用的，谁写的，怎么用。</p>
<p>C)  6-7 行调用python库中的math 和 numpy 模块，见下面两个链接：</p>
<p><a href="https://docs.python.org/2/library/math.html">https://docs.python.org/2/library/math.html</a></p>
<p><a href="http://www.numpy.org/">http://www.numpy.org/</a></p>
<p>D）9-15行：通过使用 print 命令输出一个警告，因为本文用的是缩放系数，很多人测试的时候保持缩放系数不变，直接采用不同的晶格参数。</p>
<p><strong>2.2  读取data信息，准备拟合</strong></p>
<p><img src="/2018/02/04/ex35/ex35-4.png" alt=""></p>
<p>A)  16-18行为脚本的注释说明，</p>
<p>B)  第20行中，我们使用 <code>np.loadtxt</code>读取data文件的内容，</p>
<p>注意：</p>
<p>1)  <code>data</code> 用单引号括起来，表明我们要读以<code>data</code>命名的文件。 </p>
<p>2)   <code>usecols=(0,1)</code> 代表我们要读取第一列和第二列的内容。Python中的第一个用0表示，所以这里我们用的（0,1）来表示读取第1和第2列的内容；</p>
<p>3)   <code>delimiter=&#39;\t&#39;</code>，意思是第一列和第二列之间用tab（’\t’）分开；</p>
<p>4)  <code>unpack=True</code> 意思是把读取的数据生成一个数列，并分配给a 和 E，具体见链接：</p>
<p><a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.loadtxt.html">https://docs.scipy.org/doc/numpy/reference/generated/numpy.loadtxt.html</a></p>
<p>通过第20行，我们可以获得两个数列，第一个是 a 包含了data文件中的缩放系数， 第二个是E，包含了data文件中的能量信息</p>
<p>C) 第22-28行，把缩放系数转换为晶格常数(a<em>2.8664)，然后平方取倒数（*</em>(-2)），用来得到我们前面讲解的x。这是因为：当我们把BM方程写成： $y(x) = c_0 + c_1x + c_2x^2+c_3x^3 $ 的形式时，前提是令 (1/a)$^2$ = x。不懂的具体见Ex33中的内容。截止到现在，我们有了三个数列： a, E 和 x</p>
<p><strong>2.3 第29-40行：拟合多项式方程</strong>： </p>
<p><img src="/2018/02/04/ex35/ex35-5.png" alt=""></p>
<p>A) 最小二乘法拟合 $y(x) = c_0 + c_1x + c_2x^2+c_3x^3 $这个方程，得到常数系列c，这里我们调用了<code>numpy</code> 的<code>polyfit</code>这个模块来进行拟合。具体见：</p>
<p><a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.polyfit.html">https://docs.scipy.org/doc/numpy/reference/generated/numpy.polyfit.html</a></p>
<p>B) 第31行：本脚本的核心：<code>p = np.polyfit(x, E, 3)</code></p>
<p>1) np.polyfit 读取x和 E的数值，拟合一个$y(x) = c_0 + c_1x + c_2x^2+c_3x^3 $，</p>
<p>注意：这里拟合的时候，用的数值是x和E，(1/a)$^2$ = x， 所以，在进行拟合之前，务必确保你已经得到了正确的x数列。具体根据data文件的内容进行修改设置第24行的公式。</p>
<p>2) 括号中的3代表的是多项式方程中最大的那个次数。</p>
<p>扩展：如果你想拟合一个$ y = c_4x^4 +c_3x^4  …$的方程，把3改成4 即可。</p>
<p>3)拟合的结果输出到数列 p 中，数列p中共有4个常数（p[0],  p[1]，p[2]，p[3]），按照次数从高到底的顺序排列，对应着我们Ex33中的（c3，c2, c1, 和 c0 ）</p>
<p>4) 33-36行, 我们将p 中的数值分别分配给c3，c2, c1, 和 c0。</p>
<p><strong>2.4   38-40行，获取晶格参数</strong>：</p>
<p>到目前位置，多项式方程的常数我们已经获得了，下面就是求解问题了。</p>
<p><img src="/2018/02/04/ex35/ex35-6.png" alt=""></p>
<p>A)  第42行为下图中公式的代码描述，获取方程的解x，因为前面我们已经有了一个x变量了，这里方程的解用x1表示，</p>
<script type="math/tex; mode=display">
x x = \frac{-2c_2 + \sqrt{(2c_2)^2 - 4\times3C_3\times C_1}}{2\times3C_3}</script><p>B) 第43行获取晶格常数，公式为： (1/a)$^2$= x</p>
<p>C) 第45行，输出晶格常数的数值。</p>
<h2 id="3-扩展练习："><a href="#3-扩展练习：" class="headerlink" title="3 扩展练习："></a>3 扩展练习：</h2><p>3.1 根据解释，重新浏览脚本，知道每一行代表的含义。</p>
<p>3.2 本脚本使用的时候，需要自己根据data数列中的内容，设置更改一下获取 x 数列的公式（第24行）；</p>
<p>3.3 阅读Ex32-本节的所有内容，整个流程不要再存在什么疑问。</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>本节我们详细讲解了BM方程拟合脚本，相信大家应该了解的差不多了，拟合的办法有很多，但BM方程只有一个。请务必掌握至少一个拟合的方法。后面的这句话本来想删掉，因为本人已经早就毕业了。暂且留下来吧，权当本书的一个时间证据。</p>
<hr>
<p>此外，本人马上就要毕业答辩了，后面更新会有所放缓，努力争取保证每周一篇的速度。如果你有什么科研心得，欢迎分享。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Bulk</tag>
        <tag>BM方程</tag>
        <tag>拟合</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex36 晶格参数的确定（直接优化晶格常数）</title>
    <url>/2018/02/05/ex36/</url>
    <content><![CDATA[<p>前面一节我们学习了如何通过提交一系列不同晶格常数的单点计算以及拟合BM方程获取稳定结构的方法，此外，我们还学习了BM方程拟合的一个python脚本以及分析了脚本的工作流程。</p>
<p>师兄，算个晶格常数这也太麻烦了吧？有没有简单点的，一步到位的方法？</p>
<p>有！！！前面我们提到说可以通过两个方法： BM方程拟合是一个，现在大家已经掌握了。今天我们学习第二个方法。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">ISIF = <span class="number">3</span></span><br><span class="line">ENCUT = XXX</span><br></pre></td></tr></table></figure>
<h2 id="1-ISIF-参数"><a href="#1-ISIF-参数" class="headerlink" title="1  ISIF 参数"></a>1  ISIF 参数</h2><p>在学习ISIF = 3 前，我们先总结一下，之前不论是单点计算，结构优化，还是频率分析，我们都没有讲过这个参数。因此使用的是默认值。</p>
<p><img src="/2018/02/05/ex36/ex36-1.png" alt=""></p>
<p>查找VASP官网说明书，默认值是ISIF= 2 。是的，前面我们都是用的 ISIF = 2 。（废话，等于白说！）你还会发现有一堆其他的ISIF参数，从1 - 7，看的眼花缭乱。</p>
<p><img src="/2018/02/05/ex36/ex36-2.png" alt=""></p>
<p>坚持一下，你会发现它们有各自的特点，原子坐标是否变化，晶胞形状是否改变，以及晶胞体系是够变化。不同的参数大家根据自己研究体系的性质进行选取。</p>
<p>本文主要介绍ISIF = 3 时对晶胞的优化。其他的取值比如加压计算等，为避免对大家造成误解，在这里不做进一步地说明。因为本人计算的时候，只用到过2 和 3 的情况。</p>
<p>ISIF = 3 的时候，晶胞中原子的坐标，晶胞形状，以及体系都随着优化的过程发生变化。 回到Fe单胞的计算，我们先看一下INCAR的输入，然后再详细解释其中的内容。</p>
<p><img src="/2018/02/05/ex36/ex36-3.png" alt=""></p>
<p>对比下，前面单点计算的INCAR，你会发现有几个不同：</p>
<p>1） ENCUT = 600 设置的比之前的450大。</p>
<p>2） EDIFFG = -0.015 结构优化的收敛标准</p>
<p>3） NSW = 100 结构优化，肯定不是一步！</p>
<p>4） ISIF = 3 （讲的就是ISF =3 ，肯定要加上）</p>
<p>5） 此外， ISMEAR，SIGMA, ISPIN以及 MAGMOM大家自己主动回顾一下</p>
<p>PS： 很多人在单点计算的时候，除了NSW = 0， 还画蛇添足地设置了ISIF = 0。虽然对计算结果没有影响，但我还是想问一句：大哥，脑子去哪里了？单点计算就是原子不动弹，设置NSW = 0 或者 1， 或者 IBRION = -1，其他的按照之前的即可。</p>
<p>POSCAR，KPOINTS，POTCAR直接将前面单点计算目录（1.00）下的复制过来。</p>
<h2 id="2-ENCUT-取值"><a href="#2-ENCUT-取值" class="headerlink" title="2 ENCUT 取值"></a>2 ENCUT 取值</h2><p>师兄，Fe的ENCUT 默认值是：ENMAX  =  267.882 eV， 前面单点计算设置的 450 eV。这里为什么设置成600 eV ？ </p>
<p>如果你仔细看VASP官网的说明书，在底部有这么一段话：</p>
<p><img src="/2018/02/05/ex36/ex36-4.png" alt=""></p>
<p>红色的链接如下：</p>
<p><a href="http://cms.mpi.univie.ac.at/vasp/vasp/Volume_vs_energy_volume_relaxations_Pulay_Stress.html">http://cms.mpi.univie.ac.at/vasp/vasp/Volume_vs_energy_volume_relaxations_Pulay_Stress.html</a>   </p>
<p>最后一句，如果计算时体积发生了变化，我们需要增加ENCUT的值，比如说：ENCUT = 1.3 * max(ENMAX) ， max(ENMAX) 的意思是，如果有N个元素，取最大元素的ENMAX值。</p>
<p>这么做的原因是为了尽可能地消除 Pulay stress 对计算的影响。那么什么是Pulay Stress 呢？</p>
<h3 id="3-Pulay-Stress"><a href="#3-Pulay-Stress" class="headerlink" title="3 Pulay Stress"></a>3 Pulay Stress</h3><p><img src="/2018/02/05/ex36/ex36-5.png" alt=""></p>
<p>通过查看红色的链接内容，字面上的理解就是，当晶胞体积发生变化时，由于计算时的平面波基组不全（设置的ENCUT不够大）使得计算时的收敛不是绝对的，进而导致应力张量不对，最终导致体系的形状，体积以及能量不正确。（这个我不是很懂，字面上直译过来的。）维基百科的描述如下，链接：<a href="https://en.wikipedia.org/wiki/Pulay_Stress">https://en.wikipedia.org/wiki/Pulay_Stress</a></p>
<p><img src="/2018/02/05/ex36/ex36-6.png" alt=""></p>
<p>A plane wave basis set is created for thehexagonal lattice (left), using the reciprocal lattice vectors inside the redcircle. Then the lattice relaxes into a cubic symmetry (right). Keeping the redcircle basis constant results in lattice vectors taken from an ellipsoidinstead of a spherical area (compare to the blue circle).</p>
<p>深层次的俺也不懂，但是PulayStess 有2个办法可以减小： </p>
<p>A)  体积不变，采用一系列的晶格常数计算，然后拟合得到准确的晶格常数；（你已经知道怎么去做了，这么做是为了避免计算时晶格体积发生变化！）；</p>
<p>注意： </p>
<p>1） 在LVASPTHW的拟合流程中，拟合出来的是BM方程， BM方程的最高次数是3，也就是x的三次方。此时：x = (1/a$^2$)  ，具体见Ex32-35的详细说明。</p>
<p>2) 如果直接用晶格常数去拟合，则是6次方的关系。</p>
<p><img src="/2018/02/05/ex36/ex36-8.png" alt=""></p>
<p>3) 如果你用体积去拟合BM方程的话，最高次数是2：</p>
<p><img src="/2018/02/05/ex36/ex36-9.png" alt=""></p>
<p>B)  既然是因为ENCUT不够导致的，那么我就使劲增加ENCUT来消除（上图中unless后面的那句）。借用维基百科的一句话：Pulay stress can be reduced by increasing the energy cutoff. 所以，当有人用ISIF= 3计算，而不去设置ENCUT的时候，尽情地去嘲笑他傻X吧！！！感觉不过瘾，还可以继续吓唬他说后面的计算也有问题。</p>
<h2 id="4-ENCUT-取值"><a href="#4-ENCUT-取值" class="headerlink" title="4 ENCUT 取值"></a>4 ENCUT 取值</h2><p>官网说设置到130% * max(ENMAX)，一般来说就可以了。但很多人还是不放心，那我们就继续疯狂一些，设置到600 或者700。本人一般习惯用600。</p>
<p>师兄，前面你不是讲到增加ENCUT会增加计算量么？而且要保持计算中使用同一个计算的参数？</p>
<p>是的，这些你说的都是正确的。但是，我们使用ISIF = 3 的目的是获取稳定的晶格常数，但为了避免Pulay stress导致的误差，就必须要增加ENCUT（No Choice！！！）。一旦我们计算完成晶格常数的计算后，可以在此结果基础上，统一使用其他的ENCUT值进行计算。也就是只有确定晶格常数的这一步是个例外，其他情况还是用原来的值。</p>
<p><img src="/2018/02/05/ex36/ex36-10.jpeg" alt=""></p>
<p>举个不恰当的例子，这就好比当初你追女朋友的时候，为讨人家欢心，疯狂地买买买，什么要求都答应。等追到手了，结婚了，新鲜劲过去了，就原形毕露，不再这么大手大脚地去疯狂了。 </p>
<p><img src="/2018/02/05/ex36/ex36-11.jpeg" alt=""></p>
<p>讲到这里，使用ISIF = 3 时，你脑子第一反应就是疯狂地增加ENCUT，600不够，上700， 700感觉不够，上800，在计算承受的范围之内，越大越好！ 因此ISIF = 3 和 ENCUT两个参数必须同时出现。</p>
<h2 id="5-计算结果"><a href="#5-计算结果" class="headerlink" title="5  计算结果"></a>5  计算结果</h2><p>设置完后，提交任务：计算出来的Fe晶格参数为： 2.8318 Å，对比下前面拟合出来的结果： 2.8332 Å，两者相差：0.0014 / 2.8332 = 0.019 %， 这么点误差，完全可以忽略掉了。如果不放心，将ISIF =3 的结果，使用前面的设置，算个单点，然后跟BM拟合结果对比下，两者能量相差甚微，完全可以忽略。 </p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Methods</th>
<th>Lattice Constant</th>
<th style="text-align:left">Energy</th>
</tr>
</thead>
<tbody>
<tr>
<td>BM拟合</td>
<td>2.8332 $\AA$</td>
<td style="text-align:left">-16.47179683 eV</td>
</tr>
<tr>
<td>直接优化（ISIF=3，ENCUT=600）</td>
<td>2.8318 $\AA $</td>
<td style="text-align:left">-16.47181669 eV</td>
</tr>
</tbody>
</table>
</div>
<h2 id="6-总结："><a href="#6-总结：" class="headerlink" title="6 总结："></a>6 总结：</h2><p>学习完本节，怎么计算晶格常数的两个方法你应该都掌握了，希望大家能学到的东西有以下几个：</p>
<p>1 什么是BM方程？</p>
<p>2 BM方程拟合的方法（最小二乘法，脚本以及运行）；</p>
<p>3 BM方程获取晶格常数的原理；</p>
<p>4 ISIF = 3 和 ENCUT 必须同时设置；</p>
<p>5 Pulay Stress 是什么，如何避免； </p>
<p>6 （ISPIN，MAGMOM）：什么时候加，怎么设置；</p>
<p>7 （ISMEAR，SIMGA）：什么体系用什么值，怎么设置；</p>
<p>8 （IBRION，POTIM，NSW）：根据初始结构好坏进行设置；</p>
<p>9 （EDIFF，EDIFFG）：怎么决定收敛的；</p>
<p>10  KPOINTS的取值：经验方法（k * a）， 以及脚本；</p>
<p>11  POTCAR的生成： 手动方法以及脚本。</p>
<p>12  以及怎么追女朋友，如何防止被追？</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Bulk</tag>
        <tag>BM方程</tag>
        <tag>拟合</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex-37 DOS 计算(一)</title>
    <url>/2018/02/06/ex37/</url>
    <content><![CDATA[<p>使用VASP计算，很多时候都逃不掉DOS，能带计算的相关问题，尤其是对于计算材料的童鞋们，更是家常便饭一般。群里很多人，很多新手们都时常在讨论DOS的计算。这里我们通过VASP官网的说明，解释一下算DOS的具体步骤。前面我们学会了如何拟合或者优化稳定的晶胞结构。在此基础上，我们可以计算一下相关的DOS信息。</p>
<h2 id="1-KPOINTS"><a href="#1-KPOINTS" class="headerlink" title="1 KPOINTS"></a>1 KPOINTS</h2><p> <strong>1.1 K点数目</strong></p>
<p>与结构优化相比，算DOS的时候，需要用到更多的K点数目，这是因为K点越多，画出来的DOS图质量越高。</p>
<p>引用官网的话：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">A high quality DOS requires usually very fine k-meshes.</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>1.2 K点数目的选取</strong></p>
<p> K点数目越多越好，我们该如何设置K点数目呢？</p>
<p>还记的前面我们讲到的K点选择的经验规则吗？那一个规则可以认为是我们平时计算时K点选择的标配。对于DOS计算，我们就需要把配置提高一个档次了。</p>
<p><img src="/2018/02/06/ex37/ex37-1.png" alt=""> </p>
<p>一般来说，<code>K * a = 45</code>左右之间完全可以满足你的要求，大伙可以根据这个经验来选择K点。 </p>
<h2 id="2-NEDOS"><a href="#2-NEDOS" class="headerlink" title="2 NEDOS"></a>2 NEDOS</h2><p>NEDOS这个参数在DOS图的质量上面也有着很重要的作用。比如我们的DOS能量区间范围（DOS图的横坐标）为：[-10 eV，10eV]，VASP默认的将这个能量范围分成301点，然后作图。301也就是默认的NEDOS的取值。如果我们设置的NEDOS值够大，那么DOS区间就会被区分地越精确。NEDOS的取值一般来说：</p>
<ul>
<li><p><code>NEDOS = 3000</code>左右就足够好了。太大也没什么意义；</p>
</li>
<li><p>NEDOS越大，VASP输出的DOSCAR，vasprun.xml文件也就越大，占用存储空间。</p>
</li>
<li><p>经常有人抱怨说自己的DOS图有很多尖锐的峰，可以尝试着通过增加NEDOS这个办法来解决。</p>
</li>
<li><p>更多的信息，自己参考一下：<a href="https://cms.mpi.univie.ac.at/wiki/index.php/NEDOS">https://cms.mpi.univie.ac.at/wiki/index.php/NEDOS</a></p>
</li>
</ul>
<h2 id="3-ISMEAR（一）"><a href="#3-ISMEAR（一）" class="headerlink" title="3  ISMEAR（一）"></a>3  ISMEAR（一）</h2><p>首先我们看官网的话： <a href="https://cms.mpi.univie.ac.at/wiki/index.php/ISMEAR">https://cms.mpi.univie.ac.at/wiki/index.php/ISMEAR</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">For the calculation of the total energy in bulk materials we recommend thetetrahedron method with Blöchl corrections (ISMEAR=-5). This method also givesa smooth nice electronic density of states (DOS).</span><br></pre></td></tr></table></figure>
<p>也就是说 ISMEAR = -5 的时候（Blöchl修正的四面体方法），我们可以得到一个非常平滑的DOS图。</p>
<p><strong>注意：</strong></p>
<p>3.1 K点数目</p>
<p>设置<code>ISMEAR = -5</code> 的时候，如果K点数目K点的数目小于等于4 ， 计算会出错，得到如下的错误结果：</p>
<p> <strong>VERY BAD NEWS! internal error in subroutineIBZKPT:</strong></p>
<p> <strong>Tetrahedron method fails for NKPT&lt;4. NKPT=       1</strong></p>
<p>这也是很多人常见的错误。官网说的是K点数目小于三：the tetrahedron method is not applicable， if less than three k-points are used. （QQ群的<code>恒驰一强</code>发现官网的这个错误。）</p>
<p>K点不够，用<code>ISMEAR = -5</code>出错的解决办法：</p>
<ul>
<li><p>既然Ｋ点不够，那么我就增加Ｋ点，然后再使用<code>ISMEAR= -5</code>　（<strong>简单粗暴，强烈推荐使用</strong>）</p>
</li>
<li><p>如果增加了K点，可能还是会出错。有时也会出现下面的错误（微信群的群友（<strong>Cu—Ni</strong>）提供）。我们先把解决方法列出来，错误部分大家慢慢看：</p>
<ul>
<li>直接换一下ISMEAR的取值。</li>
<li>群友还发现：在保证K点数目大于4的时候，有时候减少K点数目或者增加K点数目都可以解决这个问题。如果你的服务器还算可以，建议增加K点数目，毕竟和K点数目越多，DOS的质量越高。这个办法大家可以参考一下。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WARNING: DENTET:can&#x27;t reach specified precision</span><br><span class="line">Number of Electronsis NELECT =</span><br></pre></td></tr></table></figure>
<p><img src="/2018/02/06/ex37/ex38-3.png" alt=""></p>
</li>
</ul>
<p>  <strong>官方的解释：</strong></p>
<p>  <a href="http://cms.mpi.univie.ac.at/vasp-forum/viewtopic.php?t=416">http://cms.mpi.univie.ac.at/vasp-forum/viewtopic.php?t=416</a></p>
<p>  <a href="http://www.error.wiki/The_old_and_the_new_charge_density_differ">http://www.error.wiki/The_old_and_the_new_charge_density_differ</a></p>
<p>  <img src="/2018/02/06/ex37/C:/Users/lqlhz/OneDrive/%E6%A1%8C%E9%9D%A2/ex37-41/ex38/ex38-4.png" alt=""></p>
<p>出现此警告(DENTET)的原因是因为无法通过tetrahedron方法得到足够精确的费米能级。也就是将态密度积分到费米面的电子数和体系的价电子数目不一致。</p>
<p>3.2 适用体系：</p>
<ul>
<li><p><code>ISMEAR = -5</code> 适用于所有体系的<strong>DOS计算</strong>。非DOS计算的时候：</p>
</li>
<li><p>对于金属体系来说，结构优化的时候不能使用<code>ISMEAR= -5</code>（注意：是<strong>优化结构的时候不能用</strong>！），这是因为四面体方法不能很好地处理费米能级处的电子占据情况，导致算出来的力会有一定百分比的误差。所以，对金属体系结构优化的时候，<code>ISMEAR &gt; = 0</code> 参考：<a href="https://cms.mpi.univie.ac.at/vasp/vasp/Partial_occupancies_different_methods.html">https://cms.mpi.univie.ac.at/vasp/vasp/Partial_occupancies_different_methods.html</a></p>
</li>
<li><p>对于半导体和绝缘体的体系，<code>ISMEAR&gt;0</code> 是不可以的。只能ISMEAR&lt;=0。</p>
</li>
<li><p>四面体方法（<code>ISMEAR = -5</code>）不适合计算能带（对所有的体系来说的）。多谢wuli8老师帮忙完善！</p>
</li>
<li>使用ISMEAR= -5 的时候，SIGMA的取值没有影响，如果不放心，取<code>SIGMA = 0.01</code>。</li>
</ul>
<p>3.3 小结：</p>
<ul>
<li>算DOS，只要K点不少于3； 用ISMEAR=-5是个不错的选择。</li>
</ul>
<h2 id="4-ISMEAR（二）"><a href="#4-ISMEAR（二）" class="headerlink" title="4 ISMEAR（二）"></a>4 ISMEAR（二）</h2><p>如果体系很大，只能适用gamma点来算，<code>ISMEAR = -5</code>的时候，肯定会出错，但服务器不给力，不能增加Ｋ点的时候，怎么办？</p>
<ul>
<li><p>对于所有的体系（K点数目小于4也可以）：可以使用<code>ISMEAR = 0</code>；<code>SIGMA = 0.01</code>。对于大部分的体系都能得到理想的结果。原则上来说，使用GS方法的时候(ISMEAR=0)，SIGMA的数值要测试下，保证<code>entropy T*S</code>这一项平均到每个原子上小于0.001 eV也就是1meV。不想测试的话，直接用个很小的值，比如这里我们说的：<code>SIGMA = 0.01</code>。</p>
<p><img src="/2018/02/06/ex37/C:/Users/lqlhz/OneDrive/%E6%A1%8C%E9%9D%A2/ex37-41/ex37/ex37-4.png" alt=""></p>
</li>
<li><p>对于金属体系来说，也可以使用<code>ISMEAR = 1</code>；<code>SIGMA = 0.01</code>。SIGMA取值太大，计算出来的能量可能不正确；SIGMA取值越小，计算越精确，需要的时间也就越多。值得注意的是：这里我们使用的0.01已经很小，没有必要设置的再小。因为对于金属体系，使用MP方法(ISMEAR=1..N)时，SIGMA= 0.10 差不多就足够了。官网给的参考值是0.20。</p>
</li>
</ul>
<p><a href="http://cms.mpi.univie.ac.at/vasp/guide/node124.html">http://cms.mpi.univie.ac.at/vasp/guide/node124.html</a></p>
<p><img src="/2018/02/06/ex37/ex37-2.png" alt=""></p>
<ul>
<li>在KPOINTS确定之后，使用多大的SIGMA值，大家最好测试一下。<strong>原则如下</strong>：SIGMA取值在<strong>保证</strong>OUTCAR中<code>entropy T*S</code>这项的能量平均到每个原子上小于 1 meV的<strong>前提下</strong>：<strong>尽可能地大</strong>。这样可以在保证准确度的同时，也加快收敛速度。 </li>
</ul>
<p><img src="/2018/02/06/ex37/ex37-3.png" alt=""></p>
<ul>
<li><strong>记住：</strong> VASP学习最快的途径就是不停地看官网，然后亲自上手去测试，测试，测试！并观察分析结果。</li>
</ul>
<hr>
<hr>
<h2 id="4-扩展练习"><a href="#4-扩展练习" class="headerlink" title="4 扩展练习:"></a><strong>4</strong> <strong>扩展练习:</strong></h2><p>4.1 阅读VASP官网关于ISMEAR和SIGMA的所有说明：</p>
<p>4.2 下载VASP的pdf说明书，搜索书中所有的ISMEAR和SIGMA关键词，阅读所有相关的内容；</p>
<p>4.3 思考SMEAR方法的意义？SIGMA的意义？</p>
<p>4.4 查看VASP说明书，查阅相关文献，了解MP和GS方法</p>
<p>4.5 测试MP和 GS方法中，SIGMA取值对计算时间，能量，收敛步数的影响。</p>
<p>4.6 分析下为什么算DOS的时候，要算两步： selfconsistent  和 none-selfconsistent calculations? </p>
<hr>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结:"></a><strong>5</strong> <strong>总结:</strong></h2><p>看完本节：你应该知道计算DOS的时候：</p>
<ul>
<li>KPOINTS和NEDOS设置的一些内容。</li>
<li>ISMEAR要用-5。</li>
<li><p>KPOINTS因计算硬件限制不能设置的很大，数目小于4的时候：</p>
<ul>
<li>对于所有体系均可以使用ISMEAR=0。</li>
<li>金属体系还可以用ISMEAR=1..N，官网建议SIGMA为0.20，太小的SIGMA值对收敛会产生影响。使用0.01-0.10的数值都是很安全的选择。</li>
<li>SIGMA的数值需要测试一下，一般来说在0.01-0.05之间足够了。</li>
</ul>
</li>
<li><p>非DOS计算的时候，对于金属来说ISMEAR不能等于 -5，优先使用ISMEAR= 1。非金属来说（半导体和绝缘体），不能 &gt; 0 。对于所有的体系， ISMEAR= 0 则是一个很安全的选择，但SIGMA的数值要测试一下。说了这么多废话，还是官网简单明了：</p>
</li>
</ul>
<p><img src="/2018/02/06/ex37/ex37-14.png" alt=""></p>
<p>For further considerations on the choice for the smearing method see sections 9.4， 10.6. To summarize， use the following guidelines:</p>
<ul>
<li>​        For <strong>semiconductors or insulators</strong> use <strong>always</strong> tetrahedron method (ISMEAR=-5)， if the cell is too large (or if you use only 1 or two k-points) use ISMEAR=0.</li>
</ul>
<ul>
<li>​        For <strong>relaxations in metals always</strong> use ISMEAR=1 and an appropriated SIGMA value (the entropy term should <strong>less than 1 meV per atom</strong>). <strong>Mind:</strong> <strong>Avoid</strong> to use ISMEAR&gt;0 for semiconductors and insulators， it might result in problems.</li>
</ul>
<p>For metals a sensible value is usually SIGMA= 0.2 (that’s the value we use for most transition metal surfaces).</p>
<ul>
<li>​        For the <strong>DOS</strong> and very accurate <em>total energy</em> calculations (<strong>no relaxation in metals</strong>) use the tetrahedron method (ISMEAR=-5).</li>
</ul>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>DOS</tag>
        <tag>ISMEAR</tag>
        <tag>SIGMA</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex-38 DOS 计算(二)</title>
    <url>/2018/02/07/ex38/</url>
    <content><![CDATA[<p>前面一节，我们留了一个问题：DOS为什么要算两步？</p>
<p>答：可以一步直接算！也就是前面一节的问题是瞎问的。那为什么大家总是有2步计算的疑问呢？本节，我们就解释这个。</p>
<h2 id="为什么算两步？"><a href="#为什么算两步？" class="headerlink" title="为什么算两步？"></a>为什么算两步？</h2><p>官网说了，算DOS有2个方法，一个是直接进行self-consistent计算（大家常说的自洽或者静态计算。）然后处理DOSCAR和vasprun.xml文件即可，如图：</p>
<p><img src="/2018/02/07/ex38/ex38-5.png" alt=""></p>
<p>我们看一下这么做的前提：</p>
<p><img src="/2018/02/07/ex38/ex38-6.png" alt=""></p>
<ul>
<li><p>1） 由于高质量的DOS需要精细的K点，如果我们设置的K点很多，就会造成计算上的负担，前面我们讲过K点与计算时间的关系；而很久很久以前，计算能力并不如现在这样快，因此可以通过分步计算来解决这一问题。</p>
</li>
<li><p>2） 另外一个原因就设计到能带的计算了，这里我们摘抄一下网上的解释：<strong>由于在能带计算时k点是一些在倒空间高对称线上的点</strong>，不能进行自洽计算。参考网址：<a href="https://http://blog.sciencenet.cn/blog-567091-675253.html/">https://http://blog.sciencenet.cn/blog-567091-675253.html/</a> 也就是计算能带的时候，自洽计算是必须的一步；</p>
</li>
<li><p>3） 即使增加K点的数目，电荷密度和有效势能的收敛依然很快，也就是K点的变化对电荷密度的收敛影响不大。</p>
</li>
</ul>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><ul>
<li>能带计算我们暂不考虑，综合下1 和 3 ，<strong>在结构优化完成之后</strong>，我们可以这么算DOS：</li>
</ul>
<ul>
<li><p>第一步，用小的K点算个单点，生成CHGCAR文件；</p>
</li>
<li><p>第二步，读取上一步的CHGCAR文件（ICHARG=11）。</p>
</li>
</ul>
<p>这样做就避免了直接用高K点网格所导致的计算负担。对于DOS计算的两个步骤，归根结底是节约时间的问题。因此，算2步并不是必须的！！！如果够土够豪，直接用高密度的K点，一步计算，没毛病！ <strong>但是对于能带计算</strong>， <strong>则必须算</strong>2<strong>步</strong>。</p>
<p>此外，VASP的说明书已经很古老了，以现在的计算能力，直接使用大K点一步计算，一般来说都可以承受的。所以，当你知道了为什么要算2步的时候，再去浏览网上的相关经验帖子，就很容易知道是怎么回事了。</p>
<h2 id="LDOS-和-PDOS"><a href="#LDOS-和-PDOS" class="headerlink" title="LDOS 和 PDOS"></a>LDOS 和 PDOS</h2><p>LORBIT = 10 把态密度分解到每个原子以及原子的spd轨道上面，称为为局域态密度，Local DOS (LDOS)</p>
<p>LORBIT =11 在10的基础上，还进一步分解到px，py，pz等轨道上，称为投影态密度（Projected DOS）或者分波态密度(Partial DOS)，即PDOS。 </p>
<p>所以LORBIT = 11可以提供我们更多的信息。</p>
<h2 id="WAVECAR"><a href="#WAVECAR" class="headerlink" title="WAVECAR"></a>WAVECAR</h2><p> 那么，WAVECAR读不读呢？大师兄的观点是：有则读，无则不读。对于WAVECAR的读取，我们需要了解ISTART这个参数：</p>
<p><img src="/2018/02/07/ex38/ex38-7.png" alt=""></p>
<ul>
<li><p>如果前面计算中保存了<strong>WAVECAR</strong>，且ISTART没有设置，VASP默认是读取的。</p>
</li>
<li><p>如果没有<strong>WAVECAR</strong>，即使你设置了ISTART=1或者2，VASP找不到可以读取的WAVECAR，也不会报错，而是继续算。</p>
</li>
</ul>
<p>那么怎么控制WAVECAR的输出呢？    </p>
<ul>
<li>1)通过设置LWAVE这个参数</li>
</ul>
<p><img src="/2018/02/07/ex38/ex38-8.png" alt=""></p>
<ul>
<li>2)读取WAVECAR可以极大地减少自洽的时间，但是VASP的WAVECAR非常大，上百M或者几G都是很常见的。一不留神存储空间就被占满了。所以，在读取WAVECAR的时候，一定要确定自己的存储空间。</li>
<li>3)如果前面计算步骤中（优化的过程）保存了WAVCAR，那么后面DOS计算的时候（1步计算或者2步计算均可），都可以读取，这会加快计算速度。</li>
</ul>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>4.1 阅读DOS和能带计算的VASP官方手册；</p>
<p>4.2 了解DOSCAR的内容以及各行各列所代表的含义；</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 结构优化完毕后：</p>
<p>一步计算DOS必须的参数：</p>
<ul>
<li>1 ISMEAR = -5</li>
<li>2 LORBIT = 11</li>
<li>3 高密度的K点</li>
</ul>
<p>两步计算DOS必须的参数:</p>
<p>第一步：</p>
<ul>
<li><p>ISMEAR = -5</p>
</li>
<li><p>LCHARG = .TRUE.</p>
</li>
<li>稍微低密度的K点</li>
</ul>
<p>第二步：</p>
<ul>
<li><p>ISMEAR = -5</p>
</li>
<li><p>ICHARGE = 11</p>
</li>
<li>LORBIT = 11</li>
<li>高密度的K点</li>
</ul>
<p>如果结构优化的时候，存了WAVECAR，计算DOS的时候可以读取WAVECAR，直接一步计算搞定。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>DOS</tag>
        <tag>ISMEAR</tag>
        <tag>SIGMA</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex-39 DOS 计算(三)</title>
    <url>/2018/02/08/ex39/</url>
    <content><![CDATA[<p>本节主要介绍如何使用p4vasp获取DOS数据。</p>
<hr>
<h2 id="1-计算实例："><a href="#1-计算实例：" class="headerlink" title="1 计算实例："></a><strong>1</strong> <strong>计算实例：</strong></h2><p>计算的体系是一个Ru的单胞，含有2个Ru原子。结构优化完毕后进行以下操作。</p>
<p>1.1 <code>cp  CONTCAR  POSCAR</code></p>
<p>1.2 INCAR的设置（一步计算）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IBRION = -1</span><br><span class="line">NSW = 0</span><br><span class="line">ISMEAR = -5</span><br><span class="line">LORBIT = 11 </span><br></pre></td></tr></table></figure>
<p>1.3 KPOINTS 采用: <code>21 21 21</code> （gamma centered：Ru为六方堆积结构！！！）</p>
<p>1.4 提交任务等待结束。</p>
<p>1.5 该计算的所有文件可以通过百度网盘下载： <a href="http://pan.baidu.com/s/1kVebDWz">http://pan.baidu.com/s/1kVebDWz</a> </p>
<hr>
<h2 id="2-DOS可视化："><a href="#2-DOS可视化：" class="headerlink" title="2 DOS可视化："></a><strong>2 DOS</strong>可视化：</h2><p>2.1 打开p4vasp</p>
<p>2.2 点击左侧<code>open</code>，导入vasprun.xml文件；</p>
<p><strong>注意：</strong>前面的2步，Linux系统下面直接输入命令 ：</p>
<p><code>p4v &amp;</code>或者 <code>p4v vasprun.xm</code>即可。</p>
<p>2.3 查看DOS：<strong>Electronic –&gt; DOS+bands</strong></p>
<p><img src="/2018/02/08/ex39/ex39-1.png" alt=""></p>
<p>效果如下如：</p>
<p> <img src="/2018/02/08/ex39/ex39-2.png" alt=""></p>
<hr>
<p>2.4 获取d轨道的DOS: </p>
<p>这里我们取d band作为例子，大家根据自己的需要选择：</p>
<p><code>Electronic</code> –&gt; <code>Local DOS+bands control</code></p>
<p> <img src="/2018/02/08/ex39/ex39-3.png" alt=""></p>
<p> 点击后如下图： </p>
<p>  <img src="/2018/02/08/ex39/ex39-4.png" alt=""></p>
<p>注意：</p>
<p>1） 这里我们填的是Ru，表示选择所有的Ru原子，具体到大家自己的计算中，</p>
<p>换成自己感兴趣的原子即可，怎么选择，我们前面已经讲到过了。（通过左侧的show按钮，以及鼠标和空格选择）</p>
<p>2） 这里我们没有考虑自旋，如果你的体系有自旋，可以选择<code>up</code>，<code>down</code>或者<code>both</code>。<code>up</code>和<code>down</code>的数据导出来的时候通过一个空行分割（后面会讲到）。</p>
<p>3）选择感兴趣的轨道：</p>
<p>如果计算中你设置的<code>LORBIT=10</code>，点击 <code>dxy</code>的时候，则其他的d轨道也会同时被选中，</p>
<p>如果你设置的<code>LORBIT=11</code>，点击<code>dxy</code>时，则仅仅选择<code>dxy</code>，其他的d轨道不会选中。如下图： </p>
<p>  <img src="/2018/02/08/ex39/ex39-5.png" alt=""></p>
<p>如果看不明白：</p>
<p>a）VASP官网查看 <code>LORBIT = 10</code> 和11 的含义；</p>
<p>b）亲自动手操作一下就明白了。</p>
<p>选择完毕后，点击 <code>Add New line</code>，效果如下：</p>
<p>  <img src="/2018/02/08/ex39/ex39-6.png" alt=""></p>
<p>图中增加了一条红色的曲线，为Ru的d轨道的DOS图， 如果你选择了s，点击Add New line，就会增加另外一条曲线。不想要某个曲线了，可以点击remove line，大家自己随意操作，直至熟练为止！！</p>
<hr>
<h2 id="3-后处理："><a href="#3-后处理：" class="headerlink" title="3 后处理："></a><strong>3</strong> <strong>后处理：</strong></h2><p>3.1  导出数据：</p>
<p>p4vasp导出数据通过中间的一个按钮： （注意，这里不通过左上角的File按钮！），如下图：点击 <code>Graph</code> –&gt; <code>Export</code> </p>
<p> <img src="/2018/02/08/ex39/ex39-7.png" alt=""></p>
<p>弹出的窗口中，选择保存的目录和数据的文件名称 </p>
<p> <img src="/2018/02/08/ex39/ex39-8.png" alt=""></p>
<p>注意：</p>
<p>1）choose 选择保存的目录；</p>
<p>2）我们选择的D盘下的VASP目录；</p>
<p>3）填上保存数据的文件名：</p>
<p>a）文件名处 <strong>.dat</strong> 记得写上，要不然后面可能会导不出数据！</p>
<p>b）为了保证导出数据，Export 多点几遍！！！</p>
<p>c）去导出的目录里面查看一下，如有了数据的文件名，说明保存成功，没有的话，继续点Export.</p>
<p> <img src="/2018/02/08/ex39/ex39-9.png" alt=""></p>
<p>图中说明：导出数据成功。</p>
<p> d）为了避免浪费时间，一定要保存成功后再关闭窗口，否则你还要重复一遍前面的步骤。 </p>
<p>4） 保存成功后，点击OK，关闭窗口。</p>
<p>3.2 查看数据：（Notepad++直接打开，无视<strong>.dat</strong>尾缀！）</p>
<p> <img src="/2018/02/08/ex39/ex39-10.png" alt=""></p>
<hr>
<p><strong>问题1： 为什么在301行后面有一个空行？ （重点是301）</strong></p>
<hr>
<p>1) 这是因为DOS计算的点VASP默认是301个，该数目由NEDOS这个参数来确定。NEDOS决定了DOS曲线中间隔的点数，如果你想要自己的DOS曲线更加平滑，可以设置一个较大的NEDOS数值，比如：<code>NEDOS = 3000</code></p>
<p>2) 如果你设置了<code>NEDOS = 500</code>， 那么会在500行以后出现一个空行。</p>
<p>问题2：为什么会有一个空行？？？(<strong>一定要搞明白</strong>！！！)</p>
<p>我们看一下前面DOS的图：</p>
<p> <img src="/2018/02/08/ex39/ex39-11.png" alt=""> </p>
<p>图中有2个DOS曲线，黑色的为空行前面的部分，红色为后面的部分。</p>
<p>同样，如果DOS图中有N个曲线，则导出的数据中会有N-1个空行将它们分开。</p>
<p>N个曲线的横坐标坐标（也就是能量）是完全一样的。知道了这一点，你就知道了自己想要的数据在哪里了！！！</p>
<p>此外，如果有<strong>磁性</strong>的话，你要注意了，up和down也是通过空行分开的。</p>
<hr>
<p>3.3 作图：</p>
<p>有了数据之后，就可以随心所欲地作图了。将数据导入excel或者origin作图，也可以使用其他小脚本，程序。这里我们使用Excel简单说下：</p>
<p>  <img src="/2018/02/08/ex39/ex39-12.png" alt=""></p>
<p>左侧为空行前面的数据，Ru总的DOS， DOS曲线1 （黑色的那个）</p>
<p>右侧为空行后面的数据，Ru d轨道的DOS， DOS曲线2（红色的那个）</p>
<p>作出来的图跟p4vasp的结果一样。图像就不美化了。关键是有了数据，并且知道数据里面空行前后代表的内容。</p>
<p> <img src="/2018/02/08/ex39/ex39-13.png" alt=""></p>
<hr>
<h2 id="4-扩展练习："><a href="#4-扩展练习：" class="headerlink" title="4 扩展练习："></a><strong>4</strong> <strong>扩展练习：</strong></h2><p>4.1 下载本节的练习，可以在自己的服务器上提交，也可以直接使用结果；</p>
<p>4.2 通过p4vasp读取vasprun.xml文件，熟练进行本节的所有操作；</p>
<p>4.3 不要偷懒！！！</p>
<p><strong>5</strong> <strong>总结：</strong></p>
<p>本节主要手把手交给大家如何用<code>p4vasp</code>这个软件查看<code>DOS</code>计算的结果。希望大家掌握这几点：</p>
<ul>
<li>1 会熟练使用改软件进行本节的操作；</li>
<li>2 了解导出数据的格式（空行是怎么分割不同曲线的）；</li>
<li>3 知道LORBIT = 10 和 11 的区别，以及在可视化操作中的不同；</li>
<li><strong>4</strong> <strong>最关键的：要会分析DOS！！！</strong></li>
</ul>
<hr>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>p4vasp</tag>
        <tag>DOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex-40 DOS 计算(四)</title>
    <url>/2018/02/09/ex40/</url>
    <content><![CDATA[<p>DOS积分的原理，积分公式相信大学的时候，大家已经掌握了，现在还有可能忘记了。不过没关系，虽然本节将积分，高等数学里面的暂时还用不到。对于DOS图来说，通过求积分可以得到相应的电子数。积分也就是求DOS曲线下的面积。但DOS图并不能通过一个函数的积分来获得，因为所对应的区域毫无规则可言。那么我们该怎么样积分呢？</p>
<p><strong>1</strong> <strong>积分的原理</strong></p>
<p>积分的原理就是把区域分成N个小块，计算每一块的面积，然后求和。如下图：</p>
<p><img src="/2018/02/09/ex40/ex40-1.png" alt=""></p>
<p>大师兄…..</p>
<p><img src="/2018/02/09/ex40/ex40-2.png" alt=""></p>
<p>好吧，言归正传，大师兄亲自画了一幅图，讲解积分的原理，如下：</p>
<p><img src="/2018/02/09/ex40/ex40-3.png" alt=""></p>
<p>1)将每一个小区间近似看成一个小的梯形，</p>
<p>2) 梯形的上底和下底为：$y_2$ 和$y_1$，高为：$x_2-x_1$。</p>
<p>3, 4)  也可以看成一个高为：$（y_1+y_2）/2$， 底为$x_2-x_1$ 的长方形。</p>
<p>5）面积为两者的乘积：$ΔA =（x_2-x_1）* （y_1+y_2）/2$。</p>
<p>6）将所有的小区间面积求和便得到了曲线所覆盖的面积，也就得到了我们所想要的电子数：$A =\sum\Delta A$</p>
<hr>
<p>注意：</p>
<p>1）电子数的积分区间是从负无穷到费米能级；</p>
<p>2）p4vasp的图中的0点就是费米能级，已经扣除过了。</p>
<p>3）科学网的一个参考链接：<a href="&lt;&lt;http://blog.sciencenet.cn/blog-567091-736149.html">&lt;&lt;http://blog.sciencenet.cn/blog-567091-736149.html</a>/&gt;&gt;</p>
<p><img src="/2018/02/09/ex40/ex40-4.png" alt=""></p>
<p>注意： 图中的DOS，如果你计算了，发现和大师兄的不一样，不用担心，大师兄本人把这个例子再运行了一遍，跟上面的图也不一样。（原因正在调查中）</p>
<hr>
<h2 id="2-d-band-center-的公式"><a href="#2-d-band-center-的公式" class="headerlink" title="2 d-band center 的公式"></a>2 d-band center 的公式</h2><p><img src="/2018/02/09/ex40/ex40-5.png" alt=""></p>
<p>在这里：</p>
<p>ε为前面的我们提到的x， $n_d$(ε)为y。在DOS图中，ε为能量， $n_d$(ε)为电子的密度。</p>
<p>注意： 积分区间是从 <strong>负无穷</strong> 到 <strong>正无穷</strong></p>
<p>参考书籍： Fundamental Concepts in Heterogeneous Catalysis，Jens K. Nørskov, Felix Studt, Frank Abild-Pedersen, Thomas Bligaard， John Wiley &amp; Sons, Inc.</p>
<p>!<img src="/2018/02/09/ex40/ex40-6.png" alt=""></p>
<p>QQ群文件的Books文件夹中下载 </p>
<p><img src="/2018/02/09/ex40/ex40-7.png" alt=""></p>
<p>百度网盘下载链接：<a href="http://pan.baidu.com/s/1bWS2Gu">http://pan.baidu.com/s/1bWS2Gu</a></p>
<p><img src="/2018/02/09/ex40/ex40-8.png" alt=""></p>
<hr>
<p>d 带穿过了费米能级，说明Ru是金属。（废话，等于白说！）</p>
<p>d带的积分从最左面到最右面。</p>
<p>关于d band 的介绍：知乎有个专栏，有兴趣的可以浏览一下：</p>
<p><a href="https://zhuanlan.zhihu.com/p/26230183">https://zhuanlan.zhihu.com/p/26230183</a> </p>
<hr>
<p><strong>3 Excel手动求积分：</strong></p>
<p>对应的公式都写在第二行里面了，excel中计算完第一个数值，直接选中然后往下拽就可以得到后面的数据了。计算文件以及Excel表格已经上传到QQ群和百度网盘，大家可以下载仔细观看练习，掌握该技能。</p>
<p>计算下载链接：<a href="http://pan.baidu.com/s/1kVqWFQn">http://pan.baidu.com/s/1kVqWFQn</a> </p>
<p><img src="/2018/02/09/ex40/ex40-9.png" alt=""></p>
<p>Step1: p4vasp 的 d band 数据！</p>
<p>Step2：A,B两列的乘积，也就是能量和密度的乘积：对应d band center公式中的<strong>分子</strong>：</p>
<p><img src="/2018/02/09/ex40/ex40-10.png" alt=""></p>
<p>Step3：</p>
<p>1）A4-A3:  小区间的能量间隔，也就是 dε，或者 xdx，$\Delta$x， $x_2-x_1$;</p>
<p>2）B4+B3: 小区间的两个起点和终点的高度：也就是对应的小区间两端的能量密度：$y_2+y_1$</p>
<p>3）C4+C3：小区间两端能量和密度乘积的加和： $x_1<em>y_1 + x_2</em>y_2 $ </p>
<p>4）Step4：求小区间的面积：</p>
<p>​      $D4<em>E4</em>0.5$：$(x_2-x_1) * (y_2+y_1)/2$</p>
<p>​      $D4<em>F4</em>0.5$: $ (x_2-x_1) <em> (x_1</em>y_1 + x_2*y_2)/2$</p>
<p>5）Step5: 将所有小区间的面积求和：</p>
<p>电子数：$\sum( (x_2-x_1) * (y_2+y_1)/2 ) $，从G4到G137(G137对应的是费米能级的那个点！！！)求和。</p>
<p><strong>再次强调：电子数目是从负无穷积分到费米能级！</strong></p>
<p>d带中心公式中的分子：从H4到H303求和</p>
<p>d带中心公式中的分母：和电子数的积分一样，但积分区间不同，这里从G4到G303求加和。</p>
<p><strong>再次强调：d带中心积分区间，按照公式，从负无穷积分到正无穷！</strong></p>
<p><em>d</em>带中心公式中的分子：从H4到H303求和</p>
<p><em>d</em>带中心公式中的分母：和电子数的积分一样，但积分区间不同，这里从G4到G303求加和。</p>
<p>以上将公式分开写，是为了方便大家理解，实际操作中，直接使用导出来的数据，将所有的公式合并在一起就可以了。</p>
<hr>
<p><strong>4 扩展练习：</strong></p>
<p>4.1 亲自上手操作，重现本节的结果；</p>
<p>4.2 尝试使用其他软件，方法求积分；</p>
<p>4.3 有好程序的，好脚本的分享给大家。</p>
<hr>
<p><strong>5</strong> <strong>总结：</strong></p>
<p>学习完本节，大家对DOS积分的数学知识应该可以掌握了，后面不管用什么软件或者脚本，都是将这个积分的原理写成机器语言来执行。知道了原理和通过excel自己操作一遍之后，基本上DOS积分的东西就懂了。下一节，QQ群里的小书童给大家演示一下Origin的积分操作。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>DOS</tag>
        <tag>积分</tag>
        <tag>d band center</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex-41 DOS 计算(五)</title>
    <url>/2018/02/10/ex41/</url>
    <content><![CDATA[<p>前面我们讲解了手动求积分的原理，本节由QQ群中的小书童给大家演示一遍Origin求积分的操作，加深一下对积分原理的印象，也借此机会掌握另一项Origin的技能。Origin的 .opj文件和Excel数据已经打包上传到QQ群中，也可以百度网盘下载：<a href="http://pan.baidu.com/s/1bpvmXY3">http://pan.baidu.com/s/1bpvmXY3</a></p>
<h2 id="1-求d带中心"><a href="#1-求d带中心" class="headerlink" title="1 求d带中心"></a><strong>1 求d带中心</strong></h2><p>1.1 复制粘贴能量、态密度、能量*态密度这三列数据到Origin中，数据见前一节练习：</p>
<p>下面我们取了<code>d band</code> 的一小部分区间作为示例进行讲解，大家学习完之后自己主动练习，获取最终的<code>d band center</code>.</p>
<p><img src="/2018/02/10/ex41/ex41-1.png" alt=""></p>
<p>1.2 选中数据并作图：</p>
<p><img src="/2018/02/10/ex41/ex41-2.png" alt=""></p>
<p><strong>plot —&gt; Line —&gt; Line</strong></p>
<p><img src="/2018/02/10/ex41/ex41-3.png" alt=""></p>
<p><img src="/2018/02/10/ex41/ex41-4.png" alt=""></p>
<p>1.3 求积分，先选中一条曲线，右键，<code>Ungroup</code>（将曲线从组中分离，便于选择）。</p>
<p><img src="/2018/02/10/ex41/ex41-5.png" alt=""></p>
<p>1.4 打开积分对话框：</p>
<p><img src="/2018/02/10/ex41/ex41-6.png" alt=""></p>
<p>1.5 再选择一条曲线进行积分，下图选择的是黑线。</p>
<p><img src="/2018/02/10/ex41/ex41-7.png" alt=""></p>
<p><img src="/2018/02/10/ex41/ex41-8.png" alt=""></p>
<p>点击OK，截图中的area就是我们要的积分，这一面积对应下图公式中的分母部分。</p>
<p><img src="/2018/02/10/ex41/ex41-9.png" alt=""></p>
<p> <img src="/2018/02/10/ex41/ex41-10.png" alt=""></p>
<p><code>d band center</code> 的积分区间为整个d带：即从负无穷到正无穷。本例我们用区间 [-6, 2]作为例子！有时候大家会对积分的区间产生疑问。一般来说积分区间是从负无穷到正无穷，但是：</p>
<ul>
<li><p>1）如上图，[-9,-8]这个区间Density为0，积分从[-9,4.0] 和[-8,4.0]结果没什么区别。</p>
</li>
<li><p>2）如果我们关心的是[-6,4.0]这一部分的性质，倘若4.0以后的部分会产生很大的噪音，那么我们也可以只从-6积分到4.0。</p>
</li>
<li><p>所以，积分区间也不是很绝对，大家要根据自己的体系合理选择。</p>
</li>
</ul>
<p>1.6 同理，选中另一条红线（能量和密度乘积），进行积分计算（上图中的分子部分） </p>
<p><img src="/2018/02/10/ex41/ex41-11.png" alt=""></p>
<p> 结果如下:</p>
<p> <img src="/2018/02/10/ex41/ex41-12.png" alt=""></p>
<p>最终，我们计算的d带区间[-6,2]的中心果为：-34.035/ 17.428 = -1.953</p>
<hr>
<h2 id="2-求电子数目"><a href="#2-求电子数目" class="headerlink" title="2 求电子数目"></a><strong>2</strong> <strong>求电子数目</strong></h2><p>电子数目的积分是从负无穷到费米能级。本例中是从-10到0（费米能级）进行积分， 选择黑线，重复前面的操作：</p>
<p>  <img src="/2018/02/10/ex41/ex41-15.png" alt=""></p>
<p>计算结果如下，电子数为13.00</p>
<p>  <img src="/2018/02/10/ex41/ex41-16.png" alt=""></p>
<hr>
<p><strong>3</strong> <strong>扩展练习：</strong></p>
<p>3.1 熟练Get本节Origin求积分的技巧；</p>
<p>3.2 阅读前面几节DOS计算的练习章节；熟练掌握DOS的提取，导出，作图和积分；</p>
<p>3.3 <code>d band center</code> 是对整个区间求积分，电子数目的积分区间是从负无穷到费米能级。</p>
<hr>
<p><strong>4</strong> <strong>总结：</strong></p>
<p>截止到本节，DOS的计算就暂时告一段落了，实际计算中，DOS的分析远远不止我们讲述的这么简单，而且网上DOS分析的脚本很多。大师兄了解到的有VTST的DOS处理脚本和vaspkit等，大家可以尝试练习使用下。如果你在科研工作中对DOS分析有自己的心得，DOS分析脚本的使用经验等，欢迎补充，分享给大家。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>DOS</tag>
        <tag>积分</tag>
        <tag>d band center</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex42 slab模型</title>
    <url>/2018/08/25/ex42/</url>
    <content><![CDATA[<p>前面我们学习了Bulk计算的一些基本的计算，拟合以及优化晶格常数，DOS计算。在材料计算方面，还有能带，声子谱的计算等等，但由于本人方向不在这一块（主要是做表面反应机理研究的），就不能详细给大家解释了。如果有同学在这方面很擅长，可以把自己的计算心得写进本书，将不胜感激。说到表面反应的机理研究，我们首先要做的就是搭建模型。先理一下思路：</p>
<p>1）计算Bulk的结构，获取稳定的晶格常数<br>2）在此基础上，搭建Slab模型。</p>
<h2 id="1-什么是Slab-模型？"><a href="#1-什么是Slab-模型？" class="headerlink" title="1 什么是Slab 模型？"></a>1 什么是Slab 模型？</h2><p>这个问题，我们看一下参考书的第四章：Density Functional Theory: A Practical Introduction （注意：本书有中文版的，本人强烈不建议！请静下心来看原版的，也恳请不要在群里求中文的pdf版本！）<br><img src="/2018/08/25/ex42/ex42-2.jpeg" alt=""><br>多相催化中，反应发生在催化剂表面上，也就是气（液）固两相的交界处。为了模拟固体的表面，我们需要一个在二维方向上具有周期性的结构来模拟固体的表面，第三维方向则不具有周期性，用来模拟气相或者液相。但是，更常用的则是在第三维方向上加上周期性，周期性的结构之间用一个什么都没有的空间（free space）来分割，也就是真空层。在这里我们需要注意的是要避免第三维方向上两个周期性结构的相互影响，也就是一个周期的电子密度沿着真空层方向要趋于零，这样才不会对相邻的结构产生影响。此时，我们需要做的就是：</p>
<p>1）增大真空层的厚度，厚度要适中，太小肯定不行，太大也不合适。想一想我们前面讲到的影响计算速度的一个因素，真空层太厚，也就意味着我们的模型尺寸变大，从而导致计算变慢。一般来说，对于表面反应的计算，15$\AA$的真空层厚度足够了。但是，对于功函数这一类对真空层敏感的计算来说，我们需要注意。</p>
<p>2）VASP中还需要加入：<code>LDIPOL = .TRUE.</code>和<code>IDIPOL = 3</code>(3指的是在z方向上)这两个参数来消除上下不对称的slab表面导致的偶极矩影响。<a href="https://cms.mpi.univie.ac.at/wiki/index.php/LDIPOL">https://cms.mpi.univie.ac.at/wiki/index.php/LDIPOL</a><br><img src="/2018/08/25/ex42/ex42-3.jpeg" alt=""><br>对于表面结构，有以下几个需要注意的:<br>1）xy 方向上表面的大小;<br>A）这个影响表面吸附物种的覆盖度;<br>B）影响体系的尺寸大小和计算时间;<br>C）不同的大小需要选取对应的K点；回想一下我们前面提到的经验规则。</p>
<p>2）不同的晶面，(111)， (100)，(110);<br>A) 这取决于你研究的方向;<br>B) 不同晶面的表面能;<br>C) 不同晶面的表面结构，反应活性等。</p>
<p>3）表面结构的层数<br>A）层数多了，原子变多，体系在 z 方向的尺寸增加，也会影响计算速度；<br>B）计算中需要弛豫的层数；<br>C）不同层数对你要计算的性质会产生影响，比如表面能；<br>D）不同晶面需要的层数也不尽相同，一般开放的表面需要更多的层数；<br>E）根据自己感兴趣的性质，选择合适的层数，也就是需要你去测试一番。</p>
<p>4）Slab模型有两种，一种是上下表面对称的，一种是非对称的。对称性结构往往需要很多层，体系较大。 非对称的结构体系较小，但存在偶极矩的影响，要注意加LDIPOL 和IDIPOL这两个参数来消除，后面我们会介绍到。</p>
<p>注意，为了更加顺利的进行下面的学习，参考书第4章的内容务必认真阅读。这会为你今后的表面研究打下坚实的基础</p>
<h2 id="2-表面模型的搭建："><a href="#2-表面模型的搭建：" class="headerlink" title="2 表面模型的搭建："></a>2 表面模型的搭建：</h2><p><img src="/2018/08/25/ex42/ex42-1.jpeg" alt="">主要使用Material Studio进行切面操作，这一部分，本人不想做过多的解释，因为各大培训班，网上各种博客都有操作说明。本节大师兄通过Cu(111)面的例子给大家简单演示一下。</p>
<p><strong>2.1 块体计算</strong><br>1) 搭建Cu单胞模型，用VESTA导出VASP计算使用的POSCAR文件，这部分不清楚的筒子们可以复习前面bulk计算的相关内容。</p>
<p>2)  INCAR文件的准备<br>A) Cu是金属，ISMEAR=1， SIGMA=0.1<br>B) ENCUT=700， Cu单胞含有的原子数很少，可以把ENCUT设置大一点<br>C) EDIFF和EDIFFG控制电子步收敛和离子弛豫的精度<br>D) PREC=High  </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">SYSTEM = Cu-Bulk calculation RELAX</span><br><span class="line">ISTART = <span class="number">0</span></span><br><span class="line">ICHARG = <span class="number">2</span></span><br><span class="line">ENCUT = <span class="number">700</span></span><br><span class="line">EDIFF = <span class="number">1e-6</span></span><br><span class="line">IBRION = <span class="number">1</span></span><br><span class="line">NSW = <span class="number">200</span></span><br><span class="line">EDIFFG = -<span class="number">0.01</span></span><br><span class="line">ISIF = <span class="number">3</span></span><br><span class="line">POTIM = <span class="number">0.1</span></span><br><span class="line">ISMEAR = <span class="number">1</span></span><br><span class="line">SIGMA = <span class="number">0.1</span></span><br><span class="line">PREC = H</span><br><span class="line">LREAL = Auto</span><br><span class="line">ALGO = Fast</span><br><span class="line">NCORE = <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>E）这里LREAL设置为Auto，是为了和后面表面能计算统一。计算时要根据原子数的多少，以及后续的计算选择LREAL的值。不能拿LREAL=.FALSE.和LREAL=ON/.TRUE.计算的结果进行能量比较。看下面<br><img src="/2018/08/25/ex42/ex42-4.jpeg" alt=""><br>F) 注意：块体材料计算时，为了后续计算其他性质，常常要求整个计算中使用相同的ENCUT，ENAUG， PREC， LREAL， ROPT，这部分大家可以看看手册 8.3 What kind of “technical” errors do exist， overview<br><img src="/2018/08/25/ex42/ex42-5.jpeg" alt=""></p>
<p>3) KPOINTS<br>a=b=c=3.6147 $\AA$， 根据前面的经验，这里设置为$13\times13\times13$的KPOINTS(Gamma  Centered).</p>
<p>4) 准备POTCAR文件进行计算：见前面讲的相关脚本—Ex30 进阶前的准备（三）</p>
<p>5) 最后计算完的Cu的晶格常数为 3.6370 $\AA$，实验值为3.615 $\AA$。大家可以去计算下。（计算例子可以QQ群中下载，也可通过该链接：<a href="http://pan.baidu.com/s/1dE84fhn">http://pan.baidu.com/s/1dE84fhn</a> 密码：nvwa）</p>
<p><strong>2.2 结构优化的注意事项：</strong></p>
<p>关于结构优化，大家在计算时要注意下面的部分，7.6.2 Accurate bulk relaxations with internal parameters (one)一定要详细的读。<br><img src="/2018/08/25/ex42/ex42-6.jpeg" alt=""></p>
<p><strong>2.3 小结</strong><br>主要以金属Cu为例讲了块体材料的计算，以及块体材料计算时的一些注意事项：</p>
<ul>
<li>体材料计算时首先要对要了解材料的性质，根据材料是金属、非金属，还是半导体，选择不同的ISMEAR和SIGMA；</li>
<li>计算时要根据原子数的多少，以及后续的计算选择LREAL的值，这方面不熟悉的朋友可以看看手册；</li>
<li>精确进行块体计算的过程以及注意事项；</li>
<li>回顾Ex36 Bulk的优化。</li>
</ul>
<h2 id="3-MS建立slab模型"><a href="#3-MS建立slab模型" class="headerlink" title="3   MS建立slab模型"></a>3   MS建立slab模型</h2><p><strong>3.1 具体步骤</strong></p>
<ul>
<li><p><code>VESTA</code>将<code>CONTCAR</code>转成<code>cif</code>格式，</p>
</li>
<li><p>MS导入cif文件，</p>
</li>
<li><p><code>build</code>→<code>surface</code>→<code>cleave surface</code>， 如下图所示，在<code>cleave plane(hkl)</code>可以输入要切的晶面，如（111）面，<img src="/2018/08/25/ex42/ex42-7.jpeg" alt=""></p>
</li>
<li><p>在<code>Surface Mesh</code>→<code>surface vectors</code>可以改变slab模型的vectors，之后选择Cleave进行切面，本例为（111）。这个时候也可以通过调节<code>Surface Box</code>→<code>top</code>和<code>thickness</code>，选择slab模型的表面终端和厚度。<img src="/2018/08/25/ex42/ex42-8.jpeg" alt="">     <img src="/2018/08/25/ex42/ex42-9.jpeg" alt=""></p>
</li>
<li><p>确定好表面终端和slab厚度之后，加真空层。<br><code>Build</code>→<code>Crystals</code>→<code>Build vacuum slab</code>，<code>Vacuum orientation</code>选择C指定真空层加在z方向上。可以通过改变<code>Vacuum thickness</code>设置真空层的厚度10 $\AA$，15 $\AA$或者更大。这可以参照之前的计算。最后选择Build完成slab模型的建立。<br><img src="/2018/08/25/ex42/ex42-10.jpeg" alt=""></p>
</li>
<li><p>可以通过<code>Lattice parameters</code>→<code>Advanced</code>→<code>Re-orient to standard</code>把真空层设置沿Z轴。<img src="/2018/08/25/ex42/ex42-11.jpeg" alt="">   <img src="/2018/08/25/ex42/ex42-12.jpeg" alt=""></p>
</li>
</ul>
<h2 id="4-总结："><a href="#4-总结：" class="headerlink" title="4  总结："></a>4  总结：</h2><p>  从本节开始，大家开始步入表面相关的计算学习。请务必认真阅读参考书，重复计算示例。本节主要简单介绍了一下Slab模型以及基本的注意事项。通过Cu的计算复习了一下<code>Bulk</code>的计算以及展示了一下通过<code>Material Studio</code>进行Cu(111)表面的搭建过程。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>slab</tag>
        <tag>MS</tag>
        <tag>模型搭建</tag>
        <tag>bulk</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex43 p(1x1) Cu(111)的单点计算</title>
    <url>/2018/08/26/ex43/</url>
    <content><![CDATA[<p>上一节的内容主要简单介绍了一下Slab模型，具体的大家去看推荐的参考书！计算部分我们做了以下几个方面的操作：</p>
<ul>
<li>Cu的Bulk计算，获取了稳定体相结构，晶胞参数；</li>
<li>将结果导入Material Studio， 并切(111)面</li>
<li>将切出来的Cu(111) 面转换成POSCAR格式。</li>
</ul>
<p>因此，VASP的四个输入文件，我们已经有了POSCAR和POTCAR，下面我们复习下POSCAR，INCAR和KPOINTS的准备工作， 然后进行单点计算。</p>
<h2 id="1-搭建slab模型"><a href="#1-搭建slab模型" class="headerlink" title="1  搭建slab模型"></a>1  搭建slab模型</h2><p>Cu(111) slab 模型（POSCAR）的制作流程（复习一下）。<strong>注意：</strong>前面我们用的是Conventional cell，下面用的是Primitive Cell。 一般来说用<code>Conventional cell</code>， FCC的金属可以用<code>Primitive Cell</code> 但对于其他体系，通过<code>Primitive Cell</code>切出来表面模型有问题。</p>
<p>A）Bulk计算结束后，将CONTCAR用VESTA转换为cif文件，然后MS导入。<br>B）Build→Symmetry→primitive cell<br>C）Build→surfaces→cleave surface<br><img src="/2018/08/26/ex43/ex43-1.jpeg" alt=""><br>D）Build→Crystals→Build Vaccum Slab 真空层选择15Å<br><img src="/2018/08/26/ex43/ex43-2.jpeg" alt=""><br>E）导出为cif，通过VESTA转化为POSCAR格式，如下：<br><img src="/2018/08/26/ex43/ex43-3.jpeg" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cu\(1\1\1)</span><br><span class="line">1.0</span><br><span class="line">        2.5717000961         0.0000000000         0.0000000000</span><br><span class="line">       -1.2858500481         2.2271576142         0.0000000000</span><br><span class="line">        0.0000000000         0.0000000000        21.2994003296</span><br><span class="line">   Cu</span><br><span class="line">    4</span><br><span class="line">Direct</span><br><span class="line">     0.000000000         0.000000000         0.000000000</span><br><span class="line">     0.333330005         0.666670024         0.098590001</span><br><span class="line">     0.000000000         0.000000000         0.295760006</span><br><span class="line">     0.666670024         0.333330005         0.197170004</span><br></pre></td></tr></table></figure>
<p>前面的操作，我们生成 <code>p(1x1)</code> 的Cu(111)面，p是<code>Primitive</code>的简称，如果你不了解p(1x1)， 去学习一下<code>Wood  Notation</code>。当然，在此基础上，你也可以将p(1x1) 在晶胞a 和b方向上扩展，生成<code>p(2x2)</code>，<code>p(3x3)</code>， <code>p(2x1)</code>等不同大小的Cu(111)表面。本节，我们就用p(1x1)做为例子。</p>
<h2 id="2-KPOINTS"><a href="#2-KPOINTS" class="headerlink" title="2  KPOINTS"></a>2  KPOINTS</h2><p><code>POSCAR</code>中，slab在平面方向上a 和 b 的大小为2.5717 Å，根据前面的经验规则，我们可以在两个方向上K点取值为：$13\times13$，z 方向上取值为1，最终KPOINTS如下图，脚本使用命令为：<code>kpoints.sh 13 13 1</code> （不知道脚本的请往前翻）</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">qli@bigbro:~/test/cu$  kpoints.sh <span class="number">13</span> <span class="number">13</span> <span class="number">1</span> </span><br><span class="line">qli@bigbro:~/test/cu$  cat KPOINTS</span><br><span class="line">K-POINTS</span><br><span class="line"> <span class="number">0</span></span><br><span class="line"><span class="built_in">Gamma</span></span><br><span class="line">  <span class="number">13</span> <span class="number">13</span> <span class="number">1</span></span><br><span class="line">  <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>为什么在z方向上只用1个K点？查找参考书（DFT：A Practical Introduction， Page 88）的说明：<br>If the vacuum region is large enough， the electron density tails off to zero a short distance from the edge of the slab. It turns out that this means that accurate results are possible using just one k point in the b3 direction.</p>
<h2 id="3-INCAR"><a href="#3-INCAR" class="headerlink" title="3  INCAR"></a>3  INCAR</h2><p>在贴出来INCAR之前，大家首先回顾一下单点计算需要注意的几个方面：<br>1）<code>System = Cu(111)</code> 可有可无<br>2）Cu 是金属，可以使用<code>ISMEAR = 1;SIGMA = 0.1</code><br>3）<code>ALGO = FAST</code> 或者使用默认值<br>4）纯净的Cu(111)体系中，Cu没有磁性，ISPIN 不用设置<br>注意：CuO中Cu具有磁性，如果你算的是Cu的氧化物，就需要考虑ISPIN了<br>5）单点计算：<code>NSW = 0</code> 也可以不设置，因为默认值就是0<br>6）截断能： <code>ENCUT = 450</code> 很多人喜欢测试这个参数，450直接用是一个很好的选择<br>7）<code>EDIFF = 1E-5</code> 电子步的收敛标准<br>8）偶极矫正：<code>LDIPOL = .TRUE. ; IDIPOL = 3</code> Slab模型一般都需要加上这个参数<br>9）控制OUTCAR和其他文件的输出：<code>NWRITE = 0 ; LWAVE  = .FALSE.;LCHARG = .FALSE.</code><br>10）也可以加上<code>NCORE</code>这个参数来加快计算步骤。一般来说，不同的机子大家需要自己测试下NCORE参数对计算的影响，个人经验：如果你的机器一个节点有12个核，设置<code>NCORE = 6</code>； 一个节点有24核，设置<code>NCORE = 12</code>。也就是节点中核数的一半。由于这个计算很快，本操作就不考虑了。最终INCAR 如下:</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">System = Cu111</span><br><span class="line"></span><br><span class="line">ISMEAR = <span class="number">1</span></span><br><span class="line">SIGMA = <span class="number">0.1</span></span><br><span class="line">ALGO = FAST</span><br><span class="line">ENCUT = <span class="number">450</span></span><br><span class="line">EDIFF = <span class="number">1E-5</span></span><br><span class="line"></span><br><span class="line">LDIPOL = .TRUE.</span><br><span class="line">IDIPOL = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">NWRITE = <span class="number">0</span></span><br><span class="line">LWAVE = .FALSE.</span><br><span class="line">LCHARG = .FALSE.</span><br></pre></td></tr></table></figure>
<h2 id="4-准备任务脚本，提交任务"><a href="#4-准备任务脚本，提交任务" class="headerlink" title="4 准备任务脚本，提交任务"></a>4 准备任务脚本，提交任务</h2><p>计算完成后， <code>grep &#39;  without&#39; OUTCAR</code>  （without前面有2个空格）或者<code>grep E0 OSZICAR | tail-n 1</code>，得到单点能为：<code>-13.96918440 eV</code></p>
<h2 id="5-扩展练习"><a href="#5-扩展练习" class="headerlink" title="5   扩展练习"></a>5   扩展练习</h2><p>5.1 计算的例子下载链接：链接: <a href="https://pan.baidu.com/s/1cHY-9g2Iswl5zV9bijBG7Q">https://pan.baidu.com/s/1cHY-9g2Iswl5zV9bijBG7Q</a> 提取码: ctxc<br>5.2 重复本节所有的练习<br>5.3 VASP官网查找本节中不了解的参数，然后学习<br>5.4 思考一下：我们得到的单点能量可以干吗用？</p>
<h2 id="6-总结："><a href="#6-总结：" class="headerlink" title="6 总结："></a>6 总结：</h2><p>刚刚步入slab的计算，我们速度稍微慢一些，本节只讲单点计算，希望大家能够跟上步骤，亲自进行操作练习，如果出错了，请认真改正，直至得到和上传的结果一样为止。再次强调，大家平时一定要多浏览VASP官网，请把VASP手册下载放到桌面上，没事的时候就翻一翻。不要去网上找一些乱七八糟的教程，拿过来就直接照着练，官网才是最正宗的。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>单点</tag>
        <tag>模型搭建</tag>
        <tag>Cu(111)</tag>
        <tag>Slab</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex44 p(1x1)Cu(111) 的优化计算</title>
    <url>/2018/08/27/ex44/</url>
    <content><![CDATA[<p>前面我们学习了Slab模型的单点计算，在此基础上，本节我们主要学习下怎么优化Slab模型。</p>
<h2 id="1-修改Slab模型"><a href="#1-修改Slab模型" class="headerlink" title="1 修改Slab模型"></a>1 修改Slab模型</h2><p>前面单点计算的<code>POSCAR</code>不可以直接拿过来用吗？为什么要修改<code>POSCAR</code>文件？</p>
<p>这是因为在Slab模型中，要固定一部分原子来模拟体相，然后放开一部分原子来模拟表面。一般来说，表面的两层原子允许弛豫，而下面的那些原子则直接固定住。</p>
<p>这样做的物理意义在于：在真实的环境下，催化剂体相看做是不变的，只有表面的原子参与催化反应。</p>
<p>VASP中固定原子需要在POSCAR中进行操作。有两个关键点：</p>
<p>1）在POSCAR的第7行后添加一行，改行内容为<code>Selective Dynamics</code>，VASP只认第一个字母，你可以直接在这一行只加 S或者s。也可以换成其他的S开头的单词，比如<code>SB</code>，<code>Sexy BigBro</code> ， <code>Super BigBro</code>等等；<br>2）在原子坐标后面加上 F 或者 T 表示固定或者放开，因为坐标有xyz三个数值，因此我们需要三个F或者T。我们可以通过设置允许原子在某一方向上移动，而其他方向上固定。</p>
<ul>
<li><code>F F F</code>表示xyz全部固定； </li>
<li><code>T T T</code> 表示xyz全部放开，</li>
<li><code>F F T</code> 表示 xy方向固定，只允许原子在z方向上移动。</li>
</ul>
<p>这一点我们前面也已经讲过了，详见Ex24 频率计算的输出与POSCAR原子的固定。</p>
<p><strong>注意：</strong></p>
<ul>
<li>如果前面的<code>POSCAR</code>直接拿过来直接用，那么在优化过程中所有的原子都会被放开。回想一下我们计算Fe, Cu单胞的例子，计算中我们没有设置F或者T，晶胞尺寸和原子的坐标在优化过程前后都发生了变化。因此你不设置<code>Selective</code> 以及 F或者T，VASP默认是所有的原子都放开的。</li>
<li><code>Selective</code> 和 F 或者 T同时出现，不要只设置<code>Selective</code>忘了FT，也不要只设置FT忘了Selective.</li>
</ul>
<h2 id="2-如何修改？"><a href="#2-如何修改？" class="headerlink" title="2 如何修改？"></a>2 如何修改？</h2><p>根据前面说，我们需要做的无非有两步，<br>1）  在第7行后加入<code>Selective Dynamics</code><br>2）  在坐标后面加入<code>T T T</code>或者 <code>F F F</code><br>我们在本节中，将底部的两层原子固定，上面两层放开。</p>
<p>实现本目的，有以下几种方式： </p>
<p>2.1）这个用文本编辑器就可以做到，很多编辑器都有列块模式，允许你同时添加N列到每行的最后。你可以使用下<code>Notepad++</code>，<code>Atom</code>这些免费开源的软件来操作</p>
<p>2.2）使用<code>p4vasp</code>，详见前面的练习Ex24</p>
<p>2.3） 本节我们重温一下<code>sed</code>的用法，直接使用命令进行操作。</p>
<p>A) 在第 7行 后添加一行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed  -i  &#x27;7aSelective Dynamics&#x27;  POSCAR</span><br></pre></td></tr></table></figure>
<p>7a 代表在第7行后面添加一行，a 是append的缩写。注意，a 和 Selective之间可以没有空格，也可以有空格，这里我们没有加空格。</p>
<p>B） 添加了Selective这一行之后，原子坐标的行数也发生了变化，为10-13行。</p>
<p>C） 第10，11行为底部的两层原子坐标，我们在最后面加上<code>F F F</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed  -i  &#x27;10,11s/$/ F F F/g&#x27; POSCAR</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 第一个F前面有个空格。</p>
<p>d） 在12-13行最后面加上 <code>T T T</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed  -i  &#x27;12,13s/$/ T T T/g&#x27; POSCAR</span><br></pre></td></tr></table></figure>
<p>这样，我们就顺利完成POSCAR的改造了，可以用来进行slab的优化计算了。</p>
<h2 id="3-KPOINTS-和-POTCAR"><a href="#3-KPOINTS-和-POTCAR" class="headerlink" title="3 KPOINTS 和 POTCAR"></a>3 KPOINTS 和 POTCAR</h2><p>保持原来的样子不变</p>
<h2 id="4-INCAR"><a href="#4-INCAR" class="headerlink" title="4 INCAR"></a>4 INCAR</h2><p>优化的时候，我门回想一下要设置的东西：<br>4.1<code>IBRION</code> 和 <code>POTIM</code><br>IBRION可以使用 1 和2，我们这里用2。（1的话适合初始结构比较好的情况，这里我们也可以用。）<br><code>POTIM =0.1</code>  官网默认值是0.5，个人感觉比较大， 0.1是一个很不错的选择。<br>4.2 <code>EDIFFG = -0.01</code>优化时以力作为收敛标准。注意 -0.01 已经很严格了，除非特殊需要，不要设置-0.001，这样你就会在QQ群里求助大家，为什么我优化的时候一直不收敛啊。如果设置-0.01，很多步过后仍然不收敛，可以尝试一下-0.02，也是一个很安全的选择。<br>4.3 <code>NSW = 500</code>  设置最大的优化步数。<br>4.4 <code>ISIF = 2</code>   slab 模型优化的时候，我们用<code>ISIF =2</code> ，也就是VASP的默认值，不用设置， 最终<code>INCAR</code>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System = Cu111</span><br><span class="line"></span><br><span class="line">ISMEAR = 1</span><br><span class="line">SIGMA = 0.1</span><br><span class="line">ALGO = FAST</span><br><span class="line">ENCUT = 450</span><br><span class="line">EDIFF = 1E-5</span><br><span class="line"></span><br><span class="line">LDIPOL = .TRUE.</span><br><span class="line">IDIPOL = 3</span><br><span class="line"></span><br><span class="line">NWRITE = 0</span><br><span class="line">LWAVE = .FALSE.</span><br><span class="line">LCHARG = .FALSE.</span><br><span class="line"></span><br><span class="line">IBRION = 2</span><br><span class="line">POTIM = 0.1</span><br><span class="line">EDIFFG = -0.01</span><br><span class="line">NSW = 500</span><br></pre></td></tr></table></figure>
<p>注意：<br>上一节我们提到Cu没有磁性，表述是不准确的，应该是纯净的Cu(111) slab模型中，Cu不需要考虑自旋。如果你算的是CuO(111)表面，则需要考虑自旋了。</p>
<h2 id="5-提交任务"><a href="#5-提交任务" class="headerlink" title="5 提交任务"></a>5 提交任务</h2><p>计算结束后，查看OUTCAR，OSZICAR的最后几行检查下是不是正常结束。</p>
<h2 id="6-扩展练习"><a href="#6-扩展练习" class="headerlink" title="6 扩展练习"></a>6 扩展练习</h2><p>6.1 掌握本节提到的固定原子的三种做法：文本编辑器，p4vasp,  sed， 当然啦，更可以直接使用Vim 这个强大的工具来执行<br>6.2 查看结构优化相关的这几个参数，复习下它们的VASP官网说明。<br>6.3 运行本文的例子，然后将EDIFFG设置成 -0.02或者-0.001进行测试，查看与-0.01的区别。<br>6.4 VASP官网查找表面能计算的案例，结合本节以及前面的学习，尝试算一下Cu(111)面的表面能。</p>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7 总结"></a>7 总结</h2><p>截止到本节为止，Slab模型的优化，你已经可以初步掌握了。请务必跟着节奏认真练习。后面我们会继续学习Slab模型的优化，现在感觉陌生没上手的也不用担心。认真总结一下，我们如何从Bulk模型，然后一步一步操作到Slab模型优化的。每一步中都有哪些该注意的细节。这些都掌握了，就可以大大提高你计算的成功率，进而节省时间和精力。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>优化</tag>
        <tag>Cu(111)</tag>
        <tag>Slab</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex45 表面弛豫</title>
    <url>/2018/08/28/ex45/</url>
    <content><![CDATA[<h2 id="答辩心得"><a href="#答辩心得" class="headerlink" title="答辩心得"></a>答辩心得</h2><p>顺利完成博士答辩，现在我们开始继续前面的章节。<br>首先，想跟大家分享下自己答辩的体会：基础知识太不扎实，前瞻性又太不够。导致回答问题的环节，被大牛们问的就想找个缝钻进去了。这对于我的启示就是，以后写这本书的时候，每个练习尽量分成4个部分:<br>1)  第一部分讲基础知识，<br>2)  第二部分讲计算过程的细节部分，<br>3) 第三部分讨论计算结果和基础知识;<br>4) 相关发表的文章中的计算。<br>这对大家的要求就是:<br>1)  有什么任何有疑问的地方，自己要记下来，主动查阅资料，然后反馈给我;<br>2)  有什么欠妥的地方，恳请批评指正;<br>3)  如果你有相关发表的文章，可以放在前面提到的第四部分供大家研究，欢迎分享;<br>4)  这本书的作者不是我自己一个人，更是我们大家的心血，希望我们一起努力;<br>5)  本人只接受邮件咨询或者批评: lqcata@gmail.com 因为群里讨论的很多宝贵的经验总是没法及时完整的保留下来，以至于造成了很多损失。</p>
<h2 id="表面弛豫"><a href="#表面弛豫" class="headerlink" title="表面弛豫"></a>表面弛豫</h2><p>我们先想想一下，有一块金属，我们从中间切开后，新生成的两个表面上的原子和体相中的有什么区别?<br>首先，表面上的原子配位数比体相中的少了，即表层原子具有悬键。因为切开的过程就等同于把两个表面的原子键切开了。其次，配位数的减少使得表面层与内部的相互作用会更强，与体相中有所不同。这就体现在层间距(键长)上面。</p>
<p><strong>1 维基百科的解释</strong></p>
<p>理想情况下的晶体向各方向无限延伸，其中任一原子的平衡位置由晶体中其他所有原子对其作用力的总和决定。因此，每个原子所在的位置在理想晶体中是等价的，生成的晶体结构是周期性的。现实情况下的晶体大小有限，这就导致了靠近晶体表层的原子受到的作用力不同于晶体内部的原子，从而造成晶体表面原子排列方式不同于晶体内部的结果。晶体表层原子的这种行为可被分为弛豫(relaxation)和重构(reconstruction)两种情况。<br>弛豫指表面的原子层整体相对于内部的本体(bulk)的位置变化。较为常见的情况是垂直方向上的上下位移，即法向弛豫(normalrelaxation)。大部分金属表面上的弛豫都是这种类型。某些材料的表面也可能在发生法向弛豫的同时有切向的弛豫。</p>
<p><strong>2 Surface Science: An Introduction 这本书的解释</strong><br><img src="/2018/08/28/ex45/ex45-1.jpeg" alt=""><br><img src="/2018/08/28/ex45/ex45-2.jpeg" alt=""><br><img src="/2018/08/28/ex45/ex45-3.jpeg" alt=""><br><img src="/2018/08/28/ex45/ex45-4.jpeg" alt=""></p>
<p><strong>3  参考书的解释:</strong><br>Density Functional Theory: A Practical Introduction， 第94页，第四章，第4.5节 SURFACE RELAXATION 这一部分(请务必认真看完这一部分)<br><img src="/2018/08/28/ex45/ex45-5.jpeg" alt=""><br><img src="/2018/08/28/ex45/ex45-6.jpeg" alt=""><br><img src="/2018/08/28/ex45/ex45-7.jpeg" alt=""></p>
<h2 id="4-扩展练习"><a href="#4-扩展练习" class="headerlink" title="4 扩展练习:"></a>4 扩展练习:</h2><p>1)  了解表面弛豫的相关内容;<br>2)  查找相关书籍;<br>3)  认真阅读参考书4.5节的内容，并重复4.5 节的练习<br>4)下载本节的两本参考书：QQ群共享或者百度网盘链接：<a href="http://pan.baidu.com/s/1eSB2Nx4">http://pan.baidu.com/s/1eSB2Nx4</a></p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>表面弛豫相信大家都很了解了，借此机会供大家复习一下。关于表面化学的经典书籍，如果你有特别喜欢的，也请推荐给大家。 </p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>Slab</tag>
        <tag>参考书</tag>
        <tag>表面弛豫</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex46 表面弛豫的计算结果分析以及Direct坐标转换脚本</title>
    <url>/2018/08/30/ex46/</url>
    <content><![CDATA[<p>前面一节我们回顾了一下表面弛豫的基本概念，对于大多数的金属体系来说， 表面弛豫一般发生在垂直方向上。将金属沿表面方向切成两份后，由于表面原子的配位数发生了变化， 我们可以想象:该表层原子与下面一层的结合能力会更强，从而降低体系的能量。具体体现在层间距和能量两个方面。我们先回顾一下Ex44中Cu(111)表面的练习。</p>
<h2 id="1-结构优化前后变化"><a href="#1-结构优化前后变化" class="headerlink" title="1 结构优化前后变化"></a>1 结构优化前后变化</h2><p>首先观察一下结构的变化， POSCAR的结构如下：(刚刚切好的，热乎的表面)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cu\(1\1\1)</span><br><span class="line">   1.00000000000000</span><br><span class="line">     2.5717000960999998    0.0000000000000000    0.0000000000000000</span><br><span class="line">    -1.2858500480999999    2.2271576141999998    0.0000000000000000</span><br><span class="line">     0.0000000000000000    0.0000000000000000   21.2994003296000010</span><br><span class="line">   Cu</span><br><span class="line">   4</span><br><span class="line">Selective</span><br><span class="line">Cartesian</span><br><span class="line">+0.0000000000   +0.0000000000   +0.0000000000   F F F</span><br><span class="line">-0.0000128765   +1.4847792201   +2.0999078998   F F F</span><br><span class="line">+1.2858629618   +0.7423784587   +4.1996028482   T T T</span><br><span class="line">+0.0000000000   +0.0000000000   +6.2995107693   T T T</span><br></pre></td></tr></table></figure>
<p>优化后的结构：冷却后的，转化为Cartesian坐标的CONTCAR) </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cu\(1\1\1)</span><br><span class="line">   1.00000000000000</span><br><span class="line">     2.5717000960999998    0.0000000000000000    0.0000000000000000</span><br><span class="line">    -1.2858500480999999    2.2271576141999998    0.0000000000000000</span><br><span class="line">     0.0000000000000000    0.0000000000000000   21.2994003296000010</span><br><span class="line">   Cu</span><br><span class="line">     4</span><br><span class="line">Selective dynamics</span><br><span class="line">Cartesian</span><br><span class="line">+0.0000000000   +0.0000000000   +0.0000000000   F F F</span><br><span class="line">-0.0000128765   +1.4847792201   +2.0999078998   F F F</span><br><span class="line">+1.2858542192   +0.7423835062   +4.1890255872   T T T</span><br><span class="line">+0.0000182442   -0.0000105333   +6.2592676588   T T T</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>表层原子的坐标从6.2995 $\AA$减小到6.2593 $\AA$。说明该层原子向体相收缩了。<br>第一、二层的原子间距（单位： $\AA$）为:<br>6.2995-4.1996 = 2.0999 (POSCAR)<br>6.2593-4.1890 = 2.0703 (CONTCAR)，<br>前后变化了(2.0999-2.0703) / 2.0999  * 100% = 1.4 %<br>注意：这里没有区分正负号，一般来说，用负值表示向体相收缩！！！(详见参考书)</p>
<h2 id="2-弛豫能量"><a href="#2-弛豫能量" class="headerlink" title="2 弛豫能量"></a>2 弛豫能量</h2><p>那么怎么知道弛豫前后的能量变化呢? 这个问题很容易回答: </p>
<ul>
<li>第一步：我们对刚刚切好的表面算个单点计算；获得一个能量。</li>
<li>第二步：用优化完的能量减去前面单点能结果即可。</li>
</ul>
<p>实际计算过程中，第一步可以免去，因为在优化的时候，VASP会对初始结构计算一下，对应的为第一个离子步的能量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qli@bigbro:~/test/cu/cu111/opt1$ grep &#x27;  without&#x27; OUTCAR  | awk &#x27;&#123;print $7&#125;&#x27;</span><br><span class="line">-13.96892338</span><br><span class="line">-13.96932426</span><br><span class="line">-13.96974724</span><br><span class="line">-13.97030280</span><br><span class="line">-13.97016827</span><br><span class="line">-13.97041579</span><br><span class="line">-13.97047584</span><br><span class="line">-13.97063103</span><br><span class="line">-13.97082922</span><br><span class="line">-13.97086603</span><br></pre></td></tr></table></figure>
<p>所以，弛豫前后的能量（eV）变化为:<br>-13.97086603 - (-13.96892338)  = -0.00194265  </p>
<p>能量为负值，说明弛豫这个过程是放热的，也就是说刚刚切开的表面不稳定，表层原子向体相收缩后，体系能量降低，变得更稳定。<br><strong>注意：</strong>这么做的时候，一定要先检查第一个离子步中的电子步是否收敛。比如：VASP默认的单个离子步中的电子步数为60步（<code>NELM  =  60</code>），<a href="https://cms.mpi.univie.ac.at/wiki/index.php/NELM">https://cms.mpi.univie.ac.at/wiki/index.php/NELM</a><br>如果你设置的的NELM为默认值，且第一个离子步中，到了60步还没有收敛，则该这一步的能量是不可以用的。<br>此时，你需要做的就是：</p>
<ul>
<li>尝试增大 <code>NELM = 100</code> 或者其他更大的数值， 对未优化的结构重新做个单点计算。</li>
<li>收敛很困难的话，可以调节下<code>ALGO</code>这个参数。</li>
</ul>
<h2 id="3-dire2cart-py"><a href="#3-dire2cart-py" class="headerlink" title="3 dire2cart.py"></a>3 dire2cart.py</h2><p>本节讲的太少，留个转化Direct为Cartesian的脚本(<code>dire2cart.py</code>）作为补充。下载链接： </p>
<p><a href="https://pan.baidu.com/s/1ScsLWhLAPpSul0SzYNPvpg。">https://pan.baidu.com/s/1ScsLWhLAPpSul0SzYNPvpg。</a></p>
<p>上面CONTCAR的转化就是用的这个脚本。使用如下图: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qli@bigbro:~/test/cu/cu111/opt1$ ls</span><br><span class="line">CONTCAR  INCAR  KPOINTS  OSZICAR  OUTCAR  POSCAR  POTCAR  sub4  vasprun.xml</span><br><span class="line">qli@bigbro:~/test/cu/cu111/opt1$ dire2cart.py POSCAR</span><br><span class="line">###################################</span><br><span class="line"></span><br><span class="line"># #</span><br><span class="line"></span><br><span class="line">#for VASP 5.2 or higher versions  #</span><br><span class="line"></span><br><span class="line"># #</span><br><span class="line"></span><br><span class="line">###################################</span><br><span class="line"></span><br><span class="line">## This POSCAR has Direct Coordinations， Conversion is starting....</span><br><span class="line"></span><br><span class="line">## POSCAR with Cartesian Coordiations is named as POSCAR_C</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>如果你的<code>POSCAR</code>或者<code>CONTCAR</code>已经是<code>Cartesian</code>坐标了，这个脚本可以自动识别并终止转换。</li>
<li>转化后的文件为：<code>AAA_C</code>, <code>AAA</code>是你要转化的文件（POSCAR或者CONTCAR）。</li>
</ul>
<h2 id="4-扩展练习"><a href="#4-扩展练习" class="headerlink" title="4 扩展练习"></a>4 扩展练习</h2><ul>
<li><p>下载VASP官网的关于表面相关计算的pdf文档：<a href="http://www.nersc.gov/assets/Uploads/VASP-tutorial-SurfaceScience.pdf"><code>VASP Tutorial: A bit of surface science</code></a></p>
</li>
<li><p>根据自己所学，尝试着练习里面的相关内容。</p>
</li>
<li><p>其他相关的材料：<a href="http://www.nersc.gov/users/training/events/3-day-vasp-workshop/">http://www.nersc.gov/users/training/events/3-day-vasp-workshop/</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>表面能</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex47 表面能的计算（一）</title>
    <url>/2018/09/01/ex47/</url>
    <content><![CDATA[<p>继续前面的计算，这一节我们主要讲一下表面能的计算过程。</p>
<h3 id="1-表面能定义"><a href="#1-表面能定义" class="headerlink" title="1 表面能定义"></a>1 表面能定义</h3><p>首先，我们先介绍一下表面能的定义。为了偷懒，本人直接摘抄的<a href="https://en.wikipedia.org/wiki/Surface_energy">维基百科</a>的解释，如下：</p>
<p>表面能是创造物质表面时，破坏分子间化学键所需消耗的能量。在固体物理理论中，表面原子比物质内部的原子具有更多的能量，因此，根据能量最低原理，原子会自发的趋于物质内部而不是表面。表面能的另一种定义是，材料表面相对于材料内部所多出的能量。把一个固体材料分解成小块需要破坏它内部的化学键，所以需要消耗能量。如果这个分解的过程是可逆的，那么把材料分解成小块所需要的能量就和小块材料表面所增加的能量相等。但事实上，只有在真空中刚刚形成的表面才符合上述能量守恒。因为新形成的表面是非常不稳定的，它们通过表面原子重组和相互间的反应，或者对周围其他分子或原子的吸附，从而使表面能量降低。</p>
<h3 id="2-VASP计算"><a href="#2-VASP计算" class="headerlink" title="2 VASP计算"></a>2 VASP计算</h3><p>具体到VASP的计算中，表面能是怎么算出来的呢？ 下面我们看一下VASP官网的表面能的计算过程。</p>
<p><img src="/2018/09/01/ex47/ex47-2.jpeg" alt=""></p>
<p>公式先大体浏览一遍，我们分析下里面的各项所表示的内容：</p>
<ul>
<li>E<sup>rel</sup>： Relaxation energy， 即弛豫能量。这个前面一节我们已经讲过了，从刚刚切好的表面优化到稳定的表面所释放的热量。图中的第一个点就是刚刚切好表面的能量（E<sup>surf</sup>），最后一个点就是优化完成之后的能量。这个相信大家现在都能理解了。</li>
<li>σ： 在handonsession-III里面，这个用来表示表面能。</li>
<li>E<sup>surf</sup>：刚刚切好的 slab 能量；可以直接算个单点，也可以取优化过程中第一个离子步的能量。</li>
<li>N<sub>atoms</sub>： Slab 中的原子数目</li>
<li>E<sub>bulk</sub>： Bulk结构中单个原子的能量。</li>
</ul>
<p><strong>注意1：</strong></p>
<p>前面说的最后一点。E<sub>bulk</sub>， 这个不是指的体相的能量，而是体相中单个原子能量。即体相的能量除以原子数目。我们顺便回顾一下前面单胞的优化：</p>
<ol>
<li><p>获取稳定的晶格常数，两个方法：</p>
<ul>
<li>ISIF + Large ENCUT</li>
<li>通过计算不同的晶格常数的晶胞能量，用BM方程拟合</li>
</ul>
</li>
<li>得到稳定的晶格常数之后，如果用的 ISIF= 3 这个方法，则将 CONTCAR 复制成 POSCAR ，然后在 INCAR 中设置： ISIF = 2 + 正常的 ENCUT ，做个单算，算下计算晶胞的能量。</li>
<li>用晶胞的能量除以晶胞中的原子数目，就得到了这里的 E<sub>bulk</sub>。比如前面 Cu 的单胞中有4个原子，我们则用计算后体系的能量除以4。</li>
</ol>
<p><strong>注意2：</strong></p>
<p>Handonsession-III 里面的表面能，严格来说，这个定义其实是不对的。因为表面能，从字面上理解，它的单位应该是： 能量/面积。而图中只有能量，没有面积。所以，图中的表面能指的是纯能量。</p>
<ol>
<li><p>σ<sup>unrel</sup>： 将块体直接切开所用的功，因为是切成了2份，公式中除以2。  </p>
<p>注意，在这个计算里面，暂且不考虑表面的弛豫，单纯从体相切成2个表面的过程。<br>能量是刚刚切出来的slab的能量： -25.560</p>
</li>
<li><p>从体相到切开表面直至达到稳定状态，总的能量变化为：</p>
<script type="math/tex; mode=display">
\sigma = \sigma^{unrel + E^{rel}}</script></li>
</ol>
<p><strong>注意3：</strong></p>
<p>E<sup>rel</sup> 这里没有除以2。为什么呢？ 这是因为我们只放开了上面的两层原子。也就是只优化了一个表面。<br>至此，从体相切成表面，然后直至表面稳定，这一个过程的能量就算完了。<br>既然前面说了，表面能里面有面积，那么面积指的是什么面积？怎么求面积呢？</p>
<ol>
<li>面积就是你计算的slab的那一层表面积，很多人问我这个问题，我也是无语了！</li>
<li>怎么求呢? 我们先看一下Slab模型(Notepad++这个软件打开的！没有的话赶紧去安装一个)</li>
</ol>
<p><img src="/2018/09/01/ex47/ex47-3.png" alt=""></p>
<p>前面几行放大一下，看看晶格尺寸。</p>
<p><img src="/2018/09/01/ex47/ex47-4.png" alt=""></p>
<p>如果面积用A来表示， 则： </p>
<p>A = 2.57170 <em> 2.22716 – 0.000 </em> (-1.28585) </p>
<p><strong>注意4：</strong></p>
<p>这里的单位是 Å<sup>2</sup><br>原理如下图：(自画自拍，不喜勿喷!)</p>
<p><img src="/2018/09/01/ex47/ex47-5.jpeg" alt=""></p>
<p>菱形的面积等于： x1 * y2<br>如果坐标系不是那么正儿八经对在一起的时候，如下图：</p>
<p><img src="/2018/09/01/ex47/ex47-6.jpeg" alt=""></p>
<p>则面积等于：x1 <em> y2 – y1 </em> x2<br>Handonsession-III 中 Ni(100) 表面的面积为：</p>
<p><img src="/2018/09/01/ex47/ex47-7.png" alt=""></p>
<p>A = (0.5<em>0.5– 0.5 </em> (-0.5)) = 0.5 Å<sup>2</sup><br>这里我们还忘了乘以前面的缩放系数：所以，<br>A = 0.5 <em> 3.53 </em> 3.53 = 6.23045 Å<sup>2</sup><br>最终表面能为： 0.71 eV / 6.23045 Å<sup>2</sup> = 0.114 eV/Å<sup>2</sup><br>一般来说表面能的单位为： J/m<sup>2</sup><br>换算系数为： 1 eV/Å<sup>2</sup> = 16.02 J/m<sup>2</sup><br>换算完毕后，表面能为： σ = 0.114 * 16.02 J/m<sup>2</sup> = 1.826 J/m<sup>2</sup> 。</p>
<p><strong>注意5</strong>： 我们的参考书中(第97页中)给弄反了。</p>
<p><img src="/2018/09/01/ex47/ex47-8.jpeg" alt=""></p>
<p>这是因为：<br>1 eV = 1.602176487<em>10<sup>-19</sup> J<br>1 Å<sup>2</sup> = (1</em>10<sup>-10</sup>)<em> (1</em>10<sup>-10</sup>) m<sup>2</sup><br>大家自己算算就知道了。讲到这里，相信金属表面能，大家都可以照着去算一遍了。</p>
<p><strong>注意6：</strong></p>
<p>获取E<sup>surf</sup> 的时候，一定要检查：1） 单点计算是不是收敛了？或者2） 第一个离子步是不是收敛了？</p>
<p>如果没有收敛的话，表面能的计算就是错的。σ<sup>unrel</sup>和E<sup>rel</sup>都跟这个量密切相关。</p>
<h3 id="3-下面我们看一下这篇参考文献中的计算介绍："><a href="#3-下面我们看一下这篇参考文献中的计算介绍：" class="headerlink" title="3 下面我们看一下这篇参考文献中的计算介绍："></a>3 下面我们看一下这篇参考文献中的计算介绍：</h3><p>Shapecontrol in concave metal nanoparticles by etching<br>Nanoscale, 2017,9, 13089-13094 </p>
<p><img src="/2018/09/01/ex47/ex47-9.jpeg" alt=""></p>
<p>这是本人博士期间的一个工作，主要讨论了不同盐酸浓度下Pt纳米颗粒的成长，腐蚀过程以及形貌的预测。有兴趣的可以看看，当然啦，本人也希望大家多多引用。对于表面能的计算，大家可以参考支持信息中的公式1，如下图： </p>
<p><img src="/2018/09/01/ex47/ex47-10.jpeg" alt=""></p>
<p>相信到这里，大家可以完全明白这段话的意思，以及计算的整个流程了。</p>
<h3 id="4-扩展练习："><a href="#4-扩展练习：" class="headerlink" title="4 扩展练习："></a>4 扩展练习：</h3><ol>
<li>重复一下 Hand on Session -III 中 Ni(100)  表面能的计算;</li>
<li>计算下我们前面的 Cu(111) 表面能的计算;</li>
<li>计算下 Cu(100), Cu(110) 的表面能。</li>
<li>对比 Cu(111), Cu(110) 和 Cu(100) 的表面能，分析下规律。</li>
<li>思考1：表面能的计算有什么需要注意的， 请公众号留言回答！</li>
<li>思考2：表面能能用来干什么？请公众号留言回答！</li>
</ol>
<h3 id="5-总结："><a href="#5-总结：" class="headerlink" title="5 总结："></a>5 总结：</h3><p>本节，我们主要讲了表面能的计算，参考的资料有：</p>
<ol>
<li>VASP 官网的 Hand on session (如果你自己下载不到，请认真反思自己！)</li>
<li>我们的参考书： Density Functional Theory: A Practical Inroduction</li>
<li>以及本人发表的文章一篇。 </li>
<li>希望大家可以认真学习，不要急躁！！！</li>
</ol>
<p>本书中只要是用到的，提到的资料，本人都已经明确说明出处，获取方式以及下载链接了，请认真浏览，不要再浪费时间找我索要！</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>表面能</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex48 表面能的计算（二）</title>
    <url>/2018/09/02/ex48/</url>
    <content><![CDATA[<p>前面一节，我们讲解了一下 VASP 官网 Hand-On-Session-III 中表面能的计算。 </p>
<h3 id="1-首先我们要指出一点-VASP-官网的错误"><a href="#1-首先我们要指出一点-VASP-官网的错误" class="headerlink" title="1 首先我们要指出一点 VASP 官网的错误"></a>1 首先我们要指出一点 VASP 官网的错误</h3><p><img src="/2018/09/02/ex48/ex48-1.jpeg" alt=""></p>
<p>最后的表面能应该是： 0.86 - 0.015 = 0.845 eV 而不是 0.71 eV。</p>
<h3 id="2-为什么要除以-2？"><a href="#2-为什么要除以-2？" class="headerlink" title="2  为什么要除以 2？"></a>2  为什么要除以 2？</h3><p>很多人困惑为什么我们在计算的时候，上图中要除以 2。这是因为我们的单点计算中包含有 2 个面。前一节解释说是因为把 Bulk 切成了两半，以至于把大家给弄糊涂了。为什么我们的计算中会有两个面呢？首先我们看下 Slab 模型：</p>
<p><img src="/2018/09/02/ex48/ex48-2.jpeg" alt=""></p>
<p>问题： 上图的结构中有几个表面呢？</p>
<p>答案是 2 个，因为我们的 slab 模型在 z 方向上也具有周期性，虽然我们把底部的两层原子固定来模拟体相，但实际上它们还是表面。如下图：</p>
<p><img src="/2018/09/02/ex48/ex48-3.jpeg" alt=""></p>
<p>那么，为什么 E<sup>rel</sup> 没有除以 2 呢？</p>
<p>这是因为我们只优化了一个表面啊。</p>
<p>如果我们两个表面都要优化的时候，是不是 E<sup>rel</sup> 也除以 2 了呢？</p>
<p>答：是的。</p>
<p>如果你喜欢上下两个面都优化的话，那么这将引申出 slab 模型的两种情况，对称性和非对称性模型。前面我们讲的都是非对称的 slab 模型。那么什么是对称的 slab 模型呢？ 如下图：</p>
<p><img src="/2018/09/02/ex48/ex48-4.png" alt=""></p>
<p>在这个模型中，中间的三层原子被固定用来模拟体相，上下三层的原子放开用来模拟表面。此时，如果你计算表面能的时候，E<sup>rel</sup> 的数值就要除以 2 了。计算公式可以简化为：</p>
<script type="math/tex; mode=display">\begin{align*}
\sigma &=\frac{1}{2A}(E_{surf}-N_{atoms}\times E_{bulk}+E^{rel})\\
&=\frac{1}{2A}(E_{surf}^{rel} -N_{atoms}\times E_{bulk})\\
\end{align*}</script><p>其中： $E_{surf}^{rel}$ 直接就是我们优化完毕之后的对称slab模型的能量。</p>
<p>单个表面的面积 A， slab 模型中的原子数 $N<em>{atoms}$ 和 $E</em>{bulk}$ 这些能量的获取和前面一节讲的内容一致。</p>
<p>注意： 将这个公式和参考书 96 页底部的公式对比一下。然后仔细阅读参考书 97 页的公式各项的说明。</p>
<h3 id="3-对称和非对称slab模型的区别："><a href="#3-对称和非对称slab模型的区别：" class="headerlink" title="3 对称和非对称slab模型的区别："></a>3 对称和非对称slab模型的区别：</h3><ol>
<li>对称 slab 明显具有更多的原子数，在 z 方向更长，需要更多的真空层(上下两层)，这就不可避免地出现了计算量大的缺点，尤其是对于机时捉襟见肘的筒子们来说，这个模型就不用考虑啦；</li>
<li>非对称模型由于其非对称性，在计算过程中会产生偶极矩，注意这个偶极矩是由于模型引入的，并非我们常说的分子中的偶极矩。尤其是当我们要计算一些表面吸附或者反应的时候，两个 slab 之间偶极矩的相互作用会对我们的结果产生影响。但这不是什么大问题，很多计算软件都可以通过控制计算参数来消除或者将这一影响减至最小。</li>
<li>VASP 中可以通过设置：<ol>
<li><code>LDIPOL=.TRUE.</code>(打开偶极校正)</li>
<li><code>IDIPOL = 1-4</code>来解决。 1，2，3分表代表在x，y和z 方向上进行校正。4代表在所有方向上。</li>
</ol>
</li>
</ol>
<p>注意：1 和 2 必须同时加在 INCAR 里面。详见VASP官网的解释： <a href="https://cms.mpi.univie.ac.at/wiki/index.php/LDIPOL">LDIPOL</a> 和 <a href="https://cms.mpi.univie.ac.at/wiki/index.php/IDIPOL">IDIPOL</a></p>
<h3 id="4-表面能计算的参数影响："><a href="#4-表面能计算的参数影响：" class="headerlink" title="4 表面能计算的参数影响："></a>4 表面能计算的参数影响：</h3><p>从公式中可以看出 Slab 的能量和 Bulk 的能量是主要因素： </p>
<ol>
<li><p>Slab 能量：</p>
<ul>
<li>Slab的层数：如参考书中的结果。</li>
</ul>
<p><img src="/2018/09/02/ex48/ex48-5.jpeg" alt=""></p>
<ul>
<li>slab 表面的大小，一般来说 p(1x1) 的即可。当然啦，你可也比较下 p(1x1) 和 p(2x2) 的区别： 这里要注意的是： 改变表面的大小，KPOINTS 也要发生相应的变化，只有这样，两个计算的结果才具有可比性。 </li>
<li>真空层的厚度 这些大家都可以测试一下。</li>
</ul>
</li>
<li><p>Bulk 的能量前面一节我们已经讲过 Bulk 的能量计算了。前面有同学问到： Bulk 计算的时候，模型中应该包含多少个原子？<br>  个人认为：单胞或者原胞的计算均可，当然你也可以扩一下晶胞。但需要注意的是如果你要比较这些不同大小模型中单个原子的能量时，一定要注意 K 点的选择。如果 K 点密度不一致，导致单个原子的能量之间存在细小的差别，这会令你不知所措。有兴趣的可以测试一下。 </p>
</li>
<li><p>此外，大师兄还要推荐一本进阶版的参考书：Theoretical Surface Science: A Microscopic Perspective，作者是 Axel Groβ。课题组主页：<a href="https://www.uni-ulm.de/en/nawi/institute-of-theoretical-chemistry/">https://www.uni-ulm.de/en/nawi/institute-of-theoretical-chemistry/</a></p>
</li>
</ol>
<p><img src="/2018/09/02/ex48/ex48-6.jpeg" alt=""></p>
<p>​    <img src="/2018/09/02/ex48/ex48-7.jpeg" alt=""></p>
<p><img src="/2018/09/02/ex48/ex48-8.jpeg" alt=""></p>
<p>本书关于表面能的介绍在第68页，具体内容大家认真阅读，必定受益匪浅。</p>
<h3 id="5-扩展练习："><a href="#5-扩展练习：" class="headerlink" title="5 扩展练习："></a>5 扩展练习：</h3><ol>
<li>请务必认真阅读参考书中表面能， slab 模型的相关介绍；</li>
<li>认真测试，重复 Cu(111), Cu(110) 和 Cu(100) 面的计算；</li>
<li>仔细阅读 Theoretical Surface Science: A Microscopic Perspective 这本书中关于表面能的内容；</li>
<li>结合计算结果和参考书中的解释，自己参悟一下。</li>
</ol>
<h3 id="6-总结："><a href="#6-总结：" class="headerlink" title="6 总结："></a>6 总结：</h3><p>本节主要回复了一下大家提问的比较多的问题，简单介绍了一下对称和非对称 slab 模型以及一些影响表面能计算的因素。学习 VASP 没有捷径，大家多练习，多出错，多总结分析，时间长了就会慢慢理解了。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>表面能</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex49 功函数（work function）的计算（一）</title>
    <url>/2018/09/03/ex49/</url>
    <content><![CDATA[<p>前面我们讲完了表面的计算，后面两节我们主要讨论一下功函数的计算。</p>
<h3 id="1-功函数的定义"><a href="#1-功函数的定义" class="headerlink" title="1 功函数的定义"></a>1 功函数的定义</h3><p>首先，我们先看一下<strong><a href="https://en.wikipedia.org/wiki/Work_function">维基百科</a></strong>的解释：</p>
<p><strong>功函数</strong>(又称功函、逸出功)是指要使一粒电子立即从固体表面中逸出，所必须提供的最小能量(通常以电子伏特为单位)。这里“立即”一词表示最终电子位置从原子尺度上远离表面但从宏观尺度上依然靠近固体。功函数不是材料体相的本征性质，更准确的说法应为材料表面的性质(比如表面暴露晶面情况和受污染程度)功函数是金属的重要属性。功函数的大小通常大概是金属自由原子电离能的二分之一。</p>
<p>The work function W for a given surface is defined by the difference</p>
<p>W = - eϕ - E<sub>F</sub></p>
<p>where −e is the charge of an electron, ϕ is the electrostatic potential in the vacuum nearby the surface, and E<sub>F</sub> is the Fermi level (electrochemical potential of electrons) inside the material. The term −eϕ is the energy of an electron at rest in the vacuum nearby the surface. In words, the work function is thus defined as the thermodynamic work required to remove an electron from the material to a state at rest in the vacuum nearby the surface.</p>
<p><img src="/2018/09/03/ex49/ex49-1.jpeg" alt=""></p>
<p>我们再看下 <a href="https://goldbook.iupac.org/html/E/E02015.html">IUPAC</a> 官网的解释：</p>
<p>The minimum work needed to extract electrons from the Fermi level of a metal M across a surface carrying no net charge. It is equal to the sum of the potential energy and the kinetic Fermi energy taken with the reverse sign:</p>
<script type="math/tex; mode=display">\phi^{M} = -(V_{e}+\varepsilon_e^ F)</script><p>where $V_{e}$ is the potential energy for electrons in metals and  $\varepsilon_e^ F$ is the kinetic energy of electrons at the Fermi level.</p>
<h3 id="2-VASP-计算功函数的过程"><a href="#2-VASP-计算功函数的过程" class="headerlink" title="2 VASP 计算功函数的过程"></a>2 VASP 计算功函数的过程</h3><p>从前面的定义中可以看出，计算功函数我们只需要得到体系的费米能级和电子所处的静电势能，然后求差即可。</p>
<h4 id="2-1-费米能级的计算："><a href="#2-1-费米能级的计算：" class="headerlink" title="2.1 费米能级的计算："></a>2.1 费米能级的计算：</h4><p>VASP 计算结束之后，通过命令：</p>
<p>grep E-fermi OUTCAR 即可提取出来。</p>
<h4 id="2-2-静电势能的计算："><a href="#2-2-静电势能的计算：" class="headerlink" title="2.2 静电势能的计算："></a>2.2 静电势能的计算：</h4><p>通过在 INCAR 中添加： <code>LVHAR =.TRUE.</code> 这个参数。</p>
<p>加入这个参数，计算结束后，VASP 会输出一个文件： LOCPOT 文件。我们可以通过脚本，或者程序对这个文件后处理来获取静电势能，怎么处理后面会讲的很清楚，大家先不要着急心慌。</p>
<h4 id="2-3-VASP的计算流程："><a href="#2-3-VASP的计算流程：" class="headerlink" title="2.3 VASP的计算流程："></a>2.3 VASP的计算流程：</h4><ol>
<li><p>优化获取稳定的结构</p>
</li>
<li><p>将 CONTCAR 复制成 POSCAR</p>
</li>
<li><p>在 INCAR 中设置单点计算：</p>
<p>方法1：设置 <code>NSW=1 或者 0</code></p>
<p>方法2：设置 <code>IBRION = -1</code></p>
<p>方法3：直接删除 INCAR 中 NSW 这一行，采用默认值</p>
</li>
<li><p>提交任务</p>
<p>注意：</p>
<ol>
<li>如果第一步计算中有保存 WAVECAR，则静态计算的时候可以设置：ISTART = 2 读取一下，以便节省计算时间;</li>
<li>如果没有保存，直接算即可。不要在读不读 WAVECAR 这个问题上瞎操心；</li>
<li>电子步数的默认值是 40，如果你的体系不容易收敛，计算的时候请设置一个较大的 NELM 值，比如 NELM = 500。</li>
</ol>
</li>
</ol>
<h3 id="3-Cu-111-表面的功函数计算"><a href="#3-Cu-111-表面的功函数计算" class="headerlink" title="3 Cu(111) 表面的功函数计算"></a>3 Cu(111) 表面的功函数计算</h3><h4 id="3-1-准备计算文件："><a href="#3-1-准备计算文件：" class="headerlink" title="3.1 准备计算文件："></a>3.1 准备计算文件：</h4><p>新建一个 workfunction 的文件夹，将前面优化计算的： INCAR KPOINTS POTCAR CONTCAR 和提交任务的脚本复制到这个文件夹中。</p>
<h4 id="3-2-修改-INCAR-改为静态（单点）计算"><a href="#3-2-修改-INCAR-改为静态（单点）计算" class="headerlink" title="3.2 修改 INCAR 改为静态（单点）计算"></a>3.2 修改 INCAR 改为静态（单点）计算</h4><h4 id="3-3-修改-INCAR，添加-LVHAR-TRUE-这一行"><a href="#3-3-修改-INCAR，添加-LVHAR-TRUE-这一行" class="headerlink" title="3.3 修改 INCAR，添加 LVHAR = .TRUE. 这一行"></a>3.3 修改 INCAR，添加 LVHAR = .TRUE. 这一行</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System = Cull</span><br><span class="line">ISMEAR = 1 </span><br><span class="line">SIMGA = 0.1</span><br><span class="line">ALGO = FAST</span><br><span class="line">ENCUT = 450</span><br><span class="line">EDIFF = 1E-5</span><br><span class="line"></span><br><span class="line">IDIPOL =.TRUE.</span><br><span class="line">IDIPOL = 3</span><br><span class="line"></span><br><span class="line">NWRITE = 0</span><br><span class="line">LWAVE = .FALSE.</span><br><span class="line">LCHARG = .FALSE.</span><br><span class="line">IBRION = 2</span><br><span class="line">POTIM = 0</span><br><span class="line">EDIFFG = -0.01</span><br><span class="line">NSW = 1 </span><br><span class="line"></span><br><span class="line">LVHAR = .TRUE.</span><br></pre></td></tr></table></figure>
<h4 id="3-4-将-CONTCAR-重命名为-POSCAR"><a href="#3-4-将-CONTCAR-重命名为-POSCAR" class="headerlink" title="3.4 将 CONTCAR 重命名为 POSCAR"></a>3.4 将 CONTCAR 重命名为 POSCAR</h4><h4 id="3-5-提交任务，等待结束。"><a href="#3-5-提交任务，等待结束。" class="headerlink" title="3.5 提交任务，等待结束。"></a>3.5 提交任务，等待结束。</h4><h3 id="4-后处理方法-1：p4vasp"><a href="#4-后处理方法-1：p4vasp" class="headerlink" title="4 后处理方法-1：p4vasp"></a>4 后处理方法-1：p4vasp</h3><p>p4vasp 一直是本人强烈推荐的VASP计算相关的建模，可视化，查看结构，结果的软件。本节我们讲解一下如何通过 p4vasp 对功函数的计算结果可视化。</p>
<h4 id="4-1-导入数据"><a href="#4-1-导入数据" class="headerlink" title="4.1 导入数据"></a>4.1 导入数据</h4><ol>
<li><p>Linux 系统下面，进入计算的目录直接敲命令： p4v &amp; 即可 (我们稍微等下 Windows 用户的操作，后面可视化过程是一样的)</p>
</li>
<li><p>Windows 下面，首先要将计算生成的 LOCPOT 文件保存到本地电脑上。</p>
<p>注意：有时候这个文件可能会很大，下载的时候比较蛋疼，不想下载的话等待下节的讲解。</p>
</li>
<li><p>打开 p4vasp 并导入 LOCPOT 文件：file —&gt; loadsystem，然后找到 LOCPOT 所在的目录，点解导入，效果如下</p>
<p><img src="/2018/09/03/ex49/ex49-2.png" alt=""></p>
</li>
</ol>
<h4 id="4-2-开始可视化-Linux-Windows-都一样了"><a href="#4-2-开始可视化-Linux-Windows-都一样了" class="headerlink" title="4.2 开始可视化 (Linux, Windows 都一样了)"></a>4.2 开始可视化 (Linux, Windows 都一样了)</h4><p>Electronic –&gt; Local potential</p>
<p><img src="/2018/09/03/ex49/ex49-3.png" alt=""></p>
<p>效果如下：</p>
<p><img src="/2018/09/03/ex49/ex49-4.jpeg" alt=""></p>
<p>WOC，这是什么东东？ 是不是算错啦？</p>
<p>别急，看下面：</p>
<p>点击下图中的 <code>Show</code>，会出现三个方向让你选择，一般都是沿着 z 方向的，按照红色箭头点下即可。</p>
<p><img src="/2018/09/03/ex49/ex49-5.png" alt=""></p>
<p>效果如下：</p>
<p><img src="/2018/09/03/ex49/ex49-6.png" alt=""></p>
<p>Wow, Wonderful!!! 是不是很有成就感？</p>
<p>But， 怎么才能获取静电势能的数值呢？ 图中的纵坐标范围太大了，目测取值的话，误差应该在 0.5 eV 左右，太大了，不行。 那么我们只能导出数据，慢慢分析了。</p>
<h4 id="4-3-导出数据"><a href="#4-3-导出数据" class="headerlink" title="4.3 导出数据"></a>4.3 导出数据</h4><p>还记得前面我们讲的 DOS 的计算吗？我们求 <code>d band center</code>，电子数目积分的时候将数据导出来了。同样，图中组成曲线的点的坐标我们也可以导出来。<br>点击： <code>Graph</code>—&gt;<code>Export</code></p>
<p><img src="/2018/09/03/ex49/ex49-7.png" alt=""></p>
<p>选择保存的目录，并给保存的文件一个名字。然后点击，<code>Export</code>， 图中的 cu.dat 就会保存你指定的目录下了。</p>
<p><img src="/2018/09/03/ex49/ex49-8.png" alt=""></p>
<p><strong>注意：</strong></p>
<ol>
<li>名字后面一定要有尾缀<code>.dat</code>或者 <code>.data</code>， 否则会导出失败；</li>
<li>如果按照我说的步骤做的话，还不会弄，请自行查看前面关于 DOS 的计算，已经讲的很清楚了，不要再问我这个问题了。</li>
</ol>
<h4 id="4-4-分析数据"><a href="#4-4-分析数据" class="headerlink" title="4.4 分析数据"></a>4.4 分析数据</h4><p>有了数据，我们就底气十足，什么都不怕了。用 Notepad ++  打开 cu.dat 文件。</p>
<p><strong>注意</strong>： 这里大师兄说的是用 Notepad++，别问我从哪里下载这个神奇的软件。百度会告诉你的。</p>
<p>打开之后，我们会发现，和 DOS 计算导出来的结果有几分神似。数据共有三部分，每两部分之间由空行分开。</p>
<p><img src="/2018/09/03/ex49/ex49-9.png" alt=""></p>
<p><img src="/2018/09/03/ex49/ex49-10.png" alt=""></p>
<p>这三部分的顺序，如下图，</p>
<p><img src="/2018/09/03/ex49/ex49-11.png" alt=""></p>
<p>我们从图中可以看出，基本上在 10-18 的这个区间范围，三条线的数据差不多是一样的。静电势能的话，可以通过红线( Average 那条线)，也就是第二部分来获取。可以查看下 14-15 $\AA$ 时红色曲线的数值，如下图：</p>
<p><img src="/2018/09/03/ex49/ex49-12.png" alt=""></p>
<h4 id="4-5-获取费米能级"><a href="#4-5-获取费米能级" class="headerlink" title="4.5 获取费米能级"></a>4.5 获取费米能级</h4><p><img src="/2018/09/03/ex49/ex49-13.png" alt=""></p>
<p>套公式，功函数为： 4.84-0.03 = 4.81 eV</p>
<p>对比下维基百科中的数值：</p>
<p><img src="/2018/09/03/ex49/ex49-14.png" alt=""></p>
<p>注意：虽然维基百科给了功函数的一些数值，在发表文章的时候，你不能直接放 wiki 的链接到论文里面，这显得有些不专业。建议大家去参考 CRC handbook 里面的数值，然后引用。别问我 CRC handbook 是啥玩意，前面我也讲过了。 </p>
<h3 id="5-扩展练习："><a href="#5-扩展练习：" class="headerlink" title="5 扩展练习："></a>5 扩展练习：</h3><ol>
<li>重复本节的计算；</li>
<li>重复 VASP 官网 <a href="https://cms.mpi.univie.ac.at/wiki/index.php/Ni_111_surface_high_precision">Ni(111) 表面</a> 的计算。</li>
</ol>
<h3 id="6-总结："><a href="#6-总结：" class="headerlink" title="6 总结："></a>6 总结：</h3><p>本节我们主要</p>
<ol>
<li><p>介绍了下功函数的定义(从别的地方拷过来的)；</p>
</li>
<li><p>介绍了下 VASP 怎么计算功函数；</p>
</li>
<li><p>怎么用 p4vasp 可视化，导出数据，并获取静电势能；</p>
</li>
<li><p>怎么获取 fermi level；</p>
</li>
<li><p>举例介绍了p(1x1)Cu(111) slab 的功函数计算流程，计算结果下载：</p>
<p>链接：<a href="https://pan.baidu.com/s/1c2m52UG">https://pan.baidu.com/s/1c2m52UG</a>   密码：kfse</p>
</li>
</ol>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>p4vasp</tag>
        <tag>功函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex50 功函数（work function）的计算（二）</title>
    <url>/2018/09/04/ex50/</url>
    <content><![CDATA[<p><img src="/2018/09/04/ex50/ex50-1.png" alt=""></p>
<p>前面一节我们介绍了计算功函数的具体流程，以及用p4vasp获取真空能级的方法。</p>
<p>本节我们介绍另外两个方法，从本质上来说，这些方法是一样的，都是基于对 LOCPOT 中数据的处理。</p>
<h3 id="1-使用-vtotav-v5-2f-脚本"><a href="#1-使用-vtotav-v5-2f-脚本" class="headerlink" title="1 使用 vtotav-v5.2f 脚本"></a>1 使用 vtotav-v5.2f 脚本</h3><p>操作流程如下：</p>
<p><img src="/2018/09/04/ex50/ex50-2.jpeg" alt=""></p>
<p><strong>注意：</strong></p>
<ol>
<li><p><code>gfortran -o vtotav.x vtotav-5.2f</code></p>
<p>这个命令将 <code>vtotav-5.2f</code> 这 个脚本编译成可执行文件 <code>vtotav.x</code>。</p>
<p>gfortran 不管用的话可以试试<code>ifort -o vtotav.xvtotav-5.2f</code>这个命令。</p>
</li>
<li><p>./vtotav.x 在当前目录下运行这个可执行文件;会让你选择计算的方向，这里我们 slab 的真空层是在 z 方向，所以我们输入 3  (回想一下，上一节，我们在 p4vasp 中选择z方向的鼠标操作，它们是一样的)，都是讲 LOCPOT 文件处理，然后生成z方向的相关数据。</p>
</li>
<li><p>运行完毕后，当前目录下会多出来一个 VLINE 文件。这个文件就是 p4vasp 中选择 z 方向之后所显示的红线数据，(不过横坐标有些不同)。</p>
</li>
<li><p>我们看一下 VLINE 文件的数据内容，第一行中 224 代表有 224 个点，3 代表 z 方向。</p>
</li>
<li><p>VLINE 文件中横坐标为当前点的序号，从 1-224，而 p4vasp 中导出来的文件，横坐标为 z 方向的坐标，不过这个不影响我们对真空能级的计算。</p>
</li>
</ol>
<p>上图中最后的两行命令，</p>
<ol>
<li>从上一级目录下拷贝了一个 python 脚本，名为：<code>wplot-f.py</code>；</li>
<li>运行这个 python 脚本，效果如下：</li>
</ol>
<p><img src="/2018/09/04/ex50/ex50-3.jpeg" alt=""></p>
<p>我们又得到了前面一节的功函数的图像。真空能级，大家从 150 前后取个值即可，也可以在一段直线的区间范围内求个平均数。</p>
<p>对比下前面一节和本节中的数据：</p>
<p><img src="/2018/09/04/ex50/ex50-4.png" alt=""></p>
<p>左图为本节的，右图为上节的。</p>
<p>Python 脚本这么神奇，是怎么写出来的呢？脚本内容如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># Written By Qiang for workfunction Visualization from VLINE file</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = []</span><br><span class="line">y = []</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;VLINE&quot;</span>, mode=<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">next</span>(f)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        xy=line.rstrip().split()</span><br><span class="line">        x.append(<span class="built_in">float</span>(xy[<span class="number">0</span>]))</span><br><span class="line">        y.append(<span class="built_in">float</span>(xy[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">plt.plot(x,y) </span><br><span class="line">plt.savefig(<span class="string">&#x27;workfunction&#x27;</span> + <span class="string">&#x27;.pdf&#x27;</span>, dpi=<span class="number">400</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>思路如下：</p>
<ol>
<li>读取 VLINE 文件；</li>
<li>第一行画图的时候用不着，需要跳过，next(f)；</li>
<li>将剩下的那些行中，第一个数存到 x 列表里面，第二个数存到 y 列表里面；</li>
<li>使用 matplotlib 中的 pyplot 读取 x， y 列表中的数据，进行画图： plt.plot(x,y)；</li>
<li>将生成的图保存成 workfunction.pdf 文件，分辨率 dpi 为 400。</li>
</ol>
<p><strong>注意：</strong></p>
<ol>
<li>如果你想保存成 eps, png, jpg,只需将 .pdf 改成 .eps, .png, .jpg 即可；</li>
<li>如果想要分辨率更高，可以修改400这个数值；</li>
<li>如果只想保存成 pdf 文件，不想弹出图片的查看窗口，把 plt.show() 这一行注释掉就可以了， # plt.show()；</li>
<li>如果只想看一下图，不想保存 pdf 文件，将第 16 行注释掉就可以了。</li>
</ol>
<h3 id="2-使用-vtotav-py-脚本"><a href="#2-使用-vtotav-py-脚本" class="headerlink" title="2 使用 vtotav.py 脚本"></a>2 使用 vtotav.py 脚本</h3><p>第一个脚本就讲到这里了，这个脚本不错，唯一的缺点就是横坐标不是 z 方向的数值，那么我们看一下第二个脚本的操作。</p>
<p><img src="/2018/09/04/ex50/ex50-5.jpeg" alt=""></p>
<p><strong>注意：</strong></p>
<ol>
<li><p>这里用到的脚本名字为：<code>vtotav.py</code>；</p>
</li>
<li><p>vtotav.py LOCPOT z  这个命令意思是，用 vtotav.py 读取 LOCPOT 文件，并处理生成 z 方向的数据；</p>
</li>
<li><p>脚本运行完毕后，目录中多了一个 LOCPOT_Z 文件，这个文件内容如下：</p>
<p><img src="/2018/09/04/ex50/ex50-6.jpeg" alt=""></p>
</li>
<li><p>图中最后两行，</p>
<ol>
<li>大师兄又从前面的目录下拷贝了一个脚本： wplot.py；</li>
<li>然后运行这个 python 脚本， 效果如下：</li>
</ol>
</li>
</ol>
<p><img src="/2018/09/04/ex50/ex50-7.jpeg" alt=""></p>
<p>这个脚本中，横坐标为 z 方向的大小，比前面的脚本有所改进，和 p4vasp 的数据是一样的。首先我们先看一下可视化的脚本，然后再讲解 vtotav.py 这个脚本的获取和使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># Written By Qiang for workfunction Visualization from LOCPOT_Z file</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">x = []</span><br><span class="line">y = []</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;LOCPOT_Z&quot;</span>, mode=<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    first_line = f.readline()</span><br><span class="line">    name_x = first_line.split()[<span class="number">1</span>]</span><br><span class="line">    name_y = first_line.split()[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        xy=line.rstrip().split()</span><br><span class="line">        x.append(<span class="built_in">float</span>(xy[<span class="number">0</span>]))</span><br><span class="line">        y.append(<span class="built_in">float</span>(xy[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">plt.plot(x,y) </span><br><span class="line">plt.xlabel(name_x) </span><br><span class="line">plt.ylabel(name_y) </span><br><span class="line">plt.savefig(<span class="string">&#x27;workfunction&#x27;</span> + <span class="string">&#x27;.pdf&#x27;</span>, dpi=<span class="number">400</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>这个跟前面的那个脚本很像，不同的地方在于这个脚本中读取了第一行的内容，并将它们作为横坐标和纵坐标的名字。(Distance 和 Potential)</p>
<h3 id="3-vtotav-py-脚本的获取和使用"><a href="#3-vtotav-py-脚本的获取和使用" class="headerlink" title="3 vtotav.py 脚本的获取和使用"></a>3 vtotav.py 脚本的获取和使用</h3><p>这个脚本可以在github网站免费下载，网址为：</p>
<p><a href="https://github.com/compphys/ase_tools/blob/master/scripts/vtotav.py">https://github.com/compphys/ase_tools/blob/master/scripts/vtotav.py</a> </p>
<p><img src="/2018/09/04/ex50/ex50-8.jpeg" alt=""></p>
<p>本人的做法是：</p>
<ol>
<li>把图中的代码复制下来，然后保存到一个文本里面，将文本命名为：vtotav.py；</li>
<li>赋予脚本可执行权限： chmod u+x vtotav.py；</li>
<li>将脚本移至 ~/bin 目录下： mv vtotav.py ~/bin；</li>
<li>然后直接用就可以了，跟前面图中的操作一样。</li>
</ol>
<p>不过本人刚刚发现这个脚本可以按照下面的方法下载，下载完成后，重复前面的 2-4 步即可：</p>
<ol>
<li><p>点击 scripts</p>
<p><img src="/2018/09/04/ex50/ex50-9.png" alt=""></p>
</li>
<li><p>鼠标右击这个脚本</p>
<p><img src="/2018/09/04/ex50/ex50-10.png" alt=""></p>
</li>
<li><p>另存为，然后选择保存的目录</p>
<p><img src="/2018/09/04/ex50/ex50-11.png" alt=""></p>
</li>
<li><p>这里本人保存到电脑桌面上了</p>
<p><img src="/2018/09/04/ex50/ex50-12.png" alt=""></p>
</li>
</ol>
<p><strong>注意：</strong></p>
<p>如果你运行脚本的时候，没有得到下面图中的这个结果：</p>
<p><img src="/2018/09/04/ex50/ex50-13.jpeg" alt=""></p>
<p>原因可能在与：</p>
<p><img src="/2018/09/04/ex50/ex50-14.png" alt=""></p>
<p>这个脚本需要调用 ase 这个程序中的模块，那么什么是 ase 呢？ase 怎么安装呢？</p>
<p>对于 ase，本书的 ex0 中就已经提到了，可能大家也忘记了。ASE 是 Atomic Simulation Environment 的缩写，这是一个非常强大的工具。官方网址：</p>
<p><a href="https://wiki.fysik.dtu.dk/ase/">https://wiki.fysik.dtu.dk/ase/</a></p>
<p>是大大师兄(本人的师兄)做博后的课题组开发出来。Linux 系统下面，安装 ASE 很简单：</p>
<p><img src="/2018/09/04/ex50/ex50-15.png" alt=""></p>
<p>一个命令就可以搞定了，Soooo eeeeeasy! 至于 Windows 下面嘛，本人不会。不想用 Linux，还想用 ASE 的就只能自己捣鼓捣鼓了。捣鼓好了也不要给我发教程，因为本人不推荐用 Windows 做计算。</p>
<h3 id="4-扩展练习："><a href="#4-扩展练习：" class="headerlink" title="4 扩展练习："></a>4 扩展练习：</h3><ol>
<li>下载本节的例子，以及所有的脚本，按照讲解的操作一遍流程，链接：<a href="https://pan.baidu.com/s/1dEHvHr7">https://pan.baidu.com/s/1dEHvHr7</a> 密码：ponm；</li>
<li>Linux 用户自行安装 ASE，使用 vtotav.py 这个脚本走一遍过程；</li>
<li>熟悉下用 python 画图的基本方式。</li>
</ol>
<h3 id="5-总结："><a href="#5-总结：" class="headerlink" title="5 总结："></a>5 总结：</h3><p>讲解到这里，功函数的可视化也就差不多了。当然了，只要你有了数据，用什么画图都可以， excel, origin, matlab, gplot… 不过貌似作图也没什么用，我们大体上看下，然后找个区间取静电势的数值才是正事。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>p4vasp</tag>
        <tag>功函数</tag>
        <tag>vtotav</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex51 影响功函数计算的因素（一）</title>
    <url>/2018/09/05/ex51/</url>
    <content><![CDATA[<p>前面我们通过 Cu(111) 表面作为例子，学会了功函数计算的基本步骤和可视化过程。那么功函数计算的时候，需要注意的事项有哪些呢？</p>
<h3 id="1-INCAR中的参数"><a href="#1-INCAR中的参数" class="headerlink" title="1  INCAR中的参数"></a>1  INCAR中的参数</h3><p>计算功函数的参数：<code>LVHAR =.TRUE.</code></p>
<p>加入这一参数时，VASP 只将静电势能写入 LOCPOT 文件中。</p>
<p>在早期的 VASP 版本中，静电势的写入是通过设置 LVTOT 这个参数的。</p>
<p>在 5.2.12 版本之后，如果你设置 <code>LVTOT= .TRUE.</code>，那么静电势，交换相关势都会写入到 LVTOT 中。由于我们计算功函数的时候，只需要静电势这一部分。所以，如果你用的是 5.2.12 版本之后的 VASP，设置 <code>LVHAR= .TRUE.</code> 即可。</p>
<p>如果有疑惑的话，不妨做个测试，分别设置 LVTOT 和 LVHAR = .TRUE. 然后做个单点计算对比下结果。</p>
<p>设置 <code>LVTOT = .TRUE.</code> 的结果如下：</p>
<p><img src="/2018/09/05/ex51/ex51-2.jpeg" alt=""></p>
<p>设置 <code>LVHAR = .TRUE.</code> 的结果如下：</p>
<p><img src="/2018/09/05/ex51/ex51-3.jpeg" alt=""></p>
<p>我们对比下 13-15 $\AA$范围内纵坐标的大小和平均值</p>
<p><img src="/2018/09/05/ex51/ex51-4.png" alt=""></p>
<p>很显然，两个参数对功函数的影响是不可忽略的。使用 LVTOT 这个参数，由于加入了交换相关势，曲线变得不再那么光滑，并且与 LVHAR 的结果有一定的偏差。所以，在计算功函数的时候，LVHAR 这个参数一定要注意。</p>
<p> 这一点也体现在VASP官网最新的ppt中，如下如：(自己主动根据下图中的关键词找这个 ppt，别问我要，也不要在大师兄群里求助浪费别人的时间。)</p>
<p><img src="/2018/09/05/ex51/ex51-5.jpeg" alt=""></p>
<p><img src="/2018/09/05/ex51/ex51-6.png" alt=""></p>
<p><strong>注意：</strong></p>
<p>在 Hand-on-session (<strong>老版本</strong>的官方教程)中，使用的是 LVTOT 这个参数。老版本就是过时的意思。希望大家的以新版本的计算为准。</p>
<p><img src="/2018/09/05/ex51/ex51-7.png" alt=""></p>
<p>老版本中功函数的计算例子。</p>
<h3 id="2-真空层的厚度及修改"><a href="#2-真空层的厚度及修改" class="headerlink" title="2 真空层的厚度及修改"></a>2 真空层的厚度及修改</h3><p>真空层的厚度：指的是 slab 在 z (或者 c )方向上的长度减去表面原子在 z 方向的坐标。</p>
<p><img src="/2018/09/05/ex51/ex51-8.png" alt=""></p>
<p>Slab 方向的长度，指的是 POSCAR 或者 CONTCAR 中第 5 行中的数值，上图箭头所指的地方。</p>
<p>那么我们怎么修改真空层的厚度呢？</p>
<p>由于 slab 模型中的原子部分就在那边乖乖地待着，我们只需改变 slab 中晶格常数在 z 或者 c 方向的长度即可。</p>
<p>例子1：上图中真空层的厚度为 15 $\AA$，我们需要一个 20 $\AA$  的 slab 模型，也就是在 21.2994 的基础上再加 5 个 $\AA$，等于 26.2994。但这样做，对不对呢？修改之后的 POSCAR：</p>
<p><img src="/2018/09/05/ex51/ex51-9.png" alt=""></p>
<p>结构如下图：</p>
<p><img src="/2018/09/05/ex51/ex51-10.png" alt=""></p>
<p>我们发现 slab 的 Cu 原子部分之间好像也被拉长了。测量了一下两个 Cu 原子之间的距离为： 2.956 Å。</p>
<p><img src="/2018/09/05/ex51/ex51-11.png" alt=""></p>
<p>修改之前为： 2.547 Å。</p>
<p><img src="/2018/09/05/ex51/ex51-12.png" alt=""></p>
<p>所以：我们在前面的操作中，直接修改的 z 方向的数值，<strong>方法是错误的。</strong></p>
<p>原因在于：前面的结构中坐标为分数坐标： Direct</p>
<p>我们修改完成之后，Cu 原子在 c 方向的距离也会发生相应的改变。</p>
<p>所以，如果直接修改 POSCAR 或者 CONTCAR 改变真空层厚度的话，我们一定一定要先将它们转化为 Cartesian 坐标。怎么转化呢？</p>
<p>方法1：用软件操作，比如 p4vasp。</p>
<p><img src="/2018/09/05/ex51/ex51-13.png" alt=""></p>
<p>我们可以切换坐标通过鼠标点一下即可，然后保存成 Cartesian 的 POSCAR。</p>
<p>当然啦，也可以使用其他软件，比如 VESTA 等等，更好的选择，也欢迎留言补充。</p>
<p>方法2：使用脚本转换：</p>
<ol>
<li><p>VASP 官网在 POSCAR 的解释部分，提到了怎么进行坐标切换的公式。</p>
<p>链接如下：<a href="https://cms.mpi.univie.ac.at/vasp/vasp/POSCAR_file.html">https://cms.mpi.univie.ac.at/vasp/vasp/POSCAR_file.html</a> </p>
<p><img src="/2018/09/05/ex51/ex51-14.png" alt=""></p>
</li>
<li><p>在此基础上，本人写了一个 python 的小脚本，可以实现 Direct 到 Cartesian 的转换。 </p>
<p>运行如下：</p>
<p><img src="/2018/09/05/ex51/ex51-15.png" alt=""></p>
<p>图中流程的解释：</p>
<ol>
<li>将一个计算中的 CONTCAR 复制过来；</li>
<li>使用 head -n 10 看一下这个 CONTCAR 的文件结构。(10 指的是前面 10 行，如果你想看前面 5 行，使用 head -n 5 )；</li>
<li>dire2cart.py CONTCAR  使用脚本进行转换，转换的对象为 CONTCAR；</li>
<li>转换完成后，Cartesian 的保存为 CONTCAR_C 文件；</li>
<li>cat CONTCAR_C 这个命令查看转化后的内容。(当然也可以继续使用前面的 head 命令) </li>
</ol>
<p>本脚本下载链接： <a href="https://pan.baidu.com/s/1eRMJ7m6">https://pan.baidu.com/s/1eRMJ7m6</a>   密码：btsl</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment">#Convert direc coordiation to cartesian Writen By Qiang </span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line">script, file_to_be_converted = sys.argv </span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">###################################</span></span><br><span class="line"><span class="string">#                                 #</span></span><br><span class="line"><span class="string">#for VASP 5.2 or higher versions  #</span></span><br><span class="line"><span class="string">#                                 #</span></span><br><span class="line"><span class="string">###################################</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line">file_read = <span class="built_in">open</span>(file_to_be_converted, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">line = file_read.readlines()</span><br><span class="line">a1 = <span class="built_in">float</span>(line[<span class="number">2</span>].split()[<span class="number">0</span>])</span><br><span class="line">a2 = <span class="built_in">float</span>(line[<span class="number">3</span>].split()[<span class="number">0</span>])</span><br><span class="line">a3 = <span class="built_in">float</span>(line[<span class="number">4</span>].split()[<span class="number">0</span>])</span><br><span class="line">b1 = <span class="built_in">float</span>(line[<span class="number">2</span>].split()[<span class="number">1</span>])</span><br><span class="line">b2 = <span class="built_in">float</span>(line[<span class="number">3</span>].split()[<span class="number">1</span>])</span><br><span class="line">b3 = <span class="built_in">float</span>(line[<span class="number">4</span>].split()[<span class="number">1</span>])</span><br><span class="line">z1 = <span class="built_in">float</span>(line[<span class="number">2</span>].split()[<span class="number">2</span>])</span><br><span class="line">z2 = <span class="built_in">float</span>(line[<span class="number">3</span>].split()[<span class="number">2</span>])</span><br><span class="line">z3 = <span class="built_in">float</span>(line[<span class="number">4</span>].split()[<span class="number">2</span>])</span><br><span class="line"> </span><br><span class="line">num_atoms = <span class="built_in">sum</span>([<span class="built_in">int</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> line[<span class="number">6</span>].split()])</span><br><span class="line"> </span><br><span class="line">x_cartesian = []</span><br><span class="line">y_cartesian = []</span><br><span class="line">z_cartesian = []</span><br><span class="line">tf = []</span><br><span class="line"> </span><br><span class="line">start_num = <span class="number">9</span> <span class="comment"># Default: With Selected T T T, coordination starts from line 9</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert</span>():</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start_num, num_atoms + start_num):</span><br><span class="line">        x_cartesian.append(<span class="built_in">float</span>(line[i].split()[<span class="number">0</span>]) * a1 + <span class="built_in">float</span>(line[i].split()[<span class="number">1</span>]) * a2 + <span class="built_in">float</span>(line[i].split()[<span class="number">2</span>]) * a3)</span><br><span class="line">        y_cartesian.append(<span class="built_in">float</span>(line[i].split()[<span class="number">0</span>]) * b1 + <span class="built_in">float</span>(line[i].split()[<span class="number">1</span>]) * b2 + <span class="built_in">float</span>(line[i].split()[<span class="number">2</span>]) * b3)</span><br><span class="line">        z_cartesian.append(<span class="built_in">float</span>(line[i].split()[<span class="number">0</span>]) * z1 + <span class="built_in">float</span>(line[i].split()[<span class="number">1</span>]) * z2 + <span class="built_in">float</span>(line[i].split()[<span class="number">2</span>]) * z3)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(line[i].split()) &gt; <span class="number">3</span>:   <span class="comment"># if  T T T exist, there are more than 3 elements in the list line[i].split()</span></span><br><span class="line">            tf.append((line[i].split()[<span class="number">3</span>]))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tf.append(<span class="string">&#x27; &#x27;</span>)   <span class="comment"># if there is no T T T, use space instead. </span></span><br><span class="line">     </span><br><span class="line">    file_out = <span class="built_in">open</span>(file_to_be_converted+<span class="string">&#x27;_C&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">7</span>):</span><br><span class="line">        file_out.write(line[i].rstrip() + <span class="string">&#x27;\n&#x27;</span>)  <span class="comment"># first 7 lines are kept the same </span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;S&#x27;</span> <span class="keyword">in</span> line[<span class="number">7</span>]:</span><br><span class="line">        file_out.write(line[<span class="number">7</span>].rstrip()+ <span class="string">&#x27;\n&#x27;</span>)  <span class="comment"># if  T T T exists, write the Selective line </span></span><br><span class="line">    file_out.write(<span class="string">&#x27;Cartesian&#x27;</span> + <span class="string">&#x27;\n&#x27;</span>)          <span class="comment"># Coordination system is Cartesian now. </span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(x_cartesian)):</span><br><span class="line">        file_out.write(<span class="string">&quot;%+-3.10f   %+-3.10f   %+-3.10f   %s %s %s\n&quot;</span> </span><br><span class="line">        %(x_cartesian[i], y_cartesian[i], z_cartesian[i], tf[i], tf[i], tf[i]))</span><br><span class="line">     </span><br><span class="line">    file_out.close()</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;-----------------------------------------------------\n&#x27;</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;POSCAR with Cartesian Coordiations is named as %s_C\n&#x27;</span> %(file_to_be_converted)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;-----------------------------------------------------\n&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> line[<span class="number">7</span>][<span class="number">0</span>]  == <span class="string">&#x27;S&#x27;</span> <span class="keyword">or</span> line[<span class="number">7</span>][<span class="number">0</span>]  == <span class="string">&#x27;s&#x27;</span>:  <span class="comment"># # With Selected T T T, coordination starts from line 9</span></span><br><span class="line">    start_num = <span class="number">9</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>  line[<span class="number">8</span>][<span class="number">0</span>]  == <span class="string">&#x27;D&#x27;</span> <span class="keyword">or</span> line[<span class="number">8</span>][<span class="number">0</span>]  == <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">This POSCAR has Direct Coordinations, Conversion is starting....</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">              &quot;&quot;&quot;</span></span><br><span class="line">        convert()</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">elif</span>  line[<span class="number">8</span>][<span class="number">0</span>]  == <span class="string">&#x27;C&#x27;</span> <span class="keyword">or</span> line[<span class="number">8</span>][<span class="number">0</span>]  == <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">This POSCAR has Cartesian Coordinations! Process is aborted!</span></span><br><span class="line"><span class="string">               </span></span><br><span class="line"><span class="string">              &quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">else</span> : </span><br><span class="line">    <span class="built_in">print</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">----------------------------------------------------</span></span><br><span class="line"><span class="string">Pay Attetion! There is no TTT in coordinations part!</span></span><br><span class="line"><span class="string">----------------------------------------------------</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">     </span><br><span class="line">    start_num = <span class="number">8</span> <span class="comment"># without Selected, No  T T T , coordination starts from line 8 </span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span>  line[<span class="number">7</span>][<span class="number">0</span>]  == <span class="string">&#x27;D&#x27;</span> <span class="keyword">or</span> line[<span class="number">7</span>][<span class="number">0</span>]  == <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">This POSCAR has Direct Coordinations, Contersion starts....</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">        convert()</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">elif</span>  line[<span class="number">7</span>][<span class="number">0</span>]  == <span class="string">&#x27;C&#x27;</span> <span class="keyword">or</span> line[<span class="number">7</span>][<span class="number">0</span>]  == <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="string">This POSCAR has Cartesian Coordinations already! </span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">Process is aborted!</span></span><br><span class="line"><span class="string">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line">file_read.close()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>那么怎么把 Cartesian 转化为 Direct 呢？</p>
<ol>
<li>使用 VASP，因为 VASP 的默认输出就是 Direct 坐标，算个单点就可以啦（笑话，别当真！）；</li>
<li>使用 p4vasp 等其他软件；</li>
<li>写个脚本倒着再做一遍，不过本人经常使用的是 Cartesian 坐标，懒得再写了，有兴趣的可以自己试试。</li>
</ol>
<h3 id="3-批量处理POSCAR"><a href="#3-批量处理POSCAR" class="headerlink" title="3 批量处理POSCAR"></a>3 批量处理POSCAR</h3><p>当我们完成转化后，就可以批量处理 Cartesian 坐标的 POSCAR 了。</p>
<ol>
<li><p>先准备一个文件夹，名字为 10，这个文件夹中有一个真空层为：10 Å 的 POSCAR 以及 INCAR, KPOINTS, POTCAR， 任务脚本；</p>
</li>
<li><p>运行命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in $(seq 12 2 36); do cp 10 $i ; sed -i &quot;5s/16/$((6+$i))/g&quot; $i/POSCAR; done</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例演示：</p>
<p><img src="/2018/09/05/ex51/ex51-16.png" alt=""></p>
<p>运行完这个命令后,会生成从 12 到 36 的 N 个文件夹，每个文件夹之间间隔为 2。我们通过下面这个命令查看所有文件夹中 POSCAR 中 z 方向的大小：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in *; do head -n 5 $i/POSCAR | tail -n 1 ; done</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>解释：</strong></p>
<ul>
<li><p>head -n 5 $i/POSCAR 获取POSCAAR前5行中的内容，</p>
</li>
<li><p>后面跟着一个 |tail -n 1， 这个命令的意思是，显示前面5行中的最后一行。</p>
</li>
<li><p>head 和 tail 这两个命令之间用  |  (pipe) 连在一起，表示将前面 head 命令的结果传递给后面的 tail 命令。</p>
</li>
<li><p>任务准备好之后，批量提交就可以了。(不会的话，请前面自己翻批量操作的介绍。)</p>
</li>
</ul>
<h3 id="4-扩展练习："><a href="#4-扩展练习：" class="headerlink" title="4 扩展练习："></a>4 扩展练习：</h3><ol>
<li>使用 LVTOT 和 LVHAR 测试一下，加深下印象；</li>
<li>使用不同的测试不同真空层对功函数的影响以遍下一节的学习。</li>
</ol>
<h3 id="5-总结："><a href="#5-总结：" class="headerlink" title="5 总结："></a>5 总结：</h3><p>下一节我们讨论一下真空层对计算功函数的影响，以及如何批量获取真空能级。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>p4vasp</tag>
        <tag>功函数</tag>
        <tag>vtotav</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex52 影响功函数计算的因素（二）</title>
    <url>/2018/09/06/ex52/</url>
    <content><![CDATA[<p>前面功函数的计算流程( VASP 计算细节以及结果分析)，我们已经掌握了。这一节介绍一下影响功函数的主要因素：真空层的厚度。首先个人经验：计算功函数的时候，真空层厚度一定要足够。</p>
<p><img src="/2018/09/06/ex52/ex52-0.png" alt=""></p>
<p>这里有两点：</p>
<ol>
<li>多厚才算足够?具体要根据自己的体系测试下，一般来说 20 Å 左右足以。</li>
<li>是不是越厚越好? 越厚的话，计算出来的结果差别不大，但会增加计算量。前面我们讲过影响计算量的因素。</li>
</ol>
<p>我们以 Cu(111) 表面的例子，简单介绍下真空层厚度对功函数的影响。</p>
<h3 id="1-不同真空层厚度的测试-上一节内容"><a href="#1-不同真空层厚度的测试-上一节内容" class="headerlink" title="1 不同真空层厚度的测试(上一节内容)"></a>1 不同真空层厚度的测试(上一节内容)</h3><p><img src="/2018/09/06/ex52/ex52-1.png" alt=""></p>
<ol>
<li><p>先准备一个真空层为 10 Å 的计算文件夹： POSCAR 如上图；</p>
</li>
<li><p>将前面两节的 INCAR,KPOINTS, POTCAR, 以及提交任务的脚本复制过来；</p>
</li>
<li><p>批量生成测试文件，每个文件夹以真空层的厚度命名。命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in $(seq 12 2 36); do cp 10 $i; sed -i &quot;5s/16/$((6+$i))/g&quot;$i/POSCAR ; done</span><br></pre></td></tr></table></figure>
</li>
<li><p>批量提交任务。</p>
</li>
</ol>
<p><strong>注意：</strong></p>
<ol>
<li>这样的批量操作本书刚刚开始的时候就已经讲到了，这里不要再问我。</li>
<li>如果不会用这个办法批量制作输入文件，想其他的办法批量操作，条条大路通罗马，不要死磕在我的这个命令上。</li>
</ol>
<h3 id="2-结果处理"><a href="#2-结果处理" class="headerlink" title="2 结果处理"></a>2 结果处理</h3><p>前面的测试计算中，共有 14 个任务。在 Ex50 这一节中<code>vtotav-v5.2f</code>, <code>vtotav.py</code> 或者 p4vasp 这三种可视化的方法，我们查找真空能级的数值，都必须读取数据文件，比如 VLINE, LOCPOT_Z 或者 p4vasp 导出来的 *dat 文件。所以，我们要分别在这 14 个任务的文件夹中重复 Ex50 的操作14次。手动挨个弄可以完全实现，但本人不想这么做，因为这样弄除了让你的操作更熟练些外，并不会有其他的收获。那就写个脚本批量处理吧。</p>
<p><img src="/2018/09/06/ex52/ex52-2.png" alt=""></p>
<p>首先我们分析下上图： 我们获取的真空能级在图中直线部分中间的一个点或者一个小区间的平均值。大约是真空层一半的高度。比如，我们的表层原子 z 方向坐标为 6，真空层厚度为 16，那么我们可以取 6 + (16/2)= 14 时对于的点来得到真空能级。也可以通过 [14-1, 14+1] 这个区间中所有的真空能级求平均数来获得。下面我们看一下脚本的主要内容：</p>
<ol>
<li><p>注意部分：</p>
<p>使用这个脚本的时候，需要注意的内容。本人写了一堆废话在脚本里面，主要是提醒大家使用脚本的时候，需要注意的一些事项。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Welcome to visit our website: www.bigbrosci.com to get more useful information.</span></span><br><span class="line"> </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Written By Qiang </span></span><br><span class="line"><span class="string">This script has two functions:</span></span><br><span class="line"><span class="string"> 1) workfunction Visualization from LOCPOT_Z file</span></span><br><span class="line"><span class="string"> 2) Roughly estimate the Vaccum Energy</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Please Contact lqcata@gmail.com if you have questions.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Note1: Read POSCAR with Cartesian coordinations! </span></span><br><span class="line"><span class="string">  This means </span></span><br><span class="line"><span class="string">  1) you have to convet the direct to cartesian firstly </span></span><br><span class="line"><span class="string">  2) otherwise you will get an error.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Note2: Read LOCPOT_Z to plot the figure and calculate the vaccum energy</span></span><br><span class="line"><span class="string">  This means </span></span><br><span class="line"><span class="string">  1)1you have to run command:  work.py LOCPOT z firstly to get the LOCPOT_Z file before use this script</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Note3: the idea to calculate the vaccum energy is following:</span></span><br><span class="line"><span class="string">  1) get the middle z value in the plateau: </span></span><br><span class="line"><span class="string">     middle z value = ( coordination of the highest atom + length of the slab in z direction) / 2 </span></span><br><span class="line"><span class="string">  2) selecte the area to calculate the vaccum energy: </span></span><br><span class="line"><span class="string">     from  (middle z  value - 1) to (middle z value + 1)  unit is in angstrom </span></span><br><span class="line"><span class="string">  3) do the average of all points y direction.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Note 4: this is only a rough estimation but useful.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Note 5: Check the figure firstly and then use the numbers calculated from this script. </span></span><br><span class="line"><span class="string">  1) If the midlle z value is far from the plateau in the figure, you have to calculate the energy by hand.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>脚本是谁写的，主要功能是什么；</li>
<li>脚本读取 POSCAR, POSCAR 要为 Cartesian 坐标；</li>
<li>脚本默认读取 LOCPOT_Z 文件，如果没有该文件，你需要做的一些事情(生成以及如何将 VLINE 文件转换为 LOCPOT_Z 文件)</li>
<li>该脚本是如何获取真空能级的；</li>
<li>一定要查看功函数可视化的结果，用来判断我们的这个方法是否试用。</li>
</ol>
<p>写这么多废话，原因主要有 2 个：</p>
<ol>
<li>提醒大家在使用别人脚本的时候，一些需要注意的事项你要清楚。如果不清楚，可以咨询下脚本的作者；</li>
<li>如果你写了一个脚本放到网上供大家使用，请花些时间写清楚脚本的运行原理，以及尽可能详细的注意事项。</li>
</ol>
</li>
<li><p>脚本正文：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">x = []</span><br><span class="line">y = []</span><br><span class="line">dic = &#123;&#125;</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;LOCPOT_Z&quot;</span>, mode=<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    first_line = f.readline()</span><br><span class="line">    name_x = first_line.split()[<span class="number">1</span>]</span><br><span class="line">    name_y = first_line.split()[<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        xy=line.rstrip().split()</span><br><span class="line">        x.append(<span class="built_in">float</span>(xy[<span class="number">0</span>]))</span><br><span class="line">        y.append(<span class="built_in">float</span>(xy[<span class="number">1</span>]))</span><br><span class="line">        dic.update(&#123;xy[<span class="number">0</span>]:xy[<span class="number">1</span>]&#125;)</span><br><span class="line">plt.plot(x,y) </span><br><span class="line">plt.xlabel(name_x) </span><br><span class="line">plt.ylabel(name_y) </span><br><span class="line">plt.savefig(<span class="string">&#x27;workfunction&#x27;</span> + <span class="string">&#x27;.pdf&#x27;</span>, dpi=<span class="number">400</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#%%%%%%%%%%%%%%%%%%%%%%#</span></span><br><span class="line"><span class="comment"># Get the Vaccum Energy</span></span><br><span class="line"><span class="comment">#%%%%%%%%%%%%%%%%%%%%%%#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the total line numbers of POSCAR </span></span><br><span class="line">num_lines = <span class="built_in">sum</span>(<span class="number">1</span> <span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;POSCAR&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Read POSCAR </span></span><br><span class="line">pos = <span class="built_in">open</span>(<span class="string">&#x27;POSCAR&#x27;</span>, mode = <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">line = pos.readlines()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get  the  slab length in z direction </span></span><br><span class="line">vaccum = <span class="built_in">float</span>(line[<span class="number">4</span>].split()[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get all atoms&#x27; coordination in z direction and store them in the list</span></span><br><span class="line">z_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>, num_lines): </span><br><span class="line">    z_list.append(<span class="built_in">float</span>(line[i].split()[<span class="number">2</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment">#  max(z_list) is highest atoms&#x27; coordination in z direction</span></span><br><span class="line"><span class="comment"># Get the vaccum lenth: </span></span><br><span class="line">l_vaccum = vaccum - <span class="built_in">max</span>(z_list)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;The Vaccum in this calculation is:\t\t %s&#x27;</span>  %(l_vaccum)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Choose the middle z value in the workfuntion.pdf </span></span><br><span class="line">num_middle = (<span class="built_in">max</span>(z_list) + vaccum) / <span class="number">2</span> </span><br><span class="line"><span class="comment">#print num_middle</span></span><br><span class="line"></span><br><span class="line">middle_y = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dic.keys():</span><br><span class="line">    i = <span class="built_in">float</span>(i)</span><br><span class="line"><span class="comment"># Select the date area within 1 angstrom from the middle point:</span></span><br><span class="line">    <span class="keyword">if</span> i &gt; num_middle -<span class="number">1</span> <span class="keyword">and</span> i &lt;  num_middle + <span class="number">1</span>:</span><br><span class="line">        middle_y.append(<span class="built_in">float</span>(dic.get(<span class="built_in">str</span>(i))))</span><br><span class="line"><span class="comment"># Get the average value in the selected area</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;The Vaccum Energy in this calculation is:\t %s&#x27;</span>  %(np.mean(middle_y))</span><br><span class="line"></span><br><span class="line">pos.close()</span><br></pre></td></tr></table></figure>
<ol>
<li><p><code>plt.show()</code> 之前为我们 Ex50 这一节可视化的脚本： 44 和 53 行中，额外将 LOCPOT_Z 中两列的数据保存到一个字典里面，便于后面根据 z 方向的坐标查找真空能级。</p>
</li>
<li><p>获取 POSCAR 文件总的行数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">num_lines = sum(1 for line in open(&#x27;POSCAR&#x27;))</span><br></pre></td></tr></table></figure>
</li>
<li><p>读取 POSCAR 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pos = open(&#x27;POSCAR&#x27;, mode = &#x27;r&#x27;)</span><br><span class="line">line = pos.readlines()</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取 slab 在 z 方向的数值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vaccum = float(line[4].split()[2])</span><br></pre></td></tr></table></figure>
</li>
<li><p>将所有原子的 z 坐标保存到 z_list 数列中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">z_list = []</span><br><span class="line">for i in range(9, num_lines): </span><br><span class="line">  z_list.append(float(line[i].split()[2]))</span><br></pre></td></tr></table></figure>
</li>
<li><p>获得真空层的厚度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">l_vaccum = vaccum - max(z_list)</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算距离表层原子一半真空层厚度的z方向的数值： num_middle</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">num_middle = (max(z_list) + vaccum) / 2 </span><br></pre></td></tr></table></figure>
</li>
<li><p>将 [num_middle-1, num_middle+1] 区间范围内所有的真空能级提取出来，并保存到middle_y 这个数列中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">middle_y = []</span><br><span class="line"></span><br><span class="line">for i in dic.keys():</span><br><span class="line">    i = float(i)</span><br><span class="line"># Select the date area within 1 angstrom from the middle point:</span><br><span class="line">    if i &gt; num_middle -1 and i &lt;  num_middle + 1:</span><br><span class="line">        middle_y.append(float(dic.get(str(i)))</span><br></pre></td></tr></table></figure>
</li>
<li><p>求平均值，并打印出来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print &#x27;The Vaccum Energy in this calculation is:\t %s&#x27;  %(np.mean(middle_y))</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>运行脚本：</p>
<p><img src="/2018/09/06/ex52/ex52-3.png" alt=""></p>
<p>图中第一个命令中，输出比较复杂，并且会和前面示例一样，展示功函数可视化的结果。</p>
<p>但这不便于批量提取数据，可注销脚本中一下三行，直接获取真空能级</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#plt.show() </span><br><span class="line">#print &#x27;The Vaccum in this calculation is:\t\t %s&#x27;  %(l_vaccum)</span><br><span class="line">#print &#x27;The Vaccum Energy in this calculation is:\t %s&#x27;  %(np.mean(middle_y))</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用脚本批量获取真空能级</p>
<p>先将脚本复制到bin文件夹中，赋予可执行权限。</p>
<p><img src="/2018/09/06/ex52/ex52-4.png" alt=""></p>
<ol>
<li><p>批量生成 LOCPOT_Z 文件：</p>
<p><img src="/2018/09/06/ex52/ex52-5.png" alt=""></p>
</li>
<li><p>使用脚本批量读取</p>
<p><img src="/2018/09/06/ex52/ex52-6.png" alt=""></p>
</li>
</ol>
</li>
<li><p>批量获得费米能级：</p>
<p><img src="/2018/09/06/ex52/ex52-7.png" alt=""></p>
<p>我们需要的为第 4 列的数据。(图中的冒号也算作一列)</p>
</li>
</ol>
<h3 id="3-数据分析："><a href="#3-数据分析：" class="headerlink" title="3 数据分析："></a>3 数据分析：</h3><p><img src="/2018/09/06/ex52/ex52-8.png" alt=""></p>
<p>真空能级，费米能级以及功函数随真空层厚度的变化</p>
<p><img src="/2018/09/06/ex52/ex52-9.png" alt=""></p>
<p>图中的测试曲线看起来很漂亮，但纵坐标范围太大，我们将功函数随真空层的变化作图如下：</p>
<p><img src="/2018/09/06/ex52/ex52-10.png" alt=""></p>
<p>从图中，可以看出： 20-30 Å 范围内，功函数的波动变化较小，为 4.81 eV。其他的波动值在 4.85-4.87 eV 之间。Cu(111) 表面的功函数为：4.94 eV。参考的是 CRC handbook 中的数值。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Gu</th>
<th style="text-align:center">100</th>
<th style="text-align:center">5.10</th>
<th style="text-align:center">FE</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">110</td>
<td style="text-align:center">4.48</td>
<td style="text-align:center">PE</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">111</td>
<td style="text-align:center">4.94</td>
<td style="text-align:center">PE</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">112</td>
<td style="text-align:center">4.53</td>
<td style="text-align:center">PE</td>
</tr>
</tbody>
</table>
</div>
<p>实验与理论偏差为： -0.13 / 4.94  = 2.63 %</p>
<p>师兄，实验值结果是 4.94 eV， 如果我们采用 30 Å 时的结果 (4.87 eV)，跟实验的差别更小，是不是更好?</p>
<p>可以这么说。但是</p>
<ol>
<li>从我们测试的结果可以看出来，功函数随着真空层的变化，存在一个计算的误差；</li>
<li>实验测量值也会有一定的误差范围。</li>
</ol>
<p>所以，如果你硬要把理论和实验结果完美地吻合，这是很难做到的，这当然也是大家所梦寐以求的终极目标。一般来说，只要在合理的误差范围之内 (5% 的样子)，跟实验值结果一致就可以了，此外，如果你发表文章的时候，为了保证计算的可重复性。计算参数设置，模型尺寸等都要尽可能地详细。</p>
<p>师兄，不是说真空层对功函数的影响很大吗，为什么在 10 Å 的时候，得到的功函数 (4.80 eV) 和 20 Å (4.81 eV) 的时候一样?</p>
<p>这是因为，在当前的体系下，4 层的 p(1x1)-Cu(111) 表面，10 Å 已经可以了。但 10-20 Å 时，误差波动较大。12 Å 的数据也可以用，如同前面所提到的，他们都在一个合理的误差范围之内，但必须注明你的模型尺寸。对于其他的体系，还需要大家自己动手去测试一下。</p>
<p>此外，给大家推荐一篇文章：<a href="https://pubs.rsc.org/is/content/articlehtml/2016/mh/c5mh00160a">Fermi level, work function and vacuum level</a></p>
<p><img src="/2018/09/06/ex52/ex52-11.png" alt=""></p>
<p>本文刚刚开始的图片就是从这篇文章中偷过来的。</p>
<h3 id="4-扩展练习："><a href="#4-扩展练习：" class="headerlink" title="4 扩展练习："></a>4 扩展练习：</h3><ol>
<li>复习功函数的相关内容；</li>
<li>计算，测试自己研究体系的功函数；</li>
<li>弄清获取真空能级的脚本原理(切记，搞不明白之前，不可乱用！！！)</li>
</ol>
<h3 id="5-总结："><a href="#5-总结：" class="headerlink" title="5 总结："></a>5 总结：</h3><p>到本节为止，功函数的计算就先简单介绍到这里了，计算步骤，可视化以及测试都大体讲解了一下。但我们用的模型例子比较简单，如果你的体系复杂，计算仍有疑问，请在 QQ 群中交流或者发邮件给我 (lqcata@gmail.com) 。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>功函数</tag>
        <tag>真空层</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex55 简单粗暴地获取初始构型（二）</title>
    <url>/2018/10/02/ex55/</url>
    <content><![CDATA[<p>前面一节，我们通过一个简单的方法获取了一个Cu-O键的键长。因为我们固定了Cu的坐标，当计算完成之后，O原子初始构型的坐标可以直接将计算后的结果复制过来。此时需要注意<code>Direct</code>和<code>Cartesian</code>的坐标问题。</p>
<h2 id="1-搭建合理的O吸附模型"><a href="#1-搭建合理的O吸附模型" class="headerlink" title="1 搭建合理的O吸附模型"></a>1 搭建合理的O吸附模型</h2><p>1）取Cu(111)表面模型的POSCAR (Cartesian坐标)</p>
<p><img src="/2018/10/02/ex55/ex55-1.png" alt=""></p>
<hr>
<p>2) 复制快速获取初始构型计算(Cu-O dimer)的结果</p>
<p><img src="/2018/10/02/ex55/ex55-2.png" alt=""></p>
<center>上图中的最后一行。</center>

<hr>
<p>3) 构建O的吸附模型：</p>
<p><img src="/2018/10/02/ex55/ex55-3.png" alt=""></p>
<p>当然了,我们也可以根据键长或者O在z方向的坐标直接在Cu(111)表面基础上搭建。</p>
<p><img src="/2018/10/02/ex55/ex55-4.png" alt=""></p>
<hr>
<p>这个简单粗暴的方法到此就讲解完了。有以下几个需要注意的地方：</p>
<p>A）这里我们用的是Cu(111)的 p(1x1) slab模型,表面只有一个原子。一般来说，大家计算吸附的时候，模型都比这个大，我们可以取一层原子。记住，要固定住这层原子。</p>
<p>B）这个方法基于的是气相中的计算，因此偶极矫正不要加！因为加上去之后，收敛会变得很困难。这个大家可以用自己测试测试。</p>
<p>下面我们讲一个基于slab模型的方法，虽然比这个计算量大，但也异常的快，相对于后面的计算，花费的时间也可以忽略不计。</p>
<hr>
<h2 id="2-快速获取初始构型方法（二）"><a href="#2-快速获取初始构型方法（二）" class="headerlink" title="2 快速获取初始构型方法（二）"></a>2 快速获取初始构型方法（二）</h2><p>1）在这个方法中，第一步我们先取slab模型的结构，这里就不讲了。</p>
<p>2） 搭建一个初始的吸附模型。此时我们要根据原子半径，大体确认一下键长的合理范围，前面也讲过了，就不再细说了。 由于前面一节我们已经有了一个O原子的坐标数据，可以直接拿过来。如下：</p>
<p><img src="/2018/10/02/ex55/ex55-5.png" alt=""></p>
<p>注意：实际操作的时候，这个方法可以使用前面一节的方法的出来的结果；也可以直接设置初始值，这两个方法之间联系不太大。</p>
<hr>
<p>3） 固定slab模型中的所有原子！所有原子！所有原子！</p>
<p>重要的事情说三遍，是把slab模型中的原子全部固定!只放开吸附的分子。这里大师兄在vim里面操作，使用了下面的命令：<code>:12,13s/T/F/g</code>  意思是把12和13行中的T全部替换成F。当然也可以使用sed进行操作，相信大家经过这么长时间的练习，已经掌握基本的Vim和sed操作，就不浪费时间了。效果如下：</p>
<p><img src="/2018/10/02/ex55/ex55-7.png" alt=""></p>
<hr>
<p>4）  设置INCAR，这里是slab模型，把之前Cu(111)表面优化计算的INCAR直接拿过来了。</p>
<p>EDIFF、EDIFFG 可以适当放宽，下图大师兄懒得改了。</p>
<p><img src="/2018/10/02/ex55/ex55-8.png" alt=""></p>
<hr>
<p>5）  生成对应的POTCAR，K点只用gamma点！K点只用gamma点！K点只用gamma点！</p>
<p><img src="/2018/10/02/ex55/ex55-9.png" alt=""></p>
<p>这里需要注意的有两点：</p>
<p>A）  计算前一定要检查POTCAR和POSCAR是否对应，养成这个好习惯</p>
<p>B）  一定要用gamma点。因为我们知道，K点越多，计算量越大。</p>
<hr>
<p>6）  提交任务等待结束。</p>
<p>O原子的坐标，从最初的7.950优化到了8.009。</p>
<p>到此，另外一种快速获取稳定构型的方法，也介绍完了。希望大家可以举一反三，运用到自己实际的课题计算中。</p>
<hr>
<h2 id="3-正式优化O的吸附"><a href="#3-正式优化O的吸附" class="headerlink" title="3 正式优化O的吸附"></a>3 正式优化O的吸附</h2><p>前面我们已经获取的初始的一个合理的构型，下面就开始正常计算了。想一想，在上一步的基础上，正式计算的时候，我们有哪几个需要修改的部分。</p>
<p>1） 结构 </p>
<p>这个是必须要想到的。怎么做呢？ 直接将CONTCAR 复制成 POSCAR即可。</p>
<p>PS： 怎么完成复制这一步还不会的话，请从头开始学。</p>
<p>2） 复制完了并不代表完事，前面一步我们还固定了表层的原子，此时我们需要放开。使用sed命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;12,13s/F/T/g&#x27; POSCAR</span><br></pre></td></tr></table></figure>
<p>3）KPOINTS：使用前面Cu slab优化时用的 13x13x1</p>
<p>4） INCAR中，如果前面一步的计算精度较低，这时，我们就要提高一下了。</p>
<p>5）POTCAR 不变</p>
<p>6）提交任务的脚本：由于前面的计算量很小，一般可以使用小队列进行计算，如果计算量增大了，这时我们也需要稍微修改下脚本。</p>
<p><img src="/2018/10/02/ex55/ex55-12.png" alt=""></p>
<p>7)   提交任务，等待结束，查看结果。</p>
<p><img src="/2018/10/02/ex55/ex55-13.png" alt=""></p>
<p>O原子的坐标从8.009 优化到了8.093。键长从1.75 Å 优化到 1.80 Å，变化很小，这说明我们的初始构型已经很接近优化结果了。</p>
<h2 id="4-扩展练习："><a href="#4-扩展练习：" class="headerlink" title="4 扩展练习："></a>4 扩展练习：</h2><p>1)   本节的实例中，使用了 <code>&amp;&amp;</code> 这个连接前后的命令，大家学习下是怎么回事</p>
<p>2)   重复本节练习，掌握其中的关键点。</p>
<h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5 小结"></a>5 小结</h2><p>一个合理的初始构型可以极大地降低我们的工作量，这一点是大家务必要记在心里的。而获取合理的初始构型，一方面需要我们用化学的知识去搭建结构，另一方面，也需要配合一些简单的低精度的计算去完成。希望大家可以掌握这两节的精髓，运用到自己的课题中，提高自己的计算效率。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>初始构型</tag>
        <tag>简单粗暴</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex53 表面吸附以及模型的搭建思想</title>
    <url>/2018/09/30/ex53/</url>
    <content><![CDATA[<p>吸附这个词，对于做表面化学的人来说，是一个普通的不能再普通的名词了。从今天这一节开始，我们将逐步进入表面化学相关计算领域。</p>
<p><img src="/2018/09/30/ex53/ex53-1.jpeg" alt=""> </p>
<h2 id="1-我们先看一下维基百科的解释"><a href="#1-我们先看一下维基百科的解释" class="headerlink" title="1) 我们先看一下维基百科的解释:"></a>1) 我们先看一下维基百科的解释:</h2><p>a）吸附是指某种气体，液体或者被溶解的固体的原子，离子或者分子附着在某表面上。这一过程使得表面上产生由吸附物构成的膜。吸附不同于吸收，吸收是指作为吸附物的液体浸入或者溶解于另一液体或固体中的过程。吸附仅限于固体表面，而吸收同时作用于表面和内部。</p>
<p>b) 吸附也属于一种传质过程，物质内部的分子和周围分子有互相吸引的引力，但物质表面的分子，其中相对物质外部的作用力没有充分发挥，所以液体或固体物质的表面可以吸附其他的液体或气体，尤其是表面面积很大的情况下，这种吸附力能产生很大的作用，所以工业上经常利用大面积的物质进行吸附，如活性炭、水膜等。吸附过程有两种情况:</p>
<p>一种是物理吸附，在吸附过程中物质不改变原来的性质，因此吸附能小，被吸附的物质很容易再脱离，如用活性炭吸附气体，只要升高温度，就可以使被吸附的气体逐出活性炭表面。</p>
<p>另一种是化学吸附，在吸附过程中不仅有引力，还运用化学键的力，因此吸附能较大，要逐出被吸附的物质需要较高的温度，而且被吸附的物质即使被逐出，也已经产生了化学变化，不再是原来的物质了，一般催化剂都是以这种吸附方式起作用。</p>
<p><img src="/2018/09/30/ex53/ex53-2.jpeg" alt=""></p>
<h2 id="2-IPUAC-GoldBook中的定义"><a href="#2-IPUAC-GoldBook中的定义" class="headerlink" title="2) IPUAC GoldBook中的定义:"></a>2) IPUAC GoldBook中的定义:</h2><p>Adsorption: An increase in the concentration of a dissolved substance at the interface of a condensed and a liquid phase due to the operation of surface forces. Adsorption can also occur at the interface of a condensed and a gaseous phase.</p>
<p><a href="https://goldbook.iupac.org/html/A/A00155.html">https://goldbook.iupac.org/html/A/A00155.html</a></p>
<h2 id="3-参考书"><a href="#3-参考书" class="headerlink" title="3) 参考书"></a>3) 参考书</h2><p>吸附在物理化学中也是一个非常重要的概念，只要学过物理化学，肯定不会错过这一部分的内容。主要列举有关吸附的几本参考书，具体内容本节则不再详细介绍，这也超出了本书所包含的范围。</p>
<p>a) Atkins’ Physical Chemistry </p>
<p>(链接: <a href="https://pan.baidu.com/s/1hsJ95sg">https://pan.baidu.com/s/1hsJ95sg</a> 密码:nfxw)</p>
<p>b) Concepts of Modern Catalysis and Kinetic  (By I. Chorkendorff）</p>
<p>链接: <a href="https://pan.baidu.com/s/1hrA5LHi">https://pan.baidu.com/s/1hrA5LHi</a> 密码:aqvq)</p>
<p>c) 南大物理化学(傅献彩主编)</p>
<h1 id="吸附在催化研究中的地位"><a href="#吸附在催化研究中的地位" class="headerlink" title="吸附在催化研究中的地位"></a>吸附在催化研究中的地位</h1><p>催化剂发挥催化作用的前提是:反应物需要和催化剂有接触（也就是反应物吸附到催化剂表面上并且得到活化）。写这句话的意思就是:研究一个催化反应，第一步我们需要搞懂的就是反应物在表面的吸附情况。个人计算的心得就是：反应的初始态，过渡态以及末态，它们都是表面的吸附物种。这句话的意思是：在我们的计算中，吸附贯穿着我们对催化现象的整个研究过程中。吸附不仅仅是把反应物放到表面上就完事了，更与后面的反应息息相关。切记不要在思考的时候把后面我们要学习的过渡态和吸附隔离开。</p>
<h1 id="吸附模型的搭建"><a href="#吸附模型的搭建" class="headerlink" title="吸附模型的搭建"></a>吸附模型的搭建</h1><p>前面我们已经讲过slab模型了，搭建吸附模型的本质就是在slab模型基础上，再添加吸附分子的xyz坐标。搭建的模型无非就是一个xyz的坐标文件。需要注意的有3个方面:</p>
<p>1) 熟悉VASP的POSCAR格式: 每一行的内容所代表的意思以及它们之间的相互联系:</p>
<ul>
<li>元素行，原子数目以及原子的坐标之间的关系；</li>
<li>Selective Dynamic 行与 T T T， F F F 等原子固定的关系；</li>
<li>Cartesian 坐标和 Direct 坐标的区别等等；</li>
<li>POSCAR与KPOINTS的关系。</li>
</ul>
<p>熟悉POSCAR或者CONTCAR的格式可以使你在搭建模型过程中游刃有余。</p>
<p>2) Slab模型在Z方向上: </p>
<ul>
<li><p>slab的厚度</p>
</li>
<li><p>真空层的厚度，</p>
</li>
</ul>
<p>这两点一方面决定了我们计算量的大小。另一方面，对于不同的体系，我们需要不同厚度的slab模型来保证计算的准确性。例如：对于金属体系来说，越开放的表面往往需要更多的层数。所以，在准确性和计算量上，我们要合理地权衡和取舍。可以通过一些基本的测试工作，以及参考他人发表的计算参数来确定。</p>
<p>3) Slab模型在XY方向上:</p>
<ul>
<li><p>表面的大小：这个主要影响覆盖度，计算的工作量；</p>
</li>
<li><p>表面的吸附位点：比如面心立方金属的111表面，有top(t)，bridge(b)，fcc(f) 和hcp(h)这几个位置，在搭建模型的时候要考虑吸附物种分别在这几个位置上的情况；</p>
</li>
<li><p>吸附物种与表面的结合情况：不同的分子构型?用什么原子?哪一部位和表面接触?初始猜测的键长多少? 等等</p>
</li>
</ul>
<p>这些对于你搭建合理的模型至关重要。一个合理的模型可以极大地降低计算工作量，提高你的计算成功率。当然，这需要一个扎实和良好的化学基本功来作为保障。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本节简单介绍了一下吸附的概念，吸附模型搭建的一些基本的思路，大家可以自己主动思考一下:本节提到的相关内容之间的相互关系以及具体的注意事项。在后面具体的实例操作计算中，我们会逐步慢慢展开详细介绍。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>模型搭建</tag>
        <tag>吸附</tag>
        <tag>slab模型</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex54 简单粗暴地获取初始构型（一）</title>
    <url>/2018/10/01/ex54/</url>
    <content><![CDATA[<p>$\require{mediawiki-texvc}$</p>
<p>Ex54-Ex56主要介绍一下如何计算：单个氧原子在p(1x1)-Cu(111)表面top位上的吸附。在实际的计算过程中，一个好的初始结构会极大地加快并节约你的计算时间，这不仅仅体现在服务器运行的时间上，也会避免很多错误的结果，因为这些错误结果的纠正耗时费力，通常折磨得新手们心力交瘁。可以回顾下前面我们O$_2$ 分子的优化过程：不合理的初始结构导致的错误结果以及计算时间的增加。本节主要介绍一个快速获取优化初始构型的方法。该方法简单粗暴，可以让你在极短的时间内快速获得一个化学的feeling。</p>
<hr>
<h2 id="1-Top-site-的构型"><a href="#1-Top-site-的构型" class="headerlink" title="1 Top site 的构型"></a>1 Top site 的构型</h2><p>在Cu(111)表面上，top位指的是直接吸附在Cu原子上方。其他的位点是什么，先不要着急，后面会慢慢学。如果一个O原子吸附在Cu原子上方，在空间坐标上，大家很容易想到，O和Cu在xy方向的坐标应该是差不多的，z方向O的坐标为：Cu的z坐标 + Cu-O键的键长。如下图：</p>
<p><img src="/2018/10/01/ex54/ex54-1.png" alt=""></p>
<hr>
<h2 id="2-确定O原子在z方向上的坐标"><a href="#2-确定O原子在z方向上的坐标" class="headerlink" title="2  确定O原子在z方向上的坐标"></a>2  确定O原子在z方向上的坐标</h2><p>知道了前面的基本原理，O原子的坐标我们就可以通过Cu-O的键长来初步获得了。那么Cu-O的键长怎么获得呢？这里列举了一下几个常用的方法。</p>
<p>1）查数据库：</p>
<p>2）查文献：自己去查，不要在QQ群里让别人给你发文献。</p>
<p><img src="/2018/10/01/ex54/ex54-2.png" alt=""></p>
<p>这两条主要考验的是大家查询资料的能力，这里暂且不详细介绍了。有兴趣的可以加入大师兄文献互助超级群，跟众多文献检索大牛学习。(群号:<strong>157099073</strong>)</p>
<hr>
<p>3）自己估算</p>
<p>估算的话，可以根据Cu和O原子的半径：Cu和O成键，键长肯定要小于两者的半径之和。搜一下维基百科，Cu的半径为1.35 Å，O的为0.60 Å。(<a href="https://www.wikipedia.org/">维基百科</a>，搜索<code>Atomic Radius</code>就可以得到下面这个表)</p>
<p><img src="/2018/10/01/ex54/ex54-4.png" alt=""></p>
<p>从上面的数据我们可以得出：Cu-O键要小于1.95 Å。在吸附构型搭建的时候设置比1.95 Å小点的值作为初始，进行优化。一般来说，原子半径之和减去0.1-0.3 Å都是可以的。但是不能太小，否则第一步优化的时候排斥力太大，会导致计算出错。</p>
<hr>
<p>4）自己初算：</p>
<p>初算就是初步采用一个小的模型，简单优化一下，得到一个合理的键长数值。小的模型主要指2个方面： </p>
<ul>
<li><p>结构简单；</p>
</li>
<li><p>计算参数简单。</p>
</li>
</ul>
<p>下面我们主要在估算的基础上，介绍一个初算的方法：直接优化一下气相中Cu-O双原子分子的结构。</p>
<p>这个结构不难搭建，将前面练习中O$_2$分子中的一个O原子换成Cu进行优化即可。</p>
<p>为了加深大家对搭建模型的印象，我们从<code>p(1x1)-Cu(111)</code>表面的结构出发，然后一步一步搭建CuO的气相结构模型，并计算。</p>
<hr>
<h2 id="3-搭建初算的模型-Cu-O双原子结构"><a href="#3-搭建初算的模型-Cu-O双原子结构" class="headerlink" title="3  搭建初算的模型(Cu-O双原子结构)"></a>3  搭建初算的模型(Cu-O双原子结构)</h2><p>1）p(1x1)-Cu(111)表面的结构</p>
<p><img src="/2018/10/01/ex54/ex54-5.png" alt=""></p>
<p>将前面几节计算的一个真空层为15 $\AA$的例子直接拿过来。表层原子在z方向的坐标为6.259 (第十二行)。</p>
<hr>
<p>2）修改格子大小(3-5行)</p>
<p>这里修改的很随意，第三行中直接把2.571改成了12.571；</p>
<p>第四行中把2.227改成了12.227。</p>
<p>第五行中将21.299改成了12.299</p>
<p><img src="/2018/10/01/ex54/ex54-6.png" alt=""></p>
<p>效果如下:</p>
<p><img src="/2018/10/01/ex54/ex54-7.png" alt=""></p>
<p>注意：</p>
<p>A）当然也可以用其他大小的格子；(例如：8x8x8 $\AA^3$)</p>
<p>B）格子大小直接影响计算量和时间。(回顾下前面所学)</p>
<hr>
<p>3）保留表层的Cu原子，删除其他的Cu原子。</p>
<p><img src="/2018/10/01/ex54/ex54-8.png" alt=""></p>
<p>注意：</p>
<p>A）我们这里将表层以下的三个原子删掉了，只保留z坐标为6.259的这个原子；</p>
<p>B） 第7行中原子数目也要相应的改变。从4 改成1。</p>
<p>C） 效果如下图：</p>
<p><img src="/2018/10/01/ex54/ex54-9.png" alt=""></p>
<hr>
<p>4）加入O原子</p>
<p><img src="/2018/10/01/ex54/ex54-10.png" alt=""></p>
<p>注意：</p>
<p>A）第6行中，在Cu的后面加上了一个O，不是数字0；</p>
<p>B）Cu 和 O 之间用1个或者几个空格隔开，不要用<code>Tab</code>；</p>
<p>C）第7行中，记得加上O原子的数目</p>
<p>D）最后一行添加O原子的坐标，这里我们直接把Cu原子的复制过来了。</p>
<p><img src="/2018/10/01/ex54/ex54-11.png" alt=""></p>
<p>由于两个原子坐标一样，Cu和O堆在一起了。</p>
<hr>
<p>5）修改O原子坐标</p>
<p><img src="/2018/10/01/ex54/ex54-12.png" alt=""></p>
<p>注意:</p>
<p>A）这里我们把Cu固定住了;为了方便下一步的计算。</p>
<p>B）Cu-O之间的键长，设置的为1.8 Å；</p>
<p>C）O的z坐标为：6.259 + 1.8 = 8.059。</p>
<p><img src="/2018/10/01/ex54/ex54-13.png" alt=""></p>
<hr>
<p>6）到这里，Cu-O双原子分子的气相结构就搭建完毕了，保存成POSCAR即可。</p>
<p>上面的效果图是本人每一步打开展示给大家的。实际操作中，完全没有必要。我们需要学习的是：</p>
<p>A）怎么将脑子中的模型转化为VASP的POSCAR文件；</p>
<p>B）格子大小怎么修改；</p>
<p>C）怎么添加原子，添加或者删除原子后，原子数目怎么弄；</p>
<p>D）怎么添加原子坐标。</p>
<p>E）怎么通过改坐标修改原子位置。</p>
<hr>
<h2 id="4-INCAR检查"><a href="#4-INCAR检查" class="headerlink" title="4 INCAR检查"></a>4 INCAR检查</h2><p><img src="/2018/10/01/ex54/ex54-14.png" alt=""></p>
<p>注意:</p>
<p>1）算的是气相中的：ISMEAR = 0；SIGMA = 0.05 (本书前面就讲过了)</p>
<p>2）IBRION = 2；POTIM = 0.1；NSW =100 是优化的参数</p>
<p>3）EDIFF和EDIFFG是电子步和离子步的收敛标准。</p>
<hr>
<p>师兄，磁性呢？对称性呢？</p>
<p>因为本例子是一个初算，几步算完，看下键长。这个任务的使命就完成了。</p>
<p>很多细节的东西可以暂时不用考虑。这里EDIFFG用的也有点小，本人忘了修改了。大家可以设置为 -0.05或者直接使用能量作为标准，这些都可以的。</p>
<p>虽然本节我们很多地方都没有考虑，这是由于任务的性质所决定的。我们对其定位就是瞎算下，得到一个初始的构型。这也是一个课题中为数不多的，可以为所欲为的计算了。但你正儿八经开始算的时候，各种细节问题都要考虑进去。而这一步的计算，也可以作为一个缓冲期，让你有充足的时间去思考一下正式计算时其他需要的注意事项。</p>
<hr>
<h2 id="5-POTCAR、KPOINTS检查"><a href="#5-POTCAR、KPOINTS检查" class="headerlink" title="5  POTCAR、KPOINTS检查"></a>5  POTCAR、KPOINTS检查</h2><p>A) 根据POSCAR获取对应的POTCAR：见附录自动生成POTCAR的脚本。</p>
<p>B) 使用gamma点计算。<code>cat POTCAR</code></p>
<p><strong>注意：</strong></p>
<p>在提交一个任务前，一定要将INCAR、KPOINTS、POSCAR、POTCAR以及脚本在心里默念一遍。然后对应的检查一下，是否有些遗漏的地方。否则等算完了，发现错了，又得浪费很多时间重新计算了。</p>
<hr>
<h2 id="6-检查结果"><a href="#6-检查结果" class="headerlink" title="6 检查结果"></a>6 检查结果</h2><p><img src="/2018/10/01/ex54/ex54-16.png" alt=""></p>
<p>1）上个厕所的功夫，任务就结束了，共算了6步。(其实是切换电脑系统的功夫)<img src="/2018/10/01/ex54/ex54-17.gif" alt=""></p>
<p>2）Cu—O 的键长：7.95-6.26 = 1.69 Å</p>
<p><strong>注意：</strong> </p>
<p>此时的键长只作为下一步的初始猜测，如果和文献去比有点差异，也不要太较真。</p>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7 总结:"></a>7 总结:</h2><p>本节，你会学到：</p>
<p>1）如何通过原子半径，估算一个初始的键长值。</p>
<p>2）如果搭建一个简单的模型，初算一个键长值。</p>
<p>3）复习气相中的优化。</p>
<p>4）复习下计算前准备工作：INCAR、POSCAR、POTCAR、KPONTS的检查。</p>
<p>如果本节的内容，你有不理解的地方；想获取脚本等信息；请查阅前面讲的以及附录中的内容。搭建几何模型，无非就是按照软件的格式，修改原子坐标罢了。这里我们强调的是几何模型。但，几何模型所具有或者要表达的物理、化学意义，这才是最关键的。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>初始构型</tag>
        <tag>简单粗暴</tag>
        <tag>POSCAR</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex56 吸附能的计算（一）</title>
    <url>/2018/10/03/ex56/</url>
    <content><![CDATA[<p>我们已经优化完成了O原子在Cu(111)表面上的吸附。总结并数一下，到目前为止我们从前面的计算中可以获取哪些能量。</p>
<ul>
<li>Cu(111) slab 的能量</li>
<li>slab上有O吸附时，体系优化完的能量</li>
</ul>
<p>再往前想一下，我们也计算了</p>
<ul>
<li><p>O$_2$分子的能量</p>
</li>
<li><p>以及O原子在气相中的能量。</p>
<p>有了这几个能量，我们就可以计算O在p(1x1)的Cu(111)表面上的吸附能了。这也是本节的主要内容。</p>
</li>
</ul>
<h2 id="1-什么是吸附能？"><a href="#1-什么是吸附能？" class="headerlink" title="1 什么是吸附能？"></a>1 什么是吸附能？</h2><p><img src="/2018/10/03/ex56/ex56-1.png" alt=""></p>
<p>从字面上不难理解，就是分子或者原子从气相中吸附到表面上所释放的能量。计算吸附能的时候，需要注意的有两点：起始和终态。</p>
<p>1）  <strong>终态：</strong>这里说的终态就是O原子在表面吸附，并且优化完的构型。我们标记为 slab+O，它的能量为  E(slab+O)。</p>
<p>2）  <strong>初态：</strong>我们计算O的吸附能，起始状态是O$_2$ 和 纯净的slab表面。因为在实际反应中，O$_2$在气相中解离成2个O原子，然后再吸附，这种可能性微乎其微。前面我们讲了O$_2$分子的优化，这里我们直接把O$_2$分子的能量拿来用。起始的两个结构能量分别标记为：E(O$_2$) 和 E(slab)。</p>
<p>由于在终态的吸附结构上面，我们只有1个氧原子， 所以初始态我们要用O$_2$能量的一半:  E(O$_2$)/2。</p>
<p>3）  注意：文献报道里面，也有很多人用O原子在气相中的能量来计算O的吸附能。这样做的话，其物理意义为：O$_2$需要先解离成O原子，然后O原子再吸附。此时，初始状态为分解的O原子，因此O$_2$分子解离的能量没有考虑在内。由于O$_2$解离是吸热反应，忽略掉解离能，会导致O的吸附能很强。单个O原子的能量标记为：E(O)。</p>
<p>4）  所以，大家在计算的时候，一定要把自己的计算公式标出来，此外，大家看到直接用O原子能量计算出来的吸附能，不要用O$_2$作为参考能量的结果进行对比。</p>
<p>5） 这两个计算方法，哪个对，哪个错呢？ 答：都是对的。因为O$_2$的解离能是一个常数，加上去（用O$_2$能量作为起始）或者忽略掉（用O原子能量作为起始）得到的结果之间的区别无非也是这个常数。看下面的计算。</p>
<hr>
<h2 id="2-计算吸附能（单个O原子）"><a href="#2-计算吸附能（单个O原子）" class="headerlink" title="2 计算吸附能（单个O原子）"></a>2 计算吸附能（单个O原子）</h2><p>公式1: </p>
<script type="math/tex; mode=display">
E_{ads1}(O) = E_{slab+O} – E_{slab} – E_{O_2}/2</script><p>公式2: </p>
<script type="math/tex; mode=display">
E_{ads2}(O) = E_{slab+O} – E_{slab} – E_{O}</script><p>$E_{slab+O}$ ：O 在Slab上，优化完结构的能量；</p>
<p>$E_{slab}$: 优化的slab的能量；</p>
<p>$E_{O_2}$: O$_2$ 分子在气相中的能量；</p>
<p>$E_{O}$: O原子在气相中的能量；</p>
<p>带入数据后：</p>
<script type="math/tex; mode=display">
E_{ads1}(O) =  -17.68238420~eV – (-13.97082922~eV) – (-9.85498627~eV) = 1.216~eV</script><script type="math/tex; mode=display">
E_{ads2}(O) =  -17.68238420~eV – (-13.97082922~eV) – (-1.89237882~eV) = -1.819~eV</script><hr>
<p>前面我们说了，如果直接用O原子在气相中的能量，则忽略了O$_2$分子解离的能量（或者是O原子结合能）。</p>
<p>我们知道O$_2$ 分子解离是一个吸热反应，那么，解离能可以通过以下两个方式来获取：</p>
<p>1)     两个吸附能量相减来得到：</p>
<script type="math/tex; mode=display">
E_{ads1}(O) - E_{ads2}(O) = 1.216~eV – (-1.819~eV) = 3.035~eV</script><p>2)    直接通过O$_2$分子和O原子的能量得到。单个O原子的结合能为：</p>
<script type="math/tex; mode=display">
E_{binding} = [ E_{O_2} – E_O * 2] /2，</script><p>代入数据后得到：</p>
<script type="math/tex; mode=display">
E_{binding} =[ -9.85498627~eV – (-1.89237882~eV *2) ] / 2 = -3.035~eV</script><hr>
<h2 id="3-思考问题："><a href="#3-思考问题：" class="headerlink" title="3 思考问题："></a>3 思考问题：</h2><p>1）  前面我们计算的$E_{ads1}(O)$ = 1.216 eV 是一个正值，为什么会这样？ 算错了吗？还是有其他物理意义？</p>
<p>2）  如何计算H，CO，CH$_4$, CH$_3$OH 等的吸附能，把计算的公式列出来。每个能量计算的细节，注意部分有哪些？</p>
<p>3） 如何计算脱附能？</p>
<hr>
<h2 id="4-扩展练习："><a href="#4-扩展练习：" class="headerlink" title="4 扩展练习："></a>4 扩展练习：</h2><p>1）  推荐阅读下面这两篇文章（本人的，当然喜欢大家多多引用了。）讲的是关于甲醇，乙醇，乙二醇，以及甘油在Cu, Ru, Pd以及Pt的(111)上面的解离。Ex系列的后续文章，表面反应的优化，过渡态的计算等，基本都以这两篇文章的内容为主。希望大家能够好好学习，并多多引用。此外，计算的很多细节都在支持信息里面，大家不要错过。一时半会看不完没有关系，下载后结合本书慢慢看。</p>
<p><img src="/2018/10/03/ex56/ex56-2.png" alt=""></p>
<p>链接：<a href="https://pubs.acs.org/doi/abs/10.1021/cs501698w">https://pubs.acs.org/doi/abs/10.1021/cs501698w</a></p>
<p><img src="/2018/10/03/ex56/ex56-3.png" alt=""></p>
<p><strong>链接：</strong><a href="https://www.nature.com/articles/s41467-018-02884-y"><strong>https://www.nature.com/articles/s41467-018-02884-y</strong></a> </p>
<hr>
<p>2）  回顾并重复本节所涉及到的计算，以及注意细节部分。</p>
<p>A.      单个O原子的能量；</p>
<p>B.      O$_2$分子优化；</p>
<p>C.      Cu bulk的优化；</p>
<p>D.      p(1x1)-Cu(111)表面的搭建及优化；</p>
<p>E.       O原子在p(1x1)-Cu(111)的top位吸附的模型搭建及优化；</p>
<p>G.      不满半年的新手，建议从Ex0 从头学习。</p>
<hr>
<h2 id="5-总结："><a href="#5-总结：" class="headerlink" title="5 总结："></a>5 总结：</h2><p>本节我们主要介绍了O原子在p(1x1)-Cu(111)表面top位上的吸附能的计算公式。顺便带大家回顾一下整个计算流程。如果你从头跟着学过来的话，每个流程中的细节，需要注意的部分肯定都已经掌握了，后面举一反三，就慢慢渐入佳境了。也就是所谓的开始入門了。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>Cu(111)</tag>
        <tag>吸附能</tag>
        <tag>结合能</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex57 吸附能的计算（二）</title>
    <url>/2018/10/04/ex57/</url>
    <content><![CDATA[<p>$\require{mediawiki-texvc}$</p>
<p>本节我们简单讨论一下覆盖度对吸附能的影响。首先回顾一下，前面我们讲到的内容。</p>
<ul>
<li><p>吸附能为初态和末态的能量差：</p>
<ul>
<li>初态为纯净的slab 和 O$_2$分子或者O原子</li>
<li>末态为O吸附的slab</li>
</ul>
</li>
<li><p>O$_2$分子优化计算的时候，要注意: </p>
<ul>
<li>从数据库获取O$_2$分子的键长，作为初始值；</li>
<li>ISPIN = 2  </li>
<li>ISMEAR = 0; SIMGA = 0.05 </li>
<li>IBRION= 2; POTIM = 0.1</li>
<li>用gamma点。</li>
</ul>
</li>
<li>O 原子优化计算的时候，注意的计算细节与前面相同。额外注意的是：<ul>
<li>O 原子再怎么优化还是一个O原子，所以上一行表述是不恰当的，应该是O原子的单点计算；</li>
<li>Box的尺寸为：$13\times14\times15~\AA^3$  或者$13.1\times13.2\times13.3 \AA^3$ 但绝对不能为$13\times13\times13$这种正方体的</li>
</ul>
</li>
<li>怎么优化Bulk的结构，扫晶格拟合和ISIF = 3直接优化（ENCUT要大，不妨取个700~eV）</li>
<li>slab怎么优化，Selective 和 坐标后面 T F 的关系</li>
<li>O吸附模型怎么搭建，如何得到合理的初始模型（有实验值优先使用，没有的话用粗精度的初算一下）。</li>
<li>此外，还要学会怎么判断计算结束，不同类型任务结束的特征是什么？</li>
</ul>
<hr>
<h2 id="打个比方"><a href="#打个比方" class="headerlink" title="打个比方"></a>打个比方</h2><p>回到上一节我们留的问题，为什么O在p-(1x1)-Cu(111)表面上的吸附能是正的呢？在解释这个问题先，我们先看下面一组照片：</p>
<p><img src="/2018/10/04/ex57/ex57-1.jpeg" alt=""></p>
<p><img src="/2018/10/04/ex57/ex57-2.jpeg" alt=""></p>
<p><img src="/2018/10/04/ex57/ex57-3.jpeg" alt=""></p>
<hr>
<p>第一张里面，地铁车厢里面是空的，这时候你上去，座位随便挑。</p>
<p>第二张里面，有些人了已经占了，但还是有座位的，你的选择并没有那么多了。</p>
<p>第三张里面，人太多，能不能出来都是个问题，有没有座位想都不敢想了。</p>
<p>那么回到我们的这个问题，我们把O的吸附结构在xy平面上重复一下：</p>
<p><img src="/2018/10/04/ex57/ex57-4.png" alt=""></p>
<p>你会发现，表面上密密麻麻全是O原子（绿色的为Cu原子）！空间这么小，如果你是O原子，你愿意在这上面挤么？ 你是选择空旷的车厢还是人满为患的呢？如果我是氧原子，我肯定不愿意。所以，如果非得在这个表面上挤的话。我们就需要一些外力的作用，比如下图中的这俩年轻力壮的小伙子协警。</p>
<p><img src="/2018/10/04/ex57/ex57-5.jpeg" alt=""></p>
<p>这俩人使的劲就是O原子的吸附能。正值的意思表明我们需要额外的力才能将其吸附在表面上。表面越挤，正值越大。</p>
<hr>
<p>如果你还是不理解的话，我们看另外一个例子：</p>
<p><img src="/2018/10/04/ex57/ex57-6.jpeg" alt=""></p>
<p>早上，开学了。老师有1个苹果，需要将这个苹果分给教室里面的学生。而学生还没有来齐，当你第一个到达教室时，发现整个苹果都是你的。开心程度 100%。正要吃的时候，小明进来了，老师说你俩要分一下，你只能得到一半了，开心程度 50%; 你俩正要吃的时候，小红和小白也进来了，老师说，打住，你们四个分，于是每人只能拿1/4，你的开心程度掉到 25%了。</p>
<p>表面就是这个苹果，O原子就是学生，总共就这一个苹果，学生越多，平均分到的就越少。学生之间可能还会因为分的不均匀而打架（相互排斥），导致开心程度越来越低。当开心程度成负的时候，老师就需要施展神通费心思（额外的功）逗你们开心。</p>
<hr>
<p>看完这两个例子，你也许就明白了，为什么这个时候O原子的吸附能这么大了。太他妈挤了或者人太多，分不到苹果吃了，心里肯定不爽！下面，我们把车厢清空，学生数目控制一下，看看心情能不能好点。</p>
<hr>
<h2 id="搭建p-2x2-Cu-111-表面"><a href="#搭建p-2x2-Cu-111-表面" class="headerlink" title="搭建p-(2x2)-Cu(111)表面"></a>搭建p-(2x2)-Cu(111)表面</h2><p>1 用p4vasp打开p-(1x1)-Cu(111)的CONTCAR</p>
<p>2 选择Edit —&gt; Multiply cell</p>
<p><img src="/2018/10/04/ex57/ex57-7.png" alt=""></p>
<p>3 弹出的窗口，如图填入扩展的倍数：</p>
<p><img src="/2018/10/04/ex57/ex57-8.png" alt=""></p>
<p>这代表我们在x和y方向上分别扩展到原来的2倍。点击Multiply，效果如下图：</p>
<p><img src="/2018/10/04/ex57/ex57-9.png" alt=""></p>
<p>4 关闭Multiply这个窗口，p4vasp主界面左上角选择：<code>File</code> —&gt; <code>Save system as</code></p>
<p>5 在弹出的窗口，选择目录，保存成POSCAR，点击OK即可。</p>
<p><img src="/2018/10/04/ex57/ex57-10.png" alt=""></p>
<p>6 这样我们就有了一个p-(2x2)的slab模型了。</p>
<hr>
<h2 id="搭建O在p-2x2-Cu-111-上的吸附结构"><a href="#搭建O在p-2x2-Cu-111-上的吸附结构" class="headerlink" title="搭建O在p-(2x2)-Cu(111)上的吸附结构"></a>搭建O在p-(2x2)-Cu(111)上的吸附结构</h2><p>1 我们可以用之前计算的结果搭建这个初始结构,O吸附优化的CONTCAR：</p>
<p><img src="/2018/10/04/ex57/ex57-11.png" alt=""></p>
<p>O原子在$z$方向的坐标为8.0928$\AA$。先记住这个数字。</p>
<hr>
<p>p-(2x2)的Slab坐标（在p-(1x1)基础上扩展的）:</p>
<p><img src="/2018/10/04/ex57/ex57-12.png" alt=""></p>
<p>在这个坐标上面修改，搭建结构：</p>
<p><img src="/2018/10/04/ex57/ex57-13.png" alt=""></p>
<p>1）添加O原子元素</p>
<p>2）添加O原子数目</p>
<p>3）添加O原子坐标</p>
<p>4）弄完后，保存成POSCAR</p>
<p>到现在，p-(2x2)的slab以及O原子的吸附模型都有了，准备INCAR,KPOINTS,POTCAR以及任务脚本，提交这两个结构的优化计算。等待结束。</p>
<hr>
<p>计算吸附能：</p>
<p>公式1： </p>
<script type="math/tex; mode=display">
E_{ads1}(O) = E_{slab+O} – E_{slab} – E_{O_2}/2</script><p>公式2： </p>
<script type="math/tex; mode=display">
E_{ads2}(O) = E_{slab+O} – E_{slab} – E_{O}</script><p>带入数据：</p>
<script type="math/tex; mode=display">
E_{ads1}(O) = -60.61682891~eV – (-55.96049190~eV )- (-9.85498627~eV)/2 = 0.271~eV</script><script type="math/tex; mode=display">
E_{ads2}(O) = -60.61682891~eV – (-55.96049190~eV )- (-1.89237882~eV)= -2.764~eV</script><p>发现吸附能$E_{ads1}(O)$从正的1.216降低到0.271 eV了。看来空间对O原子的吸附影响很大。</p>
<hr>
<p>地铁里面空间稍微大了些，现在不需要年轻小伙子暴力推搡了，大妈指挥下就可以了。</p>
<p><img src="/2018/10/04/ex57/ex57-14.jpeg" alt=""></p>
<p>分的苹果稍微多了些，虽然还是有些不情愿，稍微诱导一下，就开心了。</p>
<p><img src="/2018/10/04/ex57/ex57-15.png" alt=""></p>
<hr>
<p>前面的解释只是用现实的例子瞎扯一顿。但发表文章的时候不能这样说啊，我们就需要一些科学和专业的解释。而在实际表面上，覆盖度影响吸附能的因素有很多。体相中电子的分布转移，与吸附物种的成键，吸附物种之间的排斥和吸引等等。如果你想了解的更多，更专业！阅读下面这篇文献：</p>
<p><img src="/2018/10/04/ex57/ex57-16.png" alt=""></p>
<p>谷歌上可以下载免费的，有权限的也可以直接下载。类似这样已经注明的文献，请不要花时间找我要，自己去下载。</p>
<p>（每设一道坎，就会把很多懒家伙挡住！跨过一道又一道坎，你就把别人远远甩在后面了。所以，请自己主动起来！）</p>
<hr>
<h2 id="扩展训练："><a href="#扩展训练：" class="headerlink" title="扩展训练："></a>扩展训练：</h2><p>1 重复p-(2x2)-Cu(111)的练习，心里面默念一遍INCAR, KPOINTS, POTCAR, POSCAR。看看都有些什么需要注意的。</p>
<p>2 阅读推荐的文献，学习表面物种之间的相互作用，覆盖度是怎么影响吸附能的。有哪几方面？</p>
<p>3 本文提到了一个专业名词：覆盖度，查找相关的文献，了解这个名词是怎么回事，文献报道的覆盖度都是怎么算出来的。</p>
<hr>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>本节，大师兄带你做了趟地铁，当了回幼儿园的小朋友。来体验下人多的感觉。覆盖度高的时候吸附能很小或者是正值，说明物种在表面不稳定，需要额外的力来促使它们老老实实待在表面上。表面就那么大点的地方，空间有限，p-(1x1)上吸附的时候，表面太挤了，O原子不愿意待在上面。而表面扩成p-(2x2)后，空间明显大了很多，O原子虽然不情愿，但明显不像在(1x1)上那么不爽了。从吸附能就可以看出来，降低了1~eV左右。从另一个角度来看，这明显就是一场O原子争夺表面资源的战争。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>Cu(111)</tag>
        <tag>吸附能</tag>
        <tag>覆盖度</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex58 吸附能的计算（三）</title>
    <url>/2018/10/05/ex58/</url>
    <content><![CDATA[<p>前面一节我们将Cu的slab表面扩展成p(2x2), 然后放了一个O原子在上面吸附。最后发现与p(1x1)表面上吸附相比，O原子的吸附能从+1.2 降低到0.2 eV. 说明覆盖度高的时候，O原子的吸附很差。吸附能受覆盖度的影响很大。</p>
<p>那什么是覆盖度？ Surface coverage（θ）</p>
<p>从字面上理解，就是表面被吸附物(原子或分子等)覆盖的程度。一个固定大小的表面，如果上面某一吸附物越多，那么说它的覆盖度也就越大。也可以理解为：该吸附物在表面上的浓度也就越大。在多相催化的过程中，吸附是第一步。而在催化剂表面上，其活性位点数量是有限的（N个），如果N1个活性位点被吸附物种占据了，那么此时的覆盖度：θ= N1/N。如果所有的活性位点都被占据了，那么覆盖度就是1。 这个相信学过物理化学，以及相关多相催化基础知识的都能理解。 如果不知道的，请自己查找相关参考书学习，主要是在Langmuir 吸附那一部分。</p>
<hr>
<p>在表面计算中，覆盖度我们通常使用原子数目的比来表示。首先，在p(2x2)的Cu(111)表面上，有4个Cu原子，我们可以认为活性位点是4个。当我们放一个O上去后，占据了一个Cu，那么此时的覆盖度是1/4。前面我们在p(1x1)的表面上放了一个O，可以认为是Monolayer的O吸附，也就是覆盖度为1。</p>
<p>1）之所以用原子数来表示，而不用表面积。是因为吸附的物种往往不像O原子这么简单，比如甲醇，乙醇，等等。这些表面上吸附物种的面积很难算，将它们的面积除以表面的面积，可行性不大。</p>
<p>2）师兄，如果我的吸附分子很大，比如苯环。 1个Cu原子上面放不下，那该怎么表示?</p>
<hr>
<p>首先你需要扩胞，如上一节所讲的，将表面扩大到能容得下苯环为止。</p>
<p>1）比如我们将表面扩展成p(3x3)后才能放上去一个苯环，那么此时的覆盖度就是1/9。虽然数值很小，但对于苯环来说，Monolayer的吸附，按照这个定义，其覆盖度就是1/9。</p>
<p>2） 如果我们知道一个苯环可以占据9个表面的原子，那么我们将这9个原子看做一个活性位点，那么覆盖度就是 1/1。第一个1指的是1个苯环，第二个1指的是1个活性位点（9个原子）。</p>
<p>大家在计算的时候，一方面参考专业书，文献中的表示，另一方面根据自己的体系需要，只要将问题描述清楚就可以了。</p>
<p>继续回到上一节留的另一个问题：扩胞时有什么需要注意的事项。</p>
<p>1）扩胞的操作已经展示给大家了，相信这不再是什么难事了；</p>
<p>扩胞后的结果见下图： </p>
<p><img src="/2018/10/05/ex58/ex58-1.png" alt=""></p>
<p>2）扩胞后计算，我们需要注意的主要是KPOINTS这个文件。前面p(1x1)-Cu(111)，我们用的K点是：13x13x1。那我们扩完胞后，晶格变大了，还能继续用$13\times13\times1$吗？</p>
<p>答：可以用来计算。但结果不能用来和其他K点的进行比较。</p>
<hr>
<p>什么意思呢？</p>
<p>这里大师兄想要表达的是：如果你想要对比两个计算结果，首先要保证它们在一个计算的等级上， 即两个计算K点的网格密度是一样的，或者差不多的。在Reciprocal space中，晶胞的长度为$2\pi/a$。然后我们将这个长度分割成k段。每一段长度为：$2\pi/ka$</p>
<p>我们扩胞后，晶胞长度变为2a，则在Reciprocal Space中，晶胞的长度为$2\pi/2a$ =$\pi/a$。</p>
<p>如果我们用之前的KPOINTS，那么就会将π/a分成k段，每段长：$\pi/a$， 由于分的更细，这会导致扩胞后K点的密度更大。</p>
<p>为了保持和扩胞前的密度一致，我们需要将$\pi/a$分割成 k/2 段，这样每段长为$2\pi/ka$。</p>
<hr>
<p>因此当我们扩胞后，KPOINTS如果保持不变，会导致前后两个计算的K点密度不一致时，从而计算的精度也不一样，所以两个结果没有可比性。</p>
<p>师兄，你说了这么多废话。那我们该怎么办呢？</p>
<p>很简单，将K点数目减小就可以了。 前面p(1x1)我们使用的是$13\times13\times1$，那么扩胞成p(2x2)后，K点就需要相应的减小到$7\times7\times1$。更简单一点，回想我们前面说到的那个经验选择。<code>K * a</code> 的取值范围。</p>
<p><a href="https://wiki.fysik.dtu.dk/gpaw/exercises/surface/surface.html">https://wiki.fysik.dtu.dk/gpaw/exercises/surface/surface.html</a></p>
<p><img src="/2018/10/05/ex58/ex58-2.png" alt=""></p>
<p>我们只要保证所有计算中： K * a 的数值差不多就OK了。所以，当你看到这里，你就可以随便扩胞了，什么p(2x2),  p(3x3),  p(4x4)啦，扩胞后都知道该怎么选择K点并修改KPOINTS了。</p>
<hr>
<p>那对于其他输入文件呢？</p>
<p>INCAR：</p>
<p>此时，对于Cu体系来说，可以保持不变。但有些与原子数目相关的参数，你还是需要在INCAR里面修改，保持与新的POSCAR对应。比如： </p>
<ul>
<li><p>MAGMOM, 但如果你的体系是具有磁性，需要重新设置MAGMOM。</p>
</li>
<li><p>更复杂点的体系，如果你的体系是不仅有磁性，还是反铁磁，当你扩胞后，你还要给不同的原子设置磁矩的方向。</p>
</li>
</ul>
<p>POTCAR： 保持不变</p>
<p>提交任务的脚本： 扩胞后，由于体系变大， 计算会变慢，为了加快速度，我们可能会需要增加节点数目。</p>
<hr>
<p>计算步骤：</p>
<p><strong>老实人的做法：</strong></p>
<p>扩胞后，很多人问计算吸附能的步骤，不清楚该怎么样进行。</p>
<p>第一步：优化扩胞后的Slab 模型： 因为扩抱前已经relax过了，所以这一步很快就会结束；得到新的slab能量。</p>
<p>第二步：在第一步优化的基础上搭建吸附模型； 然后优化，得到slab+吸附物的能量。</p>
<p>第三步：套公式，计算吸附能。</p>
<p>老司机的做法</p>
<p>当然了，如果你经验丰富，计算的够多了，可以尝试这样做：</p>
<p>第一步：优化扩胞后的Slab 模型： 因为扩抱前已经relax过了，所以这一步很快就会结束；得到新的slab能量：</p>
<p>同时：在扩胞后的slab模型上（没有优化）直接搭建吸附模型，然后优化，得到slab+吸附物的能量。</p>
<p>第二步：套公式，计算吸附能。</p>
<p>这两种做法，最后的结果应该是一样的，如果有差别，也是微乎其微，可以忽略不计。<strong>注意：</strong>在计算纯的slab能量时，表面应该是放开的。</p>
<hr>
<p>另一个很常见的问题是，slab的表面我应该放开还是固定呢？</p>
<p>严格来说，slab的表层原子应该是弛豫的，也就是坐标后对应的是 T T T，这样更符合物理化学意义，因为催化剂表面的原子不可能会不动。厉害的时候，吸附物还会导致表面重构。所以你在阅读文献，会发现理论部分都会写：Top two layers 放开来模拟表面，底部的原子固定来模拟体相等等这样类似的话。</p>
<p>但是，将表面原子放开后，会导致结构优化步数的增加，从而引起计算量的增加。如果你的模型很大，吸附结构很多，可以先从小模型，低K点出发，先固定住表面，算一遍吸附，大体有个感觉后，再一步一步增加计算的精度。</p>
<p>如果体系太大了，可以尝试着固定表面来算吸附能，步骤如下：</p>
<ul>
<li>1）先优化slab模型，这一步表面原子是要放开的；</li>
<li>2）固定表面原子，</li>
<li>3）放吸附物种优化。</li>
</ul>
<p>目前计算能力基本上可以完全满足放开表面原子的计算。所以，大家不要纠结这个问题。表面的原子能放开，尽量放开。如果实在是不放心，那么就找一篇和你工作很相近，体系类似的计算文章，看看别人怎么设置的，照猫画虎就可以了。</p>
<hr>
<h2 id="参考阅读："><a href="#参考阅读：" class="headerlink" title="参考阅读："></a>参考阅读：</h2><p>Density Functional Theory：A Practical Introduction, <strong>Chapter 3</strong>：Nuts and bolts of DFT calculations</p>
<p><img src="/2018/10/05/ex58/ex58-3.png" alt=""></p>
<hr>
<h2 id="扩展练习："><a href="#扩展练习：" class="headerlink" title="扩展练习："></a>扩展练习：</h2><p>另一个无关痛痒，但对后面工作效率会造成影响的问题就是：</p>
<p><img src="/2018/10/05/ex58/ex58-4.png" alt=""></p>
<p>当扩展完之后，你会看到，Cu原子的坐标，是按照每个单胞中的坐标来排列的。在p(2x2)中有4个p(1x1)的单胞，先列出来第一个(1x1)中4个原子的坐标，然后再列出来第二个(1x1)的，以此类推。但是，比如我们想仅仅放开表面的第一层原子（也就是纵坐标为6.26的所有原子），就得把纵坐标为4.189的原子挨个由T T T 改成 F F F （图中箭头所指的部分）。这样会很麻烦，还浪费很多时间。</p>
<p>怎么解决这个问题，快速将表层，次表层原子固定或者放开呢 ? 看下一节的内容。</p>
<hr>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>扩胞</tag>
        <tag>吸附能</tag>
        <tag>覆盖度</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex59 吸附能的计算（四）</title>
    <url>/2018/10/07/ex59/</url>
    <content><![CDATA[<p>丑话说在前头，本节内容有点多，大家慢慢消化。掌握本节的核心思想，对于后面提高你的工作效率，节省时间有着很大的帮助。前面一节，我们在扩展练习中提到了扩胞后，原子坐标的后面T T T 和 F F F 修改的问题。因为扩展后原子坐标是按照单胞为顺序排列的，如果想要将表面的原子快速固定或者放开，那么我们就需要知道表面原子所在的行数。</p>
<h2 id="方法一：找规律-sed命令"><a href="#方法一：找规律-sed命令" class="headerlink" title="方法一：找规律+sed命令"></a>方法一：找规律+sed命令</h2><p><img src="/2018/10/07/ex59/ex59-1.png" alt=""></p>
<p>上图中，p(2x2)的POSCAR命名为POSCAR-2x2，最表层原子所在的行数为：13，17， 21， 25，次表层的原子所在的行数为： 12， 16， 20， 24。仔细分析下，你会发现，表层原子的行数为： 9 + 4<em>n ；次表层的行数为：8 + 4 </em> n，其中n = 1-4，4表示在扩完后的slab模型里面有4个(1x1)的单元。有了这个关系，我们就可以通过sed命令任意固定这两层的原子了, 命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in &#123;1..4&#125;; do sed -i &quot;$((8+4*$i)), $((9+4*$i))s/T T T/F F F/g&quot; POSCAR</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in &#123;1..4&#125;; do sed -i &quot;$((8+4*$i)), $((9+4*$i))s/T/F/g&quot; POSCAR</span><br></pre></td></tr></table></figure>
<p>效果如下图：通过sed命令快速将表层原子批量固定住。</p>
<p><img src="/2018/10/07/ex59/ex59-2.png" alt=""></p>
<p>我们还可以只放开最表层的原子，使用sed命令快速将最表层的原子批量放开！</p>
<p>在前面结果的基础上可以使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for  i  in &#123;1..4&#125;; do sed -i &quot;$((9+4*$i))s/ F F F/ T T T/g&quot; POSCAR</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for  i  in &#123;1..4&#125;; do sed -i &quot;$((9+4*$i))s/F/T/g&quot; POSCAR</span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/07/ex59/ex59-3.png" alt=""></p>
<p>Soooo Easy！！！再也不用挨行修改T T T 或者F F F 了。</p>
<h2 id="方法二：分层处理-sed命令"><a href="#方法二：分层处理-sed命令" class="headerlink" title="方法二：分层处理+sed命令"></a>方法二：分层处理+sed命令</h2><p>什么，原来还有第二种方法？ 这种方法是本人常用的。前面我们提到，在p(2x2)的slab模型中，原子坐标是按照p(1x1)的单元排列的。既然我们想根据层数固定原子，那么我们可以先将原子按照层数来排列，这样就可以方便的选择同一层的原子了。</p>
<p>那么该怎么将它们按照层数排列呢？ 这时候你应该想到，不同层之间的原子，它们的坐标在z方向是不同的。有了这个依据，我们就可以根据z方向坐标的大小来排列原子了。</p>
<p>首先我们先用一个笨方法实现所预想的小目标。</p>
<p><strong>第一步：</strong>将坐标复制到excel表格里面。本人用的是libre office(Linux下面的Microsoft)。不过功能大同小异，Windows用户按照做就可以了。</p>
<p><strong>第二步：</strong>选中所复制的数据，然后根据图中的D列来排序。</p>
<p><img src="/2018/10/07/ex59/ex59-4.png" alt=""></p>
<p>排序完的结果, 如下图：</p>
<p><img src="/2018/10/07/ex59/ex59-5.png" alt=""></p>
<p>从图中，我们可以看出，原子根据在z方向上的坐标分成了4部分。</p>
<p><strong>注意：</strong>这里我们所有原子都是Cu原子，因此可以全部选中然后直接排序。如果你的体系中有好几种不同的原子，你需要按照元素，逐一进行排序。 比如体系中有C H O，我们先将C原子按照Z方向坐标排序，然后再排H原子的，最后再排O原子的。要保持和POSCAR前面元素顺序一致。</p>
<p>排序完成之后，将POSCAR中的坐标替换为Excel中的数据。</p>
<p><img src="/2018/10/07/ex59/ex59-6.png" alt=""></p>
<p>这样的话，我们的模型就搞定了。剩下的就是使用sed命令批量替换T T T和 F F F了</p>
<p>但是，师兄等等，上图看起来坐标很乱啊，结构能用吗？ 放心，绝对可以用。</p>
<p>如果不放心的话，可以用p4vasp打开一下，然后重新保存成POSCAR即可。最终我们的POSCAR如下图：</p>
<p><img src="/2018/10/07/ex59/ex59-7.png" alt=""></p>
<p><img src="/2018/10/07/ex59/ex59-8.png" alt=""></p>
<p>从图中可以看出来，次表层的原子在18-21行，最表层的原子在22-25行。所以可以这样使用sed命令来快速实现表层原子的固定与弛豫。</p>
<p><img src="/2018/10/07/ex59/ex59-9.png" alt=""></p>
<p><img src="/2018/10/07/ex59/ex59-10.png" alt=""></p>
<h2 id="方法三：-使用脚本分层"><a href="#方法三：-使用脚本分层" class="headerlink" title="方法三： 使用脚本分层"></a>方法三： 使用脚本分层</h2><p>师兄，这个问题竟然还可以使用脚本来解决？</p>
<p>当然了，使用鼠标拖拖点点的事情，一般都可以用脚本来实现。脚本是用python写的，本人给它起了一个高大上的响亮名字：sortcar.py。（适用于python2.6以及以上的版本，低于2.6或者python3可能会出错。）</p>
<p>由于p(2x2)的slab坐标前面已经用过了，下面我们用p(3x3)的slab来演示一下脚本的使用。</p>
<p><img src="/2018/10/07/ex59/ex59-11.png" alt=""></p>
<p>新鲜出炉的，等待被sort的p(3x3)slab的POSCAR。被sort过的POSCAR如下图：</p>
<p><img src="/2018/10/07/ex59/ex59-12.png" alt=""></p>
<p>使用sortcar.py 将坐标按照z方向大小排列。输出文件为XXX_sorted，其中 XXX为我们想要排列的POSCAR或者CONTCAR。如果你的VASP坐标结构文件名字为：BigBro，那么被sort之后，输出文件就是: BigBro_sorted。</p>
<p>脚本这么神奇，内容如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python </span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> sys </span><br><span class="line"></span><br><span class="line">in_file = sys.argv[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">### READ input file ###</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_inputcar</span>(<span class="params">in_file</span>):</span></span><br><span class="line">    f = <span class="built_in">open</span>(in_file, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    lines = f.readlines()</span><br><span class="line">    f.close()</span><br><span class="line">    ele_name  = lines[<span class="number">5</span>].strip().split()</span><br><span class="line">    ele_num = [<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> lines[<span class="number">6</span>].strip().split()]</span><br><span class="line">    dict_contcar =  &#123;ele_name[i]:ele_num[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(ele_name))&#125; </span><br><span class="line">    dict_contcar2 = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> ele_name: </span><br><span class="line">        indice  = ele_name.index(element)</span><br><span class="line">        n_start = <span class="built_in">sum</span>(ele_num[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, indice+<span class="number">1</span>)) - dict_contcar.get(element) +<span class="number">1</span></span><br><span class="line">        n_end = <span class="built_in">sum</span>(ele_num[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, indice+<span class="number">1</span>)) +<span class="number">1</span></span><br><span class="line">        dict_contcar2[element].append(<span class="built_in">range</span>(n_start, n_end)) </span><br><span class="line">    <span class="keyword">return</span> lines, ele_name, ele_num, dict_contcar2, dict_contcar</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_elements</span>(<span class="params">ele</span>):</span></span><br><span class="line">    lines, ele_name, ele_num, dict_contcar2, dict_contar = read_inputcar(in_file)</span><br><span class="line">    coord_total = []</span><br><span class="line">    my_list = []</span><br><span class="line">    my_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> dict_contcar2.get(ele)[<span class="number">0</span>]:</span><br><span class="line">        coord_list = lines[j+<span class="number">8</span>].strip().split()[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">        tf_list = lines[j+<span class="number">8</span>].strip().split()[<span class="number">3</span>:]</span><br><span class="line">        my_list.append(coord_list)</span><br><span class="line">        dict_key = <span class="string">&#x27;-&#x27;</span>.join(coord_list)</span><br><span class="line">        my_dict[dict_key] = tf_list</span><br><span class="line">       </span><br><span class="line">    data = np.array(my_list)</span><br><span class="line">    data=data[np.argsort(data[:,<span class="number">2</span>])]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> data:</span><br><span class="line">         coord = <span class="string">&#x27;  &#x27;</span>.join(k)</span><br><span class="line">         tf = <span class="string">&#x27;  &#x27;</span>.join(my_dict.get(<span class="string">&#x27;-&#x27;</span>.join(k)))</span><br><span class="line">         coord_total.append(coord + <span class="string">&#x27;  &#x27;</span> + tf )</span><br><span class="line">    <span class="keyword">return</span> coord_total</span><br><span class="line"></span><br><span class="line"><span class="comment">## Generate the New POSCAR file</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Get_and_Save_lines</span>(<span class="params">file_name, start_line, end_line</span>):</span></span><br><span class="line">    f = <span class="built_in">open</span>(file_name)</span><br><span class="line">    lines =  f.readlines()</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines[<span class="built_in">int</span>(start_line):<span class="built_in">int</span>(end_line)]:</span><br><span class="line">        file_out.write(line.rstrip()+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">out_name = in_file + <span class="string">&#x27;_sorted&#x27;</span></span><br><span class="line">file_out = <span class="built_in">open</span>(out_name, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">Get_and_Save_lines(in_file, <span class="number">0</span>, <span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">ele_name = read_inputcar(in_file)[<span class="number">1</span>]</span><br><span class="line">dict_contcar = read_inputcar(in_file)[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ele_name:</span><br><span class="line">    <span class="keyword">if</span> dict_contcar.get(i) &gt; <span class="number">1</span> :</span><br><span class="line">        file_out.write(<span class="string">&#x27;\n&#x27;</span>.join(get_elements(i)))</span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        file_out.write(<span class="string">&#x27;\n %s \n&#x27;</span> %(<span class="string">&#x27;  &#x27;</span>.join(get_elements(i))))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>注意事项：</strong></p>
<p>1） 这里我们用的是Cu(111)的例子，比较简答，脚本的威力展示不出来。<br>2） 如果你的体系有很多不同的原子，脚本首先会将同一种元素原子的坐标排列，然后依次类推。<br>3） 有些地方可能有些冗余。但本人一直在用，效果还不错。<br>4） 本人建议，只针对表面使用这个脚本。也就是吸附前的slab模型。如果你放了吸附物种，不建议使用，因为吸附物种间不同原子之间的连接顺序可能会被打乱。<br>5） 在放吸附物种之前，最好将表面先排序完，怎么做，前面三种方法任选。<br>6） 脚本的话已经上传，大家可以通过链接下载：<a href="https://pan.baidu.com/s/1X5xLRsvRmFfNE8IlKwvbFQ）">https://pan.baidu.com/s/1X5xLRsvRmFfNE8IlKwvbFQ）</a></p>
<p>7）如果使用脚本出错的话，可能是因为你的python版本太低。这个脚本只适用于python2.6及以上的。Python3可能也不适用。出现错误，直接放弃，掌握了这个方面的思想就足够了。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>本节讨论的内容与科研关系说大不大，说小也不小，主要是在解决工作效率和时间上。想象一下，如果你的slab中有很多原子（金属氧化物，硫化物等），而且还不是同一种的，你用前两种方法的时候，就得十分小心了，此时脚本的作用就显示出来了。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>脚本</tag>
        <tag>sed</tag>
        <tag>sort</tag>
        <tag>固定原子</tag>
        <tag>规律</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex60 吸附能的计算（五）</title>
    <url>/2018/10/08/ex60/</url>
    <content><![CDATA[<p>前面我们发现将p(1x1)-Cu(111)的表面扩展成p(2x2)后，由于O的覆盖度降低了，O原子的吸附能能+1.2 eV降低到 0.2 eV作用，说明O原子更加容易吸附在表面上了。当你仔细观察p(2x2)的表面，你会发现，表面上不仅仅有Cu原子的上方可以放O原子，还有其他的位点。如下图：</p>
<p><img src="/2018/10/08/ex60/ex60-1.png" alt=""></p>
<p>如果我们想分析下不同位点对吸附能的影响，首先我们需要搭建模型，然后重复O原子的吸附优化步骤。本节主要简单介绍一下如何快速搭建不同的吸附位点模型。</p>
<h2 id="1-不同表面位点："><a href="#1-不同表面位点：" class="headerlink" title="1 不同表面位点："></a>1 不同表面位点：</h2><p>观察不同位点的结构特征，在面心立方金属的(111)表面上有4种不同的位点:</p>
<p>1) Top位，前面已经花了很多时间介绍了，本节就不再啰嗦<br>2) Bridge位：从名字大家就可以推断这个位点的吸附为两个Top原子的中间。<br>3) Fcc位和Hcp位：这两个吸附位点都是在三个原子的中心，为hollow位。</p>
<p>那么这两个位点怎么区分呢？ </p>
<p>如果表面的Hollow位正下方（即第二层，图中黄色的）有原子，为Hcp位，在第三层的话（图中红色的），则这个hollow为Fcc位。<br>由于Fcc位点的原子在第三层，离表面最远（far），大家把英文单词的far 和 Fcc位的第一个字母关联起来即可。远的那个就是Fcc，近的是Hcp。<br>注意： Fcc 和 Hcp 分别是 face centered cubic 和  hexagonal close-packed 的缩写。</p>
<h2 id="2-不同位点的吸附模型"><a href="#2-不同位点的吸附模型" class="headerlink" title="2 不同位点的吸附模型"></a>2 不同位点的吸附模型</h2><p>怎么搭建Bridge和Fcc，以及Hcp位的吸附模型？</p>
<p>1) Bridge位: </p>
<p>这个位点在两个原子的中心。设两个原子的坐标分别为（x1，y1， z1）和（x2， y2， z2），它们中心得坐标为： （x1+x2）/ 2， （y1+y2）/ 2， （z1+z2）/ 2。在这里，z1和z2 是相等的。所以我们可以通过两个原子的坐标，计算一下中心的坐标，然后按照之前O原子搭建的步骤，添加O原子的Bridge位的坐标即可。<br>2) Fcc位和Hcp</p>
<ul>
<li><p>这两个位点就更容易了，前面我们知道它们正下方分别为第三层和第二层的原子。那么我们在这两层随便取个原子，x和y 方向的坐标就确定了。</p>
</li>
<li><p>关于z方向的坐标，大家可以想象一下，如果O原子从Top位移到Bridge，Fcc和Hcp，由于和O成键的原子多了，也就是O和表面结合地更强了，那么它在z方向的坐标肯定比在Top位上要小。所以在这三个构型的z坐标，我们可以在Top位O的基础上稍微调小一点。那么小多少呢？ 一般来说0.1-0.2Å就可以了。</p>
</li>
</ul>
<h2 id="3-使用p4vasp搭结构"><a href="#3-使用p4vasp搭结构" class="headerlink" title="3 使用p4vasp搭结构"></a>3 使用p4vasp搭结构</h2><p>前面介绍的方法是直接修改POSCAR来搭建模型，对于O原子的吸附这种简单的模型，大家都还可以胜任，但如果体系复杂了，比如一个苯环，乙醇分子等等，这样我们的计算坐标的工作量就有点大了。此时，p4vasp的优势就开始慢慢显示出来了。</p>
<h3 id="3-1-从Top到Bri"><a href="#3-1-从Top到Bri" class="headerlink" title="3.1 从Top到Bri"></a>3.1 从Top到Bri</h3><p>1） 首先，我们要有一个O原子在Top位上的吸附结构<br>2） 然后选择Top位的原子和相邻的那个原子，（p4vasp选中的结构看起来不是很清楚，见黄圈标出来的那两个）</p>
<p><img src="/2018/10/08/ex60/ex60-2.png" alt=""></p>
<p>3） 选则 Edit –&gt; Move Atoms 后会弹出这样的界面：</p>
<p><img src="/2018/10/08/ex60/ex60-3.png" alt=""></p>
<p>按照图中的1 2 3依次点击， 你便会获得一个<code>Vector</code>。也就是从5到7号原子的一个向量。</p>
<p>但我们如果按照这个向量平移O原子的话，只会把它从5号原子移动到7号原子上，而不是Bridge的位点。 </p>
<p>前面我们说了，Bridge的坐标就是这两个原子连线的中心。所以，我们把Vector减小一半就可以了。</p>
<p><img src="/2018/10/08/ex60/ex60-4.png" alt=""></p>
<p>修改完Vector之后，我们便可以移动O原子了。</p>
<p><strong>这里注意</strong></p>
<p>要把前面选中的5 和 7 号原子换成 O，要不然你移动的是 5和7 号原子而不是O。最后点move，效果如下：</p>
<p><img src="/2018/10/08/ex60/ex60-5.png" alt=""></p>
<p>这样我们便获得了Bridge的吸附结构。</p>
<p>前面提到，我们在搭建Bridge结构的时候，O原子的坐标可以比Top位的稍微低一些，这个操作怎么实现呢？<br>1） 首先选中氧原子，<br>2） 在Vector那一行修改移动的位置即可。如下图：</p>
<p><img src="/2018/10/08/ex60/ex60-6.png" alt=""></p>
<p>点击move ，保存POSCAR即可。</p>
<h3 id="3-2-从Bridge-到-Hcp："><a href="#3-2-从Bridge-到-Hcp：" class="headerlink" title="3.2 从Bridge 到 Hcp："></a>3.2 从Bridge 到 Hcp：</h3><p>1） 选中O原子和Hcp位下面的Cu原子，并获取Vector</p>
<p><img src="/2018/10/08/ex60/ex60-7.png" alt=""></p>
<p>2） 修改Vector在z方向的大小。</p>
<p><img src="/2018/10/08/ex60/ex60-8.png" alt=""></p>
<p>点击 Move，效果如下：</p>
<p><img src="/2018/10/08/ex60/ex60-9.png" alt=""></p>
<p>保存成Hcp对应的POSCAR即可。</p>
<h3 id="3-3-从Hcp到Fcc"><a href="#3-3-从Hcp到Fcc" class="headerlink" title="3.3 从Hcp到Fcc"></a>3.3 从Hcp到Fcc</h3><p>1）选中O原子和Fcc的一个原子，获取Vector：</p>
<p><img src="/2018/10/08/ex60/ex60-10.png" alt=""></p>
<p>2）修改Vector在z方向的大小，由于Fcc和Hcp的吸附很接近，直接平移即可，也就是z方向大小为0</p>
<p><img src="/2018/10/08/ex60/ex60-11.png" alt=""></p>
<p>点击move，最终的Fcc结构，如下图，保存POSCAR。</p>
<p><img src="/2018/10/08/ex60/ex60-12.png" alt=""></p>
<p><strong>注意：</strong></p>
<p>保存结构的时候，可以自己建对应的文件夹，在文件夹里面将结构保存成POSCAR，也可以保存成类似<code>POSCAR-Fcc</code>， <code>POSCAR-Hcp</code>， <code>POSCAR-Top</code>这一种的名字，计算的时候，将它们重新命名为<code>POSCAR</code>就行了。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>本节，大师兄主要给大家介绍了如何在表面上，使用<code>p4vasp</code>平移原子来搭建不同的吸附位点模型。使用p4vasp搭结构非常方便简单，也会加深你对模型结构的理解，另一方面，使用这一种操作的话准确性更高，搭建出来的模型比自己手动放原子要合理很多。所以强烈推荐大家使用<code>p4vasp</code>。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>p4vasp</tag>
        <tag>模型搭建</tag>
        <tag>吸附位点</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex61 吸附能的计算（六）</title>
    <url>/2018/10/09/ex61/</url>
    <content><![CDATA[<p>前面一节我们搭建好了p(3x3)-Cu(111)表面上不同吸附位点的O原子吸附模型。（fcc, hcp, top以及bri）也就是我们有了4个<code>POSCAR</code>。下面我们计算O原子在不同位点上的吸附能。根据吸附能的公式，我们还要有Cu(111) slab的能量。总共5个计算。O$_2$的前面已经算了，这里就不重复了。</p>
<p>强调一下吸附能的定义：就是物种吸附到表面上所放出的能量，放出能量意味着吸附能是负值。很多人把这个过程颠倒了，然后来定义吸附能，这是错误的！虽然数值一样，但表示的物理意义完全不一样。颠倒过来是脱附，而不是吸附！！！而基本概念搞不清楚，最直接的后果就是给审稿人留下一个坏印象，增加拒稿的几率。当然，基本概念正确也会被拒稿，概念搞错了文章也有可能会接收。</p>
<h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1 准备工作:"></a>1 准备工作:</h2><p><code>INCAR</code>：和前面p(1x1)的计算一样<br><code>KPOINTS</code>：根据前面我们经常提到的经验规则：k*a=30 </p>
<p>链接：<a href="https://wiki.fysik.dtu.dk/gpaw/exercises/surface/surface.html">https://wiki.fysik.dtu.dk/gpaw/exercises/surface/surface.html</a><br><code>POSCAR</code>：已经准备好<br><code>POTCAR</code>: 根据POSCAR生成对应的POTCAR，脚本见本书的附录章节。<br>提交任务的脚本或者命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A rule of thumb for choosing the initial k-point sampling is, that the product, ka, between the number of k-points, k, in any direction, and the length of the basis vector in this direction, a, should be:</span><br><span class="line"></span><br><span class="line">    ka ~ 30 Å, for d band metals</span><br><span class="line">    ka ~ 25 Å, for simple metals</span><br><span class="line">    ka ~ 20 Å, for semiconductors</span><br><span class="line">    ka ~ 15 Å, for insulators</span><br><span class="line"></span><br><span class="line">Remember that convergence in this parameter should always be checked.</span><br></pre></td></tr></table></figure>
<h2 id="2-天河II号提交任务"><a href="#2-天河II号提交任务" class="headerlink" title="2 天河II号提交任务"></a>2 天河II号提交任务</h2><p>前面我们已经讲解了如何在天河2号上提交任务，Learn VASP 系列的前面几节也介绍了一些相关的批量操作知识。下面简单通过实例操作展示下批量提交任务的一个流程。</p>
<p><img src="/2018/10/09/ex61/ex61-1.png" alt=""></p>
<p>其中<code>qsuball</code>是本人在<code>~/.bashrc</code>文件中，给批量提交任务的命令行随便起的一个名字，详见前面关于alias的使用介绍。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias qsuball=&#x27;for i in *; do cd $i ; qsub ; cd $OLDPWD; done&#x27;</span><br></pre></td></tr></table></figure>
<p><code>qsub</code> 是我们在超算中心提交单个任务的脚本，内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line">rm job_sub </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;#!/bin/bash&#x27;</span> &gt;&gt; job_sub</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export LD_LIBRARY_PATH=/THFS/opt/intel/composer_xe_2013_sp1.3.174/mkl/lib/intel64:$LD_LIBRARY_PATH&#x27;</span> &gt;&gt; job_sub </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;yhrun -p gsc -n 24 /THFS/opt/vasp/5.4.4/vasp.5.4.4/bin/vasp_std &#x27;</span> &gt;&gt; job_sub </span><br><span class="line">yhbatch -p gsc -N 1 -J <span class="built_in">test</span> job_sub </span><br></pre></td></tr></table></figure>
<p>将上面内容复制到一个文件里面，将文件命名为<code>qsub</code>，然后走一遍下面的2个步骤。<br>1）<code>chmod u+x qsub</code> (赋予可执行权限)<br>2)  <code>mv  qsub  ~/bin</code>  （放到 ~/bin 文件夹下）</p>
<h2 id="3-查看结果"><a href="#3-查看结果" class="headerlink" title="3 查看结果"></a>3 查看结果</h2><p>等待任务排队，计算，结束。一个任务结束后，我们需要做的肯定就是检查结果了。那么改怎么样检查结果呢？这里列举出本人常用的几个方法和步骤。</p>
<h3 id="1）查看OSZICAR"><a href="#1）查看OSZICAR" class="headerlink" title="1）查看OSZICAR"></a>1）查看OSZICAR</h3><p>i)  在查看<code>OSZICAR</code>之前，我们回顾下前面的INCAR。</p>
<p><img src="/2018/10/09/ex61/ex61-2.png" alt=""> </p>
<p>这里我们设置了<code>NSW = 500</code>,也就是允许本计算最大的离子步数。</p>
<p>ii） 再看下<code>OSZICAR</code>的末尾部分， 命令： <code>tail  OSZICAR</code></p>
<p><img src="/2018/10/09/ex61/ex61-3.png" alt=""></p>
<p>从这里可以看出来，经过25个离子步，我们的计算就已经停止了，说明收敛了。</p>
<h2 id="2）-查看OUTCAR"><a href="#2）-查看OUTCAR" class="headerlink" title="2） 查看OUTCAR"></a>2） 查看OUTCAR</h2><p><img src="/2018/10/09/ex61/ex61-4.png" alt=""></p>
<p>对于VASP的所有计算来说，只要你看到这样的结果，说明你的任务已经算完了。这里你要记住：算完和收敛不是一回事。比如你设置的<code>NSW = 500</code>， VASP优化了<code>500</code>步没有收敛的话，会自动停止，也会出现上图的结果。</p>
<p><strong>怎么查看收敛呢？</strong> </p>
<p>i) 可以对比计算的离子步和我们设置的离子步。如果实际计算得了离子步小于<code>INCAR</code>中的，任务就收敛了。这也是前面查看<code>OSZICAR</code>的目的。<br>ii）可以通过<code>OUTCAR</code>里面的关键词： <code>reached</code></p>
<p><img src="/2018/10/09/ex61/ex61-5.png" alt=""></p>
<p>如果你看到最后面的： <code>Stopping structural energy minimisation</code>  这就表明你的优化任务已经完成。<br>而事实上，的确有很多人把这句话误认为是计算出错了，然后在群里面求助，本人实在是想不通。</p>
<h2 id="4-删除VASP乱七八糟的输出文件"><a href="#4-删除VASP乱七八糟的输出文件" class="headerlink" title="4 删除VASP乱七八糟的输出文件"></a>4 删除VASP乱七八糟的输出文件</h2><p><img src="/2018/10/09/ex61/ex61-6.png" alt=""></p>
<p>计算完成之后，VASP会出现很多平时我们用不到的文件，<code>CHG</code> <code>CHGCAR</code> <code>WAVECAR</code> 这三个占用的空间很大，容易把应胖撑爆。</p>
<p>由于计算目录下的存储空间有限，本人计算的时候，一般都默认VASP不写入这些文件。</p>
<p>此外，在表面结构优化的时候，<code>EIGENCAL, IBZKPT, REPORT,DOSCAR``以及超算中心与任务相关的输出文件：slurm-XXX</code> 文件，一般来说正常计算结束后，我们也不需要。</p>
<p>因此，本人写了一个小脚本，用来删除这些乱七八糟的文件。脚本运行效果如上，脚本内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="keyword">for</span>  i  <span class="keyword">in</span> $(find . -name INCAR); <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">cd</span> $(dirname <span class="variable">$i</span>)</span><br><span class="line">    rm CHG  CHGCAR  job_sub  PCDAT REPORT  slurm-*.out  WAVECAR  XDATCAR -f</span><br><span class="line">    <span class="built_in">cd</span> <span class="variable">$OLDPWD</span>;</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>大家可以针对自己的计算任务，修改<code>rm XXX</code> 哪一行中的文件名。</p>
<p><img src="/2018/10/09/ex61/ex61-7.png" alt=""></p>
<p>上图中还运行了一个脚本（ta.sh），就是提取当前目录下，所有计算结果的能量。也是本人临时写的。有兴趣的可以自己照着写一遍，然后运行下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> *; <span class="keyword">do</span></span><br><span class="line"><span class="keyword">if</span> [ -e <span class="variable">$i</span>/OUTCAR ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> -e  <span class="variable">$i</span> <span class="string">&quot;\t&quot;</span> $(grep <span class="string">&#x27;  without&#x27;</span> <span class="variable">$i</span>/OUTCAR |tail -n 1 | awk <span class="string">&#x27;&#123;print $7&#125;&#x27;</span>) </span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<h2 id="5-获取能量，计算吸附能"><a href="#5-获取能量，计算吸附能" class="headerlink" title="5 获取能量，计算吸附能"></a>5 获取能量，计算吸附能</h2><p>有了上面的数据，我们就可以进行吸附能的计算，如下图：</p>
<p><img src="/2018/10/09/ex61/ex61-8.png" alt=""></p>
<p>一般来说，使用eV作为单位，精确到小数点后面2位即可。整理下表格：</p>
<p><img src="/2018/10/09/ex61/ex61-9.png" alt=""></p>
<p>从上图我们可以看出来，这四个位点的吸附能强弱顺序为： fcc ≈ hcp &gt; bridge &gt; top</p>
<h2 id="6-扩展练习"><a href="#6-扩展练习" class="headerlink" title="6  扩展练习"></a>6  扩展练习</h2><p>1） 学会如何判断计算正常结束，并且优化达到收敛的标准了？<br>2） 总结并思考不同位点的吸附能的计算。<br>3） 学会判断稳定的吸附位点。<br>4） 思考下计算结束之后，除了我们讲的这些，还有那些需要检查的？<br>5） 本节的三个脚本：<br>i)   qsub （天河II号提交任务）<br>ii） rmvasp.sh (删除乱七八糟文件)<br>iii）ta.sh (获取当前目录下，所有计算任务的能量)</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>收敛</tag>
        <tag>吸附能</tag>
        <tag>天河II号</tag>
        <tag>删除VASP文件</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex62 吸附能的计算（七）</title>
    <url>/2018/10/10/ex62/</url>
    <content><![CDATA[<p>前面我们得到了不同吸附位点上吸附能的顺序，但结构是什么样子的呢？我们优化完的结果对不对？这还是一个问题。因此我们需要查看一下优化完的结果。</p>
<h2 id="1-获取（下载）CONTCAR"><a href="#1-获取（下载）CONTCAR" class="headerlink" title="1  获取（下载）CONTCAR"></a>1  获取（下载）CONTCAR</h2><p>没有结构，我们看个屁啊？所以第一步就是把超算中心的计算结果下载到自己的电脑里面。这里我们说获取或者下载CONTCAR，而不是OUTCAR等其他VASP的输入文件，原因在于本人这边网速传输太慢了。所以我的策略是能量等信息在服务器里面直接获取，结构的话只下载CONTCAR。如果网速允许的话，可以把所有的计算结果下载到自己电脑里面，这样查看更加方便。</p>
<p><img src="/2018/10/10/ex62/ex62-1.png" alt=""></p>
<p><img src="/2018/10/10/ex62/ex62-2.png" alt=""></p>
<p>上图中，我们先挂载超算中心到本地电脑上，然后将计算目录下的CONTCAR复制到本地桌面上。（ccall 这个命令）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in * ; do if [ -e $i/CONTCAR ]; then mkdir ~/Desktop/$i; cp $i/CONTCAR ~/Desktop/$i ; fi; done</span><br></pre></td></tr></table></figure>
<p>备注：<br>由于本人这边传输很慢，即使挂载了超算中心到本地电脑上，访问内容的时候，后台依然有数据传输。所以先下载再查看。</p>
<h2 id="2-使用ASE查看结构："><a href="#2-使用ASE查看结构：" class="headerlink" title="2 使用ASE查看结构："></a>2 使用ASE查看结构：</h2><p>ASE 是Atomic Simulation Environment的简称，下载安装见：<a href="https://wiki.fysik.dtu.dk/ase/">https://wiki.fysik.dtu.dk/ase/</a>  本人只会在Linux下面使用，Windows用户自行解决。解决不了，我也没有办法。如果Linux用户解决不了，那么使用后面的第二种方法：p4vasp查看结构。</p>
<p>如果你的网速很给力，可以直接通过自己电脑进入超算中心的目录，进行下面的操作。</p>
<p><img src="/2018/10/10/ex62/ex62-3.png" alt=""></p>
<p>这个软件的<strong>优点</strong>就是： 我们可以一次性打开当前目录下，所有计算的CONTCAR， 从而避免了使用软件挨个导入结构查看。无形中会减少我们很多的工作量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ase-gui  */CONTCAR </span><br></pre></td></tr></table></figure>
<h2 id="3-使用p4vasp-查看结构"><a href="#3-使用p4vasp-查看结构" class="headerlink" title="3 使用p4vasp 查看结构"></a>3 使用p4vasp 查看结构</h2><p>Ubuntu下面唯一推荐的软件：下面图片拍的不是很好，大家凑活着看吧。</p>
<p><img src="/2018/10/10/ex62/ex62-4.png" alt=""></p>
<p>这里，p4vasp和前面说的ASE一样，也可以一个命令打开所有的计算结果。</p>
<p><img src="/2018/10/10/ex62/ex62-5.png" alt=""></p>
<p>作为<code>p4vasp</code>的忠实粉丝，这也是本人唯一推荐的<code>Ubuntu</code>系统下查看，搭建结构的软件。</p>
<ul>
<li>i）使用p4vasp可以非常容易地进行原子替换，平移，旋转等基本操作。</li>
<li>ii）可以查看VASP的结算结果，DOS，能带，优化过程等等。</li>
<li>iii）Windows 系统下p4vasp的功能有些弱，除了不能批量打开文件外（可能是本人不会用），其他的和Ubuntu差不多。</li>
<li>iv）这个软件也有很多其他细微不尽人意的地方，但不影响我们的正常使用。</li>
<li>如果你刚开始接触这个软件，认真用鼠标各个地方点点操作一下，查看各个功能按钮的作用。</li>
<li>此外，VASP官网的<code>ppt</code>教程中也有一些零星的<code>p4vasp</code>操作教程，大家可以参考一下。</li>
</ul>
<h2 id="4-其他软件："><a href="#4-其他软件：" class="headerlink" title="4 其他软件："></a>4 其他软件：</h2><p>当然了， 不论在linux还是Windows下面，都有很多查看结构的软件，比如：<code>Jmol</code>，<code>Xcrysden</code>，<code>Molden</code>， <code>VESTA</code>， <code>Material Studio</code>等等。这里就不再详细介绍了，主要原因是本人不太会使用这些软件操作。目前大家需要做的就是根据自己的喜好，掌握一个软件：学会查看结构，键长，键角等信息即可。切记不可贪多，等一个软件掌握好了之后，有余力的话再去学习另一个的操作。</p>
<h2 id="5-扩展练习："><a href="#5-扩展练习：" class="headerlink" title="5 扩展练习："></a>5 扩展练习：</h2><p>1） 自己优化O在Cu(111)表面上不同位点的吸附，计算吸附能<br>2） 选择一款自己喜欢的软件，查看不同的吸附结构。<br>3） 思考其他单原子在其他金属表面上的吸附，该如何计算？<br>4） 思考原子在表面上，为什么不同吸附位点的吸附能不一样？</p>
<h2 id="6-总结："><a href="#6-总结：" class="headerlink" title="6 总结："></a>6 总结：</h2><p>本节没有什么技术难度，全靠自己亲自手动操作，使用一个软件并不是一蹴而就的过程，大家先把基本的简单操作掌握了，后面再逐渐提高自己的其他技能。此外，本节学习完之后，单原子在表面上的吸附对大家来说应该不是什么困难的事情了。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>p4vasp</tag>
        <tag>ASE</tag>
        <tag>CONTCAR</tag>
        <tag>结构查看</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex63 吸附能的计算（八）</title>
    <url>/2018/10/11/ex63/</url>
    <content><![CDATA[<p>在进行本文的内容之前，大家先玩个人尽皆知的小游戏：</p>
<h2 id="找不同"><a href="#找不同" class="headerlink" title="找不同"></a>找不同</h2><p><strong>（一）</strong>找出下面两幅图中不同的部分。</p>
<p><img src="/2018/10/11/ex63/ex63-1.jpeg" alt=""></p>
<p>相信这个大家很快都能找出来，找不出来的话，不建议继续浏览下面的部分。</p>
<p>（二）下面两个截图中，找出不同的部分</p>
<p><img src="/2018/10/11/ex63/ex63-2.png" alt=""> </p>
<p><img src="/2018/10/11/ex63/ex63-3.png" alt=""></p>
<p>（三）下面两个截图中，找出不同的部分</p>
<p><img src="/2018/10/11/ex63/ex63-4.png" alt="">  <img src="/2018/10/11/ex63/ex63-5.png" alt=""></p>
<p>聪明美丽能干活泼善良可爱宇宙超级无敌的你会发现： </p>
<p>在找不同2中，两个图中内容的区别在于：  POSCAR 的第6行<br>在找不同3中，两个图中内容的区别在于：  POTCAR 的第二个元素</p>
<p>当你发现了这些不同之处，就应该差不多明白了，这是2个计算任务文件，一个是C原子在Cu(111), 另一个是O原子在Cu(111)上的计算。</p>
<p>仔细分析不同的地方，你就应该想到: 既然我们有了O吸附相关的计算文件，那么就可以在此模板基础上，快速编辑C的吸附模型，然后进行计算。</p>
<p>在进行下面的快速编辑模型的内容，先给大家介绍一个Linux下面常用的比较不同的命令：diff。简单操作如下，更高级的大家自由去百度学习，并加以发挥拓展。 </p>
<p><img src="/2018/10/11/ex63/ex63-6.png" alt=""></p>
<h2 id="批量搭结构"><a href="#批量搭结构" class="headerlink" title="批量搭结构"></a>批量搭结构</h2><p>快速准备C原子在Cu(111)上吸附的计算文件：</p>
<p>1）<code>INCAR</code> 保持一样<br>2）<code>KPOINTS</code> 保持一样<br>3）<code>POSCAR</code>: 将 O 直接替换成C就OK了。<br>i）直接编辑，无数种编辑器任你选。不过 Windows下一定要记得编辑完后运行下: <code>dos2unix</code><br>ii）使用sed命令： <code>sed -i &#39;6s/O/C/g&#39; POSCAR</code></p>
<p>4）<code>POTCAR</code>: </p>
<p>i) 使用前面我们介绍的脚本：potcar.sh， 脚本运行例子如下图：（去本书的附录章节里面找脚本）</p>
<p><a href="https://www.bigbrosci.com/2017/12/21/A05/">https://www.bigbrosci.com/2017/12/21/A05/</a></p>
<p><img src="/2018/10/11/ex63/ex63-7.png" alt=""></p>
<p>直接输入脚本名，后面跟你想要的元素名。</p>
<p>看下本人在天河II号服务器上的设置。</p>
<p>1） potcar.sh 在本人账号的： <code>~/bin</code> 目录下<br>2） VASP所有的POTCAR文件在： <code>~/bin/pot</code> 目录下<br>3） pot目录下，每个元素的文件夹中有2两个文件：<code>POTCAR</code> 和 <code>PSCTR</code> （PSCTR这个我也不知道有什么用。）<br>4）新手，没有经验，不会用超算的，不会Linux的，可以效仿下：</p>
<p><img src="/2018/10/11/ex63/ex63-8.png" alt=""></p>
<p>脚本下载后，将POTCAR所在的目录替换成你的： path=”你的目录”。<br>怎么知道目录呢？ 使用上图中的pwd 这个命令。</p>
<p><img src="/2018/10/11/ex63/ex63-9.png" alt=""></p>
<p>ii) 我很多时候都懒得去看POSCAR中的元素以及顺序，便打算根据POSCAR中的内容生成对应的POTCAR，于是便写了一个脚本：<code>pospot.sh</code>。使用方法如下： </p>
<p><img src="/2018/10/11/ex63/ex63-10.png" alt=""></p>
<p>上图运行了这个脚本两次：<br>1） 第一次运行的时候，目录下没有POTCAR，于是脚本直接生成新的<br>2） 第二次运行的时候，目录下有了一个POTCAR，于是脚本将POTCAR中的元素顺序读出来，然后删掉旧的POTCAR，重复1）的操作，生成新的POTCAR。（大师兄本人的扯淡逻辑，大家可以忽略，脚本文章末尾下载直接使用即可。）<br>3） 注意：这个脚本读取的仅仅是以 元素 命名文件夹中的POTCAR。什么意思呢？ 举个例子：Cu的POTCAR有：Cu，Cu_GW, Cu_pv，Cu_sv_GW这四种。脚本读取的仅仅是Cu中的POTCAR。如果你想用<code>Cu_pv</code>，那么请使用： <code>potcar.sh Cu_pv C H O</code>这个命令。<br>4） 脚本内容如下：大家可以自己手动敲一遍，找找感觉。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash  </span></span><br><span class="line"><span class="comment"># show old POTCAR </span></span><br><span class="line"><span class="keyword">if</span> [ -e POTCAR ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&#x27;old POTCAR containes....&#x27;</span></span><br><span class="line">  grep TIT POTCAR| awk <span class="string">&#x27;&#123;print $4&#125;&#x27;</span> | xargs</span><br><span class="line"><span class="comment"># Remove old POTCAR  </span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&#x27;************************&#x27;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Removing OLD POTCAR.....&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&#x27;************************&#x27;</span></span><br><span class="line">  rm POTCAR -f</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># generate new POTCAR </span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Generating NEW POTCAR...&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;************************&#x27;</span></span><br><span class="line">potcar.sh $(sed -n 6p POSCAR)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Done&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># compare elements in new POTCAR and POSCAR</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;************************&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;NEW POTCAR containes....&#x27;</span></span><br><span class="line">grep TIT POTCAR| awk <span class="string">&#x27;&#123;print $4&#125;&#x27;</span> | xargs</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;************************&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Elements in POSCAR&quot;</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;************************&#x27;</span></span><br><span class="line">sed -n 6p POSCAR</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>5）提交任务的脚本保持一样</p>
<p>前面所说的都是一些具体的做法，用化学的思维来说，应该叫基元反应。当你掌握了这些具体的做法后，可以通过批处理的方式将它们集成起来。本人的做法如下：</p>
<p>1）批量编辑POSCAR：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed  -i  &#x27;6s/O/C/g&#x27; */POSCAR </span><br></pre></td></tr></table></figure>
<p><img src="/2018/10/11/ex63/ex63-12.png" alt=""></p>
<p>i） 将O原子的计算直接复制成C原子的<br>ii）使用sed 批量编辑POSCAR中的元素行。</p>
<p>2）完成前面的一步，直接批量提交任务： 提交任务的时候，脚本自动根据POSCAR生成对应的POTCAR.</p>
<p><img src="/2018/10/11/ex63/ex63-13.png" alt=""><br><img src="/2018/10/11/ex63/ex63-14.png" alt=""></p>
<p>我是怎么做的呢？</p>
<p>在<code>~/.bashrc</code> 文件中 将<code>pospot.sh</code> 写到 <code>qsuball</code>里面了。大家可以看下我的<code>~/bashrc</code>文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias q=&#x27;yhqueue&#x27;</span><br><span class="line">alias qsuball=&#x27;for i in * ; do cd $i ; pospot.sh &amp;&amp; qsub ; cd $OLDPWD; done&#x27;</span><br><span class="line">alias qdel=&#x27;yhcancel&#x27;</span><br><span class="line">alias fenergy=&#x27;grep &quot;  without&quot; OUTCAR&#x27;</span><br><span class="line">alias ..=&#x27;cd ..&#x27;</span><br><span class="line">alias ...=&#x27;cd ../..&#x27;</span><br><span class="line">alias ....=&#x27;cd ../../..&#x27;</span><br><span class="line">alias gl=&#x27;grep LOOP OUTCAR&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="批量删除任务"><a href="#批量删除任务" class="headerlink" title="批量删除任务"></a>批量删除任务</h2><p>前面批量提交了任务，但这些任务已经算起来了，但这些结果对我没有用出，纯属浪费机时，所以我要杀死它们。这里介绍给大家一个简单的批量删除任务的命令： {..} 操作如下：</p>
<p><img src="/2018/10/11/ex63/ex63-16.png" alt=""></p>
<p><code>qdel</code> 就是天河II号中的<code>yhcancel</code>命令，本人根据自己的习惯，修改了一下<code>alias</code>中的内容（见前面<code>~/bashrc</code>文件的内容）</p>
<p>如果你的任务不是连续的，也可以使用这个命令， 只要把第一个和最后一个任务的ID号写在花括号里两个点<code>..</code>的两端即可。非常简单，暴力和直接。</p>
<p>中间如果有些任务不是你的，即使你想杀死也没有权限，系统会报错，直接忽视即可。</p>
<h2 id="找不同-1"><a href="#找不同-1" class="headerlink" title="找不同"></a>找不同</h2><p>前面我们弄完了C原子的计算任务，下面我们再玩一次找不同的游戏</p>
<p>找不同4：下面2个截图中找出不同的地方：</p>
<p><img src="/2018/10/11/ex63/ex63-17.png" alt="">  <img src="/2018/10/11/ex63/ex63-18.png" alt=""></p>
<p>师兄，这个题很简单，你要算H原子的吸附。跟前面的操作是一样的。</p>
<p><strong>但是</strong>，请看最后一行。</p>
<p>仔细的你会发现，这个题跟前面的有些不一样，原因在于最底部的坐标也稍微变化了一下，从<code>7.935</code>变成 <code>7.635</code>了。 这是为什么呢？<br>原因在于和C，O原子比起来，H原子很小，它在表面上吸附的时候，会更贴近表面。因此我们把z方向的坐标稍微修改了一下： 减小了 0.3 A。这样做的话可以保证我们的初始结构更<strong>具有合理的物理化学意义</strong>，从而加快计算的收敛，节约时间。大家在搭建模型的时候，结构合理是必须要考虑的，也是脑子里要时刻思考的事情。</p>
<p>通过<code>sed</code>命令批量操作在H原子的吸附上，只能完成一半的任务，也就是把元素行中的C或者O改成H。而另一半的任务：坐标的修改，则需要大家自己手动操作一下（记得在<code>Cartesian</code>坐标下修改，如果你脑子转的很快，可以迅速将<code>Direct</code>转化为<code>Cartesian</code>的话，也可以直接编辑<code>Direct</code>坐标）。</p>
<h2 id="扩展练习："><a href="#扩展练习：" class="headerlink" title="扩展练习："></a>扩展练习：</h2><p>1） 完成本节的所有操作；<br>2） 计算C,H，O在Cu(111)表面上，不同位点上的吸附；<br>3） 思考脚本的运行原理；<br>4） 思考如何通过：（找不同 + 写脚本）来节省自己的体力；<br>5） 思考自己平时常见的人工错误，并尝试用脚本来解决或者避免。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>本文的题目是闭着眼算，不是让你真正闭着眼去提交任务，而是不通过可视化的界面进行结构的批量搭建，输入文件的批量处理以及提交任务。希望大家在搭结构的时候，多一些思考，少一些操作，在搭建合理结构的路上突飞猛进。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>脚本</tag>
        <tag>sed</tag>
        <tag>模型搭建</tag>
        <tag>找不同</tag>
        <tag>批量操作</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex64 吸附能的计算（九）</title>
    <url>/2018/11/02/ex64/</url>
    <content><![CDATA[<p><img src="/2018/11/02/ex64/ex64-00.png" alt=""></p>
<p>前面我们讲解了一堆单原子的吸附计算和一些日常的操作，现在是时候来点复杂的操练了。这次，我们拿CO开刷，计算它在Cu(111)表面上的吸附。由于CO比前面的O多了一个原子，复杂性稍微提高了些，但也不是太复杂。作为一个由简单向复杂体系的过渡，是一个很好地例子。</p>
<p>在计算CO的吸附之前，我们首先要了解以下3点：（都是教科书里面的经典内容，下面只列出来，不再细说，如果不懂的话，找本结构化学书好好啃一啃。）</p>
<h2 id="1-CO分子信息："><a href="#1-CO分子信息：" class="headerlink" title="1. CO分子信息："></a>1. CO分子信息：</h2><h3 id="1）CO的分子结构，如下图："><a href="#1）CO的分子结构，如下图：" class="headerlink" title="1）CO的分子结构，如下图："></a>1）CO的分子结构，如下图：</h3><p><img src="/2018/11/02/ex64/ex64-01.png" alt=""></p>
<h3 id="2）-CO的几何结构：（用来搭建吸附和气相的模型）"><a href="#2）-CO的几何结构：（用来搭建吸附和气相的模型）" class="headerlink" title="2） CO的几何结构：（用来搭建吸附和气相的模型）"></a>2） CO的几何结构：（用来搭建吸附和气相的模型）</h3><p><img src="/2018/11/02/ex64/ex64-02.png" alt=""><br><img src="/2018/11/02/ex64/ex64-03.png" alt=""></p>
<h3 id="3）-CO与金属的成键方式-（用来搭建吸附模型）"><a href="#3）-CO与金属的成键方式-（用来搭建吸附模型）" class="headerlink" title="3） CO与金属的成键方式 （用来搭建吸附模型）"></a>3） CO与金属的成键方式 （用来搭建吸附模型）</h3><p><img src="/2018/11/02/ex64/ex64-04.png" alt=""></p>
<h2 id="2-搭建CO吸附的模型："><a href="#2-搭建CO吸附的模型：" class="headerlink" title="2. 搭建CO吸附的模型："></a>2. 搭建CO吸附的模型：</h2><p>上一节我们学到了闭着眼操作的一些方式，这一节我们继续闭着眼搭结构。操作流程如下：</p>
<h3 id="1）-将上一节中-C-原子吸附的那几个模型复制过来，进行修改："><a href="#1）-将上一节中-C-原子吸附的那几个模型复制过来，进行修改：" class="headerlink" title="1） 将上一节中 C 原子吸附的那几个模型复制过来，进行修改："></a>1） 将上一节中 C 原子吸附的那几个模型复制过来，进行修改：</h3><ul>
<li>i) 修改POSCAR中的元素（第6行）和原子数目部分（第七行），添加O原子。</li>
</ul>
<p><img src="/2018/11/02/ex64/ex64-05.png" alt=""></p>
<ul>
<li>iii）在POSCAR的尾部，添加O原子的坐标：</li>
</ul>
<p><img src="/2018/11/02/ex64/ex64-06.png" alt=""></p>
<p>可以看到上图中，最后两行的坐标一模一样，这是因为CO在表面上吸附的时候，我们假定的是直立吸附。所以C 和 O原子的坐标在x和y方向上一样。不同的区别在z方向上，即CO的键长。CO如果吸附在表面上，肯定会和表面原子有作用，也就是所谓的活化，如果原子被活化了，那么CO键就会被削弱，具体体现在键长上。与气相的键长相比，表面上CO的键长数值更大一些。前面我们查数据库得到CO键长为：1.138A.这里我们不妨设置成1.2A。根据这些，我们设置O原子的坐标，如下：</p>
<p><img src="/2018/11/02/ex64/ex64-07.png" alt=""></p>
<p>同样，我们可以对其他吸附位点的坐标进行类似的修改，结果如下图：</p>
<p><img src="/2018/11/02/ex64/ex64-08.png" alt=""></p>
<h2 id="3-背一遍VASP的输入文件，检查还有那些需要修改的："><a href="#3-背一遍VASP的输入文件，检查还有那些需要修改的：" class="headerlink" title="3. 背一遍VASP的输入文件，检查还有那些需要修改的："></a>3. 背一遍VASP的输入文件，检查还有那些需要修改的：</h2><ul>
<li>i） INCAR： 跟之前保持一致；</li>
<li>ii）KPOINTS：跟之前保持一致；</li>
<li>iii） POSCAR： 已经修改完毕；</li>
<li>iV） POTCAR：提交任务的脚本里面自动生成</li>
<li>V）提交任务命令： qsuball （前面已经讲解过了）</li>
</ul>
<h2 id="4-提交任务："><a href="#4-提交任务：" class="headerlink" title="4. 提交任务："></a>4. 提交任务：</h2><p><img src="/2018/11/02/ex64/ex64-09.png" alt=""></p>
<p>上图，我们删除了slab的计算，因为前面我们已经计算过了，没有必要浪费机时再算一遍。</p>
<h2 id="5-思考下吸附能的计算公式："><a href="#5-思考下吸附能的计算公式：" class="headerlink" title="5. 思考下吸附能的计算公式："></a>5. 思考下吸附能的计算公式：</h2><script type="math/tex; mode=display">
E_{ads}(CO) = E_{slab+CO} - E_{slab} - E_{CO^{gas}}</script><p>前面我们还忘记了CO的气相结构优化。现在我们回忆一下前面所讲的气相分子的优化：</p>
<h3 id="1）-气相分子的结构模型搭建。"><a href="#1）-气相分子的结构模型搭建。" class="headerlink" title="1） 气相分子的结构模型搭建。"></a>1） 气相分子的结构模型搭建。</h3><p>直接将一个Cu(111)表面上吸附的POSCAR拿过来修改一下即可：</p>
<p><img src="/2018/11/02/ex64/ex64-10.png" alt=""></p>
<h3 id="2）-INCAR：直接拿Cu-111-吸附的修改下。"><a href="#2）-INCAR：直接拿Cu-111-吸附的修改下。" class="headerlink" title="2） INCAR：直接拿Cu(111)吸附的修改下。"></a>2） INCAR：直接拿Cu(111)吸附的修改下。</h3><p>对于气相分子的优化来说：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ISMEAR = 0 </span><br><span class="line">SIGMA = 0.01</span><br></pre></td></tr></table></figure>
<h3 id="3）-KPOINTS：-gamma-点即可。"><a href="#3）-KPOINTS：-gamma-点即可。" class="headerlink" title="3） KPOINTS： gamma 点即可。"></a>3） KPOINTS： gamma 点即可。</h3><h3 id="4）-这里我们没有批量提交，手动运行一下：pospot-sh脚本，生成对应的POTCAR。"><a href="#4）-这里我们没有批量提交，手动运行一下：pospot-sh脚本，生成对应的POTCAR。" class="headerlink" title="4） 这里我们没有批量提交，手动运行一下：pospot.sh脚本，生成对应的POTCAR。"></a>4） 这里我们没有批量提交，手动运行一下：<code>pospot.sh</code>脚本，生成对应的POTCAR。</h3><h3 id="5）-使用提交单个任务的脚本：-qsub-提交任务。具体操作如下图："><a href="#5）-使用提交单个任务的脚本：-qsub-提交任务。具体操作如下图：" class="headerlink" title="5） 使用提交单个任务的脚本： qsub  提交任务。具体操作如下图："></a>5） 使用提交单个任务的脚本： qsub  提交任务。具体操作如下图：</h3><p><img src="/2018/11/02/ex64/ex64-11.png" alt=""></p>
<h2 id="6-扩展练习："><a href="#6-扩展练习：" class="headerlink" title="6. 扩展练习："></a>6. 扩展练习：</h2><ul>
<li>1）完成CO吸附的计算；</li>
<li>2）进一步熟练简单模型的闭着眼操作方式；</li>
<li>3）复习分子气相结构的优化过程。</li>
</ul>
<h2 id="7-总结："><a href="#7-总结：" class="headerlink" title="7. 总结："></a>7. 总结：</h2><p>本节，通过CO的吸附模型搭建，带领大家走出简单的单原子吸附，开始逐渐接触复杂的吸附计算。如果前面内容掌握了，本节就是一个水到渠成的事情。在多原子分子的吸附计算中，首先我们要知道分子的电子和几何结构，分子哪一部分（这里的C原子）和表面成键。在本节的例子中，如果你不知道C和金属作用，你还需要计算Metal-O-C这样的结构。可能还会计算CO横着吸附的结构，任务无形中就会增加一倍或者更多，从而造成机时的浪费。退一步来说，如果你真的不知道吸附是以什么方式进行的，想尝试N种初始的结构，我的建议是：把slab的原子全部固定住，然后用gamma点算一下它们的吸附能，先大体上判断一下，把那些吸附特别强的结构筛选出来，用作下一步的计算。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>模型搭建</tag>
        <tag>吸附能</tag>
        <tag>CO</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex65 p4vasp 的旋转操作</title>
    <url>/2018/11/03/ex65/</url>
    <content><![CDATA[<p>经过前面的学习，相信对于：单原子和双原子分子的吸附，大家已经掌握了怎么搭建模型，以及计算吸附能了。下一节我们要讲的是三原子分子的吸附。在进行三原子分子吸附的计算之前，我想是时候祭出本人使用p4vasp搭结构的一个法宝了。古人语，工欲善其事，必先利其器。所以，本人认为这一节的学习对于以后的结构搭建非常重要，尤其是对于那些使用p4vasp的筒子们来说。说了这么多废话，本节主要内容是手动搭建一个H$_2$O分子，并实现分子的任意旋转。</p>
<hr>
<h2 id="1-获取结构"><a href="#1-获取结构" class="headerlink" title="1. 获取结构"></a>1. 获取结构</h2><p>首先我们先知道H$_2$O分子的基本结构。本人的做法是去NIST数据库查找资料。操作如下图：</p>
<p><img src="/2018/11/03/ex65/ex65-01.png" alt=""></p>
<p>点击上的链接，或者点击 <a href="https://cccbdb.nist.gov/expgeom1x.asp">NIST网址</a>查询得到下面的信息：</p>
<p><img src="/2018/11/03/ex65/ex65-02.png" alt=""></p>
<p>在NIST的数据库里面，基本的热力学数据，结构都有了。大家完全可以按照上图中的<code>Cartesian</code>坐标搭建一个H$_2$O的结构，直接复制到POSCAR即可。不过，这个操作我们先缓一下，以后你有的是机会操作。本节主要介绍下如何是从头开始搭建一个H$_2$O分子模型，整个操作过程的学习比搭建模型的结果更加重要。</p>
<hr>
<h2 id="2-模型搭建："><a href="#2-模型搭建：" class="headerlink" title="2. 模型搭建："></a>2. 模型搭建：</h2><h3 id="1）数据库结构"><a href="#1）数据库结构" class="headerlink" title="1）数据库结构"></a>1）数据库结构</h3><p>O—H的键长为0.9578 A，∠HOH = 104.478°。</p>
<h3 id="2）直角形H2O分子"><a href="#2）直角形H2O分子" class="headerlink" title="2）直角形H2O分子"></a>2）直角形H2O分子</h3><p>首先，我们在xy平面内搭建一个直角形的H$_2$O分子。O放到原点： 0, 0, 0，H_1沿着x轴， 0.96, 0, 0，H_2 沿着y轴： 0, 0.96, 0</p>
<p><img src="/2018/11/03/ex65/ex65-03.png" alt=""></p>
<p><img src="/2018/11/03/ex65/ex65-04.png" alt=""></p>
<h3 id="3）修改角度"><a href="#3）修改角度" class="headerlink" title="3）修改角度"></a>3）修改角度</h3><p> 前面说了，∠HOH = 104.478°， 我们该怎么做呢？</p>
<ul>
<li><p>i) 可以自己手动算一算，其中一个H原子的坐标，然后更新坐标信息。三角公式大师兄早就忘的一干二净了，暂时跳过。</p>
</li>
<li><p>ii）通过p4vasp进行旋转操作。</p>
<p>对于旋转操作，我们首先要定义一个旋转轴；然后选择旋转的原子，以及角度。在上面H$_2$O的结构里面，很容易就想到，如果∠HOH 从 90°增大到 104.478°， 我们需要以O原子所在的z轴，旋转一个H原子即可，旋转角度为14.478°。</p>
</li>
</ul>
<hr>
<h3 id="4）-p4vasp获取旋转轴的操作："><a href="#4）-p4vasp获取旋转轴的操作：" class="headerlink" title="4） p4vasp获取旋转轴的操作："></a>4） p4vasp获取旋转轴的操作：</h3><ul>
<li>i) 选中O原子；</li>
<li>ii) P4vasp界面左上方， <code>Edit</code>—&gt;<code>Rotate Atoms</code>；</li>
<li>iii) 弹出的界面点击：<code>Get Group</code>；</li>
<li>iv）<code>Center</code> 那一行，点击<code>1st</code>的按钮；</li>
<li>v) <code>Second point</code>那一行，点击<code>1st</code>的按钮；</li>
<li>vi) <code>Axis</code>那一行，点击 <code>Z</code>的按钮。</li>
</ul>
<p>这样我们就定义了一个穿过O原子的z轴。</p>
<p><img src="/2018/11/03/ex65/ex65-05.png" alt=""></p>
<h3 id="5）-p4vasp选择要旋转的原子和角度："><a href="#5）-p4vasp选择要旋转的原子和角度：" class="headerlink" title="5） p4vasp选择要旋转的原子和角度："></a>5） p4vasp选择要旋转的原子和角度：</h3><ul>
<li>i)把鼠标分别移动要要旋转的H上，通过键盘的<code>space</code> 空格键选择。</li>
<li>ii)在上一步<code>Edit</code> –&gt; <code>Rotate Atoms</code> 弹出的对话框中，再点一下： <code>Get Group</code>。</li>
<li>iii)最后一行，我们选择 -15 作为旋转的角度。</li>
</ul>
<p><strong>注意1</strong>： +15 和 -15 顺时针和逆时针旋转15°。 如果你旋转错了，不要心慌，把数值改下，重新旋转即可。</p>
<p><strong>注意2</strong>： 你也可以先选中O和H原子，然后在center 和 second point 那两行都选择1st来获取旋转轴。</p>
<p><img src="/2018/11/03/ex65/ex65-06.png" alt=""></p>
<p>点击最下面的： Rotate，效果如下：</p>
<p><img src="/2018/11/03/ex65/ex65-07.png" alt=""></p>
<p>由于我们绕着O原子旋转，所以O原子选中或者不选中，旋转操作都对其坐标都没有影响。通过Structure – Measure 测定一下 三个原子的角度。</p>
<p><img src="/2018/11/03/ex65/ex65-08.png" alt=""></p>
<hr>
<h2 id="3-绕任意轴旋转"><a href="#3-绕任意轴旋转" class="headerlink" title="3.  绕任意轴旋转"></a>3.  绕任意轴旋转</h2><p>上面我们介绍了一下，绕一个单原子的轴进行的旋转操作。而实际的模型调整，搭建的过程中，这种情况并不多，大多时候我们需要绕着一个3D空间里面的轴进行旋转，而不仅仅局限在xyz这样简单的情况。我们知道，两点可以确定一条直线，所以，对于旋转轴来说，我们可以通过两个原子来定义。下面我们讲解一下，H$_2$O分子绕着一个O—H键的旋转操作。</p>
<h3 id="1）定义旋转轴："><a href="#1）定义旋转轴：" class="headerlink" title="1）定义旋转轴："></a>1）定义旋转轴：</h3><ul>
<li>i) 选择 O 原子 和 H原子；</li>
<li>ii) Edit –-&gt; Rotate Atoms；</li>
<li>iii) Get group；</li>
<li>iv) Center 那一行，点 1st；</li>
<li>v) Second point那一行，点 last。</li>
</ul>
<p>点完之后，下面一行会自动填充我们选择的旋转轴。即从1st原子指向last原子的一个轴。最后一部分，我们写的是60，即绕着O—H键 旋转60°。</p>
<p><img src="/2018/11/03/ex65/ex65-09.png" alt=""></p>
<p>选择要旋转的原子，由于前面两个原子已经用来定义旋转轴了，剩下的第三个就是我们旋转操作的对象。选中所有的原子，然后点击 Get group。 下面的图是：H$_2$O 的一个H原子绕着另外两个原子的轴旋转 -60 °的效果。我们绕着一个O—H 键旋转，旋转操作对轴上的原子坐标没有影响，所以大家可以选中这些原子，也可以先通过这两个原子定义旋转轴，进行最后一步操作的时候，取消选择也可以。</p>
<p><img src="/2018/11/03/ex65/ex65-10.png" alt=""></p>
<h3 id="2）移动水分子"><a href="#2）移动水分子" class="headerlink" title="2）移动水分子"></a>2）移动水分子</h3><p> 一般对于分子的计算来说，如果分子在原点附近的话，由于周期性的原因，结构的一部分会进入到另外一个相邻的格子里面，虽然对于计算没有什么影响，但对后面的其他可视化过程（比如，频率计算等）会造成一定的影响。所以本人经常把原子移到格子里面。选择所有的原子，在最后的Vector部分，选择5 5 5， 即在xyz三个方向上都移动5A的距离。点击move，效果如下图，然后保存结构。</p>
<p><img src="/2018/11/03/ex65/ex65-11.png" alt=""></p>
<hr>
<h2 id="4-扩展练习："><a href="#4-扩展练习：" class="headerlink" title="4. 扩展练习："></a>4. 扩展练习：</h2><ul>
<li>1） 重复本节的所有操作；</li>
<li>2） 复习前面乙醇分子模型的搭建</li>
<li>3） 根据今天所学，随意操作乙醇分子中，原子的旋转，平移等操作，直至熟练位置。</li>
</ul>
<h2 id="5-总结："><a href="#5-总结：" class="headerlink" title="5. 总结："></a>5. 总结：</h2><p>本节的重点是学会用p4vasp 进行分子的旋转操作，并复习下分子的平移操作。分子的旋转在表面结构模型的搭建过程中，非常重要，熟练掌握这一个技巧，可以极大提高自己搭建模型的合理性和准确性，从而在后面的计算过程中，节约我们的计算时间。如果你有更好的方法，也也可以分享经验给大家。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>模型搭建</tag>
        <tag>吸附能</tag>
        <tag>CO</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex66 H$_2$O在Cu(111)表面上的吸附模型</title>
    <url>/2018/11/04/ex66/</url>
    <content><![CDATA[<p>结合上一节的内容，下面主要讲解一下H$_2$O分子在Cu(111)表面吸附的初始模型搭建。</p>
<h2 id="1-计算H-2-O气相分子的能量"><a href="#1-计算H-2-O气相分子的能量" class="headerlink" title="1. 计算H$_2$O气相分子的能量"></a>1. 计算H$_2$O气相分子的能量</h2><p>相信大家已经轻车熟路了（老司机）。只将INCAR，KPOINTS，POSCAR列出来，不再详细解释。如下图：</p>
<p><img src="/2018/11/04/ex66/ex66-01.png" alt=""></p>
<p>提交任务，结束后，将CONTCAR中的Direct坐标转换为Cartesian，方便后面的表面模型搭建。</p>
<p>怎么转换前面也讲过了，这里也不再啰嗦。</p>
<hr>
<p><strong>☆☆☆注意：很多人问H$_2$O的分子计算用不用打开自旋的问题?</strong></p>
<p>我的回答是：</p>
<ul>
<li>1）如果你的体系是开壳层的，那么就打开自旋。</li>
<li>2）如果你的体系是闭壳层的，那么就闭嘴。</li>
<li>3）如果你不知道自己的体系是开壳层的还是闭壳层的，那么就：</li>
<li><ul>
<li>i) 自己去测试一把，然后对比下，打开与不打开的区别</li>
</ul>
</li>
<li><ul>
<li>ii）查找文献，看别人怎么做的。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-搭建H-2-O的吸附模型"><a href="#2-搭建H-2-O的吸附模型" class="headerlink" title="2. 搭建H$_2$O的吸附模型"></a>2. 搭建H$_2$O的吸附模型</h2><p><strong>1） 打开p(3x3)-Cu(111)的slab结构。</strong></p>
<p>先点击左侧的Build，然后点击右上方的text 按钮，进入编辑的部分。如下面的示意图：</p>
<p><img src="/2018/11/04/ex66/ex66-02.png" alt=""></p>
<p>注意：上面的只是p4vasp的一个界面，不是p(3x3)-Cu(111)的slab结构。</p>
<hr>
<p><strong>2） 元素行，原子数目</strong></p>
<p>在元素行，添加O和H，下面一行，添加对应的原子数。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="/2018/11/04/ex66/ex66-03.png" alt=""></h2><p><strong>3）添加H$_2$O分子坐标</strong></p>
<p> 在坐标的最后面，将前面CONTCAR的Cartesian坐标直接复制过来即可。</p>
<p><img src="/2018/11/04/ex66/ex66-04.png" alt=""></p>
<p><strong>4） 结果：</strong></p>
<p><img src="/2018/11/04/ex66/ex66-05.png" alt=""></p>
<p>师兄，水分子跑到slab里面去了，这可怎么办？ 答：往上平移下即可。</p>
<p>选择O H 以及表面上的任意一个Cu原子。回顾前面的平移操作：</p>
<p>From 那行点 1st 代表的是O原子</p>
<p>To 那行点 last 代表的是表面的4号Cu原子</p>
<p>得到的vector 就是从O到Cu的平移矢量。</p>
<p><strong>☆☆☆注意：</strong></p>
<p>Vector的第三个数字，这个是O和Cu在垂直方向上的距离。我们知道，H$_2$O在Cu上吸附的时候，Cu—O有一定的距离，不妨先给个初始值2A。所以，我们需要把 1.246改成3.246。</p>
<hr>
<p><strong>小窍门</strong>：在下面红色圈出来的部分，可以通过一些快捷的操作来实现原子的选择。</p>
<p><img src="/2018/11/04/ex66/ex66-06.png" alt=""></p>
<ul>
<li>i） 在p4vasp 里面可以直接通过写元素符号，选择该元素所有的原子；</li>
<li>ii） -10 代表从第一个到第10个原子；</li>
<li>iii） all 代表所有的原子；</li>
<li>iv） 10- 代表从10到最后的原子；</li>
<li>v） 10-25 代表从10到25号原子；</li>
<li>vi） 剩下的，自己瞎捉摸去吧，我也不知道了。</li>
</ul>
<hr>
<p>上面移动的效果如下：</p>
<p><img src="/2018/11/04/ex66/ex66-07.png" alt=""></p>
<p><strong>5） 周期性显示的小技巧</strong></p>
<p>刚开始选择的4号原子在两个格子之间的界面上，本人喜欢将分子放到表面的中间。操作如上图：</p>
<ul>
<li>i） 选择表面上的2个原子： 4 和 5 来定义平移的一个vector。</li>
<li>ii） 平移一下O和H原子，效果如下：</li>
</ul>
<p><img src="/2018/11/04/ex66/ex66-08.png" alt=""></p>
<p>当然，在开始的时候，你也可以将H$_2$O分子直接移动到5号原子的表面，大师兄这里做了一些无用的分解操作，主要是为了加深大家的操作印象。</p>
<hr>
<h2 id="3-考虑不同的可能性"><a href="#3-考虑不同的可能性" class="headerlink" title="3. 考虑不同的可能性"></a>3. 考虑不同的可能性</h2><p>到目前为止，我们已经顺利搭建了一个H$_2$O分子的吸附模型。把它保存到type_1目录下，名字为POSCAR。</p>
<p><strong>师兄，为什么要建一个type_1的目录？</strong></p>
<p>因为除了这个结构，H$_2$O分子在表面上还有很多其他的可能性。为了保证我们可以获得最稳定的吸附结构，我们就需要将这些可能的结构都算一遍。那么还有其他什么样的可能性呢？</p>
<ul>
<li>1） 一个H原子指向天空，另外的O—H 键平行于表面。这个结构怎么实现？ 回想上一节我们讲到的绕着O—H键旋转的操作。看下图，不解释。</li>
</ul>
<p><img src="/2018/11/04/ex66/ex66-09.png" alt=""></p>
<ul>
<li>2） 2个H原子都指向天空，只留一个O原子在表面。（剪刀手V）</li>
</ul>
<p><img src="/2018/11/04/ex66/ex66-10.png" alt=""></p>
<hr>
<p>操作思路： 定义一个穿过O原子的y 轴，然后旋转氢原子。</p>
<p>将这两个结构分别保存到type_2 和 type_3 目录下，名字为POSCAR。按照这样完成的话，你的目录应该是这个样子的：</p>
<p><img src="/2018/11/04/ex66/ex66-11.png" alt=""></p>
<p><strong>☆小窍门</strong>：p4vasp  */POSCAR  打开当前所有目录下的POSCAR，然后：</p>
<p><img src="/2018/11/04/ex66/ex66-12.png" alt=""></p>
<p><strong>☆☆☆注意</strong>：本操作是在Ubuntu系统下操作的。Windows的用户可能不能实现p4v */POSCAR 这样的操作，下面讲解的搭建模型可能会多花出一些时间。在这里大师兄表示无能为力。</p>
<hr>
<h2 id="4-不同的吸附位点"><a href="#4-不同的吸附位点" class="headerlink" title="4. 不同的吸附位点"></a>4. 不同的吸附位点</h2><p>我们前面了解到Cu(111)表面也有很多不同的位点：Top，Fcc，Hcp，和 Bri。所以这三种的初始构型在这四个位点上也要考虑。</p>
<p>Bridge的操作，选择5 和 6， 然后将Vector的数值减小一半，然后平移。</p>
<p><img src="/2018/11/04/ex66/ex66-13.png" alt=""></p>
<p><img src="/2018/11/04/ex66/ex66-14.png" alt=""></p>
<p>平移完了，将结构保存到bri目录下。</p>
<p><strong>此时不要关闭平移的对话框（这是☆重点1）</strong></p>
<p><strong>点system对应的这个框，选择type_2 的POSCAR（☆重点2）</strong></p>
<p>再点一下move，就完成这个类型的bri结构了。</p>
<p><img src="/2018/11/04/ex66/ex66-15.png" alt=""></p>
<p><img src="/2018/11/04/ex66/ex66-16.png" alt=""></p>
<p>同样，不要关闭对话框，打开type_3的结构，继续平移，获取对应的bri位结构。</p>
<p><img src="/2018/11/04/ex66/ex66-17.png" alt=""></p>
<p>这样操作的话，避免了重复获取平移Vector的那些鼠标点点的操作。点一次，可以继续用于其他结构的操作。希望大家可以掌握这个小窍门，提高自己搭模型的速度。Windows的用户，可以通过将Vector的数值先记下，然后打开另一个结构的时候，直接输入vector就可以了。类似的，我们可以快速搭建完FCC，HCP的结构，最后，你的目录应该是这样子的：</p>
<p><img src="/2018/11/04/ex66/ex66-18.png" alt=""></p>
<p>将这些结构复制到服务器里面，准备提交任务。</p>
<hr>
<h2 id="5-扩展练习："><a href="#5-扩展练习：" class="headerlink" title="5. 扩展练习："></a>5. 扩展练习：</h2><ul>
<li>1） 完成这12个结构的搭建，彻彻底底地掌握p4vasp平移，旋转操作。</li>
<li>2） 使用MS，VESTA，p4vasp 搭建一个p(4x4)-Pt(111) 的吸附模型。（Bulk，slab的优化过程不用做，只熟悉搭建模型的过程。</li>
<li>3） 思考如何批量准备输入文件，并提交任务？</li>
<li>4） 思考准备的任务输入文件有什么需要注意的地方？</li>
</ul>
<hr>
<h2 id="6-总结："><a href="#6-总结：" class="headerlink" title="6. 总结："></a>6. 总结：</h2><p>学完这一节：</p>
<ul>
<li>1） p4vasp的基本操作，我是没有什么其他可以再教的了。基本上学会这些可以说p4vasp已经入门了，剩下的就是大家没事瞎点点，然后琢磨的事情了。</li>
<li>2）至少含有1-3原子的分子吸附模型你应该会搭建了。原则如下：</li>
<li><ul>
<li>i）通过基本的化学常识和自己所学的知识判断与表面结合地原子； </li>
</ul>
</li>
<li><ul>
<li>ii）分析表面不同的吸附位点；</li>
</ul>
</li>
<li><ul>
<li>iii） 思考可能的吸附方式（躺着、竖着、斜着、歪着等等），并通过平移，旋转来实现。</li>
</ul>
</li>
</ul>
<p>而最后一点，每思考一种吸附方式，都会使得自己的模型数目激增（这种吸附方式在不同位点上），增加工作量。所以，大家在操作的时候，一定要多看文献，因为前人已经把这蛋疼的路帮你走通了。但这并不意味着别人算的就是对的，大家都是人，也会有疏忽的时候，如果你感觉某个结构应该会更稳定，一定要去尝试一下。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>模型搭建</tag>
        <tag>吸附能</tag>
        <tag>H$_2$O</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex67 H$_2$O在Cu(111)表面上的吸附能</title>
    <url>/2018/11/05/ex67/</url>
    <content><![CDATA[<p>前面我们搭建了十二个H$_2$O的初始吸附构型。为了获取最稳定的结构，我们需要将这些可能的结构都优化一遍，然后通过吸附能来判断。但是这12个结构，我们都要优化的话，需要很多的机时，尤其是对于那些不太富裕的课题组来说，计算量着实不小。那么我们应该怎么办呢？ 回顾：</p>
<ul>
<li>1）前面几节我们讲的通过简化模型来加快计算的步骤</li>
<li>2）谁偷了我的机时系列。</li>
</ul>
<hr>
<p>这里我们可以选择的办法有N个：主要是这两个：1） 减小K点； 2）减小模型。</p>
<h3 id="1）-减小K点的做法"><a href="#1）-减小K点的做法" class="headerlink" title="1） 减小K点的做法"></a>1） 减小K点的做法</h3><ul>
<li>i)固定住所有的表面原子（H$_2$O分子除外） </li>
<li>ii)使用gamma点进行计算</li>
</ul>
<h3 id="2）-减小模型的做法"><a href="#2）-减小模型的做法" class="headerlink" title="2） 减小模型的做法"></a>2） 减小模型的做法</h3><ul>
<li>i)删去底部的2层原子</li>
<li>ii)固定表层的所有原子</li>
<li>iii)正常优化进行计算</li>
</ul>
<h3 id="3）-也可以前面两个方法结合起来进行操作"><a href="#3）-也可以前面两个方法结合起来进行操作" class="headerlink" title="3） 也可以前面两个方法结合起来进行操作"></a>3） 也可以前面两个方法结合起来进行操作</h3><p>不管你使用上面什么方法，简化模型这一步的主要目的就是在最快的时间，获取一个最理想的初始构型。当你的初始构型很多的时候，这种办法非常适合作为一个初始的筛选步骤。</p>
<p>师兄，为什么不通过ENCUT来减小计算量？ </p>
<p>答：完全可以，只是本人不经常用这种办法而已。个人偏好将INCAR保持不变，以避免ENCUT不同所导致的计算结果错误。</p>
<hr>
<h2 id="1-H-2-O-吸附构型的第一步筛选："><a href="#1-H-2-O-吸附构型的第一步筛选：" class="headerlink" title="1. H$_2$O 吸附构型的第一步筛选："></a>1. H$_2$O 吸附构型的第一步筛选：</h2><p>这里，大师兄采用的是前面提到的第一个办法，即固定住表面，采用gamma点，然后优化H$_2$O。</p>
<p><img src="/2018/11/05/ex67/ex67-01.png" alt=""></p>
<ul>
<li><p>1） 准备INCAR，KPOINTS(1x1x1)；</p>
</li>
<li><p>2） 批量固定表面： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;10,27s/T/F/g&#x27;  */*/POSCAR </span><br></pre></td></tr></table></figure>
</li>
<li><p>3） 将准备好的INCAR和KPOINTS批量复制到各个文件夹中: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in */*； do cp INCAR KPOINTS $i ; done</span><br></pre></td></tr></table></figure>
</li>
<li><p>4） 批量提交任务qsuball.sh</p>
</li>
</ul>
<hr>
<p>任务结束后，首先查看一下能量信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in */*; do echo $i $(grep &#x27;  without&#x27; $i/OUTCAR | tail -n 1| awk &#x27;&#123;print $7&#125;&#x27;) ; done</span><br></pre></td></tr></table></figure>
<p><img src="/2018/11/05/ex67/ex67-02.png" alt=""></p>
<p>上图，我们发现能量数值相近的差不多，这表明它们很可能是同一个结构。我们把数值sort一下，如下图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in */*; do echo $i $(grep &#x27;  without&#x27; $i/OUTCAR | tail -n 1| awk &#x27;&#123;print $7&#125;&#x27;) ; done | sort -k 2</span><br></pre></td></tr></table></figure>
<p><img src="/2018/11/05/ex67/ex67-03.png" alt=""></p>
<hr>
<p>通过使用p4vasp 批量查看：（p4v <em>/</em>/CONTCAR） 你会发现能量为-145.56XXX的都是H$_2$O平行吸附在Cu表面，O在Cu的top位上。</p>
<p><img src="/2018/11/05/ex67/ex67-04.png" alt=""></p>
<hr>
<p>而剩下的，就只有两种结构了：</p>
<ul>
<li>结构1） type_3/bri 为V型吸附，O在桥式位置上。</li>
</ul>
<p><img src="/2018/11/05/ex67/ex67-05.png" alt=""></p>
<ul>
<li>结构2）type_3/top为V型结构，O在top位置上。</li>
</ul>
<p><img src="/2018/11/05/ex67/ex67-06.png" alt=""></p>
<h2 id="2-进一步优化"><a href="#2-进一步优化" class="headerlink" title="2. 进一步优化"></a>2. 进一步优化</h2><p>到现在位置，前面的12个初始结构，可以快速的被筛选成了3个。将这三个结构复制step2的文件夹中。在此基础上，开始正常计算：</p>
<ul>
<li><p>1） 将CONTCAR批量复制成POSCAR：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> *； <span class="keyword">do</span> mv <span class="variable">$i</span>/CONTCAR <span class="variable">$i</span>/POSCAR ; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>2） KPOINTS变回原来的（4x4x1）:  sed 批量操作</p>
</li>
<li><p>3） 表面两层原子放开： sed 批量操作</p>
</li>
<li><p>4） 默背一遍提交任务的几个输入文件：INCAR，KPOINTS，POSCAR，POTCAR，脚本，集中注意力思考是否还有没有考虑到的参数或者细节，确保无误后</p>
</li>
<li><p>5） 批量提交任务： qsuball.sh</p>
</li>
<li><p>6）等待结束，查看结果</p>
</li>
</ul>
<p><img src="/2018/11/05/ex67/ex67-07.png" alt=""></p>
<p>你会发现两个top的能量也一样了，说明这两个结构很可能优化到一块去了。查看后发现都是平行吸附的结构了。</p>
<ul>
<li>7） 结构细节：化学上，我们对键长，键角这些信息一定不要放过。测量一下Cu—O 的距离，为： 2.343 $\AA$。</li>
</ul>
<p><img src="/2018/11/05/ex67/ex67-08.png" alt=""></p>
<ul>
<li>8） 计算吸附能：<script type="math/tex; mode=display">
\begin{align}
E_{ads} &= E_{slab+H_2O} – E_{slab} – E_{H_2O^{gas}} \\
&= (-140.33072118 eV) – (-125.93154318 eV) – (-14.21915741 eV)  \\
&= - 0.18 eV。
\end{align}</script></li>
</ul>
<p>与本人4年前的计算结果（-0.17 eV）相差0.01 eV。<a href="https://pubs.acs.org/doi/abs/10.1021/cs501698w">ACS Catal., 2015, 5, 1027-1036： https://pubs.acs.org/doi/abs/10.1021/cs501698w </a> </p>
<p><img src="/2018/11/05/ex67/ex67-09.png" alt=""></p>
<p>本人发表文章支持信息里面的数据。</p>
<p><strong>☆☆☆注意1：</strong></p>
<p>这里吸附能计算的时候，我们取的是最稳定的结构。文献里面提到的也通常是作者所找到的稳定结构。当然，对于不稳定的结构，吸附能也就是顺带的事情了。写在文章里面的话，要标明什么结构对应的吸附能是多少。</p>
<p><strong>☆☆☆注意2：</strong></p>
<p>分子在表面上是物理吸附？还是化学吸附？ 通过计算出来的吸附能你应该会判断。如果不知道的话，那么就需要多多翻阅物化书了。</p>
<hr>
<h2 id="3-扩展练习："><a href="#3-扩展练习：" class="headerlink" title="3. 扩展练习："></a>3. 扩展练习：</h2><ul>
<li>1） 根据结构和吸附能判断我们的计算结果是不是对的？</li>
<li>2） 查找其他相关文献，将自己的计算结果与文献的进行对比。</li>
<li>3） Step1中12个计算，以及step2中的3个计算，结构和输入文件已经打包，下载链接：<a href="https://pan.baidu.com/s/1iyS_nzhI-MuJykabI6rj1w">https://pan.baidu.com/s/1iyS_nzhI-MuJykabI6rj1w</a></li>
</ul>
<h2 id="4-总结："><a href="#4-总结：" class="headerlink" title="4. 总结："></a>4. 总结：</h2><p> 通过本节，你应该学会的知识有：</p>
<ul>
<li>1） 学会如何通过降低工作量来快速筛选不同的初始结构，并最终获取稳定的构型。</li>
<li>2） 巩固和加深对批量操作的理解。</li>
<li>3） 对于更加复杂的结构，其吸附能的基本计算流程要掌握。</li>
</ul>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>模型搭建</tag>
        <tag>吸附能</tag>
        <tag>H$_2$O</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex68 频率，零点能，吉布斯自由能的计算</title>
    <url>/2018/11/06/ex68/</url>
    <content><![CDATA[<p>前面几节，我们讲解完成了表面上吸附的计算细节。学习到现在，表面吸附的具体流程，如何简化计算，如何判断优化的结构正确与否，这些都是你应该掌握，并且时刻保持思考的事情。尤其是计算存在N种可能性的时候。当你优化出来最稳定的结构，一定要认真琢磨一番，为什么这个结构比其他的构型稳定？是什么因素导致了这个结构最稳定？ 从本人多年老司机的经验，简单来说：最稳定的结构从骨子里都透着美的气质，也就是比其他结构看起来更加顺眼。</p>
<hr>
<p>一旦我们获得了最稳定的结构，就可以进行后面的其他计算了，比如相关的过渡态，与其他分子的吸附能进行对比，与已有的参考文献进行对比，等等。<strong>应公众号阅读和分享冠军的要求</strong>，我们本节以及后面两节要讲解一下吉布斯自由能的计算，这也是物理化学、化学反应中最常见的一个物理量，尤其是对做电化学的筒子们来说，吉布斯自由能的计算是大家都需要牢牢掌握的。物理化学中，我们学到了：G = H – TS。 而对于G的计算，大家普遍卡在S的这个部分。<strong>再次强调</strong>，VASP不可以直接算熵，因此我们需要通过频率来自己计算，而OUTCAR里面的那个entropy不是我们物理化学的熵。本节我们简单介绍一下表面吸附物种的频率计算的一些注意事项，以及气相分子的S的获取以及G的计算</p>
<hr>
<p><strong>1 准备频率计算：</strong></p>
<p>回顾前面我们讲解的乙醇分子的计算例子，然后进行如下的步骤：</p>
<p>1） 修改INCAR的参数</p>
<p>IBRION = 5</p>
<p>POTIM = 0.015 或者0.01-0.02范围的值都可，闲的没事也可以测试下。</p>
<p>NFREE = 2</p>
<p>NSW = 1  1-10000的值均可，没事也可以测试下。</p>
<p>2） POSCAR: 将表面的原子固定住，使用sed命名，或者自己写个小脚本来处理。</p>
<p>3） KPOINTS，一般来说，很多人都使用和优化过程一样的KPOINTS，但从我个人的经验来看，使用更小的K点来计算则是一个更加有效，节约机时的做法。但前提是你要做足够的测试</p>
<p>4） POTCAR保持不变 （废话，等于没说）</p>
<hr>
<p><strong>2 K点的测试：</strong></p>
<p>回顾前面谁偷了我的机时系列，思考下面的计算，学会分析节约机时，省钱省力省时间。</p>
<p>1） 我们首先使用111, 221, 331, 441进行测试，然后对比振动频率的不同。EDIFFG 对于所有的计算均为 1E-7。</p>
<p>小技巧1）： 提取频率的波数，对应的能量，使用 grep  cm-1 OUTCAR 这个命令</p>
<p>小技巧2）： 只提取虚频，使用 grep  f/i OUTCAR</p>
<p>下面是我们测试的结果。H<sub>2</sub>O为三原子非线性的分子，振动的自由度为：3N - 6 = 3; 也就是有三个振动方式。减去的那6个分别为平动和转动。</p>
<p>对比下不同K点振动波数的区别，都在下面图里了，大家自己看下。</p>
<p><img src="/2018/11/06/ex68/ex68-1.png" alt=""></p>
<p>上面图中，前三个为振动的一些能量信息，通过对比可以发现：</p>
<p>i）使用 111 的KPOINTS的时候，我们得到了一个虚频，而其他的KPOINTS没有。</p>
<p>ii）对于振动来说，所有的KPOINTS的结果基本保持不变。</p>
<hr>
<p>2) 看下不同K值对计算时间的影响。</p>
<p><img src="/2018/11/06/ex68/ex68-2.png" alt=""></p>
<p>啥也不想说了，111所花的时间也仅仅是441的一个零头。如果你是个糙哥，111的结果完全够用。如果你是个细心的软男，不敢用111，但又害怕浪费机时，221则是个很好地选择。</p>
<hr>
<p><strong>3 EDIFFG的测试 </strong></p>
<p>这里之所以测试EDIFFG这个参数，是因为它决定了每一个离子步中电子步的步数。收敛条件越苛刻，需要的时间也就越多。</p>
<p>1） 下面是EDIFFG分别为1E-5，1E-6和1E-7的结果， 所有的计算中：KPOINTS为441</p>
<p><img src="/2018/11/06/ex68/ex68-3.png" alt=""></p>
<p>通过上面，你可以发现：EDIFFG  从1E-5到1E-7，振动频率变化很小。这个给我们的启示是，1E-5够用了。</p>
<p>2） 我们看一下时间：</p>
<p><img src="/2018/11/06/ex68/ex68-4.png" alt=""></p>
<p>K点都为441的时候，1E-5所花的时间是1E-7的一半。</p>
<hr>
<p><strong>4  思考与测试</strong></p>
<p>i) 通过前面的测试结果, 是不是就可以说我们可以使用gamma点和EDIFFG = 1E-5结合进行计算呢？</p>
<p>2）测试不同的KPOINTS + EDIFFG， 并且与 441 + EDIFFG = 1E-7的结果进行对比，筛选出最佳的节约机时，而又保证结果准确的参数。</p>
<hr>
<p><strong>5 总结一下表面上频率的计算：</strong></p>
<p>1） POSCAR， 固定表面</p>
<p>2） 修改INCAR： IBRION， POTIM， NFREE， 以及NSW（可有可无）</p>
<p>3） Play with KPOINTS + EDIFFG，节约机时，省时间去做其他的事情，给老板省钱。</p>
<p>4） 如果收敛困难的体系，可以保存优化步骤的WAVECAR用于下一步的频率计算。</p>
<hr>
<p><strong>6  零点能的计算：</strong></p>
<p>频率计算完成之后，我们便可以计算零点能了。回顾前面乙醇的例子。这里的振动零点能等于前三个振动模式能量之和，（EDIFFG = 1E-7， KPOINTS=441）的结果为：</p>
<p>（462.8 meV + 449.4 meV + 193.1 meV）/ 2000 = 0.55 eV。</p>
<hr>
<p><strong>7  熵的计算</strong></p>
<p> 零点能算完之后，我们还可以继续算以算熵。通过振动频率计算熵的做法我们下一节具体讨论。本节先介绍一下气相分子熵的获取。对于H<sub>2</sub>O来说，有3个平动和3个转动，而VASP在这方面做的实在是太差了。如果你有兴趣，可以翻阅一下<strong>Gaussian</strong>对于熵的计算细节：（<strong>下载链接</strong>：<a href="http://gaussian.com/thermo/">http://gaussian.com/thermo/</a> ）</p>
<p><img src="/2018/11/06/ex68/ex68-5.png" alt=""></p>
<p>我们可以根据这个，手动去计算平动和转动对熵的贡献，但相信大部分人不知道怎么去计算。庆幸的是，气相分子的熵值有热力学数据可以查。这里大师兄推荐2个数据库：</p>
<p><strong>1）CRC Handbook</strong></p>
<p>这是本人使用频率最高的数据库了。只要数据库里有的东西，写文章的时候直接引用这本书即可，非常方便。</p>
<p>如果有师弟师妹再问你类似相关的问题，也可以用这本书直接砸砸砸！真可谓是绝世好板砖！</p>
<p><img src="/2018/11/06/ex68/ex68-6.jpeg" alt=""></p>
<hr>
<p><strong>2) NIST 数据库 </strong> </p>
<p>网址： <a href="https://janaf.nist.gov/">https://janaf.nist.gov/</a> </p>
<p>如果你看一些原子热力学或者其他相关的计算，你会发现很多人在这个数据库里面获取熵值。很多人不仔细阅读文献，经常给我抱怨说找不到别人怎么算的。是的，你肯定不知道别人怎么算的，因为人家直接查的表，没有算。下面是这个数据库的简单用法：</p>
<p>1）点击红圈中的箭头： </p>
<p><img src="/2018/11/06/ex68/ex68-7.png" alt=""></p>
<p>2） 出来的下拉菜单中，点下H，然后找到H<sub>2</sub>O</p>
<p><img src="/2018/11/06/ex68/ex68-8.png" alt=""></p>
<p>3） 点view ，你会得到下面的界面：</p>
<p>-</p>
<p><img src="/2018/11/06/ex68/ex68-9.png" alt=""></p>
<p>不同温度下的熵值已经在表中了。直接拿过来用，气相的T*S到手！</p>
<hr>
<p><strong>8 吉布斯自由能的计算(气相分子)</strong></p>
<p>气相分子的吉布斯自由能为： G = H - TS = U + PV - TS = E_DFT + E_ZPE + nRT - TS  （n=1）</p>
<p>i） E_DFT就是我们直接提取的OUTCAR的能量。</p>
<p>ii） E_ZPE 我们计算的气相分子的零点能。（<strong>注意</strong>：是气相的，不是本节中我们算的表面的零点能）</p>
<p>iii）TS 查表获取</p>
<p>iV) 注意单位要统一。</p>
<hr>
<p><strong>9 总结: </strong></p>
<p>通过本节，你应该学会</p>
<p>1）怎么计算表面吸附物种的振动；</p>
<p>2）计算零点能；</p>
<p>3）知道频率计算中KPONTS和EDIFFG对计算时间和结果的影响；</p>
<p>4）知道怎么去测试它们的影响，并筛选出合理的参数，节约机时；</p>
<p>5）知道气相分子的熵怎么获取；</p>
<p>6）知道气相分子吉布斯自由能的计算。</p>
<p>7） 关于数据库：如果你是</p>
<p>i) 单身狗：如果有心仪的女生问你怎么算气相分子的熵，请一定不要告诉她这两个数据库。自己查了以后告诉她，没准儿她下次还会来问你。大师兄也只能帮到这儿了，剩下的就看你们自己的发挥啦！</p>
<p>ii）单身的小姐姐或者小妹妹：有了这两个数据库就完全掌握了主动权，剩下的就看个人的心情喽。</p>
<p>iii）老板的话，请直接拿板砖砸！</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>频率</tag>
        <tag>零点能</tag>
        <tag>吉布斯自由能</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex69 表面吸附物种的熵</title>
    <url>/2018/11/07/ex69/</url>
    <content><![CDATA[<p>上一节我们知道怎么获取气相分子的熵以及吉布斯自由能的计算。这一节，我们简单介绍一下表面吸附分子熵的计算。</p>
<h3 id="复习基础知识"><a href="#复习基础知识" class="headerlink" title="复习基础知识"></a>复习基础知识</h3><p>首先我们应该要知道对一个体系来说，都有哪几部分对熵有贡献。一般熵通过统计热力学计算分子的配分函数来获取：主要有平动，转动，振动，电子以及核这5部分。参考下面的这个链接： <a href="http://210.45.168.34:8080/elite/wlhx/jiaocai/C_05.htm">http://210.45.168.34:8080/elite/wlhx/jiaocai/C_05.htm</a> 或者找本物化书狂补统计热力学的知识。</p>
<p>1）电子运动的能级间隔很大，除了在几千度以上的高温条件下，电子常常处于基态。一般情况下各激发态对配分函数的贡献都可忽略。</p>
<p>2）原子核的能级间隔极大，在一般的物理和化学过程中，原子核总是处于基态。所以这一项也可以忽略。</p>
<p>3）到现在我们需要考虑的只有平动，转动和振动这三个了。</p>
<h3 id="分子从气相到表面吸附的过程"><a href="#分子从气相到表面吸附的过程" class="headerlink" title="分子从气相到表面吸附的过程"></a>分子从气相到表面吸附的过程</h3><p>当分子从气相吸附到表面上，打个不恰当的比喻，就如同图中的苍蝇被粘住在纸板上，因此就不能随便乱飞了，更不用说施展什么空中技巧了。</p>
<p><img src="/2018/11/07/ex69/ex69-1.jpeg" alt=""></p>
<p>同样，对分子来说，举个例子，一个非线性的三原子分子，一共有3N个自由度。气相里面为：3个平动，3个转动以及3N-6个振动。但是当它吸附到表面上，由于平动和转动被限制住了，这6个自由度则会转化成振动自由度，也就是在表面上分子有3N个振动模式。如果你可视化表面上吸附分子频率计算的结果，会发现最后6个分别对应的是平动和转动，但它们已经不是气相中的平动和转动了，我们称之为：frustrated translation，frustrated rotation。</p>
<p><img src="/2018/11/07/ex69/ex69-2.jpeg" alt=""></p>
<p>（你大妈(平动转动)已经不是十年前的大妈了，你大爷(振动)永远是你大爷）</p>
<p>这两个在表面化学里面是非常令人蛋疼的东西。这个我们后面慢慢讲。至少现在我们知道了，表面的吸附物种有3N个振动方式。所以，平动和转动对熵的贡献也不用管了，直接处理振动即可。（不会算的筒子们小开心下。）</p>
<h3 id="通过振动频率来计算Entropy"><a href="#通过振动频率来计算Entropy" class="headerlink" title="通过振动频率来计算Entropy"></a>通过振动频率来计算Entropy</h3><p>振动频率对熵的贡献，随便查阅一本统计热力学的书，都可以找到答案，这里我们的参考书是第十版Atkins的物理化学。</p>
<p>Physical Chemistry 第10版的642页。获取方式：QQ群文件，Books文件下里面就有，自己下载。</p>
<p><img src="/2018/11/07/ex69/ex69-3.jpeg" alt="">  <img src="/2018/11/07/ex69/ex69-4.png" alt=""></p>
<hr>
<p><img src="/2018/11/07/ex69/ex69-5.png" alt=""></p>
<p>图里面圈出来的公式里面，β，h，c，是基本的物理学常数。v （上面加个波浪号）是波数，单位是：m<sup>-1</sup>。我们就是通过这个公式来计算单个振动模式对熵的贡献。这个很简单，直接把数值带入公式即可，可以摁计算器，也可以用excel等其他工具进行计算。本节，我们分享一个对应这个公式的python小脚本。</p>
<p><img src="/2018/11/07/ex69/ex69-6.png" alt=""></p>
<p>通过单个振动频率计算熵的小脚本，图里面的98.485是错的，应该是96.485，kJ/mol 转换为 eV的常数。</p>
<p>脚本解释：</p>
<p>i）VASP得到的频率波数是cm<sup>-1</sup>，这也是大家所习惯接受的，所以在12行，单位要乘以100先将 cm<sup>-1</sup> 转化成m<sup>-1</sup>。</p>
<p>ii） 剩下的14-19行是一些基本的物理量，我们默认温度是300K;</p>
<p>iii) 21-27行：是我们定义的一个计算熵的小函数。</p>
<p>x_i 是书里面的 βhcv</p>
<p>pf_l和pf_r 是花括号里面，减号左面和右面的部分</p>
<p>pf 得到的是花括号的结果</p>
<p>然后entropy 是 pf * R</p>
<p>iv）29-31行就是调用函数，然后输出S, TS部分了。这里S的单位是 J K<sup>-1</sup>mol<sup>-1</sup>。TS 的单位是我们熟悉的eV。</p>
<p>v）自己对着图片输入一遍就可以得到脚本了，不要问我要现成的。如果自己照着抄的脚本运行出现错误，反复跟图片里面的进行对比，然后进行修改。</p>
<hr>
<h3 id="熟悉不同的振动频率对熵的贡献"><a href="#熟悉不同的振动频率对熵的贡献" class="headerlink" title="熟悉不同的振动频率对熵的贡献"></a>熟悉不同的振动频率对熵的贡献</h3><p>有了这个小脚本，我们就可以计算任何振动频率对熵的贡献了。一般来说，我们VASP的频率计算会有3N个波数，我们需要做的就是挨个算（虚频除外），然后求和即可。这里，大师兄想强调的并不是如何去通过这些频率去算熵（相信到现在你也已经学会了），而是要了解频率大小对熵的贡献程度。下图是我们计算了不同波数（从10到500 cm<sup>-1</sup>）的振动所对应的熵，以及TS, 单位分别为：J K<sup>-1</sup>mol<sup>-1</sup> 和 eV。</p>
<p><img src="/2018/11/07/ex69/ex69-7.png" alt=""></p>
<p>通过上图的结果，你会发现：当波数越小的时候，TS越大，随着波数增加，TS越来越小，在490 cm<sup>-1</sup>, 300K 的时候,连0.01eV都不到。一般来说，正常的振动频率（3n-6，过去以及现在的大爷那部分）对熵的贡献，基本上就可以忽略掉了，因为一般来说正常的频率波数在400-3000cm<sup>-1</sup>范围之间。</p>
<p>我们现在知道，波数越小，他们对熵的贡献也就越大，而前面我们说的frustrated translation 和 rotation，它们恰恰具有很小的波数，尤其是frustrated translation这部分，大部分都在50cm<sup>-1</sup>以下，因此他们对熵的贡献不能忽略。然而，它们既有体相声子谱的一些特征，也有气相分子的平动和转动的样子。因此在处理的时候，要小小心心地将它们剥离开来，非常令人蛋疼。正所谓：雄兔脚扑朔，雌兔眼迷离；双兔傍地走，安能辨我是雄雌？</p>
<p><img src="/2018/11/07/ex69/ex69-8.jpeg" alt=""></p>
<p>另一方面：由于它们的波数很小，而VASP在小波数这部分的计算很烂，软件计算的结果也会导致很大的误差产生。一般来说大家都直接放弃，忽略这部分了。当然这样的理由很多人不服，明明知道它们波数小，对熵的贡献大，却又不得不忽略。这里，大师兄再给你另外一个解释：摘自Computational Catalysis (RSC) 这本书的第32页。如下：</p>
<p><img src="/2018/11/07/ex69/ex69-9.png" alt=""></p>
<p>在这里建议我们将平动单独处理，假设的是分子在二维平面内可以运动。也就是说只损失了一个方向的自由度。经验告诉我们，对不同的过渡金属表面来说，平动部分对熵的贡献可以作为一个常数来处理。所以，又可以不考虑了…. 以上是大家一般都不考虑这部分的贡献的原因。当然，你也可以根据上面的公式计算frustrated translation对熵的贡献，然后其他的按照振动来处理即可。</p>
<p>如果你对这一部分感兴趣，可以参考下这些人的工作：</p>
<p>1） Campbell 这个牛牛的JACS，还有一篇Chemical Review，大家自己找下。</p>
<p><img src="/2018/11/07/ex69/ex69-10.png" alt=""></p>
<p>2） 最新的一篇JPCC</p>
<p><img src="/2018/11/07/ex69/ex69-11.png" alt=""></p>
<p>3） Tamkin 这个软件的作者以及她发表的一些文章： <a href="http://molmod.github.io/tamkin/">http://molmod.github.io/tamkin/</a> </p>
<p><img src="/2018/11/07/ex69/ex69-12.png" alt=""></p>
<p>4）Norskov 这个牛牛的一本书：Fundamental Concepts in Heterogeneous Catalysis （群文件也有，自己去找）</p>
<p><a href="https://onlinelibrary.wiley.com/doi/book/10.1002/9781118892114">https://onlinelibrary.wiley.com/doi/book/10.1002/9781118892114</a> </p>
<p><img src="/2018/11/07/ex69/ex69-13.jpeg" alt=""></p>
<p>注意： 在这本书里的P33页，不同的吸附位点，构型数目，也会对熵有贡献：如下图：</p>
<p><img src="/2018/11/07/ex69/ex69-14.png" alt=""></p>
<p>这个的贡献不是很大，如果你的覆盖度为1/9的时候，R <em> ln((1/9) / (8/9)) = R </em> ln (1/8)， 300K的时候，TS = 300 <em> 8.314 </em> ln (1/8) / 1000 / 98.485 = 0.053 eV。差不多可以忽略掉。</p>
<h3 id="再提零点能"><a href="#再提零点能" class="headerlink" title="再提零点能"></a>再提零点能</h3><p>师兄，既然前面的frustrated的平动和转动我们都忽略了，那么他们的零点能矫正的时候还用不用考虑。</p>
<p>答：小波数范围对零点能的贡献很小，一般来说，考虑或者不考虑它们的贡献，无关紧要。本人一般直接都加上。</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>1）表面化学中，熵的贡献主要在吸附/脱附的阶段，因为分子损失/获得了大部分的平动和转动，对于表面吸附物种的熵：</p>
<p>i）3N-6的振动部分贡献很小，可以忽略不计；</p>
<p>ii）Frustrated rotation 大约在200-400cm<sup>-1</sup>左右，也可以和振动部分一起忽略；</p>
<p>iii）Frustrated translation部分，可以近似为二维平动来处理。也可以忽略，一般来说：忽略 是大家普遍的做法。如果理论基础不扎实，只想简单算算，那么你的腰椎间盘还是不要突出为妙。</p>
<p>iv）表面吸附位点的数目对熵的贡献，基本也可以忽略。</p>
<p>2） 而在表面反应的阶段，我们计算反应热和活化能的时候通过下面的公式：</p>
<p>ΔE = E(FS) – E(IS)；</p>
<p>Ea = E(TS) – E(IS) </p>
<p>这两个量的计算都是通过相减来得到的，而这个相减的过程中：</p>
<p>i）大部分熵的贡献可以被抵消掉了；</p>
<p>ii）小波数范围内零点能的矫正部分也会被抵消掉，所以零点能校正的时候，大胆地直接地把非虚频的部分直接加起来就可以了。</p>
<p>iii）如果你不信，那么可以通过频率计算一下IS，FS，或者TS的熵，然后计算矫正过的ΔE, Ea，会发现熵的贡献很小很小，所以一般大家都直接考虑零点能，而不考虑熵的贡献，如果有审稿人问你这个问题，用脚本算一下，回答审稿人说影响不大就是了。</p>
<p>3）总结：表面吸附物种的熵，一路忽略，结果就是啥也不算… 不过，不算归不算，但背后的原因或者依据你得搞明白。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>表面吸附</tag>
        <tag>熵</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex70 过渡态的计算（一）</title>
    <url>/2018/11/08/ex70/</url>
    <content><![CDATA[<p>从本节起，我们开始学习下过渡态相关的计算。在进行下面的讲解之前，大家务必要记住这两点：</p>
<ul>
<li><p>1） 过渡态只是一个结构而已，过渡态的计算并不是你想象的那么神秘；也就是计算很容易。</p>
</li>
<li><p>2）物理化学，结构化学书中的过渡态相关的基本知识要掌握，也就是你的理论基础要扎实。感觉基础不好的，认真看书。</p>
</li>
</ul>
<h3 id="过渡态计算的例子"><a href="#过渡态计算的例子" class="headerlink" title="过渡态计算的例子"></a>过渡态计算的例子</h3><p>我们遵循一个从简单到复杂的顺序，慢慢介绍一下表面化学中过渡态的一般计算思路和方法。简单的例子，本节我们选取的是VASP官网的经典计算：NH<sub>3</sub>的翻转，如下图：</p>
<p><img src="/2018/11/08/ex70/ex70-1.png" alt=""></p>
<p>如果你不太懂这个过程，可以把NH<sub>3</sub>看做一把雨伞。翻转的过程，就相当于大风把伞吹翻。</p>
<p><img src="/2018/11/08/ex70/ex70-2.jpeg" alt=""></p>
<p>对于这个计算的一些参考资料，大家可以点下面这两个链接：</p>
<p>1） <a href="http://www.vasp.at/vasp-workshop/tutorials/tutorial_ammonia_flipping.pdf">http://www.vasp.at/vasp-workshop/tutorials/tutorial_ammonia_flipping.pdf</a></p>
<p>Vasp官网的一个PPT介绍，这个PPT有些年头了，不过对于我们学习还是很有帮助的。建议看完PPT里面的内容（最好是自己练习一遍后），再继续下面的学习。</p>
<p>2） <a href="https://cms.mpi.univie.ac.at/wiki/index.php/Category:Examples">https://cms.mpi.univie.ac.at/wiki/index.php/Category:Examples</a></p>
<p>VASP wiki网页中关于过渡态计算的例子。</p>
<hr>
<h3 id="过渡态计算：初末态结构的优化。"><a href="#过渡态计算：初末态结构的优化。" class="headerlink" title="过渡态计算：初末态结构的优化。"></a>过渡态计算：初末态结构的优化。</h3><p>过渡态计算的第一步：我们要知道自己想算什么，需要准备什么？</p>
<p>算过渡态，肯定指的是某一个反应或者过程的过渡态。过渡态的两边也分别对应着反应物和反应产物。所以，算一个反应的过渡态，不管计算过程如何，我们最终都会有三个结构：初始和末态结构，以及过渡态。初末态的结构和前我们已经讲过的优化过程是一样的，我们先回顾一番。</p>
<hr>
<h4 id="初态结构的优化"><a href="#初态结构的优化" class="headerlink" title="初态结构的优化"></a>初态结构的优化</h4><p><strong>1）搭建结构（POSCAR）</strong></p>
<p><img src="/2018/11/08/ex70/ex70-3.jpeg" alt=""></p>
<p>该图中的三个结构分别对应的是NH3翻转的初始，过渡态以及末态结构。这里反应物和产物都是NH3。首先，我们肯定要有一个NH3的结构。这里大师兄就直接复制PPT里面的坐标快速制备一个POSCAR。</p>
<p><img src="/2018/11/08/ex70/ex70-4.png" alt=""></p>
<p>注意： PPT里面没有写元素符号，大家记得自己加上。下图是本人复制后制作的POSCAR。 （添加了元素行，Cartesian坐标。）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ammonia flipping</span><br><span class="line">1.0</span><br><span class="line"> +9.0000000000  +0.0000000000  +0.0000000000</span><br><span class="line"> +0.0000000000 +10.0000000000  +0.0000000000</span><br><span class="line"> +0.0000000000  +0.0000000000 +11.0000000000</span><br><span class="line">H N</span><br><span class="line"> 3 1</span><br><span class="line">Selective</span><br><span class="line">Cartesian</span><br><span class="line"> +3.8185740000  +3.9721220000  +4.3936400000  T T T</span><br><span class="line"> +3.0000000000  +2.5542720000  +4.3936400000  T T T</span><br><span class="line"> +2.1814260000  +3.9721220000  +4.3936400000  T T T</span><br><span class="line"> +3.0000000000  +3.5000000000  +4.0000000000  F F F</span><br></pre></td></tr></table></figure>
<p><img src="/2018/11/08/ex70/ex70-5.png" alt=""></p>
<hr>
<p><strong>2） 准备输入文件（INCAR）</strong></p>
<p>优化NH$_3$的初始结构：(回顾气相分子计算需要注意的地方)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System = NH3</span><br><span class="line">ISMEAR = 0</span><br><span class="line">SIMGA = 0.01</span><br><span class="line"></span><br><span class="line">ALGO = FAST</span><br><span class="line">ENCUT = 450</span><br><span class="line">EDIFF = 1E-5</span><br><span class="line"></span><br><span class="line">NWRITE = 0</span><br><span class="line">LWAVE = .FALSE.</span><br><span class="line">LCHARG = .FALSE.</span><br><span class="line"></span><br><span class="line">IBRION = 2</span><br><span class="line">POTIM = 0.1</span><br><span class="line">EDIFFG = -0.02</span><br><span class="line">NSW = 100</span><br></pre></td></tr></table></figure>
<p><strong>3） 准备输入文件（KPOINTS）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">K-POINTS</span><br><span class="line"> 0</span><br><span class="line">Gamma</span><br><span class="line"> 1 1 1</span><br><span class="line"> 0 0 0</span><br></pre></td></tr></table></figure>
<p><strong>4） 准备POTCAR 并提交任务</strong></p>
<p><strong>5) 优化完的结构：</strong></p>
<p><img src="/2018/11/08/ex70/ex70-6.png" alt=""></p>
<p>只需要几步优化就完成了。这是因为我们复制的别人的（VASP官网例子）结构，因为这些结构已经被优化过了。即我们优化过程有一个很好的猜测结构。</p>
<p>这给我们的启发就是：在你开始计算的时候，一定要善于利用前人的或者自己前面的计算结构。这会大大节省我们的计算工作量。</p>
<hr>
<h4 id="末态结构的搭建优化"><a href="#末态结构的搭建优化" class="headerlink" title="末态结构的搭建优化"></a>末态结构的搭建优化</h4><p>在上面结构的基础上，我们很容易搭建初末态的结构。仔细观察这个图，我们可以保持H原子的坐标不变，只需要将N原子的坐标修改一下。初始结构里面，三个H原子在xy平面上，</p>
<p>N与H原子z方向的距离为0.3929 Å。如果N原子翻转过去，那么它的坐标将会是：</p>
<p>4.3929 + 0.3929  = 4.7858 Å。</p>
<p><img src="/2018/11/08/ex70/ex70-7.jpeg" alt=""></p>
<p><strong>自行将这个图顺时针旋转90°</strong></p>
<p><img src="/2018/11/08/ex70/ex70-8.png" alt=""></p>
<p>然后跟前面同样的方法，优化一下就可以了。</p>
<h4 id="过渡态结构的优化"><a href="#过渡态结构的优化" class="headerlink" title="过渡态结构的优化"></a>过渡态结构的优化</h4><p><img src="/2018/11/08/ex70/ex70-9.jpeg" alt=""></p>
<p>上图中，我们可以发现，过渡态是一个平面的结构，我们可以按照前面末态结构搭建的思想弄一个初始的过渡态结构出来。即直接将N原子的z方向坐标修改成H原子的。如下图：</p>
<p><img src="/2018/11/08/ex70/ex70-10.png" alt=""></p>
<p>对比下前面初末态结构的坐标，你会发现Z 方向上被固定住了（最后一列SZ没有选择）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+3.8177218605  +3.9717738141  +4.3929644172  T T F</span><br><span class="line">+3.0000000000  +2.5559112549  +4.3926756556  T T F</span><br><span class="line">+2.1822781395  +3.9717738141  +4.3929644172  T T F</span><br><span class="line">+3.0000000000  +3.5000000000  +4.3929644172  F F F</span><br></pre></td></tr></table></figure>
<p>这样做是强制优化过程中，所有的原子都在xy平面上。我们只优化H原面的坐标。原因如下：</p>
<p><img src="/2018/11/08/ex70/ex70-11.png" alt=""></p>
<p>这个三角形对应的就是我们从初始结构（IS）搭建过渡态结构（TS）的过程。在初始结构里面，N在三角形最下面，H在右边的点上，当我们人为把N原子放到H平面上的时候，N从下面的点移动到上面，导致N—H 键变短（从1.022 减小到0.944 Å）。但这个变短的过程是我们人为搭建结构所导致的。所以我们要把H原子在xy表面上放开，继续优化一下。参数（ICNAR，POTCAR， KPOINTS）保持不变，提交优化任务，最终我们的过渡态结构如下：</p>
<p><img src="/2018/11/08/ex70/ex70-12.png" alt=""></p>
<p>N, H 在同一平面内，N—H 键长为：1.004 Å</p>
<hr>
<h3 id="频率计算：（过渡态的验证办法之一）"><a href="#频率计算：（过渡态的验证办法之一）" class="headerlink" title="频率计算：（过渡态的验证办法之一）"></a>频率计算：（过渡态的验证办法之一）</h3><p>验证一个算完的过渡态是不是真正过渡态的时候，我们需要用到频率计算。因为过渡态只有一个虚频。（自己看书去学习为什么只有一个虚频？）复习下前面我们讲过的频率计算的细节：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IBRION = 5</span><br><span class="line">POTIM = 0.015</span><br><span class="line">EDIFF = 1E-6</span><br><span class="line">NFREE = 2</span><br><span class="line">NSW = 1</span><br></pre></td></tr></table></figure>
<p>5）此外，我们需要另外加一个无关痛痒的参数：NWRITE = 2 （或者不设置，默认值是2）</p>
<p>大师兄本人喜欢用NWRITE = 0 。但当参数为0，使用Jmol可视化频率计算结果的时候：你会发现所有的原子都是同一个颜色，如下图：</p>
<p><img src="/2018/11/08/ex70/ex70-13.png" alt=""></p>
<p>当使用NWRITE的默认值2的时候，则是正常的：这是因为NWRITE = 0 写入的OUTCAR的数据太少，Jmol无法获取元素相关的参数用来可视化。此处，特别感谢群里的：<strong>连赞小朋友</strong>帮忙分析.</p>
<p><img src="/2018/11/08/ex70/ex70-14.png" alt=""></p>
<p>提取频率相关的参数，可以使用下面的命令：</p>
<p>grep cm-1 OUTCAR 提取所有的频率（检查频率结果推荐使用）</p>
<p>grep ‘i=’  OUTCAR  提取所有的虚频 （基本没啥用）</p>
<p>grep ‘f  =’ OUTCAR 提取所有的非虚频 （计算零点能推荐使用）</p>
<p>Jmol中所有的虚频都在最下面，大家可以根据前面的grep命令的结果和Jmol的界面对比下。本计算一共有3个虚频： 5.7, 10.2和806.8 cm<sup>-1</sup> 。前面2个虚频很小，直接不管就可以了。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>算到这里，NH<sub>3</sub>翻转的过渡态我们就已经讲完了。本节采用的是直接优化的方法获取过渡态的结构，适用于一些非常简单的体系或者你已经非常熟悉的过渡态结构。回到开头我们讲的那句话，过渡态只是一个结构而已，我们需要做的就是如何通过一些计算的技巧和方法来获取这些结构。很多人一提到过渡态就会想到使用VTST编译的VASP程序算NEB（Nudged Elastic Band method）以及CI-NEB (Climbing Image NEB)，其实NEB和CI-NEB也仅仅是大家常用的一个方法而已，除此之外，还有很多。</p>
<p><strong>最关键的</strong>就是通过结构化学的基础知识来搭建、计算并判断这些过渡态结构背后的物理化学意义，通俗点说就是：算的对不对，你要自己心里有个数。</p>
<p>很多人会说算过渡态要通过频率来验证，其实这一步只是前面一步的副产物而已。只要你的化学基本功底深厚，加以训练，就可以准确判断反应的路径。</p>
<p>本节计算例子的下载： 链接：<a href="https://pan.baidu.com/s/1hHGhrOlxMik8NBUqEzolwQ">https://pan.baidu.com/s/1hHGhrOlxMik8NBUqEzolwQ</a>   密码：2dw5</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>NEB</tag>
        <tag>过渡态</tag>
        <tag>NH3</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex71 过渡态的计算（二）</title>
    <url>/2018/11/09/ex71/</url>
    <content><![CDATA[<p>前面一节我们讲了直接优化NH<sub>3</sub>翻转的过渡态。这一节我们继续直接优化过渡态的介绍。计算乙烷分子（CH<sub>3</sub>CH<sub>3</sub>）绕C—C键旋转的过渡态。我们知道：乙烷有交错式和重叠式构型。而重叠式能量较高。想象乙烷分子绕着C—C旋转，从交错式到重叠式，再到交错式这一个过程。很容易就得到这个结论：重叠式的结构就是过渡态。所以，如果计算这个过渡态的工作就转化成了优化重叠式的构型。这也是本节的一个主要思想。</p>
<hr>
<h3 id="手动搭建初始的乙烷构型。"><a href="#手动搭建初始的乙烷构型。" class="headerlink" title="手动搭建初始的乙烷构型。"></a>手动搭建初始的乙烷构型。</h3><p>首先，我们要搭建一个初始的乙烷构型。把C—C键的两个C平行于z轴。思考一下：</p>
<p>1）  我们为什么要这样做？</p>
<p>2）  乙烷构型网上到处都是，随便下载一个就可以直接拿来使用，如果将任意取向的结构转化为C—C 键平行于z轴的结构呢？</p>
<p>下面是我们搭建的乙烷结构，并优化的结果。优化过程中，两个C原子在xy方向的坐标被固定住了。</p>
<p><img src="/2018/11/09/ex71/ex71-1.png" alt=""></p>
<p><img src="/2018/11/09/ex71/ex71-2.png" alt=""></p>
<p>很显然，我们的初始结构经过优化后转变成了交错式的构型。</p>
<hr>
<h3 id="搭建过渡态的初始构型"><a href="#搭建过渡态的初始构型" class="headerlink" title="搭建过渡态的初始构型"></a>搭建过渡态的初始构型</h3><p>在重叠式的结构中，乙烷分子的两个CH<sub>3</sub>关于穿过CC轴的xy平面是对称的。所以，我们将上面CH<sub>3</sub>中H原子的xy坐标修改的和下面部分一样。</p>
<p><strong>注意：</strong></p>
<p>1）  只修改xy坐标，z坐标保持不变</p>
<p>2）  观察图中：3和8， 4和7， 以及5 和6 的xy坐标。</p>
<p>3）  固定xy坐标，直接优化z方向</p>
<p><img src="/2018/11/09/ex71/ex71-3.png" alt=""></p>
<p>下面是优化完的结果：计算很快就收敛了。</p>
<p><img src="/2018/11/09/ex71/ex71-4.png" alt=""></p>
<hr>
<h3 id="对比一下交错式和重叠式C—C的键长："><a href="#对比一下交错式和重叠式C—C的键长：" class="headerlink" title="对比一下交错式和重叠式C—C的键长："></a>对比一下交错式和重叠式C—C的键长：</h3><p><img src="/2018/11/09/ex71/ex71-5.png" alt=""></p>
<p><img src="/2018/11/09/ex71/ex71-6.png" alt=""></p>
<p>在重叠式中，C—C 稍微拉长了一点。</p>
<h3 id="频率计算"><a href="#频率计算" class="headerlink" title="频率计算"></a>频率计算</h3><p>在频率计算的时候，本人把所有的原子都放开了，如下图：</p>
<p><img src="/2018/11/09/ex71/ex71-7.png" alt=""></p>
<p><img src="/2018/11/09/ex71/ex71-8.png" alt=""></p>
<p>通过命令发现，有个256 cm<sup>-1</sup>的虚频。使用Jmol可视化一下：</p>
<p><img src="/2018/11/09/ex71/ex71-9.png" alt=""></p>
<p>过渡态计算完毕。</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>大家等了很久，看完肯定会对本节失望。但过渡态计算里面的一些技巧很多都是自己琢磨出来的。比如我们将分子沿着平行z轴的方向放置，根据对称性手动搭建过渡态的结构，以及固定坐标，选择性地优化等。还是那句话：过渡态只是个结构，我们需要做的就是通过各种各样的办法来实现快速优化这个结构的目的。</p>
<p>本节计算例子下载链接: <a href="https://pan.baidu.com/s/18TdaLhWnz4_IDMjJJGBMFw">https://pan.baidu.com/s/18TdaLhWnz4_IDMjJJGBMFw</a>   密码: ugjt</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>POSCARtoolkit.py</tag>
        <tag>NEB</tag>
        <tag>过渡态</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex72 过渡态的计算（三）</title>
    <url>/2018/11/10/ex72/</url>
    <content><![CDATA[<p><img src="/2018/11/10/ex72/ex72-1.png" alt=""></p>
<p>不好意思，让大家久等了。最近一直很忙，后面还是会很忙。为了不让大家失望，抽时间把简单的过渡态计算讲解一下，这一节我们需要学习的是通过CI-NEB（Climbing Image Nudged Elastic Band）计算H原子在Ru(0001)表面上的扩散过程。</p>
<h3 id="NEB计算过渡态的准备工作"><a href="#NEB计算过渡态的准备工作" class="headerlink" title="NEB计算过渡态的准备工作"></a>NEB计算过渡态的准备工作</h3><p><strong>准备工作1：</strong></p>
<p>说到NEB或者CINEB，不得不提的就是Henkelman课题组的VTST：<a href="http://henkelmanlab.org/">http://henkelmanlab.org/</a> . 我们需要下载VTST的code，然后将VASP编译一下，得到一个可以使用vtst的VASP版本。</p>
<p>链接：<a href="http://theory.cm.utexas.edu/vtsttools/download.html">http://theory.cm.utexas.edu/vtsttools/download.html</a> </p>
<p>很不幸，怎么编译，我一窍不通。如果这一关过不了的话，后面的也只能看看热闹，不能亲自实践了。如果你已经编译好了VTST的VASP版本， 那么就可以继续下面的学习了。</p>
<p><strong>准备工作2：</strong></p>
<p>我们将VTST的一些实用小脚本下载下来：<a href="http://theory.cm.utexas.edu/vtsttools/download.html">http://theory.cm.utexas.edu/vtsttools/download.html</a> </p>
<p><img src="/2018/11/10/ex72/ex72-2.png" alt=""> </p>
<p>下载VTST Scripts后解压，把所有脚本都复制到 ~/bin 目录下：效果如下:</p>
<p><img src="/2018/11/10/ex72/ex72-3.png" alt=""></p>
<p>很多脚本估计你一辈子都不会用到，没关系，它们很小，不占存储空间，静悄悄躺在bin文件里面就行了。Linux老手们嫌烦可以把这些脚本放到一个文件夹里面，然后bashrc文件里面修改下路径就可以了。</p>
<p><strong>准备工作3</strong>：</p>
<p>修改nebresults.pl 文件，将57到71行注释掉，注释掉就是在每一行的开头加个#号，效果如下：</p>
<p><img src="/2018/11/10/ex72/ex72-4.png" alt=""></p>
<p>为什么需要这么做？</p>
<p>如果neb运行的时候，你使用这个命令，它就会把你的OUTCAR文件压缩，VASP找不到OUTCAR，就不知道该往哪里存储，然后就挂掉了。大家可以在neb任务运行的时候分别运行下注释前后的脚本，对比下就清楚了。</p>
<h3 id="扩散的基础知识"><a href="#扩散的基础知识" class="headerlink" title="扩散的基础知识"></a>扩散的基础知识</h3><p>准备工作完成，我们加深下扩散（diffusion）的一些概念：</p>
<p>2.1  扩散我们高中的时候应该就学习过了。具体的定义这里不讲了。大家自行参考教科书或者维基百科：链接如下：</p>
<p><a href="https://en.wikipedia.org/wiki/Diffusion">https://en.wikipedia.org/wiki/Diffusion</a> </p>
<p>对于分子在表面上的扩散，就跟我们在校园里瞎晃悠是一样的。哪天指不定遇到个对上眼的美女，过渡态就要开始了。</p>
<p>2.2  具体到分子在金属表面上的扩算，一般来说，扩散的能垒差不多是吸附能的12%左右。这里我们说的吸附能，指的是最稳定的那个结构所对应的。</p>
<p>为什么是12% 呢？ 这只是一个经验性的结论，大家可以参考大牛Manos Mavrikakis的俺狗娃文章: (不要留言问我要这个文章…)</p>
<p>A Simple Rule of Thumb for Diffusion on Transition-Metal Surfaces</p>
<p><a href="https://onlinelibrary.wiley.com/doi/abs/10.1002/anie.200602223">https://onlinelibrary.wiley.com/doi/abs/10.1002/anie.200602223</a></p>
<p><img src="/2018/11/10/ex72/ex72-5.png" alt=""></p>
<p>2.3  从结构角度来看，举个面心立方的金属(111)面为例，表面上有fcc, hcp, top, 和 bridge这四个位点。如果fcc或者hcp的位点对应稳定的吸附构型，那么bridge的这个位点就是扩散的过渡态。所以，如果你想简单算一个扩散的过渡态，直接算bridge的吸附就可以了。但是，bridge的位点也不是那么容易就可以算出来的。前面我们讲过Cu(111)表面的吸附计算，很多人就反应bri的结构优化不出来。Bridge 的位点就跟下面的这个独木桥类似，少一不小心就掉下去了。</p>
<p><img src="/2018/11/10/ex72/ex72-6.jpeg" alt=""></p>
<p>换个角度来分析：既然我们直接优化得不到bridge的结构，而这个结构恰恰就是过渡态，那么我们就可以使用算过渡态的方法来得到bridge的结构。当然，能直接优化出来bridge的结构是最好的。</p>
<h3 id="过渡态计算的步骤"><a href="#过渡态计算的步骤" class="headerlink" title="过渡态计算的步骤"></a>过渡态计算的步骤</h3><p>3.1 第一步：优化初始和末态结构。</p>
<p> 首先我们先优化一个扩散前后的两个结构： H在FCC和HCP位点上的吸附。这个对于认真练习过前面计算的筒子们来说就是小菜一碟了。直接列出来top view 的示意图：</p>
<p><img src="/2018/11/10/ex72/ex72-7.png" alt=""></p>
<p>FCC site</p>
<p><img src="/2018/11/10/ex72/ex72-8.png" alt=""></p>
<p> HCP site</p>
<p>3.2 第二步：准备NEB的结构</p>
<p>这里我们需要用到VTST官网的一个小脚本：nebmake.pl，使用方法如下： </p>
<p><code>nebmake.pl   IS  FS  N</code></p>
<p>1）  敲命令nebmake.pl</p>
<p>2）  IS 指的是初始结构:</p>
<p>3）  FS指的是末态结构</p>
<p>4）  N 指的是你要插点的个数。</p>
<p><strong>细节1：</strong></p>
<p>IS, FS 是VASP的POSCAR或者CONTCAR。</p>
<p>可以是其他目录里面的POSCAR或者CONTCAR, 也可以是当前目录下的POSCAR或者CONTCAR。 </p>
<p>你可以把初始结构的POSCAR命名成你的名字：bigbro ， 末态命名成：bigbra. 运行的时候命令应该这么敲：<code>nebmake.pl   bigbro  bigbra  8</code></p>
<p>下面图里面的三个事例，是等价的。自己随意领会：</p>
<p><img src="/2018/11/10/ex72/ex72-9.png" alt=""></p>
<p><img src="/2018/11/10/ex72/ex72-10.png" alt=""></p>
<p><img src="/2018/11/10/ex72/ex72-11.png" alt=""></p>
<p><strong>细节2：</strong> </p>
<p>插入的点数要保证可以被使用的核数整除。比如我们打算用24个核进行计算，那么N可以是下面的几种情况：</p>
<table style="width: 618px;" cellspacing="0" cellpadding="0"><tbody><tr class="firstRow"><td style="border: 1px solid windowtext; padding: 0in 7px;" width="189" valign="top"><p style="margin-bottom: 0px; text-align: center; line-height: 1.5em;"><span style="font-size: 14px;">N</span></p></td><td style="border-color: windowtext windowtext windowtext currentcolor; border-style: solid solid solid none; border-width: 1px 1px 1px medium; border-image: none 100% / 1 / 0 stretch; padding: 0in 7px;" width="189" valign="top"><p style="margin-bottom: 0px; text-align: center; line-height: 1.5em;"><span style="font-size: 14px;">Cores used for each Image</span></p></td><td style="border-color: windowtext windowtext windowtext currentcolor; border-style: solid solid solid none; border-width: 1px 1px 1px medium; border-image: none 100% / 1 / 0 stretch; padding: 0in 7px;" width="189" valign="top"><p style="margin-bottom: 0px; text-align: center; line-height: 1.5em;"><span style="font-size: 14px;">Total</span></p></td></tr><tr><td style="border-color: currentcolor windowtext windowtext; border-style: none solid solid; border-width: medium 1px 1px; border-image: none 100% / 1 / 0 stretch; padding: 0in 7px;" width="189" valign="top"><p style="margin-bottom: 0px; text-align: center; line-height: 1.5em;"><span style="font-size: 14px;">1</span></p></td><td style="border-color: currentcolor windowtext windowtext currentcolor; border-style: none solid solid none; border-width: medium 1px 1px medium; padding: 0in 7px;" width="189" valign="top"><p style="margin-bottom: 0px; text-align: center; line-height: 1.5em;"><span style="font-size: 14px;">24</span></p></td><td style="border-color: currentcolor windowtext windowtext currentcolor; border-style: none solid solid none; border-width: medium 1px 1px medium; padding: 0in 7px;" width="189" valign="top"><p style="margin-bottom: 0px; text-align: center; line-height: 1.5em;"><span style="font-size: 14px;">24</span></p></td></tr><tr><td style="border-color: currentcolor windowtext windowtext; border-style: none solid solid; border-width: medium 1px 1px; border-image: none 100% / 1 / 0 stretch; padding: 0in 7px;" width="189" valign="top"><p style="margin-bottom: 0px; text-align: center; line-height: 1.5em;"><span style="font-size: 14px;">4</span></p></td><td style="border-color: currentcolor windowtext windowtext currentcolor; border-style: none solid solid none; border-width: medium 1px 1px medium; padding: 0in 7px;" width="189" valign="top"><p style="margin-bottom: 0px; text-align: center; line-height: 1.5em;"><span style="font-size: 14px;">6</span></p></td><td style="border-color: currentcolor windowtext windowtext currentcolor; border-style: none solid solid none; border-width: medium 1px 1px medium; padding: 0in 7px;" width="189" valign="top"><p style="margin-bottom: 0px; text-align: center; line-height: 1.5em;"><span style="font-size: 14px;">24</span></p></td></tr><tr><td style="border-color: currentcolor windowtext windowtext; border-style: none solid solid; border-width: medium 1px 1px; border-image: none 100% / 1 / 0 stretch; padding: 0in 7px;" width="189" valign="top"><p style="margin-bottom: 0px; text-align: center; line-height: 1.5em;"><span style="font-size: 14px;">6</span></p></td><td style="border-color: currentcolor windowtext windowtext currentcolor; border-style: none solid solid none; border-width: medium 1px 1px medium; padding: 0in 7px;" width="189" valign="top"><p style="margin-bottom: 0px; text-align: center; line-height: 1.5em;"><span style="font-size: 14px;">4</span></p></td><td style="border-color: currentcolor windowtext windowtext currentcolor; border-style: none solid solid none; border-width: medium 1px 1px medium; padding: 0in 7px;" width="189" valign="top"><p style="margin-bottom: 0px; text-align: center; line-height: 1.5em;"><span style="font-size: 14px;">24</span></p></td></tr><tr><td style="border-color: currentcolor windowtext windowtext; border-style: none solid solid; border-width: medium 1px 1px; border-image: none 100% / 1 / 0 stretch; padding: 0in 7px;" width="189" valign="top"><p style="margin-bottom: 0px; text-align: center; line-height: 1.5em;"><span style="font-size: 14px;">2</span></p></td><td style="border-color: currentcolor windowtext windowtext currentcolor; border-style: none solid solid none; border-width: medium 1px 1px medium; padding: 0in 7px;" width="189" valign="top"><p style="margin-bottom: 0px; text-align: center; line-height: 1.5em;"><span style="font-size: 14px;">12</span></p></td><td style="border-color: currentcolor windowtext windowtext currentcolor; border-style: none solid solid none; border-width: medium 1px 1px medium; padding: 0in 7px;" width="189" valign="top"><p style="margin-bottom: 0px; text-align: center; line-height: 1.5em;"><span style="font-size: 14px;">24</span></p></td></tr><tr><td style="border-color: currentcolor windowtext windowtext; border-style: none solid solid; border-width: medium 1px 1px; border-image: none 100% / 1 / 0 stretch; padding: 0in 7px;" width="189" valign="top"><p style="margin-bottom: 0px; text-align: center; line-height: 1.5em;"><span style="font-size: 14px;">12</span></p></td><td style="border-color: currentcolor windowtext windowtext currentcolor; border-style: none solid solid none; border-width: medium 1px 1px medium; padding: 0in 7px;" width="189" valign="top"><p style="margin-bottom: 0px; text-align: center; line-height: 1.5em;"><span style="font-size: 14px;">2</span></p></td><td style="border-color: currentcolor windowtext windowtext currentcolor; border-style: none solid solid none; border-width: medium 1px 1px medium; padding: 0in 7px;" width="189" valign="top"><p style="margin-bottom: 0px; text-align: center; line-height: 1.5em;"><span style="font-size: 14px;">24</span></p></td></tr><tr><td style="border-color: currentcolor windowtext windowtext; border-style: none solid solid; border-width: medium 1px 1px; border-image: none 100% / 1 / 0 stretch; padding: 0in 7px;" width="189" valign="top"><p style="margin-bottom: 0px; text-align: center; line-height: 1.5em;"><span style="font-size: 14px;">3</span></p></td><td style="border-color: currentcolor windowtext windowtext currentcolor; border-style: none solid solid none; border-width: medium 1px 1px medium; padding: 0in 7px;" width="189" valign="top"><p style="margin-bottom: 0px; text-align: center; line-height: 1.5em;"><span style="font-size: 14px;">8</span></p></td><td style="border-color: currentcolor windowtext windowtext currentcolor; border-style: none solid solid none; border-width: medium 1px 1px medium; padding: 0in 7px;" width="189" valign="top"><p style="margin-bottom: 0px; text-align: center; line-height: 1.5em;"><span style="font-size: 14px;">24</span></p></td></tr><tr><td style="border-color: currentcolor windowtext windowtext; border-style: none solid solid; border-width: medium 1px 1px; border-image: none 100% / 1 / 0 stretch; padding: 0in 7px;" width="189" valign="top"><p style="margin-bottom: 0px; text-align: center; line-height: 1.5em;"><span style="color: red; font-size: 14px;">8</span></p></td><td style="border-color: currentcolor windowtext windowtext currentcolor; border-style: none solid solid none; border-width: medium 1px 1px medium; padding: 0in 7px;" width="189" valign="top"><p style="margin-bottom: 0px; text-align: center; line-height: 1.5em;"><span style="color: red; font-size: 14px;">3</span></p></td><td style="border-color: currentcolor windowtext windowtext currentcolor; border-style: none solid solid none; border-width: medium 1px 1px medium; padding: 0in 7px;" width="189" valign="top"><p style="margin-bottom: 0px; text-align: center; line-height: 1.5em;"><span style="color: red; font-size: 14px;">24</span></p></td></tr></tbody></table>

<p><strong>注意：</strong></p>
<p>表中最后一个很可能会出错，因为你用3个核来计算一个image.  上面说的不是绝对的，具体要根据自己的服务器和习惯来设置。</p>
<p>本人使用4个节点（每个节点12个核，共48个核）进行计算，一般N设置位4或者8.</p>
<p><strong>细节三：</strong> </p>
<p>同样核数下，N设置的越大，计算每个image所需要的核数就会减少，导致计算变慢。</p>
<p>N需要怎么设置才好呢？ </p>
<p>一方面需要大家去咨询一些现成的经验：问问师兄师姐，没有师兄师姐，就在现有的条件下自己去摸索摸索。当然这需要耗费大量的时间和精力，也不符合当下很多人急于速成的心态。</p>
<p>我们着重讲解另一个方面，也就是你对自己研究体系的掌控性。个人感觉分两点：</p>
<p>1）反应过程结构变化的理解，这需要我们在前面初末态的优化上下功夫；</p>
<p>2）化学键的理解：对一个化学键来说，它断裂时候的过渡态键长应该在这个化学键的1-2倍之间。1 指的是这个化学键本身，2指的是这个键被拉长了2倍。你肯定会说我在扯蛋，如果更经验性一点，应该在1.5倍左右。掌握这个这有助于你第一眼去判断自己的过渡态对不对。当然，1.5只是个粗糙的数值，不同的键会有不同的经验性数值。</p>
<p><strong>3.3 第三步: 检查初末态结构的原子坐标是否是一一对应。</strong></p>
<p>这是很多人算过渡态经常忽略的一步，有时候也是很费精力的一步。一个人是不是在闭着眼瞎算，从这一步基本上就可以看出来了。这里大师兄推荐一个linux下检查结构的方法。 命令：p4v 0*/POSCAR   一次性打开所有的Image结构，然后逐个点开，查看整个反应轨迹进行检查。</p>
<h3 id="扩展练习"><a href="#扩展练习" class="headerlink" title="扩展练习"></a>扩展练习</h3><p>本节我们需要做的很简单</p>
<p>1） 浏览VTST的网站，阅读相关过渡态计算的步骤以及CI-NEB相关的文献；</p>
<p>2） 下载VTST的脚本，复制到~/bin文件夹，修改nebresults.pl脚本；</p>
<p>3） 计算H在FCC 和HCP的吸附；</p>
<p>4） 使用脚本生成NEB计算的Images文件。</p>
<p>5） 使用脚本生成前面两节：NH3翻转，以及乙烷旋转的Images文件。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本节应该够新手们练习一阵子的了，下一节，我们介绍怎么把NEB的计算运行起来。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>NEB</tag>
        <tag>过渡态</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex73 过渡态的计算（四）</title>
    <url>/2018/11/11/ex73/</url>
    <content><![CDATA[<p>在学习下面neb的计算前，思考了很久，感觉有必要先给大家介绍一个非常实用的python小脚本，经历过反复的修改，最终在群友小塔玛斯的努力下，完成了一个稳定的过渡态计算中非常实用小脚本：<code>POSCARtoolkit.py</code></p>
<p>本节我们介绍一下这个脚本的具体使用方法。</p>
<h3 id="版本和版权问题："><a href="#版本和版权问题：" class="headerlink" title="版本和版权问题："></a>版本和版权问题：</h3><p>版本：</p>
<p>这个脚本有2个版本，分别适用于python3和python2的2.6及以上版本。</p>
<p>大家根据自己使用的python版本进行下载，如果运行的时候出现错误，请先检查是不是版本的问题。链接:<a href="https://pan.baidu.com/s/1JJHVM27NdIC-uZlxzlg-Mg">https://pan.baidu.com/s/1JJHVM27NdIC-uZlxzlg-Mg</a>   提取码:mt7e</p>
<p>版权问题：</p>
<p>这个脚本大家随便实用，如果感觉不错，碰到作者时，请他吃顿饭。作者坐高铁买不起盒饭时，在任何QQ群里呼救时，使用者需慷慨解囊，集资把盒饭钱凑够。</p>
<p>如果不接受这个条款，请自觉不使用该脚本。</p>
<h3 id="使用前的准备工作"><a href="#使用前的准备工作" class="headerlink" title="使用前的准备工作"></a>使用前的准备工作</h3><p>2.1）下载脚本，将脚本命名为：POSCARtoolkit.py  </p>
<p>2.2）可执行化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod u+x POSCARtoolkit.py</span><br></pre></td></tr></table></figure>
<p>2.3）将脚本移到~/bin 文件夹下面： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv POSCARtoolkit.py ~/bin</span><br></pre></td></tr></table></figure>
<p>注释：</p>
<p>A) 2.2 和2.3步的顺序可以颠倒，不影响使用；</p>
<p>B) 如果没有~/bin文件夹，那么 mkdir ~/bin 手动创建一个即可。</p>
<h3 id="坐标转换"><a href="#坐标转换" class="headerlink" title="坐标转换"></a>坐标转换</h3><p>这个脚本可以实现分数坐标（Direct）向笛卡尔坐标（Cartesian）的转换。VASP的输出结果是以分数坐标的形式存在CONTCAR中，但我们在操作模型的过程中，移动原子都是以Å来进行的，所以将分数坐标转化为笛卡尔坐标对于搭建模型很有帮助。脚本用法：<code>POSCARtoolkit.py -i POSCAR</code></p>
<p><strong>注意：</strong></p>
<p>如果你的POSCARtoolkit.py脚本在和POSCAR一个目录下，使用下图中的命令，如果你已经完成了前面2中的步骤，脚本前面的python 不用输入。</p>
<p> <img src="/2018/11/11/ex73/ex73-1.jpg" alt=""></p>
<p>描述1） -i 代表 input的意思, 后面紧跟你要转化的文件，可以是POSCAR，CONTCAR，也可以是其他的VASP的坐标文件。比如你把POSCAR命名成bigbro, 也是可以直接转换的。 POSCARtoolkit.py –i bigbro  即可。</p>
<p>描述2）：脚本将含有分数坐标的POSCAR 转换成笛卡尔坐标的POSCAR_C。输出的文件被命名为POSCAR_C。</p>
<p>描述3）如果你预先把POSCAR命名为bigbro， 那么运行程序后，输出结果为 bigbro_C.</p>
<p>描述4）如果POSCAR已经为笛卡尔坐标，则转换终止，大家可以尝试一下转换一个笛卡尔坐标的POSCAR。</p>
<h3 id="原子层数的固定"><a href="#原子层数的固定" class="headerlink" title="原子层数的固定"></a>原子层数的固定</h3><p>除了可以实现坐标系的转换，该脚本还可以根据Z方向的原子坐标，固定底部几层原子。</p>
<p>这在slab模型的相关计算中非常实用，如下图所示，在slab模型中，我们经常将底部的原子层固定，只放开表面的来进行计算。</p>
<p><img src="/2018/11/11/ex73/ex73-2.jpg" alt=""></p>
<p>比如我们把底部的三层原子进行固定。脚本的用法如下：<code>POSCARtoolkit.py -i POSCAR_C -f</code></p>
<p><img src="/2018/11/11/ex73/ex73-3.png" alt=""></p>
<p>描述1） 脚本会根据阈值（默认1.5 Å）划分层，这里的1.5 Å指的是层间距。</p>
<p>描述2） 用户可以通过在脚本后面增加参数 -y 1.0 自己定义更小的阈值</p>
<p>描述3） 如果不想每次使用的时候使用参数-y，用户也可以直接在脚本里面修改阈值的大小，如下如，在第40行中，默认的阈值1.5被修改0.5。</p>
<p><img src="/2018/11/11/ex73/ex73-4.png" alt=""></p>
<p>当然，修改脚本默认的参数后，如果使用中使用的 –y， 还是会按照 –y 后面的阈值进行操作。</p>
<p>描述4） 输入完命令，回车后，会提醒用户输入固定的层数，这里我们输入3，回车，即固定底下三层原子，而其他原子放开。</p>
<p>描述5） 上图命令中，我们对POSCAR_C 进行操作，输出文件问POSCAR_C_C。</p>
<h3 id="固定和放开用户选择的原子"><a href="#固定和放开用户选择的原子" class="headerlink" title="固定和放开用户选择的原子"></a>固定和放开用户选择的原子</h3><p>除了固定层数外，该脚本允许用户选择部分原子放开，固定或者部分放开。这个功能实现的前提是POSCAR 或者 CONTCAR 中有 <code>Selective dynamics</code> 信息。如果没有，则可先固定任意的原子层（POSCARtoolkit.py -i  CONTCAR  -f ），这样的话<code>Selective dynamics</code>就会被写入到输出文件POSCAR_C中。然后用户再对POSCAR_C进行原子选择性操作。 下面我们先详细介绍一下脚本的用法，然后再加一些实例的操作来帮助用户理解。</p>
<p>用法：POSCARtoolkit.py -i POSCAR_C [-f or -r] -s [your selections]</p>
<p>描述1)：POSCARtoolkit.py -i POSCAR_C 我们对输入文件POSCAR_C 进行操作</p>
<p>描述2): -f 和 –r  配合后面的 –s 进行操作。</p>
<ul>
<li>-f 表示表示固定（fix）选中的原子，</li>
<li>-r 代表放开（relax）选中的原子，由于原子在xyz三个方向上都可以选择放开，所以使用-r的时候要配合F T 来进行操作。 如下：<ul>
<li>-r  FFT  代表只放开z方向，同理 –r TTF， -r  TFT， -r TTT， -r FTT这些你就知道是怎么回事了。</li>
<li>-r 后面的FFT这三个字母之间可以有空格，也可以没有。也就是说：FFT 和 F  FT， FF T 以及 F F T 效果是一样的。</li>
</ul>
</li>
</ul>
<p>描述3） -s 选项表示选择部分原子, 后面是你要选择的原子，选择项如下：</p>
<ul>
<li><p>all 表示选中所有原子</p>
</li>
<li><p>1-5 6 9 表示选中 第1-5个和6,9 号原子</p>
</li>
<li><p>Pt 表示选中所有的Pt原子</p>
</li>
<li><p>1-5 6 9 Pt 表示选中 第1-5个和6,9 号原子和所有的Pt原子</p>
</li>
</ul>
<p>描述4）其他未选择的原子，限制信息保持不变。</p>
<p>实例操作1： 如果我们想固定POSCAR_C中所有的原子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POSCARtoolkit.py -i POSCAR_C  -f  -s  all</span><br></pre></td></tr></table></figure>
<p>注释： -f 表示fix， -s all 表示选择所有的原子</p>
<p>POSCAR_C 中必须有<code>Selective dynamics</code>这一行</p>
<p><img src="/2018/11/11/ex73/ex73-5.png" alt=""></p>
<p>实例操作2： 将所有的原子只在z方向上放开：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POSCARtoolkit.py -i POSCAR_C  -r FF T  -s  all</span><br></pre></td></tr></table></figure>
<p>注释：放开z方向上使用 –r FF T， FFT之间有无空格均可。</p>
<p><img src="/2018/11/11/ex73/ex73-6.png" alt=""></p>
<p>实例操作3： 将所有的C，H, O 原子在xy方向上放开：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POSCARtoolkit.py -i POSCAR_C  -r TTF  -s  C H O</span><br></pre></td></tr></table></figure>
<p>实例操作4： 将所有的Pt原子和40号原子在z方向放开：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POSCARtoolkit.py -i POSCAR_C  -r  FFT  -s  Pt 40</span><br></pre></td></tr></table></figure>
<h3 id="批量转化"><a href="#批量转化" class="headerlink" title="批量转化"></a>批量转化</h3><p>前面介绍的都是针对一个文件进行操作，由于固定原子层数的功能我们设置了一个交互，需要用户指定需要固定的层数（z轴从下到上）。</p>
<p>但这对于层数批量固定操作来说是个累赘，我们不想每操作一个文件就输入一次层数。</p>
<p>所以，如果想跳过交互，可以通过管道连接符 | 实现。比如固定底部4层：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo 4 | python POSCARtoolkit.py -i CONTCAR –f</span><br></pre></td></tr></table></figure>
<p>知道了这一点，我们就可以通过一个for循环进行批量固定层数的操作了。比如我们有POSCAR1， POSCAR2 到POSCAR100个文件，</p>
<p>1) 我们想批量固定它们的底部3层。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in POSCAR&#123;1..10&#125;; do echo 3 | python POSCARtoolkit.py  –i  $i  –f ; done </span><br></pre></td></tr></table></figure>
<p>2) 我们想批量将C H O原子在z方向上放开，zy方向上固定。（这个不需要管道连接符）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in POSCAR&#123;1..10&#125;; do python POSCARtoolkit.py  –i  $i  –r FFT –s C H O ; done</span><br></pre></td></tr></table></figure>
<h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><p>这个脚本在模型操作的过程中，实用性很强，也很方便。实在是VASP计算中的一大利器。本脚本是群友tamas-zju-VASP（小塔玛斯）费煞苦心完成的。如果感觉不错，欢迎打赏。下载链接: <a href="https://pan.baidu.com/s/1JJHVM27NdIC-uZlxzlg-Mg">https://pan.baidu.com/s/1JJHVM27NdIC-uZlxzlg-Mg</a>   提取码:mt7e</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>POSCARtoolkit.py</tag>
        <tag>NEB</tag>
        <tag>过渡态</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex74 过渡态的计算（五）</title>
    <url>/2018/11/12/ex74/</url>
    <content><![CDATA[<p>前面2节我们讲了如何通过vtst的脚本进行插点,得到过渡态计算中特定数目的images，以及一个非常实用的小脚本来固定slab模型中底层的原子。本节我们就准备一下过渡态计算中：POSCAR、KPOINTS和POTCAR文件的准备工作。</p>
<h3 id="关于Images"><a href="#关于Images" class="headerlink" title="关于Images"></a>关于<code>Images</code></h3><p>前面我们插了8个点，得到10个文件夹，分别为00， 01， 02，….09</p>
<p>细心的你会发现，每个文件夹中都会有一个POSCAR文件。00 中的POSCAR对应的是<code>nebmake.pl IS FS 8</code>命令中的IS，两个一模一样，同理，09 中的POSCAR是<code>nebmake.pl IS FS 8</code>命令中的FS。01到08位我们设想的一个反应路径。（通过p4vasp 0*/POSCAR 这个小技巧，来查看整个路径是不是合理）所有IMAGES中的元素行都是一样的，所以我们任取一个用来生成POTCAR文件。</p>
<p>结合之前VASP的使用经验，每个文件夹中都有一个POSCAR，那么算NEB的时候：是不是各个文件夹也中都要有INCAR， KPOINTS和 POTCAR以及提交任务的脚本呢？</p>
<p>如果你这么想，是很正常的。但我们算过渡态的时候，却不是这样操作的。</p>
<p>实际上，我们将00 到 09 这10个文件夹作为一个整体，看作一个POSCAR。和在这些文件夹相同的目录下， 有INCAR, KPOINTS 和 POTCAR文件。</p>
<p>如果你还不理解，看下面的两个图：首先我们放一个错误的准备工作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex74/wrong$ ls</span><br><span class="line">00  01  02  03  04  05  06  07  08  09</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex74/wrong$ ls *</span><br><span class="line">00:</span><br><span class="line">INCAR  job_sub  KPOINTS  POSCAR  POTCAR</span><br><span class="line"></span><br><span class="line">01:</span><br><span class="line">INCAR  job_sub  KPOINTS  POSCAR  POTCAR</span><br><span class="line"></span><br><span class="line">02:</span><br><span class="line">INCAR  job_sub  KPOINTS  POSCAR  POTCAR</span><br><span class="line"></span><br><span class="line">03:</span><br><span class="line">INCAR  job_sub  KPOINTS  POSCAR  POTCAR</span><br><span class="line"></span><br><span class="line">04:</span><br><span class="line">INCAR  job_sub  KPOINTS  POSCAR  POTCAR</span><br><span class="line"></span><br><span class="line">05:</span><br><span class="line">INCAR  job_sub  KPOINTS  POSCAR  POTCAR</span><br><span class="line"></span><br><span class="line">06:</span><br><span class="line">INCAR  job_sub  KPOINTS  POSCAR  POTCAR</span><br><span class="line"></span><br><span class="line">07:</span><br><span class="line">INCAR  job_sub  KPOINTS  POSCAR  POTCAR</span><br><span class="line"></span><br><span class="line">08:</span><br><span class="line">INCAR  job_sub  KPOINTS  POSCAR  POTCAR</span><br><span class="line"></span><br><span class="line">09:</span><br><span class="line">INCAR  job_sub  KPOINTS  POSCAR  POTCAR</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这就是刚刚说的，把INCAR, KPOINTS, POTCAR 和脚本都复制到images对应的文件夹中。知道了错误的准备文件，那下面我们看一下正确的做法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex74/wrong$ cd ../right/</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex74/right$ ls</span><br><span class="line">00  01  02  03  04  05  06  07  08  09  INCAR  job_sub  KPOINTS  POTCAR</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex74/right$ ls *</span><br><span class="line">INCAR  job_sub  KPOINTS  POTCAR</span><br><span class="line"></span><br><span class="line">00:</span><br><span class="line">POSCAR</span><br><span class="line"></span><br><span class="line">01:</span><br><span class="line">POSCAR</span><br><span class="line"></span><br><span class="line">02:</span><br><span class="line">POSCAR</span><br><span class="line"></span><br><span class="line">03:</span><br><span class="line">POSCAR</span><br><span class="line"></span><br><span class="line">04:</span><br><span class="line">POSCAR</span><br><span class="line"></span><br><span class="line">05:</span><br><span class="line">POSCAR</span><br><span class="line"></span><br><span class="line">06:</span><br><span class="line">POSCAR</span><br><span class="line"></span><br><span class="line">07:</span><br><span class="line">POSCAR</span><br><span class="line"></span><br><span class="line">08:</span><br><span class="line">POSCAR</span><br><span class="line"></span><br><span class="line">09:</span><br><span class="line">POSCAR</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex74/right$</span><br></pre></td></tr></table></figure>
<p>把0{0..9}这些文件夹作为一个整体，看作POSCAR。这些文件夹 和INCAR，KPOINTS, POTCAR，以及提交任务的脚本放在同一个目录下。</p>
<p><strong>备注：</strong></p>
<p>1） 上面本人插了8个点，纯属自己的日常计算习惯，并不属于什么过渡态的技巧。大家根据自己服务器的运算能力，设置合理的数目。</p>
<p>2） POTCAR与这些images中的元素数目要对应，这个大家应该都会了。</p>
<p>3） KPOINTS: 划重点</p>
<p>如果你从网上搜索相关的资料，很多时候会发现大家经常说，先粗算一下（或者预优化一下），然后再逐渐提高精度。算过渡态的时候也是这样子的，我们不能100%确认自己预想的反应路径（Images文件对应的结构）就是合理的，或者刚刚插的这些点结构都很粗糙，直接用高精度的计算会造成资源的大量浪费，也就是费力不讨好。再严肃点，纳税人的钱不是让你这样随随便便烧的。所以，我们要掌握一些合理的技巧，争取用最少的计算资源，最短的时间，来获取最合理的过渡态结构。前面说到了粗算，到底什么是粗算？粗算需要改什么参数？</p>
<p>这里我们需要<strong>了解芝麻和西瓜的故事</strong>。</p>
<p>通过前面的学习，我们知道KPOINTS以及slab（计算体系）的大小对于计算的影响最大，它们就是西瓜。</p>
<p>而其他的参数，比如收敛标准，阶段能的大小等，都是小芝麻（当然，你收敛精度设置地极其高那也是个别情况，对于粗算的时候我们不考虑）。</p>
<p>说白了， 就是要抓住影响机时的关键因素。所以粗算的时候，我们需要改的主要有2个地方: KPOINTS 和 slab的模型（集中力量啃西瓜）。</p>
<p>Slab的修改难度较大， 对于新手不太实用，老司机也经常翻车，故先不做讨论。这里我们主要介绍通过调节KPOINTS的一个技巧来实现快速粗算的目的。</p>
<p><strong>先声明：</strong></p>
<p>以下适用于slab表面上的反应计算。如果你算的是体相里面的，比如原子的扩散等，只可作为参考，不能照搬。</p>
<p>在粗算的时候，建议使用低密度的的K点。上来就用高密度的K点计算，即使是土豪，也是不建议的。那么K点密度怎么个低法呢？ 直接来个极端就好了，用gamma点。前面我们还讲过，如果用gamma点计算的时候，需要把slab的原子固定住。</p>
<p>为什么呢？</p>
<p>你可以使用4层的p(2x2)的Cu(111)的slab模型，放开上面2层，然后gamma点优化一个CO在上面的吸附,最后会发现表层的Cu原子驰豫得如同波浪一般起伏。也就是用gamma点会导致表层原子过分地驰豫，从而造成错误的结算结果。</p>
<p>但这也不是绝对的，如果你的slab在xy方向的尺寸很大，使用gamma点的时候满足我们之前讲过的 k*a 的经验规则，即使不固定原子，也是很安全的。（为保险，需要自己测试）如果slab在xy方向的尺寸很小，使用gamma点的就一定需要把原子固定住。固定slab的时候，这里面就有很多窍门了。</p>
<p>A）<strong>首先给大家介绍一个最简单的办法。</strong>也就是上一节的内容，使用塔马斯的POSCARtoolkit.py脚本，固定和放开任意slab里面的底层原子。比如，目前我们的例子，4层的Ru原子上面，H原子的扩散。我们就可以通过一个for循环来实现slab原子的快速固定。为了方便大家，写了一个基于POSCARtoolkit.py 的bash脚本，该脚本命名为<code>fix.sh</code>, 内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="comment">## To use it</span></span><br><span class="line"><span class="comment">## fix.sh 4 POSCAR  will fix the bottom 4 layers of  POSCAR  in all image filders</span></span><br><span class="line"><span class="comment">## fix.sh 2 CONTCAR will fix the bottom 2 layers of  CONTCAR in all image folders</span></span><br><span class="line"><span class="comment">## The old POSCAR or CONTCAR will be replaced.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> 0* ; <span class="keyword">do</span></span><br><span class="line"> <span class="built_in">cd</span> <span class="variable">$i</span>;</span><br><span class="line"> <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> | POSCARtoolkit.py -i <span class="string">&quot;<span class="variable">$2</span>&quot;</span> -f;</span><br><span class="line"> mv  <span class="variable">$&#123;2&#125;</span>_C <span class="string">&quot;<span class="variable">$2</span>&quot;</span></span><br><span class="line"> <span class="built_in">cd</span> <span class="variable">$OLDPWD</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>注意：</p>
<p>1) 这里大师兄将默认的阈值设置为0.5 Å（修改的脚本）。因为原来1.5 Å有点大， 使用的时候会将表面的H和表层的Ru看作一层。</p>
<p>运行到这里的时候， 我们将所有Images中POSCAR的slab对应的原子全部固定住了。也就是粗算的POSCAR设置好了。</p>
<p>2) 不要偷懒直接复制代码就运行，由于网页上的格式问题，可能直接复制过来运行的时候回出错。</p>
<p>B)  除了使用脚本外，<strong>还有另外一个方便的办法</strong>：</p>
<p>在课题刚刚开始的时候，就把slab模型中的原子按照层数（也就是z方向的大小）进行排列，前面我们讲过怎么sort坐标了，这里就不再啰嗦。</p>
<p>排列后的一个优势就是各个层的原子在POSCAR中的序号是连续的，可以很方便地进行选择然后通过使用sed 命令将POSCAR里面的T T T 批量转化为 F F F. </p>
<p>比如本例中：10-45为Ru原子，10-18， 19-27, 28-36， 37-45 从上往下数，分别对应第一、二、三、四层的Ru原子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ru   H</span><br><span class="line">   1.00000000000000</span><br><span class="line">   8.1377999784000004   0.0000000000000000   0.0000000000000000</span><br><span class="line">   4.0688999892000002   7.0475415119999996   0.0000000000000000</span><br><span class="line">   0.0000000000000000   0.0000000000000000  21.5631999968999999</span><br><span class="line">Ru   H</span><br><span class="line">36  1</span><br><span class="line">Selective dynamics</span><br><span class="line">Direct</span><br><span class="line">  0.2212968850718230  0.2239409561475650  0.2936169649913790 F F F</span><br><span class="line">  0.2210036114118170  0.5561663540453879  0.2936884876706930 F F F</span><br><span class="line">  0.2212954084343650  0.8880992570872690  0.2936171801115680 F F F</span><br><span class="line">  0.5547059120221930  0.2208073369214740  0.2945957656788490 F F F</span><br><span class="line">  0.5547051050620690  0.5578229108467880  0.2945953069057910 F F F</span><br><span class="line">  0.5572530259134471  0.8880427972121010  0.2935860240494040 F F F</span><br><span class="line">  0.8910551675972660  0.2211397177458350  0.2944546614649750 F F F</span><br><span class="line">  0.8893412673473050  0.5559102687354450  0.2935156586054220 F F F</span><br><span class="line">  0.8893404937786400  0.8880862995751930  0.2935168781920150 F F F</span><br><span class="line">  0.1119432861914480  0.1106972088633780  0.1977748273385700 F F F</span><br><span class="line">  0.1112675774095350  0.4441060896203480  0.1977506775579700 F F F</span><br><span class="line">  0.1112675246777360  0.7779649556723670  0.1977514668340350 F F F</span><br><span class="line">  0.4440066349954530  0.1106943439331120  0.1977106006833940 F F F</span><br><span class="line">  0.4446549772136020  0.4443417041956370  0.1981365664070010 F F F</span><br><span class="line">  0.4440061461204080  0.7786377563630820  0.1977110173547200 F F F</span><br><span class="line">  0.7777009262273890  0.1113226147079440  0.1980782640541890 F F F</span><br><span class="line">  0.7777006933574599  0.4443146361556100  0.1980780083860340 F F F</span><br><span class="line">  0.7774653980933121  0.7779366397494840  0.1977260420610920 F F F</span><br><span class="line">  0.2222233413377670  0.2222233413358840  0.0992873228095945 F F F</span><br><span class="line">  0.2222233413377670  0.5555566746692190  0.0992873228095945 F F F</span><br><span class="line">  0.2222233413377670  0.8888900080025550  0.0992873228095945 F F F</span><br><span class="line">  0.5555566746710950  0.2222233413358840  0.0992873228095945 F F F</span><br><span class="line">  0.5555566746710950  0.5555566746692190  0.0992873228095945 F F F</span><br><span class="line">  0.5555566746710950  0.8888900080025550  0.0992873228095945 F F F</span><br><span class="line">  0.8888900080044310  0.2222233413358840  0.0992873228095945 F F F</span><br><span class="line">  0.8888900080044310  0.5555566746692190  0.0992873228095945 F F F</span><br><span class="line">  0.8888900080044310  0.8888900080025550  0.0992873228095945 F F F</span><br><span class="line">  0.1111100016643290  0.1111100016603930  0.0000000000000000 F F F</span><br><span class="line">  0.1111100016643290  0.4444433349937280  0.0000000000000000 F F F</span><br><span class="line">  0.1111100016643290  0.7777766683270571  0.0000000000000000 F F F</span><br><span class="line">  0.4444433349976650  0.1111100016603930  0.0000000000000000 F F F</span><br><span class="line">  0.4444433349976650  0.4444433349937280  0.0000000000000000 F F F</span><br><span class="line">  0.4444433349976650  0.7777766683270571  0.0000000000000000 F F F</span><br><span class="line">  0.7777766683310010  0.1111100016603930  0.0000000000000000 F F F</span><br><span class="line">  0.7777766683310010  0.4444433349937280  0.0000000000000000 F F F</span><br><span class="line">  0.7777766683310010  0.7777766683270571  0.0000000000000000 F F F</span><br><span class="line">  0.6419725686006360  0.3456803556224560  0.3432239557346220 T T T</span><br></pre></td></tr></table></figure>
<p>在上面POSCAR基础上，放开上面的2层：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed –i  &#x27;10,27s/F/T/g’ 0*/POSCAR</span><br></pre></td></tr></table></figure>
<p>固定所有的Ru原子，可以：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed –i  ’10,45s/T/F/g’ 0*/POSCAR</span><br></pre></td></tr></table></figure>
<p>大家随意练习折腾，本人也相信，如果从本书的Ex-0一直认真学下来，如果<code>sed</code> 命令还不会的话，说明你真的没有认真在学习。本节的例子以及脚本下载链接：</p>
<p><a href="https://pan.baidu.com/s/1qqySBpqc0zMu1lvpLVZuWA">https://pan.baidu.com/s/1qqySBpqc0zMu1lvpLVZuWA</a>   提取码: 3ryx</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本节，我们介绍了准备文件中POSCAR， KPOINTS，和POTCAR，以及他们在目录里面的排列方式。为减轻计算压力，过渡态可以先粗算一下， 通过使用gamma点结合固定slab的方式来减少计算量。通过POSCARtooklit.py或者sed命令实现批量固定slab的方法。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>NEB</tag>
        <tag>过渡态</tag>
        <tag>IMAGES</tag>
        <tag>VTST</tag>
        <tag>过渡态输入文件</tag>
        <tag>芝麻和西瓜</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex75 过渡态的计算（六）</title>
    <url>/2018/11/13/ex75/</url>
    <content><![CDATA[<h1 id="过渡态计算INCAR的设置"><a href="#过渡态计算INCAR的设置" class="headerlink" title="过渡态计算INCAR的设置"></a>过渡态计算INCAR的设置</h1><p>vasp的过渡态任务所需要的五个文件：INCAR, KPOINTS, POSCAR, POTCAR以及脚本。我们已经学习了三个，还差INCAR和脚本，这一节，我们主要介绍INCAR中参数的设置。很多读者都没有接触过渡态的计算，总是幻想着过渡态是如何地高大上，令人可望而不可即。其实很简单，记住前面我们说的那句话，过渡态的计算无非就是优化一个特殊的结构而已。既然是优化结构，那么我们就可以在前面结构优化的INCAR基础上稍加修改，让它变成过渡态的INCAR即可。</p>
<p>修改一共有以下几个重要的部分：</p>
<h3 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h3><p><code>LCLIMB = .TRUE.</code>  告诉vasp你要开始使用CI-NEB方法算过渡态了。</p>
<p><strong>注意1：</strong> <code>LCLIMB = .TRUE</code> 这个写法是错的，因为TRUE后面少了个点！<code>LCLIMB = T</code> 这个写法是可以的。</p>
<h3 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h3><p> <code>IMAGES =   8</code>   告诉vasp，你插了8个点。VASP不是智能的，根据目录下文件夹的数目自动帮你数一下插点的个数，我们要自己设置一下。</p>
<p><strong>注意2</strong>：INCAR中IMAGES的数目和实际的不符，这是很多人常犯的错误。比如插了8个点，INCAR中却是<code>IMAGES= 4</code>，这会导致VASP只读取00到05的结构，从而05到08文件夹中没有输出文件。</p>
<h3 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h3><p> 过渡态计算的优化器（Optimizer）</p>
<p>CI-NEB是基于Force 也就是力来获取能量最低的反应路径。优化的方法有2个选择，一个是VASP默认的。一个是VTST中自带的。</p>
<h5 id="3-1）VASP默认的优化方法："><a href="#3-1）VASP默认的优化方法：" class="headerlink" title="3.1）VASP默认的优化方法："></a>3.1）VASP默认的优化方法：</h5><p>IBRION =1 (quasi-Newton) 和3 (quick-min) 是基于力的优化方法。一般来说，如果你感觉自己插的点基本上就是反应的路径了，可以使用IBRION= 1。如果你的初始和末态结构不是很理想，插的点也是马马虎虎，那么3则是一个很好的选择。IBRION选择完了，我们还要设置一个合理的POTIM。个人经验0.1-1.0之间都是可以接受的。</p>
<p>所以：使用VASP自带的优化器：</p>
<p>IBRION = 1 或者3</p>
<p>POTIM = 取个合理的数值。</p>
<h5 id="3-2）VTST中也自带了一些基于力的优化方法。"><a href="#3-2）VTST中也自带了一些基于力的优化方法。" class="headerlink" title="3.2）VTST中也自带了一些基于力的优化方法。"></a>3.2）VTST中也自带了一些基于力的优化方法。</h5><p><a href="http://theory.cm.utexas.edu/vasp/optimizers.html#optimizers">http://theory.cm.utexas.edu/vasp/optimizers.html#optimizers</a></p>
<p>使用VTST自带的优化方法，我们先要关闭VASP自带的，加下面2个参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IBRION = 3</span><br><span class="line">POTIM = 0</span><br></pre></td></tr></table></figure>
<p>然后你就可以通过IOPT来选择自己喜欢的了。下面红色部分是官网的介绍：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">Optimizer input parameters</span><br><span class="line">The following parameters are readfrom the INCAR <span class="keyword">file</span>.</span><br><span class="line">(IOPT = <span class="number">0</span>) <span class="keyword">Use</span> VASP optimizersspecified from IBRION (<span class="keyword">default</span>)</span><br><span class="line">(IOPT = <span class="number">1</span>) LBFGS = Limited-memoryBroyden-Fletcher-Goldfarb-Shanno</span><br><span class="line">(IOPT = <span class="number">2</span>) CG = Conjugate Gradient</span><br><span class="line">(IOPT = <span class="number">3</span>) QM = Quick-<span class="built_in">Min</span></span><br><span class="line">(IOPT = <span class="number">4</span>) SD = Steepest Descent</span><br><span class="line">(IOPT =<span class="number">7</span>) FIRE = Fast Inertial Relaxation Engine</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>如果你已经打算用VTST自带的优化器，那么IOPT =0 不要选。</p>
<p>因为0对应的是VASP自带的。使用VTST的这个前提是我们把VASP的优化器给关掉了。但你关掉后，又设置IOPT=0，这是一个自相矛盾的选择，会导致计算过程中，你的原子纹丝不动，因为POTIM= 0.</p>
<p>所以，使用VTST自带的优化器：</p>
<p>IBRION = 3</p>
<p>POTIM = 0</p>
<p>IOPT = 1,2,3,4,7  有5个选择，官网建议使用1或者2。</p>
<h3 id="第四部分"><a href="#第四部分" class="headerlink" title="第四部分"></a>第四部分</h3><p> SPRING = -5 (这是默认值)</p>
<p>这个参数是干嘛的? 查阅一下VTST的官网，链接如下：</p>
<p><a href="http://theory.cm.utexas.edu/vtsttools/neb.html">http://theory.cm.utexas.edu/vtsttools/neb.html</a></p>
<p>The nudged elastic band (NEB) is a method for finding saddle points and minimum energy paths between known reactants and products. The method works by optimizing a number of intermediate images along the reaction path. Each image finds the lowest energy possible while maintaining equal spacing to neighboring images. This constrained optimization is done by adding spring forces along the band between images and by projecting out the component of the force due to the potential perpendicular to the band.</p>
<p>什么意思呢？打个比方，这8个IMAGES就是一条绳上的8只蚂蚱，这些蚂蚱只能在一个方向上跳，在优化的时候，蚂蚱跳的太远，或者太偏就会被拉回来。拉回来的这个力就是通过SPRING这个参数来设置的。而我们之前的优化优化计算中，一条绳上只栓一只蚂蚱，该蚂蚱则比较自由，前后左右可以随便跳，并且没有人往回拽，这也是过渡态计算和普通优化所不同的地方。具体的理论部分，大家自行查阅NEB相关的参考文献。</p>
<p>如果你算的一个基元反应，两个原子之间的键很强，那么我们就需要将SPRING这个参数设置的更负一些，比如SPRING= -10，-15 或者-20。（不一定是-5的倍数，也可以是-6，-11 等。）如果你不知道怎么设置，一般来说默认值-5就足够用了。</p>
<h3 id="第五部分"><a href="#第五部分" class="headerlink" title="第五部分"></a>第五部分</h3><p>收敛相关的参数（粗算中的芝麻部分）：</p>
<p>当然，粗算的时候，还要设置电子步以及以及离子步的收敛标准。</p>
<p>EDIFF = 1E-4 完全够用，不放心可以设置成-5；</p>
<p>NELM = 60 或者使用默认值40；</p>
<p>EDIFFG: 由于我们这一步是粗算，不用那么精确，EDIFFG = -0.05 完全够用了；</p>
<p>NSW: 个人经验，一般跑个50-60步左右就可以大体看个样子出来了，不用非得等计算达到EDIFFG设置的收敛标准。所以，前面的EDIFFG只是个形式罢了，这里我们先让这个参数占个坑，避免下一步提高精度计算的时候忘记这个参数。</p>
<p>小结一下：如果我们使用VASP自带的优化器，过渡态计算相关的参数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LCLIMB = .TRUE.  # 用CI-NEB方法算TS</span><br><span class="line">IMAGES =   8     # 反应路径插了8个点</span><br><span class="line">IBRION = 1       # 初始结构（路径）感觉不太好，可以用 IBRION = 3</span><br><span class="line">POTIM = 0.2      # 一般0.2可以满足大部分的情况</span><br><span class="line">SPRING = -5      # 约束不同IMAGES之间的力</span><br><span class="line">EDIFF = 1E-4     # 电子步的收敛标准</span><br><span class="line">EDIFFG = -0.05   # 离子步的收敛标准，在粗算中就是个摆设</span><br><span class="line">NSW = 60         # 粗算中50-100均可</span><br></pre></td></tr></table></figure>
<p>如果你粗算了一下，跑了60步没有收敛，自己查看下各个IMAGES中的CONTCAR结构，感觉差不多就可以继续提高精度继续算了。如果感觉结构不是很好，那么就把各个IMAGES中的CONTCAR复制成POSCAR，然后继续再跑。后面大师兄会带着你一步一步跑，这个先不用着急。</p>
<p><strong>总结：</strong></p>
<p>这一节我们主要学习了过渡态计算中INCAR的一些基本设置。插点算过渡态时必须要有的参数如下：</p>
<p>1）告诉程序给我们要开始算过渡态了，并且指定插点的数目(这两个参数必须要写！！！)</p>
<p> LCLIMB = .TRUE. </p>
<p> IMAGES =   8  </p>
<p>2）选择优化器(optimizer)</p>
<p>有VASP自带的和VTST自带的两种，大家选一种即可。</p>
<p>3）使用多大的劲控制蚂蚱不乱跳：</p>
<p>SPRING  = -5 （默认值）</p>
<p>4）其他的参数跟前面结构优化的基本一致。</p>
<p>在准备工作中：第1）个是最关键的，不设置就不给你算。后面的2-4）由于都有默认的参数，即使不设置也不会导致VASP罢工的情况。但它们是一些经验性很强的参数，需要结合自己的体系具体设置。不过，经验性再强，目的也只有一个，就是过渡态要算准，所以一定要将能量和结构结合起来分析。尤其是结构，Linux用户多多使用类似</p>
<p>I）              p4v  0*/CONTCAR</p>
<p>II）            ase-gui  0*/CONTCAR</p>
<p>的命令将所有的结构一次性打开，分析结构变化和能量变化之间的关系。如果是在Windows下进行计算，自行搜索办法，或学习下一节中<code>VASPkit + VMD</code>的可视化办法。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>NEB</tag>
        <tag>过渡态</tag>
        <tag>过渡态INCAR</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex76 过渡态任务的检查（一）</title>
    <url>/2018/11/16/ex76/</url>
    <content><![CDATA[<p>前面我们介绍了怎么准备过渡态计算的INCAR，POSCAR，POTCAR和POTCAR，这一节理所当然，就是要提交任务了。过渡态计算的时候，和大多数的计算是一样的：检查输入文件，准备好脚本，敲命令提交任务。所以，我们就在这三个方面展开，具体讨论一下里面的细节部分，避免不必要的出错，提高计算的成功率和效率。</p>
<h3 id="心态"><a href="#心态" class="headerlink" title="心态"></a>心态</h3><p>算过渡态的时候，要把自己想象成一个整装待命的狙击手，要熟悉自己的枪（VASP），周围的环境（影响计算的因素），以及狙杀的对象（计算的体系）。</p>
<h4 id="枪"><a href="#枪" class="headerlink" title="枪"></a>枪</h4><p>也就是VASP的输入文件，开枪前，先检查一遍自己的枪有没有问题。</p>
<p>怎么检查呢？</p>
<p>大师兄本人的方法就是：不断在心里按着顺序默念：INCAR，KPOINTS，POSCAR，POTCAR。然后根据自己的经验检查并修改。这里你也许会说，大师兄，那是因为你有经验了啊，才能这么做，没有经验的我，该怎么办呢？</p>
<p>不要怕，我们下面慢慢分析。</p>
<h4 id="INCAR"><a href="#INCAR" class="headerlink" title="INCAR"></a>INCAR</h4><p> 对于大多数的计算，影响计算时间的主要因素是KPOINTS，体系的大小，INCAR中关于收敛的参数。这三者紧密相连。而INCAR中的计算在粗算的这一个环节里面，对时间的影响不是很大。这给我们的启示就是：不管是粗算，还是后面提高精度的计算，我们使用同样的设置即可。大家一般来说的低高精度的计算，主要集中在EDIFF和EDIFFG这两个参数上。体系不是很特殊，EDIFF=1E-5; EDIFFG=-0.02 就足够了。完全没有必要再粗算的时候将它们的数值调大点或者调小点。如果可以这样思考的话，那我们就可以将INCAR的参数提前设置好，用的时候直接拿来就可以了。</p>
<p>想到了这一点，下面我们的任务就轻松了，可以写个脚本，直接敲个命令生成CI-NEB计算的INCAR。这里大师兄用的是另外一个办法：</p>
<p>1） 先准备好一个INCAR，里面肯定把CI-NEB计算的参数等乱七八糟的都写好了。</p>
<p>2）将INCAR放在一个固定的目录下面，比如：~/bin/INCAR_neb</p>
<p>3）提交任务前，将INCAR复制过来即可。</p>
<p>4）划重点：alias 的骚操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp ~/bin/INCAR_neb INCAR </span><br><span class="line">alias neb=&#x27;cp ~/bin/INCAR_neb INCAR&#x27;</span><br></pre></td></tr></table></figure>
<p>这样的话，我们直接敲个命令，就可以得到INCAR文件了。</p>
<p><strong>INCAR的检查：</strong></p>
<p>前面的做法，并不代表我们就可以直接使用INCAR文件了。能不能直接用，取决于我们的具体计算细节。若INCAR中的参数与当前任务的不一致，或者缺少某些参数，我们就需要更新一下，主要有以下几个方面：</p>
<p>1） INCAR中默认的插点数目和实际不一致，记得更新。</p>
<p>2）若POSCAR中的结构有磁性，并且和INCAR中的不一致，记得更新；</p>
<p>3）如使用DFT-D2，INCAR中C6和R6的设置和POSCAR中的元素不一致，记得更新；</p>
<p>4）如使用DFT+U，INCAR中U和J的设置与POSCAR中的元素不一致，记得更新。</p>
<p>5）若计算的体系键能比较大，ISPRING这个参数可以稍微修改下，比如从-5调小到-8。</p>
<p>6）若发现slab体系粗算的时候，不怎么收敛，偶极校正取消一下。</p>
<p><strong>KPOINTS的检查：</strong></p>
<p>我们在粗算阶段，KPOINTS直接用gamma点即可。为了方便可以使用脚本kponits.sh 1 1 1 直接生成。也可以添加到我们的alias这个命令中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias neb=&#x27;cp ~/bin/INCAR_neb INCAR &amp;&amp; kpoints.sh 1 1 1 &#x27;</span><br></pre></td></tr></table></figure>
<p><strong>POTCAR 的检查：</strong></p>
<p>可以使用我们前面的自动生成与POSCAR对应POTCAR的脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp 01/POSCAR . &amp;&amp; pospot.sh &amp;&amp; rm POSCAR </span><br></pre></td></tr></table></figure>
<p>为了方便，也可以直接将上面这句话添加到alias里面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias neb=&#x27;cp ~/bin/INCAR_neb INCAR &amp;&amp; kpoints.sh 1 1 1 &amp;&amp; cp 01/POSCAR . &amp;&amp; pospot.sh &amp;&amp; rm POSCAR &#x27;</span><br></pre></td></tr></table></figure>
<p><strong>POSCAR的检查：</strong></p>
<p>POSCAR被归结到枪这一部分，其实也是我们狙杀的对象。在粗算这部分的检查，需要注意的地方有：</p>
<p>1） 确保slab被固定住了；否则你算完会发现表面的原子都疯掉了。前面我们讲过怎么通过脚本或者sed命令批量固定了，就不再过多叙述。</p>
<p>2）使用p4v一次性打开所有的POSCAR文件：p4v 0*/POSCAR ; 这里大师兄也是用了alias</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias pp=&#x27;p4v 0*/POSCAR&#x27;</span><br><span class="line">alias ap=&#x27;ase-gui 0*/POSCAR&#x27;</span><br></pre></td></tr></table></figure>
<p>上面的2个操作都是在Linux下面的，p4v和ase-gui大家根据习惯随便选一款即可。</p>
<ul>
<li><p>使用p4vasp，然后挨个点IMAGE对应的POSCAR，检查结构对不对；</p>
</li>
<li><p>使用ase-gui 将所有的文件全部打开后，摁键盘的PageUp和PageDown这2个键，类似于自己看一帧一帧的电影，体验也很棒。</p>
</li>
<li>检查插点的时候，原子是不是乱套了，没有一一对应；</li>
<li>检查我们插的点，是不是具有很好的化学或者物理意义，也就是预先评估下自己猜的这个路径靠不靠谱。</li>
</ul>
<p>3) 使用Windows的用户先不用着急，大师兄正在学习VASPkit+VDM的骚操作。学会了下一节会及时更新，并提交过渡态的计算。</p>
<p>前面一节，我们提到说，在<code>Ubuntu</code>或者其他<code>Linux</code>系统下面，可以使用<code>p4vasp</code>或者<code>ASE</code>将结构批量打开，查看我们初步设置的NEB路径是否合理。但是在<code>Windows</code>系统下，我们不方便使用命令进行查看。这里介绍一下在<code>Windows</code>下面通过<code>VASPkit</code>结合<code>VMD</code>查看NEB路径结构的方法。</p>
<h3 id="软件的获取："><a href="#软件的获取：" class="headerlink" title="软件的获取："></a>软件的获取：</h3><ul>
<li><code>VASPkit</code>程序的下载<ul>
<li>链接：<a href="https://sourceforge.net/projects/vaspkit/">https://sourceforge.net/projects/vaspkit/</a></li>
<li>QQ群：217821116， 364586948</li>
</ul>
</li>
<li><code>VMD</code>的下载链接：<a href="http://www.ks.uiuc.edu/Research/vmd/">http://www.ks.uiuc.edu/Research/vmd/</a> </li>
</ul>
<h3 id="vaspkit的使用"><a href="#vaspkit的使用" class="headerlink" title="vaspkit的使用"></a><code>vaspkit</code>的使用</h3><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/demo_neb$ ls</span><br><span class="line"><span class="number">00</span>  <span class="number">01</span>  <span class="number">02</span>  <span class="number">03</span>  <span class="number">04</span>  <span class="number">05</span>  <span class="number">06</span>  <span class="number">07</span>  <span class="number">08</span>  <span class="number">09</span>  INCAR  KPOINTS  NEB.pdb  POTCAR</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/demo_neb$ rm NEB.pdb </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/demo_neb$ ls</span><br><span class="line"><span class="number">00</span>  <span class="number">01</span>  <span class="number">02</span>  <span class="number">03</span>  <span class="number">04</span>  <span class="number">05</span>  <span class="number">06</span>  <span class="number">07</span>  <span class="number">08</span>  <span class="number">09</span>  INCAR  KPOINTS  POTCAR</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/demo_neb$ vaspkit </span><br><span class="line"> </span><br><span class="line"> +---------------------------------------------------------------+</span><br><span class="line"> |             VASPKIT Version: <span class="number">0.71</span> (<span class="number">16</span> Nov. <span class="number">2018</span>)              |</span><br><span class="line"> |       A Pre- and Post-Processing <span class="function"><span class="keyword">Program</span></span> for VASP Code        |</span><br><span class="line"> |       Official Website: http://vaspkit.sourceforge.net        |</span><br><span class="line"></span><br><span class="line">*</span><br><span class="line">*</span><br><span class="line">*</span><br><span class="line">*                                                                 </span><br><span class="line"> <span class="number">0</span>)  Quit                                                         </span><br><span class="line"> ------------&gt;&gt;</span><br><span class="line"><span class="number">5</span></span><br><span class="line"> ==================== Catalysis-ElectroChem Kit ==================</span><br><span class="line"> <span class="number">501</span>) Thermal Corrections for Adsorbate                      </span><br><span class="line"> <span class="number">502</span>) Thermal Corrections for Gas                    </span><br><span class="line"> <span class="number">503</span>) d-Band Center (experimental)                    </span><br><span class="line"> <span class="number">504</span>) Convert NEB-Path to PDB <span class="keyword">Format</span> for Animation                    </span><br><span class="line">                                                                  </span><br><span class="line"> <span class="number">0</span>)   Quit                                                        </span><br><span class="line"> <span class="number">9</span>)   Back                                                        </span><br><span class="line"> ------------&gt;&gt;</span><br><span class="line"><span class="number">504</span></span><br><span class="line"> +-------------------------- Warm Tips --------------------------+</span><br><span class="line">         See An Example <span class="keyword">in</span> vaspkit/examples/neb_animation.        </span><br><span class="line"> +---------------------------------------------------------------+</span><br><span class="line"> --&gt;&gt; (<span class="number">1</span>) Reading Structural Parameters from <span class="number">00</span>/POSCAR <span class="keyword">File</span>...</span><br><span class="line"> +---------------------------------------------------------------+</span><br><span class="line">*</span><br><span class="line">*</span><br><span class="line">*</span><br><span class="line">+---------------------------------------------------------------+</span><br><span class="line"> |               Selective Dynamics is Activated<span class="comment">!                |</span></span><br><span class="line"> +---------------------------------------------------------------+</span><br><span class="line"> --&gt;&gt; (*) Reading Structural Parameters from <span class="number">09</span>/POSCAR <span class="keyword">File</span>...</span><br><span class="line"> +---------------------------------------------------------------+</span><br><span class="line"> |               Selective Dynamics is Activated<span class="comment">!                |</span></span><br><span class="line"> +---------------------------------------------------------------+</span><br><span class="line"> +---------------------------------------------------------------+</span><br><span class="line"> |                         * DISCLAIMER *                        |</span><br><span class="line"> |        CHECK Your Results for Consistency <span class="keyword">if</span> Necessary        |</span><br><span class="line"> |   Bug Reports and Suggestions for Improvements Are Welcome    |</span><br><span class="line"> | Citation of VASPKIT Is Not Mandatory BUT Would Be Appreciated |</span><br><span class="line"> |                     (^.^) GOOD LUCK (^.^)                     |</span><br><span class="line"> +---------------------------------------------------------------+</span><br><span class="line"> iciq-lq@ln3:/THFS/home/iciq-lq/demo_neb$ </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/demo_neb$ ls</span><br><span class="line"><span class="number">00</span>  <span class="number">01</span>  <span class="number">02</span>  <span class="number">03</span>  <span class="number">04</span>  <span class="number">05</span>  <span class="number">06</span>  <span class="number">07</span>  <span class="number">08</span>  <span class="number">09</span>  INCAR  KPOINTS  NEB.pdb  POTCAR</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/demo_neb$ </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/demo_neb$ </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>在终端输入:<code>vaspkit</code></li>
<li>输入：5 后回车</li>
<li>输入：504 后回车</li>
<li>然后你会得到一个<code>NEB.pdb</code>文件。</li>
<li><code>pdb</code>文件包含了00到09这几个文件夹中<code>POSCAR</code>的结构信息，用以<code>VMD</code>进行 查看。</li>
</ul>
<h3 id="VMD-查看pdb文件"><a href="#VMD-查看pdb文件" class="headerlink" title="VMD 查看pdb文件"></a><code>VMD</code> 查看<code>pdb</code>文件</h3><p>使用<code>VMD</code>查看<code>pdb</code>的方法，我们将<code>VASPkit</code>中的具体说明拿过来展示一下：</p>
<ul>
<li>在<code>Windows</code>系统中启动<code>VMD</code>程序</li>
<li>将我们在服务器中生成的<code>NEB.pdb</code>文件下载到本地，然后拖到<code>VMD</code>的界面</li>
<li>在<code>VMD</code>主窗口选择菜单 <code>Display</code> —&gt; <code>Orthographic</code> 正交显示模式 </li>
<li>在<code>VMD</code>主窗口选择菜单<code>Graphics</code> —&gt; <code>Representations</code> —&gt; <code>Drawing Methods</code> 选择 <code>CPK</code></li>
<li>默认是不显示盒子边界的，在<code>VMD</code>主窗口选择菜单 <code>Extensions</code> ,选择 <code>Tk Console</code> , 在弹出的<code>VMD TkConsole</code> 窗口中输入 <code>pbc box -color white</code> ，然后回车，查看模型结构。</li>
<li>点界面的右下角的箭头后，你可以看到我们初步猜测的<code>NEB</code>路径中原子快速动起来了。箭头左面有个<code>speed</code>，我们可以调节原子的速度。</li>
<li>在<code>VMD</code>主窗口选择菜单 <code>Mouse</code> —&gt; <code>Label</code> —&gt; <code>2</code>， 然后去模型界面上，点与<code>NEB</code>路径中最相关的2个原子，就可以查看<code>NEB</code>路径中，原子间距离随着<code>IMAGE</code>结构的变化了。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Windows下的用户，在做过渡态计算的时候，可视化是一个痛点，通常来说，Images中的结构都只能一个一个打开查看，计算的时候不能很好地体会一个反应的发生路径。使用VASPkit则可以顺利地解决这个问题，这个功能更详细的说明，请参考VASPkit的使用手册。当然，这个方法也适用于Linux操作系统下VASPkit + VMD的操作。此外，大师兄还是建议大家有余力的时候多多接触类似于Ubuntu，Centos这样的Linux操作系统。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>NEB</tag>
        <tag>过渡态</tag>
        <tag>检查</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex77 过渡态任务的提交与查看（一）</title>
    <url>/2018/11/20/ex77/</url>
    <content><![CDATA[<p>前面的准备工作完成了，<code>INCAR</code>，<code>KPOINTS</code>，<code>POSCAR</code>（IMAGES）， <code>POTCAR</code>也检查完了。剩下的就是准备脚本提交文件了。本节主要是在天河II号超算中心上给大家简单示范一下：</p>
<ul>
<li>1）准备脚本，提交任务；</li>
<li>2）过渡态任务运行时候的查看；</li>
<li>3） <code>VTST</code>脚本<code>nebresults.pl</code>的安装和使用。</li>
</ul>
<h3 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h3><p>首先通过命令操作，熟悉下天河II号超算中心提交NEB计算的流程。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex77$ ls</span><br><span class="line"><span class="number">00</span>  <span class="number">01</span>  <span class="number">02</span>  <span class="number">03</span>  <span class="number">04</span>  <span class="number">05</span>  <span class="number">06</span>  <span class="number">07</span>  <span class="number">08</span>  <span class="number">09</span>  INCAR  job_sub  KPOINTS  POTCAR </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex77$ </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex77$ cat job_sub</span><br><span class="line">#<span class="comment">!/bin/bash</span></span><br><span class="line">export LD_LIBRARY_PATH=/THFS/opt/intel/composer_xe_2013_sp1<span class="number">.3</span><span class="number">.174</span>/mkl/lib/intel64:$LD_LIBRARY_PATH</span><br><span class="line">yhrun -p gsc -n <span class="number">24</span> /THFS/opt/vasp/<span class="number">5.4</span><span class="number">.4_neb</span>/vasp<span class="number">.5</span><span class="number">.4</span><span class="number">.4</span>/bin/vasp_std</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex77$</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex77/$ yhbatch -p gsc -N <span class="number">2</span> -J test job_sub</span><br><span class="line">Submitted batch job <span class="number">1004311</span></span><br></pre></td></tr></table></figure>
<ul>
<li>每个节点有24核，我们使用了2个节点，共48核，来计算这个NEB任务。</li>
<li>共有8个IMAGES，也就是6个核算一个IMAGE。</li>
<li>我们调用的VASP版本是:<code>/THFS/opt/vasp/5.4.4_neb/vasp.5.4.4/bin/vasp_std</code></li>
<li>本例子下载链接：<a href="https://pan.baidu.com/s/1shjrJsRuDNYGEd2qDqvdFQ">https://pan.baidu.com/s/1shjrJsRuDNYGEd2qDqvdFQ</a>  提取码：<code>k3pp</code> </li>
</ul>
<h3 id="查看NEB计算"><a href="#查看NEB计算" class="headerlink" title="查看NEB计算"></a>查看NEB计算</h3><p>NEB一般收敛的很慢，需要跑很多离子步才会收敛，所以大家要心里有个准备，这也是为什么我们先用gamma点粗算一下，再用高密度的K点计算的原因，总之就是节约时间。虽然NEB要花很长时间才收敛，但提交任务后，我们不能守株待兔似的等着<code>NEB</code>算完，而是要勤检查结果，因为NEB的计算中，也会经常出现结构跑乱的情况。那么该怎么检查呢？ 一看能量，二看结构，三看能量和结构。</p>
<h4 id="一看能量："><a href="#一看能量：" class="headerlink" title="一看能量："></a>一看能量：</h4><p>主要是因为在<code>terminal</code>下面，相对于打开可视化软件查看结构来说，我们通过命令提取每个<code>IMAGE</code>中<code>OUTCAR</code>能量信息的操作更加方便些而已。更重要的其实还是结构的变化，也就是你的反应路径。查看能量有2个办法：</p>
<h5 id="自己用脑子想象或者写脚本："><a href="#自己用脑子想象或者写脚本：" class="headerlink" title="自己用脑子想象或者写脚本："></a>自己用脑子想象或者写脚本：</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex77$ ls</span><br><span class="line">00  01  02  03  04  05  06  07  08  09  INCAR  job_sub  KPOINTS  NEB.pdb  POTCAR  slurm-995085.out  vasprun.xml</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex77$ ta.sh</span><br><span class="line">01       -298.00705385</span><br><span class="line">02       -297.96462657</span><br><span class="line">03       -297.92754864</span><br><span class="line">04       -297.90142637</span><br><span class="line">05       -297.88475532</span><br><span class="line">06       -297.87681445</span><br><span class="line">07       -297.89025285</span><br><span class="line">08       -297.93374021</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex77$ cat ~/bin/ta.sh</span><br><span class="line"><span class="comment">#!/usr/bin/env bash</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> *; <span class="keyword">do</span></span><br><span class="line"><span class="keyword">if</span> [ -e <span class="variable">$i</span>/OUTCAR ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> -e  <span class="variable">$i</span> <span class="string">&quot;\t&quot;</span> $(grep <span class="string">&#x27;  without&#x27;</span> <span class="variable">$i</span>/OUTCAR |tail -n 1 | awk <span class="string">&#x27;&#123;print $7&#125;&#x27;</span>)</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex77$ </span><br></pre></td></tr></table></figure>
<p><strong>用脑子想象：</strong></p>
<p>在<code>ts.sh</code> 脚本的输出中，从01的能量一直往下看，自己脑子里面自带一个xy的坐标系，将这些能量填到坐标系中，直至08。你会想象得到这样的一个曲线： 能量从01的-298.007慢慢上升到06的-297.87，然后再下降到08的-297.934。这个曲线的顶点再06处，也就是我们粗算得到的过渡态。</p>
<p>当然，你也写个小脚本提取每个<code>IMAGE</code>中的能量信息，然后画图即可。</p>
<h5 id="使用VTST的脚本：nebresults-pl"><a href="#使用VTST的脚本：nebresults-pl" class="headerlink" title="使用VTST的脚本：nebresults.pl"></a>使用VTST的脚本：<code>nebresults.pl</code></h5><p>前面Ex72中，我们讲过了怎么准备VTST的那些脚本，这一节，我们讲另外一个办法。</p>
<ul>
<li><p>下载VTST的脚本：<a href="http://theory.cm.utexas.edu/vasp/scripts.html">http://theory.cm.utexas.edu/vasp/scripts.html</a> </p>
</li>
<li><p>爬梯子技术不好的话，通过这个链接下载：</p>
<p><a href="https://pan.baidu.com/s/1bSoH8wdk2XvfzdmT75SZWQ">https://pan.baidu.com/s/1bSoH8wdk2XvfzdmT75SZWQ</a> 提取码：<code>dmlt</code> </p>
</li>
<li><p>将下载的文件上传到服务器的<code>~/bin/vtst</code> 目录下；</p>
</li>
<li><p>进行如下的操作:</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/bin$ <span class="built_in">cd</span> vtst/</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/bin/vtst$ ls</span><br><span class="line">vtstscripts.tgz</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/bin/vtst$ tar -zxvf vtstscripts.tgz</span><br><span class="line">vtstscripts-937/</span><br><span class="line">vtstscripts-937/pos2xyz.py</span><br><span class="line">vtstscripts-937/sum_dos_np</span><br><span class="line">vtstscripts-937/chg2cube.pl</span><br><span class="line">vtstscripts-937/chgsplit.sh</span><br><span class="line">vtstscripts-937/akmcprocess.pl</span><br><span class="line">*</span><br><span class="line">*</span><br><span class="line">*</span><br><span class="line">vtstscripts-937/nebbarrier.pl</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/bin/vtst$ ls</span><br><span class="line">vtstscripts-937  vtstscripts.tgz</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/bin/vtst$ <span class="built_in">cd</span>  vtstscripts-937/</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/bin/vtst/vtstscripts-937$ ls</span><br><span class="line">2con.py           center.py     diffcon.pl     dymanalyze.pl    dymseldsp.pl     insplot.pl  ....</span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>vim</code>打开<code>nebresults.pl</code>文件，将<code>58-71</code>行注释掉，或者可以使用<code>sed</code>命令：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -i &#x27;58,71s/^/#/g&#x27; nebresults.pl</span><br></pre></td></tr></table></figure>
<p>效果如下图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">57 # Zip the OUTCARs again</span><br><span class="line">58 #print &#x27;Zipping the OUTCARs again ... &#x27; ;</span><br><span class="line">59 #$zip = $ENV&#123;&#x27;VTST_ZIP&#x27;&#125;;</span><br><span class="line">60 #if($zip eq &#x27;&#x27;)&#123; $zip = &#x27;gzip&#x27;; &#125;</span><br><span class="line">61 #</span><br><span class="line">62 #$i = 0;</span><br><span class="line">63 #$string = &quot;00&quot;;</span><br><span class="line">64 #while(chdir $string) &#123;</span><br><span class="line">65 #    system &quot;$zip OUTCAR&quot;;</span><br><span class="line">66 #    $i++;</span><br><span class="line">67 #    if($i &lt; 10) &#123; $string = &quot;0$i&quot;; &#125;</span><br><span class="line">68 #    elsif($i &lt; 100) &#123; $string = &quot;$i&quot;; &#125;</span><br><span class="line">69 #    chdir $dir;</span><br><span class="line">70 #&#125;</span><br><span class="line">71 #print &quot;done\n&quot;;</span><br></pre></td></tr></table></figure>
<ul>
<li>在<code>~/.bashrc</code>文件中设置脚本的目录：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/bin/vtst/vtstscripts-937$ pwd</span><br><span class="line">/THFS/home/iciq-lq/bin/vtst/vtstscripts-937</span><br></pre></td></tr></table></figure>
<ul>
<li>复制上面<code>pwd</code>命令的目录，打开<code>~/.bashrc</code> 文件，添加这一行：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=$PATH:/THFS/home/iciq-lq/bin/vtst/vtstscripts-937</span><br></pre></td></tr></table></figure>
<ul>
<li><code>source</code>一下<code>~/.bashrc</code>文件：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/bin/vtst/vtstscripts-937$ . ~/.bashrc</span><br></pre></td></tr></table></figure>
<ul>
<li>进入计算的目录下，运行<code>nebresults.pl</code>命令，操作如下图:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex77$ ls</span><br><span class="line">00  01  02  03  04  05  06  07  08  09  INCAR  job_sub  KPOINTS  NEB.pdb  POTCAR  slurm-995085.out  vasprun.xml</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex77$ nebresults.pl</span><br><span class="line"></span><br><span class="line">No OUTCAR in 00</span><br><span class="line">Unziping the OUTCARs ... </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex77$ cp 01/OUTCAR  00</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex77$ nebresults.pl</span><br><span class="line"></span><br><span class="line">No OUTCAR in 09</span><br><span class="line">Unziping the OUTCARs ... </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex77$ cp 08/OUTCAR  09</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex77$ nebresults.pl</span><br><span class="line"></span><br><span class="line">Unziping the OUTCARs ... done</span><br><span class="line">Do nebbarrier.pl ; nebspline.pl</span><br><span class="line">Do nebef.pl</span><br><span class="line">Do nebmovie.pl</span><br><span class="line">Do nebjmovie.pl</span><br><span class="line">Do nebconverge.pl</span><br><span class="line"></span><br><span class="line">Forces and Energy:</span><br><span class="line">   0         0.003505      -298.009300         0.000000</span><br><span class="line">   1         0.003505      -298.009300         0.000000</span><br><span class="line">   2         0.008701      -297.969500         0.039800</span><br><span class="line">   3         0.015508      -297.932900         0.076400</span><br><span class="line">   4         0.018300      -297.905700         0.103600</span><br><span class="line">   5         0.016765      -297.887500         0.121800</span><br><span class="line">   6         0.011627      -297.877000         0.132300</span><br><span class="line">   7         0.007293      -297.885300         0.124000</span><br><span class="line">   8         0.003607      -297.929100         0.080200</span><br><span class="line">   9         0.003607      -297.929100         0.080200</span><br><span class="line"></span><br><span class="line">Extremum 1 found at image  0.210729 with energy:  0.002874</span><br><span class="line">Extremum 2 found at image  0.788081 with energy: -0.002910</span><br><span class="line">Extremum 3 found at image  6.265931 with energy:  0.132792</span><br><span class="line">Extremum 4 found at image  8.211450 with energy:  0.074781</span><br><span class="line">Extremum 5 found at image  8.788801 with energy:  0.085561</span><br><span class="line"></span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex77$ </span><br></pre></td></tr></table></figure>
<p><img src="/2018/11/20/ex77/ex77_01.png" alt=""></p>
<p>上面的那个图在Ubuntu的终端里面，通过<code>gs mep.eps</code>命令可以直接打开。</p>
<p><strong>解释：</strong></p>
<p>1)  使用<code>nebresults.pl</code>脚本的时候，我们需要在<code>00</code>和<code>09</code>的文件夹中分别放上初始结构和末态结构所对应的<code>OUTCAR</code>。上面操作中，大师兄把<code>01</code>和<code>08</code>中的<code>OUTCAR</code>分别复制到了<code>00</code>和<code>09</code>中。</p>
<p>为什么这么做呢？</p>
<p>答：偷懒。原因有2个：</p>
<p>A）之前优化结构都是用到的高密度的K点，直接把<code>OUTCAR</code>拿过来用的话，会出现能量差别很大。做出图来能量很奇怪的样子。如下面的例子所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex77/high_k$ ta.sh</span><br><span class="line">  00       -321.15187450</span><br><span class="line">  01       -298.00935617</span><br><span class="line">  02       -297.96955082</span><br><span class="line">  03       -297.93296493</span><br><span class="line">  04       -297.90579729</span><br><span class="line">  05       -297.88754704</span><br><span class="line">  06       -297.87700139</span><br><span class="line">  07       -297.88531984</span><br><span class="line">  08       -297.92917858</span><br><span class="line">  09       -321.09850728</span><br><span class="line">  iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex77/high_k$ nebresults.pl</span><br><span class="line">  </span><br><span class="line">  Unziping the OUTCARs ... <span class="keyword">done</span></span><br><span class="line">  Do nebbarrier.pl ; nebspline.pl</span><br><span class="line">  Do nebef.pl</span><br><span class="line">  Do nebmovie.pl</span><br><span class="line">  Do nebjmovie.pl</span><br><span class="line">  Do nebconverge.pl</span><br><span class="line">  </span><br><span class="line">  Forces and Energy:</span><br><span class="line">     0         0.023782      -321.151800         0.000000</span><br><span class="line">     1         0.003505      -298.009300        23.142500</span><br><span class="line">     2         0.008701      -297.969500        23.182300</span><br><span class="line">     3         0.015508      -297.932900        23.218900</span><br><span class="line">     4         0.018300      -297.905700        23.246100</span><br><span class="line">     5         0.016765      -297.887500        23.264300</span><br><span class="line">     6         0.011627      -297.877000        23.274800</span><br><span class="line">     7         0.007293      -297.885300        23.266500</span><br><span class="line">     8         0.003607      -297.929100        23.222700</span><br><span class="line">     9         0.011589      -321.098500         0.053300</span><br><span class="line">  </span><br><span class="line">  Extremum 1 found at image  0.000009 with energy: -0.000000</span><br><span class="line">  Extremum 2 found at image  6.265997 with energy: 23.275310</span><br><span class="line">  </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex77$</span><br></pre></td></tr></table></figure>
<p><img src="/2018/11/20/ex77/ex77_02.png" alt=""></p>
<p>看到了没有，上面例子中<code>01</code>到<code>08</code> 结构的能量很大。这是因为参考的能量是<code>00</code>的。对于同一个体系，K点大的话，绝对能量更负一些。能量差别太大，导致过渡态的能量变化都可以忽略掉了。</p>
<p>B）当然我们也可以分别对<code>00</code>和<code>09</code>对应对的机构算个单点。生成各自对应的<code>OUTCAR</code>，然后再使用<code>nebresults.pl</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex77$ ta.sh</span><br><span class="line">00       -298.03233582</span><br><span class="line">01       -298.00705385</span><br><span class="line">02       -297.96462657</span><br><span class="line">03       -297.92754864</span><br><span class="line">04       -297.90142637</span><br><span class="line">05       -297.88475532</span><br><span class="line">06       -297.87681445</span><br><span class="line">07       -297.89025285</span><br><span class="line">08       -297.93374021</span><br><span class="line">09       -297.97265721</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex77$ </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex77$ nebresults.pl</span><br><span class="line"></span><br><span class="line">Unziping the OUTCARs ... done</span><br><span class="line">Do nebbarrier.pl ; nebspline.pl</span><br><span class="line">Do nebef.pl</span><br><span class="line">Do nebmovie.pl</span><br><span class="line">Do nebjmovie.pl</span><br><span class="line">Do nebconverge.pl</span><br><span class="line"></span><br><span class="line">Forces and Energy:</span><br><span class="line">   0         0.100196      -298.032300         0.000000</span><br><span class="line">   1         0.003505      -298.009300         0.023000</span><br><span class="line">   2         0.008701      -297.969500         0.062800</span><br><span class="line">   3         0.015508      -297.932900         0.099400</span><br><span class="line">   4         0.018300      -297.905700         0.126600</span><br><span class="line">   5         0.016765      -297.887500         0.144800</span><br><span class="line">   6         0.011627      -297.877000         0.155300</span><br><span class="line">   7         0.007293      -297.885300         0.147000</span><br><span class="line">   8         0.003607      -297.929100         0.103200</span><br><span class="line">   9         0.084593      -297.972600         0.059700</span><br><span class="line"></span><br><span class="line">Extremum 1 found at image  0.057295 with energy: -0.000155</span><br><span class="line">Extremum 2 found at image  6.265997 with energy:  0.155771</span><br><span class="line"></span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex77$ </span><br></pre></td></tr></table></figure>
<p><img src="/2018/11/20/ex77/ex77_03.png" alt=""></p>
<p>仔细观察，你会发现，<code>00</code> 和 <code>01</code>， <code>08</code> 和 <code>09</code> 的能量差别基本不大。所以上面我们的偷懒做法也是可取的。</p>
<p><strong>敲黑板：</strong></p>
<p>一般在粗算的时候，不用考虑那么多细节，怎么粗怎么弄。所以，我们前面讲的这个懒办法是在粗算情况下的操作。由于高K点的计算我们在优化初末态结构的时候已经有了，所以提高精度的时候就可以直接用了。</p>
<h3 id="本节要求"><a href="#本节要求" class="headerlink" title="本节要求"></a>本节要求</h3><p>1） 会提交NEB的计算任务</p>
<p>2） 会使用自己写的或者<code>nebresults.pl</code>脚本查看能量信息。</p>
<p>下一节，我们学习怎么分析这些能量。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>NEB</tag>
        <tag>过渡态</tag>
        <tag>检查</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex78 过渡态任务的提交与查看（二）</title>
    <url>/2019/02/13/ex78/</url>
    <content><![CDATA[<p>前面一节我们通过粗糙的方法演示了一遍怎么在超算上跑过渡态的NEB计算。一般来说，通过这一步我们可以大体上确定这个基元反应中的路径是不是靠谱的了。不论你得到一个粗糙的NEB能量曲线：<img src="/2019/02/13/ex78/ex78_01.png" alt=""></p>
<p>亦或者一个比较精细的：</p>
<p><img src="/2019/02/13/ex78/ex78_02.png" alt=""></p>
<p>这都表明，你快要得到这个过渡态结构了。在进行后面操作讲解之前，我们先做2个事情：</p>
<p>1） 由于本人也是老司机了，算过渡态的时候遇到的那些零零碎碎的问题一时也很难记起来，如果你正在算过渡态，并且遇到了问题和错误，可以将计算打包，以及遇到的问题发给我。如果本人有幸可以帮你解决问题，那么，作为交换条件，这个例子就写在后续的教程里面。有下面几点需要注意的：</p>
<ul>
<li><p>i）请使用邮件发送例子（lqcata@gmail.com），尽可能保证计算的文件完整，千万不要删掉某些文件后再打包发给我（CHG，CHGCAR，WAVECAR除外）。如果例子太大，可以上传到百度网盘，然后将链接和你遇到的问题发给我。</p>
</li>
<li><p>ii）本人最近很忙，可能回复有些慢，请见谅。如果你看到我在QQ群里面瞎BB的话，可以提醒下我去查看邮件。</p>
</li>
<li><p>iii）只想解决自己问题，不愿意分享自己例子的，请不要发邮件给我。</p>
</li>
</ul>
<p>2）第二件事就是分享一个自己平时常用的脚本，这个脚本主要是将前面的计算步骤保存起来，然后将CONTCAR复制成POSCAR用以下一步的计算。脚本的名字为：<code>save_calculations.sh</code>. </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash </span></span><br><span class="line"></span><br><span class="line">mv POSCAR POSCAR-<span class="variable">$1</span>  </span><br><span class="line">mv OUTCAR OUTCAR-<span class="variable">$1</span> </span><br><span class="line">mv OSZICAR OSZICAR-<span class="variable">$1</span></span><br><span class="line">mv vasprun.xml vasprun.xml-<span class="variable">$1</span></span><br><span class="line">mv EIGENVAL EIGENVAL-<span class="variable">$1</span></span><br><span class="line">mv IBZKPT IBZKPT-<span class="variable">$1</span></span><br><span class="line">cp CONTCAR CONTCAR-<span class="variable">$1</span></span><br><span class="line">mv CONTCAR POSCAR</span><br></pre></td></tr></table></figure>
<p>脚本演示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/<span class="built_in">test</span>$ ls</span><br><span class="line">CONTCAR  DOSCAR  DYNMAT  IBZKPT  INCAR  KPOINTS  OSZICAR  OUTCAR  p4vasp.log  POSCAR  POTCAR  sub12  sub24  vasprun.xml</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/<span class="built_in">test</span>$</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/<span class="built_in">test</span>$ save_calculations.sh  gamma</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/<span class="built_in">test</span>$ ls</span><br><span class="line">DOSCAR  DYNMAT  IBZKPT  INCAR  KPOINTS  OSZICAR-gamma  OUTCAR-gamma  p4vasp.log  POSCAR  POSCAR-gamma  POTCAR  sub12  sub24  vasprun.xml-gamma</span><br></pre></td></tr></table></figure>
<p>脚本说明：</p>
<ul>
<li>脚本内容很粗暴直接，大家嫌不好看也可以结合下for循环改进地更加简洁些，本人也懒得改，能实现目的就OK了；</li>
<li>效果很简单，就是把之前计算的一些结果重新命名一下，大家可以根据自己的爱好或者习惯，将gamma换成其他的。 </li>
</ul>
<h3 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h3><p>我们把参数设置地稍微精细一下，然后再跑一遍NEB。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex78$ ls</span><br><span class="line"><span class="number">00</span>  <span class="number">01</span>  <span class="number">02</span>  <span class="number">03</span>  <span class="number">04</span>  <span class="number">05</span>  <span class="number">06</span>  <span class="number">07</span>  <span class="number">08</span>  <span class="number">09</span>  INCAR  job_sub  KPOINTS  NEB.pdb  POTCAR  slurm-<span class="number">995085.</span><span class="keyword">out</span>  vasprun.xml</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex78$</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex78$ ls *</span><br><span class="line">INCAR  job_sub  KPOINTS  NEB.pdb  POTCAR  slurm-<span class="number">995085.</span><span class="keyword">out</span>  vasprun.xml</span><br><span class="line"></span><br><span class="line"><span class="number">00</span>:</span><br><span class="line">POSCAR</span><br><span class="line"></span><br><span class="line"><span class="number">01</span>:</span><br><span class="line">CHG  CHGCAR  CONTCAR  DOSCAR  EIGENVAL  IBZKPT  OSZICAR  OUTCAR  PCDAT  POSCAR  REPORT  WAVECAR  XDATCAR</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="number">08</span>:</span><br><span class="line">CHG  CHGCAR  CONTCAR  DOSCAR  EIGENVAL  IBZKPT  OSZICAR  OUTCAR  PCDAT  POSCAR  REPORT  stdout  WAVECAR  XDATCAR</span><br><span class="line"></span><br><span class="line"><span class="number">09</span>:</span><br><span class="line">POSCAR</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex78$ for i <span class="keyword">in</span> <span class="number">0</span>&#123;<span class="number">1.</span><span class="number">.8</span>&#125;; <span class="keyword">do</span> cd $i ; save_calculations.sh <span class="built_in">gamma</span> ; cd - ; done</span><br><span class="line">mv: cannot stat `vasprun.xml<span class="string">&#x27;: No such file or directory</span></span><br><span class="line"><span class="string">/THFS/home/iciq-lq/LVASPTHW/ex78</span></span><br><span class="line"><span class="string">.</span></span><br><span class="line"><span class="string">.</span></span><br><span class="line"><span class="string">.</span></span><br><span class="line"><span class="string">mv: cannot stat `vasprun.xml&#x27;</span>: No such <span class="keyword">file</span> or directory</span><br><span class="line">/THFS/home/iciq-lq/LVASPTHW/ex78</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex78$</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex78$ ls *</span><br><span class="line">INCAR  job_sub  KPOINTS  NEB.pdb  POTCAR  slurm-<span class="number">995085.</span><span class="keyword">out</span>  vasprun.xml</span><br><span class="line"></span><br><span class="line"><span class="number">00</span>:</span><br><span class="line">POSCAR</span><br><span class="line"></span><br><span class="line"><span class="number">01</span>:</span><br><span class="line">CHG  CHGCAR  CONTCAR-<span class="built_in">gamma</span>  DOSCAR  EIGENVAL-<span class="built_in">gamma</span>  IBZKPT-<span class="built_in">gamma</span>  OSZICAR-<span class="built_in">gamma</span>  OUTCAR-<span class="built_in">gamma</span>  PCDAT  POSCAR  POSCAR-<span class="built_in">gamma</span>  REPORT  WAVECAR  XDATCAR</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"><span class="number">08</span>:</span><br><span class="line">CHG  CHGCAR  CONTCAR-<span class="built_in">gamma</span>  DOSCAR  EIGENVAL-<span class="built_in">gamma</span>  IBZKPT-<span class="built_in">gamma</span>  OSZICAR-<span class="built_in">gamma</span>  OUTCAR-<span class="built_in">gamma</span>  PCDAT  POSCAR  POSCAR-<span class="built_in">gamma</span>  REPORT  stdout  WAVECAR  XDATCAR</span><br><span class="line"></span><br><span class="line"><span class="number">09</span>:</span><br><span class="line">POSCAR</span><br><span class="line"></span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex78$ kpoints.sh <span class="number">3</span> <span class="number">3</span> <span class="number">1</span> </span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex78$ yhbatch -p gsc -N <span class="number">2</span> -J test job_sub</span><br><span class="line">Submitted batch job <span class="number">1133307</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这里我们把01到08中的一些输出文件都保存了一下，然后将CONTCAR复制成POSCAR用来进行下一步的计算;</li>
<li>运行的时候，会报错mv: cannot stat ‘vasprun.xml’: No such file or directory<code>，不用管就行，因为images的文件夹中没有</code>vasprun.xml`文件，嫌报错烦的可以自己加个if语句修改下脚本。</li>
<li>我们将K点增加到331，继续计算。</li>
</ul>
<h3 id="查看计算结果"><a href="#查看计算结果" class="headerlink" title="查看计算结果"></a>查看计算结果</h3><p>查看结果的时候，有以下三个主要的方面：</p>
<p>1） 看能量</p>
<ul>
<li>可以使用VTST的nebresults.pl 的小脚本，也可以使用自己写的小脚本（ta.sh）。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex78$ ls</span><br><span class="line">00  01  02  03  04  05  06  07  08  09  exts.dat  INCAR  job_sub  KPOINTS  mep.eps  movie  movie.vasp  neb.dat  nebef.dat  POTCAR  slurm-1133307.out  spline.dat  vaspgr  vasprun.xml</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex78$ nebresults.pl</span><br><span class="line"></span><br><span class="line">Unziping the OUTCARs ... done</span><br><span class="line">Do nebbarrier.pl ; nebspline.pl</span><br><span class="line">Do nebef.pl</span><br><span class="line">Do nebmovie.pl</span><br><span class="line">Do nebjmovie.pl</span><br><span class="line">Do nebconverge.pl</span><br><span class="line"></span><br><span class="line">Forces and Energy:</span><br><span class="line">   0         0.023782      -321.151800         0.000000</span><br><span class="line">   1         0.007650      -321.196900        -0.045100</span><br><span class="line">   2         0.009671      -321.160900        -0.009100</span><br><span class="line">   3         0.010446      -321.128300         0.023500</span><br><span class="line">   4         0.014498      -321.106600         0.045200</span><br><span class="line">   5         0.019054      -321.096100         0.055700</span><br><span class="line">   6         0.019424      -321.094300         0.057500</span><br><span class="line">   7         0.013325      -321.111700         0.040100</span><br><span class="line">   8         0.005225      -321.156900        -0.005100</span><br><span class="line">   9         0.011589      -321.098500         0.053300</span><br><span class="line"></span><br><span class="line">Extremum 1 found at image  0.910082 with energy: -0.046551</span><br><span class="line">Extremum 2 found at image  5.724723 with energy:  0.057913</span><br><span class="line">Extremum 3 found at image  8.102362 with energy: -0.007602</span><br><span class="line">Extremum 4 found at image  8.999187 with energy:  0.053367</span><br><span class="line"></span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex78$ ta.sh</span><br><span class="line">00       -321.15187450</span><br><span class="line">01       -321.19698136</span><br><span class="line">02       -321.16098546</span><br><span class="line">03       -321.12832705</span><br><span class="line">04       -321.10664059</span><br><span class="line">05       -321.09613563</span><br><span class="line">06       -321.09434359</span><br><span class="line">07       -321.11177677</span><br><span class="line">08       -321.15691232</span><br><span class="line">09       -321.09850728</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>看到能量的时候，前面我们粗算的时候，已经知道能量随着路径的变化是怎么样的，这里我们就脑子自动画图，从01到08，看着能量慢慢上升，在05，06左右的时候达到最高点，然后继续下降。</p>
</li>
<li><p>注意：我们这是接着前面一节进行的计算， 00 和 09中的能量都是551K点下的能量，因此得到的能量随路径的变化是下面这样子的。如果看到这样的图片，不要慌张，跳过第一个和最后一个点，直接看中间的部分即可。</p>
<p><img src="/2019/02/13/ex78/ex78_03.png" alt=""></p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex78$ grep irre */OUTCAR</span><br><span class="line"><span class="number">00</span>/OUTCAR: Found      <span class="number">9</span> irreducible k-points:</span><br><span class="line"><span class="number">01</span>/OUTCAR: Found      <span class="number">5</span> irreducible k-points:</span><br><span class="line"><span class="number">02</span>/OUTCAR: Found      <span class="number">5</span> irreducible k-points:</span><br><span class="line"><span class="number">03</span>/OUTCAR: Found      <span class="number">4</span> irreducible k-points:</span><br><span class="line"><span class="number">04</span>/OUTCAR: Found      <span class="number">4</span> irreducible k-points:</span><br><span class="line"><span class="number">05</span>/OUTCAR: Found      <span class="number">4</span> irreducible k-points:</span><br><span class="line"><span class="number">06</span>/OUTCAR: Found      <span class="number">4</span> irreducible k-points:</span><br><span class="line"><span class="number">07</span>/OUTCAR: Found      <span class="number">4</span> irreducible k-points:</span><br><span class="line"><span class="number">08</span>/OUTCAR: Found      <span class="number">5</span> irreducible k-points:</span><br><span class="line"><span class="number">09</span>/OUTCAR: Found     <span class="number">13</span> irreducible k-points:</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>2） 看计算有没有正常结束。</p>
<p>主要是查看：i) NEB跑了多少步，ii) 自己设置了多少步，iii) 通过OUTCAR中结构收敛的特定关键词。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex78$ ls</span><br><span class="line">00  02  04  06  08  exts.dat  job_sub  mep.eps  movie       neb.dat    POTCAR             spline.dat  vasprun.xml</span><br><span class="line">01  03  05  07  09  INCAR     KPOINTS  mep.png  movie.vasp  nebef.dat  slurm-1133307.out  vaspgr</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex78$ tail 03/OSZICAR -n 5</span><br><span class="line">RMM:   2    -0.318010871323E+03   -0.48063E-06   -0.15546E-06   134   0.370E-03    0.397E-03</span><br><span class="line">RMM:   3    -0.318010871353E+03   -0.29988E-07   -0.12836E-08    21   0.273E-03    0.402E-03</span><br><span class="line">RMM:   4    -0.318010871104E+03    0.24867E-06    0.00000E+00    17   0.260E-03    0.157E-03</span><br><span class="line">RMM:   5    -0.318010871201E+03   -0.96799E-07   -0.11232E-08    18   0.266E-03</span><br><span class="line">  14 F= -.32114179E+03 E0= -.32112833E+03  d E =-.102536E-03</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex78$ grep NSW INCAR</span><br><span class="line">  NSW    = 200</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex78$ grep &#x27;reached re&#x27; 03/OUTCAR</span><br><span class="line"> reached required accuracy - stopping structural energy minimisation</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex78$</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当然你可以写一个小脚本如下来避免每次都重读在终端里面打出来。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash </span></span><br><span class="line"></span><br><span class="line">tail 03/OSZICAR -n 5</span><br><span class="line">grep NSW INCAR</span><br><span class="line">grep <span class="string">&#x27;reached re&#x27;</span> 03/OUTCAR</span><br></pre></td></tr></table></figure>
<p>也可以设置下alias来判断：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> check=<span class="string">&#x27;tail 03/OSZICAR -n 5 &amp;&amp; grep NSW INCAR &amp;&amp; grep &quot;reached re&quot; 03/OUTCAR &#x27;</span></span><br></pre></td></tr></table></figure>
<p>有能力的可以写一些更高级点的，加些if，for语句智能判断NEB有没有算完，有没有收敛。</p>
<p>3） 查看NEB中各个IMAGE中的结构有没有跑乱，散架，有没有物理化学意义。前面我们讲过了几种办法，本节我们简单复习一下，就不再啰嗦了。</p>
<p>i) 通过vaspkit 结合 vmd实现看动画的效果（Windows用户）</p>
<p>ii）使用ASE 和 p4vasp 批量打开所有的IMAGES中的CONTCAR，挨个查看。</p>
<h3 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h3><p>本节，我们主要是在前面计算的基础上，把gamma点的输出结果备份了一下，在此基础上，增加K点（提高精度）继续优化。最近瞎忙了很多事情，让很多人等急了，给大家拜个晚年，祝大伙猪年都学会麻溜滴算过渡态。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>NEB</tag>
        <tag>过渡态</tag>
        <tag>检查</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex 79 过渡态结构的确认</title>
    <url>/2019/03/28/ex79/</url>
    <content><![CDATA[<p>前面几节，我们从gamma点到3x3x1计算过渡态。首先复习一下计算的流程：</p>
<p>1） 我们计算的是金属表面上H原子的扩散；</p>
<p>2） 使用gamma点计算的时候，slab固定住了；</p>
<p>3）gamma点计算结束后，检查结果：</p>
<ul>
<li>看到有一个漂亮的NEB图；</li>
<li>能量变化也是稳稳妥妥滴；</li>
<li>结构查看也没啥异常情况；</li>
</ul>
<p>4） 在确认第3)步检查OK之后，将gamma点的计算备份；增大K点至3x3x1继续算。</p>
<p>5）计算结束后，重复第3）步的检查，确认没啥问题。</p>
<h4 id="继续算"><a href="#继续算" class="headerlink" title="继续算"></a>继续算</h4><p>前面这么做很啰嗦（大师兄本人也很啰嗦），目的只有一个：用最少的机时获取最好的NEB初始结构。当我们完成这一步之后，就可以再继续下面的操作：</p>
<ul>
<li><p>备份3x3x1的计算；</p>
</li>
<li><p>增大K点至5x5x1；</p>
</li>
<li>放开表面的原子；（<code>POSCARtoolkit.py</code>）</li>
<li>继续算，结果如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex79$ ls</span><br><span class="line">00  02  04  06  08  INCAR    POTCAR    job_sub  movie       neb.dat    slurm-1133307.out  spline.dat  vasprun.xml 01  03  05  07  09  KPOINTS  exts.dat  mep.eps  movie.vasp  nebef.dat  slurm-1133315.out  vaspgr</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex79$ cat KPOINTS</span><br><span class="line">K-POINTS</span><br><span class="line"> 0</span><br><span class="line">Gamma</span><br><span class="line">  5 5 1</span><br><span class="line">  0 0 0</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex79$ tail 02/OUTCAR</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex79$ tail 02/OUTCAR</span><br><span class="line">                            User time (sec):     3864.268</span><br><span class="line">                          System time (sec):       15.316</span><br><span class="line">                         Elapsed time (sec):     3905.371</span><br><span class="line"></span><br><span class="line">                   Maximum memory used (kb):      466776.</span><br><span class="line">                   Average memory used (kb):           0.</span><br><span class="line"></span><br><span class="line">                          Minor page faults:       816554</span><br><span class="line">                          Major page faults:           29</span><br><span class="line">                 Voluntary context switches:        29864</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex79$ tail 02/OSZICAR -n 1</span><br><span class="line">  10 F= -.32111627E+03 E0= -.32109808E+03  d E =-.130617E-03</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex79$ ta.sh</span><br><span class="line">00       -321.15187450</span><br><span class="line">01       -321.13494327</span><br><span class="line">02       -321.09807672</span><br><span class="line">03       -321.06314408</span><br><span class="line">04       -321.03855868</span><br><span class="line">05       -321.02460382</span><br><span class="line">06       -321.01884134</span><br><span class="line">07       -321.02967204</span><br><span class="line">08       -321.06853536</span><br><span class="line">09       -321.09850728</span><br></pre></td></tr></table></figure>
<p>从上面可以看到，顶点在06的位置，差不多就是过渡态了。</p>
<h4 id="验证过渡态"><a href="#验证过渡态" class="headerlink" title="验证过渡态"></a>验证过渡态</h4><p>那么我们算出来的过渡态到底对不对呢? </p>
<p>上面，我们通过能量分析，06这个Image就是过渡态了；但06就真的是过渡态吗？下面我们需要做2件事情：</p>
<p>1） 查看结构：</p>
<p><img src="/2019/03/28/ex79/ex79-1.png" alt=""></p>
<p>为了区分明显，上图中桥式位置两端的Ru原子，用暗红色标记出来。可以看出，06结构中，H原子在桥式的位置上；是我们想要的过渡态。结构这一关也过了。</p>
<p>2）频率分析：对于一个基元反应的过渡态来说，会有一个对应的虚频。因此，我们将06的CONTCAR单独取出来，做一个频率分析：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex79$ mkdir freq &amp;&amp; cp 06/CONTCAR freq/POSCAR &amp;&amp; <span class="built_in">cd</span> freq &amp;&amp;sed -i <span class="string">&#x27;10,27s/T/F/g&#x27;</span> POSCAR</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex79/freq$ cp ../INCAR  .</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex79/freq$ vi INCAR</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex79/freq$ kpoints.sh 1 1 1</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex79/freq$ pospot.sh</span><br><span class="line">Generating NEW POTCAR...</span><br><span class="line">************************</span><br><span class="line">Done</span><br><span class="line">************************</span><br><span class="line">NEW POTCAR containes....</span><br><span class="line">Ru H</span><br><span class="line">************************</span><br><span class="line">Elements <span class="keyword">in</span> POSCAR</span><br><span class="line">************************</span><br><span class="line">   Ru   H</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex79/freq$ qsub</span><br><span class="line">Submitted batch job 1179250</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex79/freq$ ls</span><br><span class="line">CHG     CONTCAR  DYNMAT    IBZKPT  KPOINTS  OUTCAR  POSCAR  REPORT   XDATCAR  slurm-1179250.out CHGCAR  DOSCAR   EIGENVAL  INCAR   OSZICAR  PCDAT   POTCAR  WAVECAR  job_sub  vasprun.xml</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex79/freq$ grep cm-1 OUTCAR</span><br><span class="line">   1 f  =   36.804765 THz   231.251161 2PiTHz 1227.674788 cm-1   152.212329 meV</span><br><span class="line">   2 f  =   30.534675 THz   191.855022 2PiTHz 1018.527097 cm-1   126.281311 meV</span><br><span class="line">   3 f/i=    9.822527 THz    61.716759 2PiTHz  327.644231 cm-1    40.622722 meV</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/LVASPTHW/ex79/freq$</span><br></pre></td></tr></table></figure>
<ul>
<li>创建freq文件夹，将06的CONTCAR复制到freq中；</li>
<li>将表面的Ru原子固定住；</li>
<li>复制NEB计算的INCAR过来，修改频率计算相应的参数；</li>
<li>使用gamma点算频率；</li>
<li>生成POTCAR；</li>
<li>提交任务。</li>
<li>查看结果，有一个虚频。计算完事！</li>
</ul>
<p>注意：</p>
<ul>
<li><p>不会算的看前面频率计算的内容；</p>
</li>
<li><p>自己测试下不同K点：2x2x1；3x3x1; 5x5x1计算出来的零点能有什么区别？频率大小有什么区别。</p>
</li>
</ul>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><p>拖拖拉拉，磨磨唧唧，终于把H原子在表面过渡态计算的NEB讲的差不多了。如果你一路沿着教程走过来，最终看到一个虚频对的结果时，会发自内心由衷地一笑：啊！啊！啊！过渡态原来这么简单。为避免这种情况的发生，我先给你脑勺拍一板凳，后面事还多着呢。还是那句话：做任何一个事情，从你认为它简单的那一刻起，你就输了。算过渡态，</p>
<p>1）要把初始结构，末态结构优化好；</p>
<p>2）合理采用粗糙的模型，来检查自己设想的反应路径；</p>
<ul>
<li>粗糙的模型：一方面指的是体系的大小，一方面是计算参数的设置；</li>
<li>切忌直接上来硬算，要不然把服务器累个半死，却得不到多少好的结果。</li>
</ul>
<p>3） 从能量，结构，虚频等多个角度去分析你的结构。</p>
<p>本节计算的文件已经打包上传到百度网盘，由于版权，压缩包里面的POTCAR就不放了，大家自己生成一下。下载链接：链接：<a href="https://pan.baidu.com/s/1sfOLxTB5Rdr5Il7vNCOkyA">https://pan.baidu.com/s/1sfOLxTB5Rdr5Il7vNCOkyA</a> 提取码：m591 </p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>NEB</tag>
        <tag>过渡态</tag>
        <tag>检查</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex80 nebmake.pl 的坑（一）</title>
    <url>/2019/03/29/ex80/</url>
    <content><![CDATA[<p>算过渡态，光知道检查虚频是不对的。如果算出来虚频多，很大程度是因为你的NEB初始结构有问题，也就是说你的过渡态路径背后的物理化学意义不是那么地理想。而对于NEB的初始结构，大部分人都是通过VTST的nebmake.pl脚本来实现的。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">nebmake.pl IS FS <span class="number">8</span> </span><br></pre></td></tr></table></figure>
<p>分析上面这个命令：有4个关键的信息:</p>
<ul>
<li>脚本：nebmake.pl</li>
<li>初始结构: IS</li>
<li>末态结构: FS</li>
<li>插的点数：8</li>
</ul>
<p>本节默认你优化好了IS，FS，并且插8个点，分析一下脚本nebmake.pl的2个坑。其实，在<strong>Density Functional Theory: A Practical Introduction</strong> 这本书的第6章，其中的一个坑已经讲过了。强烈建议新手，老手认真看看这一章。</p>
<p>想知道这两个坑，首先我们先分析下nebmake.pl的工作原理。简举个化的一维例子：一个线段两端的坐标是x1和x2，我们把这个线段分成n份，并获得每一段的起始点的坐标。想必大家都知道怎么弄。</p>
<p>x_i = x0 + i *(x2-x1)/(n+1)</p>
<p>如果扩展到三维的xyz坐标，分别对y、z进行同样的处理。我们就得到了初始结构和末态结构之间这些的IMAGES的坐标。具体见：第六章的148页。</p>
<p><img src="/2019/03/29/ex80/ex80-1.JPG" alt=""></p>
<p>知道了原理，现在就可以分析其中的两个坑了。</p>
<h4 id="坑1"><a href="#坑1" class="headerlink" title="坑1"></a>坑1</h4><p>前面讲的原子在表面扩散的例子，如果原子从fcc扩散到hcp。fcc和hcp的结构中，原子在z方向的坐标基本是相同的。如果运行nebmake.pl 这个命令，就会出现这样的一种情况，所有的IMAGE结构中，z的坐标几乎不变，也就是原子在表面横着走。而实际情况呢？原子在扩散的过程中，z方向的坐标也发生相应的变化。就如同你从山的一边爬到另一边，虽然海拔基本没变，但爬山这个过程，有升，下山过程，有降。所以，这种情况下，直接用nebmake.pl插的点在z方向上的物理意义并不准确。稍微扩展下，在x或者y方向上也可能会发生类似的情况，如果IS和FS在某一维度的变化很小时，一定要注意这一维度上的物理意义是否可以被表现出来。</p>
<p><img src="/2019/03/29/ex80/ex80-2.JPG" alt=""></p>
<p>既然知道了这个坑，我们该怎么填呢？</p>
<h5 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h5><p>管它是不是坑，或者不知道这个坑，直接开车冲过去。这是很多新手常见的做法，虽然有时候可以开过去，但不推荐，毕竟也会溅一车泥，搞不好坑大了还会掉进去。</p>
<h5 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h5><p>学习书中的例子，在计算之前先手动修改下结构。比如插了8个点，把第2和第7个IMAGES中的坐标向上移动0.1$\AA$。第3和6个向上移动0.15$\AA$，第4和5移动0.2$\AA$。这样做的好处就是，初始结构在z方向上具有更好的物理意义，使得计算收敛更快。</p>
<h4 id=""><a href="#" class="headerlink" title=""></a><img src="/2019/03/29/ex80/ex80-3.JPG" alt=""></h4><p>上图是书中的一个例子，最上面的曲线是没有调节z坐标时，初始结构所对应的能量；中间的为调节初始结构的z坐标后，初始结构的能量；最下面的是NEB计算完成之后，各个IMAGE的能量。从能量上也可以看出来，如果z坐标我们不修改的话，体系能量与稳定的相差甚远，间接告诉我们可能需要更多的优化步数来收敛。这个强烈建议大家自己亲手算一算。体系简单，不耗费那么多机时，有助于加深对NEB的认识和学习。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>NEB</tag>
        <tag>过渡态</tag>
        <tag>检查</tag>
        <tag>nebmake.pl</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex81 使用ASE批量切金属稳定的表面</title>
    <url>/2019/05/14/ex81/</url>
    <content><![CDATA[<p>最近整理材料，发现遗落在角落里的一个python脚本（<code>cssm.py</code>），可以批量切常见金属稳定表面的slab模型。 <code>cssm.py</code> 是：<code>cleave_stable_surfaces_from_metals</code>的缩写。废话不多说，下面是在天河II上运行的实例，大家照着敲一遍应该问题不大。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/cssm$ ls</span><br><span class="line">cssm.py</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/cssm$ python cssm.py</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;cssm.py&quot;</span>, line 3, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from ase import Atoms</span><br><span class="line">ImportError: No module named ase</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/cssm$ python3 cssm.py</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/cssm$ ls</span><br><span class="line">POSCAR_Ag_1           POSCAR_Co_3_bottomed  POSCAR_Fe_3           POSCAR_Ni_2_bottomed  POSCAR_Pt_2           POSCAR_Ru_1_bottomed</span><br><span class="line">POSCAR_Ag_1_bottomed  POSCAR_Cu_1           POSCAR_Fe_3_bottomed  POSCAR_Ni_3           POSCAR_Pt_2_bottomed  POSCAR_Ru_2</span><br><span class="line">POSCAR_Ag_2           POSCAR_Cu_1_bottomed  POSCAR_Ir_1           POSCAR_Ni_3_bottomed  POSCAR_Pt_3           POSCAR_Ru_2_bottomed</span><br><span class="line">POSCAR_Ag_2_bottomed  POSCAR_Cu_2           POSCAR_Ir_1_bottomed  POSCAR_Pd_1           POSCAR_Pt_3_bottomed  POSCAR_Ru_3</span><br><span class="line">POSCAR_Ag_3           POSCAR_Cu_2_bottomed  POSCAR_Ir_2           POSCAR_Pd_1_bottomed  POSCAR_Rh_1           POSCAR_Ru_3_bottomed</span><br><span class="line">POSCAR_Ag_3_bottomed  POSCAR_Cu_3           POSCAR_Ir_2_bottomed  POSCAR_Pd_2           POSCAR_Rh_1_bottomed  cssm.py</span><br><span class="line">POSCAR_Co_1           POSCAR_Cu_3_bottomed  POSCAR_Ir_3           POSCAR_Pd_2_bottomed  POSCAR_Rh_2</span><br><span class="line">POSCAR_Co_1_bottomed  POSCAR_Fe_1           POSCAR_Ir_3_bottomed  POSCAR_Pd_3           POSCAR_Rh_2_bottomed</span><br><span class="line">POSCAR_Co_2           POSCAR_Fe_1_bottomed  POSCAR_Ni_1           POSCAR_Pd_3_bottomed  POSCAR_Rh_3</span><br><span class="line">POSCAR_Co_2_bottomed  POSCAR_Fe_2           POSCAR_Ni_1_bottomed  POSCAR_Pt_1           POSCAR_Rh_3_bottomed</span><br><span class="line">POSCAR_Co_3           POSCAR_Fe_2_bottomed  POSCAR_Ni_2           POSCAR_Pt_1_bottomed  POSCAR_Ru_1</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/cssm$</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/cssm$ rm *&#123;1..3&#125;</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/cssm$ ls</span><br><span class="line">POSCAR_Ag_1_bottomed  POSCAR_Co_3_bottomed  POSCAR_Fe_2_bottomed  POSCAR_Ni_1_bottomed  POSCAR_Pd_3_bottomed  POSCAR_Rh_2_bottomed  cssm.py</span><br><span class="line">POSCAR_Ag_2_bottomed  POSCAR_Cu_1_bottomed  POSCAR_Fe_3_bottomed  POSCAR_Ni_2_bottomed  POSCAR_Pt_1_bottomed  POSCAR_Rh_3_bottomed</span><br><span class="line">POSCAR_Ag_3_bottomed  POSCAR_Cu_2_bottomed  POSCAR_Ir_1_bottomed  POSCAR_Ni_3_bottomed  POSCAR_Pt_2_bottomed  POSCAR_Ru_1_bottomed</span><br><span class="line">POSCAR_Co_1_bottomed  POSCAR_Cu_3_bottomed  POSCAR_Ir_2_bottomed  POSCAR_Pd_1_bottomed  POSCAR_Pt_3_bottomed  POSCAR_Ru_2_bottomed</span><br><span class="line">POSCAR_Co_2_bottomed  POSCAR_Fe_1_bottomed  POSCAR_Ir_3_bottomed  POSCAR_Pd_2_bottomed  POSCAR_Rh_1_bottomed  POSCAR_Ru_3_bottomed</span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/cssm$  <span class="keyword">for</span> i <span class="keyword">in</span> *med*; <span class="keyword">do</span> mkdir $(<span class="built_in">echo</span> <span class="variable">$i</span> |awk -F <span class="string">&quot;_&quot;</span> <span class="string">&#x27;&#123;print $2&quot;_&quot;$3&#125;&#x27;</span>); mv <span class="variable">$i</span>  $(<span class="built_in">echo</span> <span class="variable">$i</span> |awk -F <span class="string">&quot;_&quot;</span> <span class="string">&#x27;&#123;print $2&quot;_&quot;$3&#125;&#x27;</span>)/POSCAR;  <span class="keyword">done</span></span><br><span class="line">iciq-lq@ln3:/THFS/home/iciq-lq/cssm$ ls */*</span><br><span class="line">Ag_1/POSCAR  Co_1/POSCAR  Cu_1/POSCAR  Fe_1/POSCAR  Ir_1/POSCAR  Ni_1/POSCAR  Pd_1/POSCAR  Pt_1/POSCAR  Rh_1/POSCAR  Ru_1/POSCAR</span><br><span class="line">Ag_2/POSCAR  Co_2/POSCAR  Cu_2/POSCAR  Fe_2/POSCAR  Ir_2/POSCAR  Ni_2/POSCAR  Pd_2/POSCAR  Pt_2/POSCAR  Rh_2/POSCAR  Ru_2/POSCAR</span><br><span class="line">Ag_3/POSCAR  Co_3/POSCAR  Cu_3/POSCAR  Fe_3/POSCAR  Ir_3/POSCAR  Ni_3/POSCAR  Pd_3/POSCAR  Pt_3/POSCAR  Rh_3/POSCAR  Ru_3/POSCAR</span><br></pre></td></tr></table></figure>
<p>注：直接用<code>python cssm.py</code> 会出错，因为默认的是<code>python2</code>版本，而ASE基于<code>python3</code>，换成<code>python3 cssm.py</code>就OK了。</p>
<p>脚本内容: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> ase <span class="keyword">import</span> Atoms</span><br><span class="line"><span class="keyword">import</span> ase.io </span><br><span class="line"><span class="keyword">from</span> ase.build <span class="keyword">import</span> molecule</span><br><span class="line"><span class="keyword">from</span> ase.build <span class="keyword">import</span> bulk </span><br><span class="line"><span class="keyword">from</span> ase.build <span class="keyword">import</span> surface</span><br><span class="line"><span class="keyword">from</span> ase.build <span class="keyword">import</span> add_vacuum </span><br><span class="line"><span class="keyword">from</span> ase.build <span class="keyword">import</span> fcc111, bcc110, hcp0001</span><br><span class="line"><span class="keyword">from</span> ase.constraints <span class="keyword">import</span> FixAtoms</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## Crystal structure of elements: from https://en.wikipedia.org/wiki/Periodic_table_(crystal_structure)</span></span><br><span class="line">bcc = [<span class="string">&#x27;V&#x27;</span>,  <span class="string">&#x27;Cr&#x27;</span>, <span class="string">&#x27;Mn&#x27;</span>, <span class="string">&#x27;Fe&#x27;</span>, <span class="string">&#x27;Nb&#x27;</span>, <span class="string">&#x27;Pb&#x27;</span>]</span><br><span class="line">hcp = [<span class="string">&#x27;Mg&#x27;</span>, <span class="string">&#x27;Sc&#x27;</span>, <span class="string">&#x27;Ti&#x27;</span>, <span class="string">&#x27;Co&#x27;</span>, <span class="string">&#x27;Zn&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;Zr&#x27;</span>, <span class="string">&#x27;Tc&#x27;</span>, <span class="string">&#x27;Ru&#x27;</span>, <span class="string">&#x27;Cd&#x27;</span>, <span class="string">&#x27;Hf&#x27;</span>, <span class="string">&#x27;Re&#x27;</span>, <span class="string">&#x27;Os&#x27;</span>]</span><br><span class="line">fcc = [<span class="string">&#x27;Al&#x27;</span>, <span class="string">&#x27;Ca&#x27;</span>, <span class="string">&#x27;Ni&#x27;</span>, <span class="string">&#x27;Cu&#x27;</span>, <span class="string">&#x27;Rh&#x27;</span>, <span class="string">&#x27;Pd&#x27;</span>, <span class="string">&#x27;Ag&#x27;</span>, <span class="string">&#x27;Ir&#x27;</span>, <span class="string">&#x27;Pt&#x27;</span>, <span class="string">&#x27;Au&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">### Metal  Bulk structures from DFT calculations without vdw </span></span><br><span class="line"><span class="comment">## &#123;element:[E_bulk, Natom_in_the_bulk, lattice_a, lattice_c]</span></span><br><span class="line"><span class="comment">## &#x27;Bulks are conventional cells, not primitive cells&#x27;</span></span><br><span class="line"></span><br><span class="line">dict_metals = &#123; </span><br><span class="line"><span class="string">&#x27;Ag&#x27;</span>:(-<span class="number">10.88004463</span>,<span class="number">4</span>,<span class="number">4.1423472817</span>),</span><br><span class="line"><span class="string">&#x27;Co&#x27;</span>:(-<span class="number">14.06155869</span>,<span class="number">2</span>,<span class="number">2.4908062578</span>,<span class="number">4.0275560997</span>),</span><br><span class="line"><span class="string">&#x27;Cu&#x27;</span>:(-<span class="number">14.91182926</span>,<span class="number">4</span>,<span class="number">3.6339719976</span>),</span><br><span class="line"><span class="string">&#x27;Fe&#x27;</span>:(-<span class="number">16.47105782</span>,<span class="number">2</span>,<span class="number">2.8346922247</span>),</span><br><span class="line"><span class="string">&#x27;Ir&#x27;</span>:(-<span class="number">35.00402169</span>,<span class="number">4</span>,<span class="number">3.8852086642</span>),</span><br><span class="line"><span class="string">&#x27;Ni&#x27;</span>:(-<span class="number">21.86901226</span>,<span class="number">4</span>,<span class="number">3.5177809803</span>),</span><br><span class="line"><span class="string">&#x27;Pd&#x27;</span>:(-<span class="number">20.864555</span>,<span class="number">4</span>,<span class="number">3.9374172967</span>),</span><br><span class="line"><span class="string">&#x27;Pt&#x27;</span>:(-<span class="number">24.39436715</span>,<span class="number">4</span>,<span class="number">3.9669414218</span>),</span><br><span class="line"><span class="string">&#x27;Rh&#x27;</span>:(-<span class="number">29.10896058</span>,<span class="number">4</span>,<span class="number">3.8241655305</span>),</span><br><span class="line"><span class="string">&#x27;Ru&#x27;</span>:(-<span class="number">18.49439863</span>,<span class="number">2</span>,<span class="number">2.7126893229</span>,<span class="number">4.2897522328</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bottom</span>(<span class="params">file_in</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;This function is used to pull the cetered atoms (from ASE) back to the bottom. &#x27;&#x27;&#x27;</span></span><br><span class="line">    f = <span class="built_in">open</span>(file_in, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    lines = f.readlines()</span><br><span class="line">    f.close()</span><br><span class="line">    coord = [<span class="built_in">float</span>(line.rstrip().split()[<span class="number">2</span>]) <span class="keyword">for</span> line <span class="keyword">in</span> lines[<span class="number">9</span>:]]</span><br><span class="line">    bottom = <span class="built_in">min</span>(coord)</span><br><span class="line">    out_put = <span class="built_in">open</span>(file_in + <span class="string">&#x27;_bottomed&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">    out_put.writelines(i <span class="keyword">for</span> i <span class="keyword">in</span> lines[<span class="number">0</span>:<span class="number">9</span>])</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines[<span class="number">9</span>:]:</span><br><span class="line">        infor = line.rstrip().split()</span><br><span class="line">        infor[<span class="number">2</span>] = <span class="built_in">str</span>(<span class="built_in">float</span>(infor[<span class="number">2</span>]) - bottom)</span><br><span class="line">        out_put.write(<span class="string">&#x27;   &#x27;</span>.join(infor) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    out_put.close()   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cssm</span>(<span class="params">metal, data_dict</span>):</span>  <span class="comment"># cleave_stable_surfaces_from_metals </span></span><br><span class="line">    name = <span class="string">&#x27;POSCAR_&#x27;</span> + metal</span><br><span class="line">    <span class="keyword">if</span> metal <span class="keyword">in</span> bcc:   <span class="comment"># For bcc metals, cleave 110 surface </span></span><br><span class="line">        lattice_a = <span class="built_in">float</span>(data_dict.get(metal)[<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">4</span>):</span><br><span class="line">            name_out = name + <span class="string">&#x27;_&#x27;</span> + <span class="built_in">str</span>(i)</span><br><span class="line">            slab = bcc110(metal, a = lattice_a, size = (i, i, <span class="number">4</span>), vacuum = <span class="number">7.5</span>)</span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;(i,i,4) means repeat i i 4 in x y and z directions. vacuum will be 7.5 * 2 because it was added on the two sides.&#x27;&#x27;&#x27;</span> </span><br><span class="line">            constraint_l = FixAtoms(indices=[atom.index <span class="keyword">for</span> atom <span class="keyword">in</span> slab <span class="keyword">if</span> atom.index &lt; i*i*<span class="number">2</span>])</span><br><span class="line">            slab.set_constraint(constraint_l)</span><br><span class="line">            ase.io.write(name_out, slab, <span class="built_in">format</span>=<span class="string">&#x27;vasp&#x27;</span>)    </span><br><span class="line">            <span class="comment">### Add the element line to the POSCAR file ###</span></span><br><span class="line">            subprocess.call([<span class="string">&#x27;sed -i &#x27;</span> + <span class="string">&#x27;\&#x27;5a&#x27;</span> + metal + <span class="string">&#x27;\&#x27;  &#x27;</span> + name_out], shell = <span class="literal">True</span>  )</span><br><span class="line">            bottom(name_out)            </span><br><span class="line">    <span class="keyword">elif</span> metal <span class="keyword">in</span> hcp:   <span class="comment"># For hcp metals, cleave 0001 surface </span></span><br><span class="line">        lattice_a, lattice_c = [<span class="built_in">float</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> data_dict.get(metal)[<span class="number">2</span>:]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">4</span>):</span><br><span class="line">            name_out = name + <span class="string">&#x27;_&#x27;</span> + <span class="built_in">str</span>(i)</span><br><span class="line">            slab = hcp0001(metal, a = lattice_a, c = lattice_c, size = (i, i, <span class="number">4</span>), vacuum = <span class="number">7.5</span>)</span><br><span class="line">            constraint_l = FixAtoms(indices=[atom.index <span class="keyword">for</span> atom <span class="keyword">in</span> slab <span class="keyword">if</span> atom.index &lt; i*i*<span class="number">2</span>])</span><br><span class="line">            slab.set_constraint(constraint_l)</span><br><span class="line">            ase.io.write(name_out, slab, <span class="built_in">format</span>=<span class="string">&#x27;vasp&#x27;</span>)</span><br><span class="line">            subprocess.call([<span class="string">&#x27;sed -i &#x27;</span> + <span class="string">&#x27;\&#x27;5a&#x27;</span> + metal + <span class="string">&#x27;\&#x27;  &#x27;</span> + name_out], shell = <span class="literal">True</span>  )</span><br><span class="line">            bottom(name_out)            </span><br><span class="line">            </span><br><span class="line">    <span class="keyword">elif</span> metal <span class="keyword">in</span> fcc:   <span class="comment"># For fcc metals, cleave 111 surface</span></span><br><span class="line">        lattice_a = <span class="built_in">float</span>(data_dict.get(metal)[<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">4</span>):</span><br><span class="line">            name_out = name + <span class="string">&#x27;_&#x27;</span> + <span class="built_in">str</span>(i)</span><br><span class="line">            slab = fcc111(metal, a = lattice_a, size = (i, i, <span class="number">4</span>), vacuum = <span class="number">7.5</span>)</span><br><span class="line"><span class="comment">#            slab.center(vacuum=7.5, axis = 2)</span></span><br><span class="line">            constraint_l = FixAtoms(indices=[atom.index <span class="keyword">for</span> atom <span class="keyword">in</span> slab <span class="keyword">if</span> atom.index &lt; i*i*<span class="number">2</span>])</span><br><span class="line">            slab.set_constraint(constraint_l)</span><br><span class="line">            ase.io.write(name_out, slab, <span class="built_in">format</span>=<span class="string">&#x27;vasp&#x27;</span>)</span><br><span class="line">            subprocess.call([<span class="string">&#x27;sed -i &#x27;</span> + <span class="string">&#x27;\&#x27;5a&#x27;</span> + metal + <span class="string">&#x27;\&#x27;  &#x27;</span> + name_out], shell = <span class="literal">True</span>  )</span><br><span class="line">            bottom(name_out)            </span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Please add your element in the crystal structure lists: bcc, hcp, and fcc&#x27;</span>)  </span><br><span class="line">        </span><br><span class="line"><span class="keyword">for</span> metal <span class="keyword">in</span> dict_metals.keys():</span><br><span class="line">    cssm(metal, dict_metals)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>简单介绍:</p>
<p>首先声明：最近很忙，没时间写脚本的详解， 如果已经安装ASE的或者有天河II号账号的，可以直接试试，如果不行，自己慢慢琢磨；如果不愿意琢磨，那么就按照前面练习中的笨方法用Material Studio切面。下面以<code>Ag</code>为例：</p>
<p><code>dict_metals</code> 这个字典里面是本人计算的一些常见金属的bulk晶格常数，能量，bulk中原子数目等信息；仅供大家消遣，测试。如果你要通过这个脚本切用于发表文章的slab，运行前，先自己优化一遍bulk，然后修改成自己的结果再运行。</p>
<p>1）<code>POSCAR_Ag_1</code>， <code>POSCAR_Ag_2</code>，<code>POSCAR_Ag_3</code> 分别是<code>1x1</code>,<code>2x2</code>, <code>3x3</code>的slab模型。</p>
<p>2）ASE默认把结构放在slab的中心，加真空层的时候也是在两侧加，因此脚本里面是7.5$\AA$，对应15$\AA$；</p>
<p>3） </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">slab = fcc111(metal, a = lattice_a, size = (i, i, <span class="number">4</span>), vacuum = <span class="number">7.5</span>)</span><br></pre></td></tr></table></figure>
<p> 是切面的关键行；也是脚本的核心部分；</p>
<p>4）每个<code>slab</code>有4层，如果想切厚点，修改 <code>size = (i, i, 4)</code>中的4换成为你想要的层数。如果想切（5x5)，4层的<code>slab</code>，将前面一行的<code>for i in range(1,4)</code>改成<code>for i in range(1,6)</code>；</p>
<p>5) 通过</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">constraint_l = FixAtoms(indices=[atom.index <span class="keyword">for</span> atom <span class="keyword">in</span> slab <span class="keyword">if</span> atom.index &lt; i*i*<span class="number">2</span>])</span><br><span class="line">slab.set_constraint(constraint_l)</span><br></pre></td></tr></table></figure>
<p> 把<code>slab</code>的<code>top 2</code> 层放开；</p>
<p>6）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ase.io.write(name_out, slab, format=&#x27;vasp&#x27;) </span><br></pre></td></tr></table></figure>
<p>是通过ASE将结构输出到<code>vasp</code>的格式。</p>
<p>7）ASE的输出一般没有元素行，脚本里面自动加上了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">subprocess.call([&#x27;sed -i &#x27; + &#x27;\&#x27;5a&#x27; + metal + &#x27;\&#x27;  &#x27; + name_out], shell = True)</span><br></pre></td></tr></table></figure>
<p>8）<code>bottom(name_out)</code> 功能是把模型从中心拽到底部，输出的结果是<code>POSCAR_Ag_1_bottomed``，POSCAR_Ag_2_bottomed</code>，<code>POSCAR_Ag_3_bottomed</code>。（个人不喜欢ASE把结构放在中间）</p>
<p>9) 脚本感觉有些啰嗦，欢迎有兴趣的人改进，让它变得更加简洁易懂。</p>
<p>10）最后的bash命令，将所有的<code>bottomed</code>归类到各自对应的文件夹中,喜欢把模型放在中间的，可以不用运行<code>bottom</code>那个命令。</p>
<p>11）期待我们中国的大牛们写出比ASE更好的软件包出来，安利一波：有问题首先尝试<code>VASPKIT</code>。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>ASE</tag>
        <tag>slab</tag>
        <tag>切面</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex82 nebmake.pl 的坑（二）</title>
    <url>/2019/07/20/ex82/</url>
    <content><![CDATA[<p>前面一节，我们讲解了对于扩散这一类反应中，nebmake.pl这个命令生成IMAGES时候的一个坑。通过学习，要了解到一些脚本或者程序本身存在一些缺陷，我们在使用的时候，要避免盲目相信，直接把脚本的结构直接拿来用。总之，原则就是尽可能获取一些具有明确物理化学意义的，比较理想的初始构型。本节，讲解一下旋转过程中，nebmake.pl的坑。这里与其说是坑，不如说是nebmake.pl不适用的情况。因为涉及到旋转过程的时候，一般得到的IMAGES的结构都不咋地，需要自己认真检查，微调下结构或者重新搭结构。</p>
<p>这里我们讲一个极端的例子：乙烷分子的旋转</p>
<p>从一个交叉式的构象到另一个交叉式的构象，两个甲基绕C—C键旋转120°。如果每隔15°插一个点， 正常的结果应该如下图所示:</p>
<p><img src="/2019/07/20/ex82/ex82-1.png" alt=""></p>
<p>但是，当使用nebmake.pl这个方法产生的IMAGES结构如下图：</p>
<p><img src="/2019/07/20/ex82/ex82-2.png" alt=""></p>
<p>可以看到，</p>
<p>1）初始结构中，并没有旋转的效果，H原子走的是直线的路径。</p>
<p>2）IMAGE中，H和C原子的距离非常小，仅仅贴在一起了，显然这样的结构非常不理想。</p>
<p>如果使用这样的结构进行计算，第一个离子步结束后，计算出来原子间的作用力很强，会导致后面计算中分子直接散架，而这些散架的结构通常都不收敛，如果不及时检查结构，及时杀死，它会在服务器上一直就这样算着，而你还在傻傻地啃着西瓜，聊着QQ，等待结果。</p>
<p>解决办法：</p>
<p>知道有这个坑之后，怎么躲就好办多了。</p>
<p>1）对于类似的旋转结构，自己手动搭建；</p>
<p>2）使用其他的高级点的生成IMAGES的方法，例如IDPP。（<a href="https://wiki.fysik.dtu.dk/ase/tutorials/neb/idpp.html）">https://wiki.fysik.dtu.dk/ase/tutorials/neb/idpp.html）</a></p>
<p>3）自己写脚本实现旋转的过程。</p>
<p>小节：</p>
<p>这两节简单介绍了一下生成NEB计算IMAGES需要注意的地方，不管咋地，原则还是要再啰嗦一遍：尽可能得到具有理想物理化学意义的初始结构。毕竟好的开始是成功的一半。有兴趣的可以算一下这两节例子，加深一下自己的印象。有大佬公众号留言说贴自己的代码教程怒怼IDPP，希望看到的可以联系俺（lqcata@gmail.com）。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>NEB</tag>
        <tag>过渡态</tag>
        <tag>检查</tag>
        <tag>nebmake.pl</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex83 搬砖</title>
    <url>/2019/08/21/ex83/</url>
    <content><![CDATA[<p>前面我们介绍完了算表面吸附，以及过渡态的一些基本的操作，和注意事项。当我们面对一个新的课题时，就需要运用所学到的这些技能来完成所必需的计算，来验证我们的想法，思路等。后面几节，主要参考本人2014年发表的一篇关于甲醇分解反应计算的文章来介绍一下怎么运用所学习到的这些本领。（<a href="https://pubs.acs.org/doi/abs/10.1021/cs501698w）">https://pubs.acs.org/doi/abs/10.1021/cs501698w）</a></p>
<p>搬砖这个词用来形容我们完成一个课题的计算过程，简直不能再形象不过了。</p>
<p>首先，搬砖这一过程， 我们要明确几个要素：</p>
<p>1）老板：让你搬砖的人</p>
<p>2）搬砖工人：你自己</p>
<p>3）任务：搬砖</p>
<p>4）目的：盖房子</p>
<p>下面，你要明确一点：不会计算的搬砖工不是好搬砖工。</p>
<p>这里说的计算，不是我们的计算化学中的计算。而是把我们的工作如何一步一步分解，结合自己的实际情况，算算需要多少的时间完活。毕竟房子总有盖完的时候，搬砖工不能一直守着。所以，当老板告诉你要盖一个大房子的时候，需要多少砖这一点你要清楚。然而，很多人都是第一次搬砖，或者之前没搬过表面计算的砖，对上面说的这一点并没有一个很清晰的概念。所以，摸清自己的现实情况，这也就是本节的重点啦。</p>
<p>人有高低胖瘦之分，搬砖工也不例外，有的劲大，有的劲小。劲大搬的砖多，劲小搬的少。最后到底能搬多少砖，一方面取决于你的身体条件（自身因素，搬砖前的学习经历），另一方面取决于你的工资伙食情况（老板因素）。身体倍儿棒，老板钱儿多，这样的情况通常不会看本教程，有啥问题自己（组里）就能解决。身体倍儿棒，老板没钱，或者身体倍儿不棒，老板有钱的。就需要认真动动脑子，分析下当前的形势。没劲儿又没钱的，就应该更加注意了，需要更多地在脑力上下功夫。</p>
<p><img src="/2019/08/21/ex83/ex83-1.png" alt=""></p>
<p>比如，这篇文章中，老板让我们算一遍甲醇在四个金属上的分解反应（倒过来就是合成反应）。</p>
<h5 id="第一步：分析下需要搬多少砖块"><a href="#第一步：分析下需要搬多少砖块" class="headerlink" title="第一步：分析下需要搬多少砖块"></a>第一步：分析下需要搬多少砖块</h5><p>别看甲醇分子简单，要彻底分解成基本的C、O、H，中间有很多的基元反应要计算。从上面的图可以发现：有三类的断裂反应：C-H，O-H，C-O键的断裂，第一步这三种都可能发生的。这一步的产物在第二步中又可以发生哪一类的反应，依次类推。 最终我们可以估算一下需要计算的基元反应，以及中间体的结构。 所以，计算之前，多分析下这些可能的过程，基本的框架，多少反应，多少物种要有个概念。可以自己尝试着画，亦可以参考文献中寻找答案。</p>
<p>2）我们取的四个金属：Cu，Ru，Pt，Pd稳定的表面。所以前面的计算要乘以4。</p>
<p>3）前面说的是最理想的情况，而实际情况则是：</p>
<p>A) 对每一个表面吸附的物种来说，我们要尝试不同的位点，来获取一个稳定的构型；</p>
<p>B）对基元反应来说，这些过渡态，100%不可能都100%一次性找到，还要考虑不收敛，不同的可能性等；</p>
<p>这些都会使得计算量增加。所以，第一步，大体上有多少需要计算的东西，应该有个框架。</p>
<h5 id="第二步：确定一个合理的搬砖方案。"><a href="#第二步：确定一个合理的搬砖方案。" class="headerlink" title="第二步：确定一个合理的搬砖方案。"></a>第二步：确定一个合理的搬砖方案。</h5><p>计算资源是老板提供的，也就是你的伙食。伙食好，干活就有劲。但不管有没有劲，都不愿意大热天地一个劲地搬砖。所以这一步，我们要充分结合自己现有的计算资源，来制定一个合理的策略，用最少地劲搬最多的转。该怎么做呢？</p>
<p>A) 善于利用已经发表的文章的数据，比如，有些结构可以在支持信息里面找到，还有一些数据库里可以下载，也可以问作者要（可能性比较低）， 可以理解为找朋友一起帮忙搬砖；</p>
<p>B) 选择合适的slab模型：3x3还是4x4，slab取四层，还是取5层？这些是课题开始之前一些基本的测试工作，可以参考文献中别人的做法，也可以根据测试的结果自己合理选择。可以理解为：搬多大的砖块。</p>
<p>C) 选择合适的参数: 计算参数不对，很可能导致计算的结构或者能量有问题。 但这些都要具体分析，有些能量有问题，但结构还算OK的可以调整下参数，作为一个理想的初始结构继续用。可以理解为：半路翻车，捡起来那些没摔碎的转，继续搬。</p>
<p>D）善于使用前面我们介绍的快速获取理想初始结构的方法。可以理解为先用车把砖块搬到离工地最近的地方，省去往返来回跑的劲。</p>
<p>上面说的这些，尽可能在课题完全开展前做到位，因为它们不会花费很大的劲去做，但会节省后面很大的劲。而且，伙食好坏（计算资源给不给力），测试的过程一目了然。</p>
<h5 id="第三步：结合自己的体力，伙食，认真搬砖。"><a href="#第三步：结合自己的体力，伙食，认真搬砖。" class="headerlink" title="第三步：结合自己的体力，伙食，认真搬砖。"></a>第三步：结合自己的体力，伙食，认真搬砖。</h5><p>这一步就简单啦，体力好同时进行，左手生擒中间体，右手活拿过渡态。体力不好，俩手搬一块砖，累了饿了（没资源）就一边凉快去。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>不过对于新手来说，课题刚刚开始就真正掌握上面的这几点，难度有些大，所以建议先做些前提的准备工作：</p>
<p>1） 熟悉自己的服务器，运算能力；</p>
<p>2）多查找文献，整理需要计算的框架，幸运的话，可以从支持信息直接找到结构；</p>
<p>3）多用小体系做测试，测试完了要对结果多思考总结。不要上来就狂交任务，最后把服务器累个半死，还不出什么好的结果。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>搬砖</tag>
        <tag>课题</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex84 计算模型的注意事项</title>
    <url>/2019/12/22/ex84/</url>
    <content><![CDATA[<p>上一节我们简单介绍了一下搬砖的原则性问题。这一节，我们主要分析下搬什么砖的问题。继续采用甲醇在金属表面上分解的这个例子。物化书中我们学过表面反应的基本步骤： 1）反应物分子的吸附；2）表面反应； 3） 产物脱附。</p>
<p>甲醇分解反应第一步是先从气相吸附到催化剂金属表面。 对于这一步， 我们自然需要从甲醇的气相分子出发，研究甲醇分子在表面上的吸附结构。其中涉及到一些基本的计算细节：</p>
<p>1） 如何优化气相分子的结构，计算频率呢？</p>
<p>2）如何优化体相结构，切面，优化，计算表面相关性质：比如表面能、功函数等。</p>
<p>这些我们前面也已经讲过了，所以直接跳过。</p>
<p>这里还有一个问题在于，你去用什么表面去模拟催化剂？ 比如说Cu，可以有(111), (110), (100), (211)….等各种不同的指数面，你选哪个来算？为什么选这个来算？这涉及到：我们的研究对象是什么？通过研究这一对象，我们要解释什么？期望获得什么样的结果？对于催化反应来说，我们的研究对象有2个：催化剂和它所催化的反应。</p>
<p>如何获得催化剂的合理模型就是一个至关重要的问题了。一般来说，有下面几个供大家参考的办法：</p>
<p>1）选稳定的表面，也就是表面能低的那个，对于纳米颗粒来说，尺寸如果够大，那么表面能低的表面原子在所有暴露的表面原子中的比例会高，那么可以近似用这个面来模拟催化剂的情况；那么尺寸多大才算足够大呢？</p>
<p>我们可以尝试着从两个极端来进行思考：我们的催化剂如果是金属的话，如果采用一个单金属原子作为催化剂模型，可以想象吸附能肯定很大。当原子慢慢堆积成团簇，团簇再慢慢长到无穷大的时候，吸附能也随之发生变化。我们取无穷大时（最稳定的表面）的吸附能（E0）作为参考，看看金属团簇多大尺寸的时候，吸附能跟E0接近。那么该尺寸以及更大的纳米颗粒就可以用无穷大的催化剂模型来模拟，也就是最稳定的表面。一般来说，纳米颗粒的直径大于2nm（胆儿肥的）的时候，可以用最稳定的表面来模拟催化剂。保守些，直径大约3nm的时候可以放心地去用，不会有什么问题。</p>
<p>下面推荐一本书： Fundamental Concepts in Heterogeneous Catalysis 。书中第21页， 作者用O在Pt(111)表面的吸附能作为参考，测试了不同纳米颗粒尺寸时的吸附能，发现直径在2nm的时候，已经非常接近了。前面说的那个2nm，也是从这里来的。如果你想问我这本书从哪里可以下载，可以关注公众号：BigBroScience，然后回复：ex84 。</p>
<p><img src="/2019/12/22/ex84/ex84-1.png" alt=""></p>
<p>2）对于前面的一番说法， 也会有人说，催化剂的活性位不一定在平坦的表面上，边边角角，台阶上可能更容易发生反应。如果你单纯把工作聚集在最稳定的表面上，肯定会遗漏些什么？这也是很多审稿人喜欢折腾我们这些小白鼠的地方。一个金属有很多不同的指数面，单纯考虑最稳定的是一个保险折中的办法。因为不管你的体系搞的再复杂，跟真实情况相比，模型终究是简单的。我们只是尽自己可能去尝试着理解，解释实验的现象，描述下体系的性质，以及进行一些比较简单直接的预测。但是，如果你要深究这些，兴趣也恰好落在在这一块，那么可以对体系的各个相关结构进行一个全面的计算，分析不同表面结构，性质，反应活性有什么不同。在这个全面的计算体系中，</p>
<p>除了各种台阶面，最稳定的表面你还是要算的，这样才能有个对比。原则上说，只要你力气足够，资源充足，可以选任何你想要的表面来计算；但问题是你总会有吐的时候，如果想多算几个面的时候，要留意下面的几点：</p>
<p>注意-1：开放的表面在计算表面能，slab优化或者吸附的时候，层数的影响会很大，这个前期的测试工作要做好；</p>
<p>注意-2：生存法则：</p>
<p>A）灌水第一条：同一个反应， 这个指数面算一下发一篇文章，换个面再发篇文章，再换个面继续发文章….</p>
<p>B）灌水第二条：同一个面： 算一个反应发一篇文章，换个反应算一下再发一篇文章，再换反应；</p>
<p>C）灌水第三条：反应，表面和反应交替，排列组合式发文章。</p>
<p>3）还有一种情况，就是我们手上有实验数据，想模拟一下实验的结果。这个时候，就可以参考下催化剂的表征结果，有针对性地选取催化剂的模型，使其尽可能地去描述催化剂的结构。</p>
<p>注意的有以下几点：</p>
<p>A) 如果做实验的人找你帮忙算个东西，能推掉就推掉，别在上头浪费自己的功夫，顶死也就是个共同一作，国内基本不认可，做无用功；如果刚开始推不掉，就看看他的实验表征结果，一般般的表征以模型搭不出来为由直接拒掉；好的模型是成功的重要因素。前面我们说了，模型再复杂也是简单的。再考虑到实验表征的结果不确定性，你有很大的几率是跟实验上对不上的，到头还是白忙活。很多人会拿工作要冲子刊，杰克斯，俺狗娃为由诱惑你上船，要掂掂自己的分量，别头脑发热用屁股做决定。</p>
<p>B) 对于做实验的人来说，99%会低估计算的复杂性，总以为鼠标点点就OK的事情，其中也不乏一些所谓的大牛们。话虽然难听，却也是大实话：不要瞎几把评论自己不懂的领域。真想找人算一下，要找个靠谱的合作伙伴，找到不靠谱的瞎算，投文章更会给整个工作拉分。</p>
<p>4）最后一个及其重要的就是，认真进行文献调研。看看前人都是怎么选取的，为什么这样选？根据什么依据来选？最终确定自己的计算模型。</p>
<p>关于模型的一些就先到这儿， 本篇的工作主要是重复一遍前人已经算烂的反应，然后在此基础上，分析BEP和TSS线性关系。就直接拿各个金属最稳定的表面来计算了。那么， 什么是BEP线性关系？ 这里的BEP的全称是：Bell–Evans–Polanyi principle. 指的是对于同一类型的N个反应，这些反应的能垒和反应热之间存在的一个线性关系: $E_a$= $\alpha \Delta E$ + $\beta$ 。更详细点的介绍，参考维基百科搜索：Bell–Evans–Polanyi principle。起初这个关系是基于均相反应来说的。在2000年的时候，Neurock将这个关系引入多相催化体系，发现表面反应也存在这一关系。随后，经过了Norskov等人的继续研究，相关的文章就越来越多了。有兴趣的可以通过下面的几篇经典文献开始接触，然后再逐渐深入：J. Catal. 191, 301 (2000)，  J. Catal. 197, 229 (2001)， J. Chem. Phys. 114, 8244 (2001)</p>
<p>BEP关系有啥用呢？主要有两点:</p>
<p>关键的一点就是用来节约机时：过渡态不是一个稳定的结构，它的优化需要的计算时间比直接优化反应物种的要多得多。插8个点，也就是8倍的单个优化。再加上计算还经常容易失败。因此我们可以通过BEP关系，跳过TS的优化，直接预测反应的能垒，从而达到节约机时和生命的作用。这个方法简单粗暴，与直接进行反应路径扫描相比，在时间成本上具有压倒性的优势，但精度和准确度上就会稍逊一筹。</p>
<p>另外一点是来预测反应的能垒，这个其实和上面的有些重复，但角度不同。比如一个复杂的催化体系，基元反应数目成千上万，我们挨个算过渡态显然不可行。但是中间体的数目明显少的多，那么我们通过中间体获取反应热之后，通过BEP关系得到反应能垒，也就有了动力学的一些基本数据，从此出发，可以做一些机器学习以及微观反应动力学的模拟工作。从而跨越理论计算的原子分子尺度来到达一个更为宏观的尺寸和时间的尺度，也就是所谓的多尺度模拟。</p>
<p>继续前面的分析，如果中间体的数目也很多，算都算不完，那该怎么办？这个也可以通过一些线性组合，数据分析的方法来进行预测。比如通过Group Additivity的方法，可以将对分子中不同group的能量的求和来获得。具体的内容在后面其他章节再慢慢进行介绍。由于篇幅关系，本节（ex84的上半部分）主要是让大家对自己的研究对象有一个明确的认识，为什么研究它？为什么不研究别的？下半部分介绍中间体计算的一些注意事项。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>优化</tag>
        <tag>中间体</tag>
      </tags>
  </entry>
  <entry>
    <title>ex85 中间体的优化</title>
    <url>/2019/12/22/ex85/</url>
    <content><![CDATA[<p>本节主要给大家介绍一下中间体计算的具体流程。</p>
<p>计算中间体前的准备：</p>
<p>1）催化剂表面模型的结构以及性质自己多多了解；表面原子排列，谁带正电荷，谁带负电荷，原子间距等等，这些基本的东西自己心里要有数；没事可以整理到表格或者ppt里面，方便以后写文章用；</p>
<p>2） 表面上可能发生的反应路径，各个基元反应，自己列举出来，整理归类方便以后分析。</p>
<p>3）反应路径中各种可能分子的吸附结构先优化完成，通过这些基本分子的吸附能，吸附结构，对体系大体了解一下，一方面参考文献中别人提到的反应路径，另一方面添加自己认为可能的情况。</p>
<p>关键点：</p>
<p>中间体的优化和前面我们讲到的分子或者原子在表面上的优化是一样的。意思就是计算分子吸附的时候，基本的操作同样适用于中间体的优化。可以分布算，先从粗糙的精度出发，然后慢慢提高精度。注意的一点：</p>
<p>对于计算速度的影响：</p>
<p>1） KPOINTS：先把slab固定住，用（1x1x1）的K点对刚刚搭建的中间体结构预优化一下（基本上跑个NSW = 60就差不多了）得到一个理想的初始结构，然后再增加K点密度，放开slab的表层原子，继续优化；</p>
<p>2）EDIFF，EDIFFG：这两个参数主要影响电子步和离子步的步数，当我们用低密度的K点进行计算的时候，电子步很快收敛，离子步收不收敛我们也不在乎，所以在这一步的时候，不用对这两个参数太较真；关键在于增加K点后，我们选取一个什么样的标准，既得到理想的结构和能量，也避免了服务器做无意义的计算；</p>
<p>3）ISPIN：体系需要考虑磁性的话，粗优化的时候，可以先关掉。后面提高精度后，记得加上就可以了。</p>
<p>4）NCORE等并行参数也不要忘记加上，详细参考：</p>
<p>熟练掌握不同精度下这几个参数的使用，可以极大地提高你的计算效率，节省机时。前面说的这些，基本上试用大部分的体系，但还是要靠大家自己多多测试，摸索一下最适合自己体系的方法。</p>
<p>本节主要取表面上：CH3OH —&gt; CH3O —&gt; CH2O 这两步来简单介绍，下图中圈出来的两步；其他的路径照着葫芦画瓢就行了。<img src="/2019/12/22/ex85/ex85.png" alt=""></p>
<p> 第一步：CH3OH —&gt; CH3O + H </p>
<p>1）反应产物为表面上的甲氧基（CH3O*）和氢原子（H*)， CH3O* 可以继续进行C—H键断裂，或者C—O键断裂，生成CH3*+O<em> 或者CH2O\</em> + H*。</p>
<p>注意：这里你应该可以想象到反应网络的复杂性，从一个反应物出发可以有多个不同类型的基元反应，产物作为下一步的反应物，也会有不同类型的反应，导致整个反应网络变得越来越复杂，最后交叉合并，汇总到最基本的分解产物上来。这里我们用的是甲醇，当分子C链增长的时候，基元反应的数目就会急剧增加，增加到我们挨个算不能完成的情况，这也是我们为啥要研究BEP关系的原因。另一个原因就是，成千上万个反应，整天瞎算过渡态，有时候你并不会学到太多新鲜事物，只是重复搬砖的工作，对我们以后的成长不利。</p>
<p>2）H原子的吸附，我们就跳过吧，相信大家经过前面的学习，应该都会了。计算CH3O的结构，我们可以从CH3OH的POSCAR出发，进行下面几点思考：</p>
<p>A) 删除POSCAR中对应H原子的坐标，保存为新的POSCAR，即表面上只有CH3O，提交任务进行优化；</p>
<p>B) CH3OH的结构中，O是在一个top的位置上，但O—H 键断裂之后，O的成键能力增强了，还会继续呆在top位置上么？所以，我们要把OCH3挪到bridge, hcp, fcc 位点上，得到几个不同的结构，提交任务进行优化；</p>
<p>C) 前面我们的结构OCH3是斜着在表面上；会不会有直立的结构？ OCH3是通过O与表面结合，我们是不是可以参考O原子在表面的吸附结构；搭建OCH3直立的吸附结构？</p>
<p>D）前面说的这几点，我们都可以通过前面所说的关键点，用一个粗糙的模型扫描一遍。然后大致分析下结果，然后进行下一步的计算，最终得到稳定的OCH3在表面上的稳定结构。</p>
<p>第二步：CH3O —&gt; CH2O + H</p>
<p>这一步，从甲氧基进行了一步C—H反应，得到了甲醛和H。H的话继续跳过；甲醛的话，这里我们应该也需要跳过；因为甲醛是一个分子，在计算中间体前的准备这一步中，我们应该已经完成。安全起见，我们也列举一下几点需要注意的结构搭建工作：</p>
<p>1） 甲醛分子以C，以O还是C=O双键与表面结合？</p>
<p>2） 以不同部分与表面结合的时候，会在哪个位点上？</p>
<p>3）垂直？斜着，还是平行吸附？</p>
<p>总之，尽可能多思考不同的表面结合方式，采用粗糙的模型快速进行筛选，也要实时思考，粗糙模型会不会对这样的快速筛选产生影响？会不会漏掉什么可能的结构？</p>
<p>后面的过程依次类推，直至甲醇分子分解为最基本的化学单元(H，C, O)。</p>
<hr>
<p>下面介绍另外一种中间体模型，首先回顾一下上面搭建CH$_3$OH—&gt; CH$_3$O + H这一个反应中间体的过程：（这里我们先定义这个中间体模型为：A）</p>
<p>1) 从CH$_3$OH的POSCAR出发，</p>
<p>i) 删除POSCAR中与O相连的H原子的坐标，此时表面上只有CH$_3$O的结构，且CH$_3$O位于top位上；</p>
<p>ii) 稍微修改一下OCH$_3$的结合位点，尝试一下附近的hcp，fcc，或者bridge位点上CH$_3$O的结构，并分别保存到不同文件夹里面；</p>
<p>iii) 提交任务计算，并对比不同OCH3结构的能量，取最低的那个。</p>
<p>iV) 第ii）步中我们暴力直接删掉H原子，基于的假设是一旦O—H键断裂后，产物之间（CH$_3$O<em>, H</em>）互不影响。</p>
<p>另外一种中间体模型（设为：B）长什么样子呢？</p>
<p>1） OCH$_3$的结构与前面A的模型一样，有top，fcc，hcp，bri各种尝试的结构；</p>
<p>2） 除此之外，CH$_3$OH 中与O相连的H也在OCH$_3$ 附近。</p>
<p>也就是说，在A 模型中，我们直接删掉H原子，而在B模型中，我们只是断开O—H 键，H还留在表面上。也即是B模型保持了与反应物分子相一致的原子种类以及数目。</p>
<p>这两个办法有什么区别呢？哪个更好些?</p>
<p>我们先分析下B)的模型：它比A模型多了一个H，可以认为H 吸附在A模型上；因此A中CH$_3$O的存在会对H的吸附能产生影响，一方面来源CH$_3$O对催化剂电子结构的影响，另一方面来自与空间的影响，类似于前面我们学习过的覆盖度对O原子吸附的影响。因此我们可以计算并对比H在纯净slab和A上面的吸附能。 </p>
<p>$\Delta E<em>{ads}$ =$E</em>{ads}^{slab}$ -$E<em>{ads}^{A}$  = [$E</em>{H<em>}$  - $E<em>{Slab}$ - $E</em>{H<em>2}/2$]  -  [$E</em>{CH_3O</em>+H<em>}$  - $E_{CH_3O</em>}$ - $E_{H_2}/2$] </p>
<p>= ($E<em>{H*}$ + $E</em>{CH<em>3O*}$) - ($E</em>{Slab}$ + $E_{CH_3O<em>+H</em>}$)</p>
<p>A和B模型的区别为： 将$CH_{3}O$ 和 H 分离到无穷远时候的体系能量的变化。</p>
<p>再看一下A和B两个模型中反应热的计算：</p>
<p>A)模型：$\Delta$E(A) =  $E<em>{CH_3O*}$ + $E</em>{H<em>}$ - $E_{CH_3OH</em>}$ -  $E_{slab}$</p>
<p>B)模型：$\Delta$E(B) =  $E<em>{CH_3O<em> + H</em>}$ - $E</em>{CH_3OH*}$ </p>
<p>反应热的差：</p>
<p>$\Delta$E(A) - $\Delta$E(B) = $E<em>{CH_3O*}$ + $E</em>{H<em>}$  - ($E<em>{Slab}$ + $E</em>{CH_3O</em>+H*}$) = $\Delta E_{ads}$</p>
<p>通过上面的分析，我们得到同样的结果，即两个体系模型的区别主要在于产物之间的相互作用。如果产物之间相互作用弱，可以认为彼此相差甚远，互不影响，也就是A模型，这也是大部分人在计算过程中常常采用的方法。例子有很多，就不一一介绍了，随便取一个： <em>ACS Catal.</em> 2014, 4, 11, 4178–4188。有兴趣的可以去看看。</p>
<p>对于B模型，可以从表面覆盖度对反应的影响这一角度来分析，在键断裂后，如果产物与催化剂结合较强，来不及扩散至互不影响，那么局部的覆盖度就会增加，从而对后面的反应产生影响。有兴趣的可以参考一下这两篇文章：</p>
<p><em>ACS Catal.</em> 2015, 5, 1, 104–112； <em>ACS Catal.</em> 2014, 4, 6, 1991–2005。</p>
<p>覆盖度对表面反应的影响很复杂，一般人也不愿意碰，但是在计算过渡态相关的操作过程中，B模型却发挥着重要的作用。可以从下面2个角度来分析：1）过渡态插点的技术角度 以及2）获取合理过渡态的角度。这些将会在下一节分析。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>优化</tag>
        <tag>中间体</tag>
      </tags>
  </entry>
  <entry>
    <title>硕博（后）招聘（车芳琳课题组-美国马萨诸塞大学洛厄尔分校）</title>
    <url>/2019/10/07/j01/</url>
    <content><![CDATA[<p><img src="/2019/10/07/j01/zp01.png" alt=""></p>
<p><strong>硕博（后）招聘：美国马萨诸塞大学洛厄尔分校车芳琳课题组</strong></p>
<p><strong>（University of Massachusetts Lowell）</strong></p>
<p><code>课题组简介</code></p>
<p>车芳琳老师课题组刚刚成立，主要研究催化以及材料科学方面的多尺度理论模拟，在多尺度范围内（从原子到反应器尺度）研究燃料电池，电催化及新型能源、光催化相关的催化剂性质，反应机理，动力学等。研究的相关课题有：轻质烷烃的活化，CO2电催化，多相催化的线性关系以及微观动力学模拟，以及多相催化反应器中的流体动力学模拟。课题组主页：<a href="http://sites.uml.edu/fanglin_che/">http://sites.uml.edu/fanglin_che/</a> (或点击左下角阅读原文）</p>
<p><code>导师简介</code></p>
<p>车老师本科毕业于大连理工大学（2008-2012），博士毕业于华盛顿州立大学（2012-2016），师从J.-S. McEwen教授。分别在加拿大多伦多E. H. Sargent课题组（ 2017-2018）和美国特拉华大学Dionisios G. Vlachos课题组（2018-2019）从事博士后研究。至今以一作（含共一）在Nat. Chem. (1), Nat. communs (2), Angew. Chem. Int., Ed.(1)， ACS Catal.(3), J. Catal.(1), ACS Energy Lett.(1), Adv. Mater(1), Appl. Catal. B (2)等高水平期刊发表文章若干篇。</p>
<p>Googl Scholar：</p>
<p><a href="https://scholar.google.com/citations?hl=zh-CN&amp;user=fiRHcIQAAAAJ">https://scholar.google.com/citations?hl=zh-CN&amp;user=fiRHcIQAAAAJ</a></p>
<p><code>申请方式</code></p>
<p>目前长期招聘硕士，博士，以及博士后。有兴趣的可以将个人简历发送至：<strong>Fanglin_che@uml.edu</strong></p>
]]></content>
      <categories>
        <category>招聘</category>
      </categories>
      <tags>
        <tag>博后</tag>
        <tag>硕士</tag>
        <tag>博士</tag>
        <tag>招聘</tag>
      </tags>
  </entry>
  <entry>
    <title>博后招聘（朱虹课题组-上海交大）</title>
    <url>/2019/10/09/j02/</url>
    <content><![CDATA[<p><img src="/2019/10/09/j02/zp02.png" alt=""></p>
<p><code>工作简介</code></p>
<p>上海交通大学密西根学院朱虹老师课题组诚聘博士后 1~2 名，负责或协助团队进行金属合金体系的腐蚀性能的理论预测和腐蚀机理的研究，将与腐蚀实验团队以及世界各地的材料基因组计算研究团队开展紧密合作 (UC Berkeley, University of Michigan, UC San Diego, Georgia Tech, University of Maryland, etc)，并在现有的高通量计算平台上开发针对腐蚀相关基础参数的高通量计算工作流。诚挚邀请具有理论计算、电化学背景同学的加入。</p>
<p><code>导师简介</code></p>
<p>朱虹 (<a href="mailto:hong.zhu@sjtu.edu.cn">hong.zhu@sjtu.edu.cn</a>) 助理教授，上海交通大学材料基因组联合研究中心成员； 材料科学与工程学院，上海交通大学密西根联合学院双聘。</p>
<p>Google Scholar: <a href="https://scholar.google.com/citations?user=x1BGIfEAAAAJ">https://scholar.google.com/citations?user=x1BGIfEAAAAJ</a></p>
<p>课题组主页: <a href="http://umji.sjtu.edu.cn/~hzhu">http://umji.sjtu.edu.cn/~hzhu</a>。</p>
<p><code>工作待遇</code></p>
<ol>
<li>年收入 22w+， 享受相应上海交通大学福利待遇；</li>
<li>根据上海市博士后管理政策办理有关落户事宜；</li>
<li>优秀者可转入专职科研序列。</li>
</ol>
<p><code>招聘要求</code></p>
<ol>
<li>拥有材料、化学或相关专业的博士学位</li>
<li>具有理论模拟计算经验或具有丰富的机器学习特别是材料研究领域的经验</li>
<li>能够独立开展研究，在知名期刊上以第一作者发表论文</li>
<li>在同等条件下，优先考虑具有较高编程能力的同学</li>
</ol>
<p><code>申请方式</code></p>
<p>发邮件至 <a href="mailto:hong.zhu@sjtu.edu.cn">hong.zhu@sjtu.edu.cn</a>，并附上简历以及可以到站的时间。</p>
]]></content>
      <categories>
        <category>招聘</category>
      </categories>
      <tags>
        <tag>博后</tag>
        <tag>上海交大</tag>
      </tags>
  </entry>
  <entry>
    <title>Learn VASP The Hard Way (序言)</title>
    <url>/2017/10/10/preface/</url>
    <content><![CDATA[<p>大师兄网站不能登录的这几天时间，经过一番思考，下定决心给大家一个界面更简洁，阅读体验更好，内容更丰富的大师兄网。<br>虽然感觉时间上压力很大，但得到了很多筒子们的支持和帮助，这给了我继续写下去的动力。当然，最重要的还是老婆的支持。<br>在这里，向她（他）们表示深深的感谢。</p>
<h2 id="为什么写本书"><a href="#为什么写本书" class="headerlink" title="为什么写本书?"></a>为什么写本书?</h2><h3 id="使用人群"><a href="#使用人群" class="headerlink" title="使用人群"></a>使用人群</h3><ul>
<li><p>此书主要针对于0-6个月的VASP初学者,VASP小白,或者刚刚转换计算方向(从VASP计算一个性质到另外一个性质时),以及某一部分计算细节生疏需要复习的科研工作者。直接列出来一堆求解薛定谔方程中的各个公式定理等,肯定会对初学者造成一定的误导,因此本书不讨论过多量子力学的基本原理。</p>
</li>
<li><p>很多时候，由于对计算细节的不了解,且无人指导(导师啪啪啪打脸),不少人在计算了一个多月，或者更长时间后发现自己的参数设置错了，但是也不知道该怎么补救，从而走上了重算的这一条极其浪费时间，机时和精力的路。大师兄遇到过很多种类似的情况,周围的朋友遇到这种情况的也不在少数。更有甚者,课题做完了才发现是错的。 出现错误并不可怕,可怕的是我们不知道怎么补救，不长教训,后面还继续犯错。这也是本书的一个出发点,首先保证大家提交的任务准确无误,可以尽最大可能避免遇到前面类似的问题,进而起到间接节约时间的作用。在正确计算的同时,大家可以从头学习密度泛函理论,阅读相关课题的参考文献等。所以，本书旨在为初学者提供一个快速进入计算而又避免过多新手错误的方法。</p>
</li>
</ul>
<h3 id="不适宜人群"><a href="#不适宜人群" class="headerlink" title="不适宜人群"></a>不适宜人群</h3><ul>
<li>导师是不做计算，让你独辟蹊径，单独挑起组里做计算的大梁；</li>
</ul>
<p>国内做量化计算的人如雨后春笋般涌现出来，一批又一批，好多高校，学院都有老师开始主动尝试计算这个方向，很多做实验的老师也安排自己的学生”算一下”, 但这一部分人之前没有任何的计算功底或者经验，但仍然抱有一颗非常乐观的心态：计算无非就是操作软件的活，花几万块钱买台电脑，美其名曰计算！而到了真正计算的时候，乱七八糟的问题如瓢泼大雨般从天而降，从软件的安装，模型的搭建，计算参数的设置，计算结果的分析等等…..却又不知道如何解决，一来浪费了自己的时间和精力，二来浪费了计算资源（至少很多电费是白交了，服务器白磨损了….）。</p>
<h3 id="出发点（一）"><a href="#出发点（一）" class="headerlink" title="出发点（一）"></a>出发点（一）</h3><p>本书的一个出发点就是,本人在很多计算的QQ群里面,但是群里面很多问题都非常低级,令人费解,或者说是匪夷所思的,从最基本的建模都做不到,到计算结果不会分析等等。这些人简单而又低级的问题充斥在各个QQ群里。暂且不说这些人的导师有多么地不负责任。很多热心的人却在群里整天忙着应付这些问题,而对于自身,除了得到个活雷锋的标签外,对理论功底的提高,帮助甚微。可以说是花自己的时间替别人指导学生。不论群主给自己的群定位有多高,高级群,中级群,精英群等等,都避免不了这样的问题出现。本书主要通过实例引导大家主动思考去解决这些最基本的常见问题,进而避免因自己的低级问题浪费他人的时间。我说希望的是,对于求助或者应助的人,大家尽可能地讨论一些更高级,更深层次的科研问题,而不是浪费在这些低级的问题上。即使在新的计算中遇到了之前没有碰到过的小细节,自己也知道怎么去动脑子,主动解决。</p>
<h3 id="出发点（二）"><a href="#出发点（二）" class="headerlink" title="出发点（二）"></a>出发点（二）</h3><p>本人博士已经毕业,目前正在做博士后,早晚有一天会回到国内继续自己的研究生涯,也会有自己的学生,通过这本书把自己学到的东西保存下来,以便后面学生可以借此快速入门，虽然说磕磕碰碰是最好的学习方向，但我更希望自己的学生能从本书中领悟到解决问题的一些基本思维方式。学习计算化学的人,对解决科研问题都有着一种执着的态度,通过构建模型来阐明已知或者预测未知的结果。相对于做计算的科研工作者们,虽然我们没有实验技巧的提高,但我们可以通过训练自己的大脑来弥补。懂得思考的人永远站在社会发展的最前端。</p>
<h3 id="出发点（三）"><a href="#出发点（三）" class="headerlink" title="出发点（三）"></a>出发点（三）</h3><p>There are kinds of questions you will find yoursel asking and not knowing where to get quick answers from.</p>
<p>That’s what BigBro(a)s are trying to fix.</p>
<p>你会发现自己在问各种各样的问题,但不知道从哪里可以得到快速解答。这正是大师兄（姐）们正在尝试解决的问题:结合最基本的化学常识和软件计算细节,写一本最好的快速基本入门书。</p>
<h3 id="如何学习本书（一）"><a href="#如何学习本书（一）" class="headerlink" title="如何学习本书（一）"></a>如何学习本书（一）</h3><p>如何学习本书,大师兄在学习程序时,受到<a href="https://learnpythonthehardway.org/">learn_python_the_hard_way</a>这本书的启发:务实是这本书的一大特色,开始学习语言,乱七八糟的先统统闭嘴,照着代码练习一番,然后再自己思考琢磨,出现问题拿自己的代码和作者代码比较找出原因。<br>通过系统地学习,随着水平的提高,再逐步解释前面未讲解的内容。这一种学习方法非常适合零基础的菜鸟,因为一开始太多的概念根本不可能一股脑儿全部接受。从简单入手,指导着循序渐进,最后达到精通。打算学Python的(推荐python3),强烈建议此书，当然也有很多其他极好的书籍，这里就不再过多介绍。</p>
<h3 id="如何学习本书（二）"><a href="#如何学习本书（二）" class="headerlink" title="如何学习本书（二）"></a>如何学习本书（二）</h3><p>对于量化计算,本书也采用这样的思路,手把手先教会大家如何计算,如何避免错误。从最基本的计算开始,通过示例讲解,结合一些脚本的使用,引导大家思考解决自己的问题。因此,在这本书的学习过程里,每一章节会对应一个例子,大家务必手动搭建模型,输入文件(切忌复制粘贴),然后进行计算,得到和大师兄一致的结果。为了引导大家主动浏览官网解决问题,很多都会采用<a href="http://www.vasp.at">VASP官网</a>的例子,大师兄会重新计算后放到章节里面,供大家对比参照。</p>
<ul>
<li>VASP 官网目前国内不能直接打开，大家</li>
</ul>
<ul>
<li>可以浏览<a href="https://pan.baidu.com/s/1trvvbCKkJHu1ZPGsizW4og">pdf版本</a>。</li>
<li>自行解决被墙的办法。</li>
</ul>
<h3 id="推荐参考书"><a href="#推荐参考书" class="headerlink" title="推荐参考书"></a>推荐参考书</h3><ul>
<li><a href="https://pan.baidu.com/s/1dFN9stj">Density functional theory:A practical introduction</a>, by David Sholl.点击本文链接就可以跳转到百度网盘下载，不要从网上随便下载，很多都是阉割版的。</li>
<li><a href="http://www.vasp.at">Vasp 官网</a></li>
<li>其他参考书会在文中慢慢推荐，对新手来说，这本书+VASP手册完全足够了，不要贪多。</li>
</ul>
<h3 id="对读者的话"><a href="#对读者的话" class="headerlink" title="对读者的话"></a>对读者的话</h3><p>如果你感觉本书对你有所帮助，欢迎随意转发转载如，果你有自己的科研经验和心得,也欢迎分享给大家!<br>为保证本书的简洁性，一些与本书无关的东西，QQ群号，公众号，留言联系方式等只在序言里面出现：</p>
<ul>
<li>微信公众号： <strong>BigBroScience</strong> （大师兄科研网）</li>
<li>大师兄QQ群：<strong>2674006510</strong>  进群1）看群公告，了解群里的基本要求 2）修改自己的群名片。</li>
<li>微信群: 满100人了，所以加大师兄微信（<strong><strong>BigBroSci</strong></strong>）后才可应邀加入微信讨论群。</li>
<li>咨询邮箱: lqcata@gmail.com</li>
</ul>
<h2 id="QQ群专注于科研思维的碰撞与科研生活的分享-本书中已经详细解释或者指明的易出错部分-不建议在群中继续咨询-请大家认真学习并主动积极地去思考和练习。此外-论坛或者QQ群里-有很多无知或者stupid的回复-处在迷糊之际的菜鸟由于对自己的不自信-会一股脑儿去相信别人错误的观点-进而一路错下去-这是最可怕的。所以-如果有疑问-可以先酝酿一两天-多多查阅资料，主动思考。然后再大胆提出来-改正就是进步。"><a href="#QQ群专注于科研思维的碰撞与科研生活的分享-本书中已经详细解释或者指明的易出错部分-不建议在群中继续咨询-请大家认真学习并主动积极地去思考和练习。此外-论坛或者QQ群里-有很多无知或者stupid的回复-处在迷糊之际的菜鸟由于对自己的不自信-会一股脑儿去相信别人错误的观点-进而一路错下去-这是最可怕的。所以-如果有疑问-可以先酝酿一两天-多多查阅资料，主动思考。然后再大胆提出来-改正就是进步。" class="headerlink" title="QQ群专注于科研思维的碰撞与科研生活的分享,本书中已经详细解释或者指明的易出错部分,不建议在群中继续咨询,请大家认真学习并主动积极地去思考和练习。此外,论坛或者QQ群里,有很多无知或者stupid的回复,处在迷糊之际的菜鸟由于对自己的不自信,会一股脑儿去相信别人错误的观点,进而一路错下去,这是最可怕的。所以,如果有疑问,可以先酝酿一两天,多多查阅资料，主动思考。然后再大胆提出来,改正就是进步。"></a>QQ群专注于科研思维的碰撞与科研生活的分享,本书中已经详细解释或者指明的易出错部分,不建议在群中继续咨询,请大家认真学习并主动积极地去思考和练习。此外,论坛或者QQ群里,有很多无知或者stupid的回复,处在迷糊之际的菜鸟由于对自己的不自信,会一股脑儿去相信别人错误的观点,进而一路错下去,这是最可怕的。所以,如果有疑问,可以先酝酿一两天,多多查阅资料，主动思考。然后再大胆提出来,改正就是进步。</h2><p>title: Learn VASP The Hard Way (序言2)<br>categories: </p>
<ul>
<li>LVASPTHW<br>tags: </li>
<li>序言</li>
<li>如何学习VASP<br>date: 2017-10-10 16:30:16</li>
</ul>
<hr>
<h1 id="序言2：-如何学习VASP？"><a href="#序言2：-如何学习VASP？" class="headerlink" title="序言2： 如何学习VASP？"></a>序言2： 如何学习VASP？</h1><p>写在前头的话，虽然本书会教给你怎么样一步一步从单个原子，到气相分子，再到表面，以及后面的分子吸附，过渡态相关的计算。但为了避免很多小迷弟迷妹们过于依赖本书，偏离了大师兄写书的初衷。先强调一下VASP的学习方法：<strong>老板+1本参考书 + 2个网址</strong>。</p>
<h3 id="老板"><a href="#老板" class="headerlink" title="老板"></a>老板</h3><p>当然指的是有自己的老板指导喽，大师兄刚读博士的时候，老板并没有直接给我课题组，也没有让我自学或者跟组里的其他人学习VASP，而是花了一个月的时间让我读完此书和亲自指导我练习，这种的传授方式，是国内很多不负责任的导师需要学习的。虽然我老板每天都很忙，所有刚刚加入我们组的博士，都是老师亲手指导出来的。如果你的老板没有时间，至少要给你个师姐或者师兄，这都没有的话，那么老板要喜欢给你出钱让你去交流学习。老板又不教你，又不给师兄师姐带你，又舍不得在你身上花钱，不出意外，你会活得很惨。</p>
<h3 id="一本参考书："><a href="#一本参考书：" class="headerlink" title="一本参考书："></a>一本参考书：</h3><p>Density Functional Theory: A Practical Introduction (<a href="https://www.wiley.com/en-us/search?pq=%7Crelevance%7Cauthor%3ADavid+Sholl">David Sholl</a>)</p>
<p><img src="/2017/10/10/preface/pre-2.jpeg" alt=""></p>
<p>书的作者简历，有兴趣的可以去搜一搜。这本书对于初学者来说，很容易掌握计算的要领。而对于老手们来说，此书经常翻阅，定会不断提升你的计算水平和对计算的理解。我们举两个例子，请认真阅读里面的内容，并理解。</p>
<p> 第一章开始，为了缓解大家对DFT的恐惧，举了一个理论计算与开车的关系：</p>
<p><img src="/2017/10/10/preface/pre-3.jpeg" alt=""></p>
<p>（此开车非彼开车，老司机闭嘴，认真看，不许笑！）</p>
<p>你需要做的是如何正确地驾驶汽车，定期维护它，但你并不知道怎么去造一辆车； 类似地，你需要做的是如何正确地理论计算，避免常见的错误，但你不知道VASP程序是怎么写出来的。</p>
<p>例子2：关于收敛的解释：</p>
<p>第三章开始的部分，介绍了收敛在计算中的意义。Numerical Convergence 和Physical reality的联系: DFT计算收敛了不等于薛定谔方程求解了。而体系的性质是由薛定谔方程的解来确定的！所以DFT计算结果的物理或者化学意义才是最终要的。</p>
<p> <img src="/2017/10/10/preface/pre-4.jpeg" alt=""></p>
<p>DFT的求解的结果一定等于薛定谔方程的求解结果吗？VASP算出来的结果就一定是对的吗？其中的含义，大家自己去慢慢琢磨。</p>
<p>此外，网上的免费版本里面，很多公式符号不全。大师兄学习的时候深受其害：如图：</p>
<p><img src="/2017/10/10/preface/pre-5.jpeg" alt=""></p>
<p>图中阉割版的箭头处都是空白，你不知道是正，是负，是乘还是除。所以，为避免这种情况对阅读造成理解上的困难，建议：</p>
<ul>
<li><p>去wiley官网下载未阉割版（有权限的话），</p>
</li>
<li><p>大师兄QQ群文件下载：</p>
<p><img src="/2017/10/10/preface/pre-6.jpg" alt=""></p>
</li>
<li><p>百度网盘链接：<a href="https://pan.baidu.com/s/1OZuIfs6gmLN-Ru8UC_Ybcg">https://pan.baidu.com/s/1OZuIfs6gmLN-Ru8UC_Ybcg</a>  提取码：yq0z </p>
</li>
</ul>
<h3 id="一个网址：-VASP官网"><a href="#一个网址：-VASP官网" class="headerlink" title="一个网址： VASP官网"></a>一个网址： <a href="https://www.vasp.at/">VASP官网</a></h3><p> 学习VASP，最权威和丰富的资料参考就是官网啦。对于很多新手，手上的教程有一堆，从网上找的，师兄师姐传下来的。但那些都不如官网的例子和说明准确和直接。</p>
<p>1 VASP在线手册: <a href="http://cms.mpi.univie.ac.at/vasp/vasp/vasp.html">http://cms.mpi.univie.ac.at/vasp/vasp/vasp.html</a></p>
<p>2 VASP Pdf 手册: <a href="http://cms.mpi.univie.ac.at/vasp/vasp.pdf">http://cms.mpi.univie.ac.at/vasp/vasp.pdf</a></p>
<p>3 VASP wiki 入口: <a href="http://cms.mpi.univie.ac.at/wiki/index.php/The_VASP_Manual">http://cms.mpi.univie.ac.at/wiki/index.php/The_VASP_Manual</a></p>
<p>4 VASP官网中实用的教程和参考文档。</p>
<p><img src="/2017/10/10/preface/pre-7.jpeg" alt=""></p>
<p>老板亲自指导我学习VASP的时候，教程就是官网中的Handonsession 系列。（图中蓝色圈出来的部分）。每天让我重复教程里面的练习，提醒里面的易错部分，算什么性质需要注意什么参数，以及让我主动思考里面各个计算的含义。这一些东西在Learn-VASP-The-Hard-Way本书中都会讲到。在建议大家下载里面的内容，认真练习，学习。</p>
<p><strong>注意：</strong></p>
<p>新手也好，老司机也罢，<strong>不再建议</strong>去学习handonsession的例子，因为那是老掉牙的ppt了，最新的VASP官方workshop的ppt见下面链接： </p>
<p><a href="http://cms.mpi.univie.ac.at/wiki/index.php/NERSC_Berkeley_2016">http://cms.mpi.univie.ac.at/wiki/index.php/NERSC_Berkeley_2016</a></p>
<p><a href="http://www.nersc.gov/users/training/events/3-day-vasp-workshop/">http://www.nersc.gov/users/training/events/3-day-vasp-workshop/</a> （另一个参考网址，里面附带了Youtube的workshop视频）</p>
<p>除了VASP官网的这些参考资料外，使用说明书是我们需要经常翻阅的。遇到不会的，不懂的，有疑问的参数，请尽情的翻阅VASP官网吧。这里推荐VASP的Wiki网址。（请务必收藏本网址）</p>
<p><a href="https://cms.mpi.univie.ac.at/wiki/index.php/The_VASP_Manual">https://cms.mpi.univie.ac.at/wiki/index.php/The_VASP_Manual</a>  </p>
<p>如图：</p>
<p><img src="/2017/10/10/preface/pre-8.jpeg" alt=""></p>
<p>1：查询参数含义，设置的时候，进行搜索；</p>
<p>2：新手们从这里点击开始；</p>
<p>3：VASP的计算实例，大家可以参考里面的说明计算自己的体系性质；</p>
<p>4：INCAR的参数列表，大家没事多多点击里面的各个参数；查看含义；</p>
<p>5：再下面就是一些理论背景知识了，建议系统学习DFT的相关书籍，Wiki中的内容有限，只能作为参考。</p>
<h3 id="第二个网址"><a href="#第二个网址" class="headerlink" title="第二个网址"></a>第二个网址</h3><p>VASP的官方论坛。<a href="http://cms.mpi.univie.ac.at/vasp-forum/forum.php">http://cms.mpi.univie.ac.at/vasp-forum/forum.php</a> </p>
<p>如果你在计算中，遇到什么错误的信息，99%都可以在这里找到答案。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本书的初衷是引导大家去主动学习VASP，而不是教会大家VASP，而本节提到的参考书和官网则是新手们学习VASP最简单有效的途径。当然，还有很多有宝贵的参考书籍供大家阅读。如果你是新手的话，能把本节推荐的书啃完，再结合官网的计算一些示例练习，就足够了。如果你能坚持认认真真练习，主动重复网站的例子，认真思考，那么你的计算水平会得到极大的提升。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>序言</tag>
      </tags>
  </entry>
  <entry>
    <title>ASE消虚频的小脚本</title>
    <url>/2022/04/29/A29/</url>
    <content><![CDATA[<h4 id="ASE消虚频的小脚本"><a href="#ASE消虚频的小脚本" class="headerlink" title="ASE消虚频的小脚本"></a>ASE消虚频的小脚本</h4><p>做计算，虚频是令我们又爱又恨的一个东西。结构优化的时候，出现虚频，往往需要我们花费大量的时间和精力去消掉它们，最后搞得精疲力尽。算过渡态的时候，它又不出来，又得折腾个半死才出现。再不幸一些，除了过渡态对应的虚频外，还出现了一个伴生的姐弟虚频，我们又得继续消下去。本节简单介绍一个结构优化时消虚频的小脚本。主要是根据虚频的振动方向将体系中对应原子的坐标进行微调，然后用于重新优化。</p>
<p>简单介绍下原理，先看下VASP的OUTCAR中虚频对应的部分，</p>
<p>1）7220行带有<code>f/i</code>说明有虚频存在，</p>
<p>2） <code>X, Y, Z</code>为体系中原子的坐标，也就是<code>POSCAR</code>中的内容。</p>
<p>3） <code>dx, dy,dz</code>为虚频对应的原子振动方向上的位移。</p>
<p>4）我们将<code>（dx, dy,dz）</code>这个位移乘以一个介于0-1之间的校正因子，然后跟POSCAR中的坐标加起来即可。</p>
<p>5）以z方向为例，校正因子设为0.1，微调后的z方向坐标为： <code>10.709980</code> + <code>（-0.676634）</code> $\times$ <code>0.1</code>  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7219</span><br><span class="line">7220    3 f/i=    9.313471 THz    58.518262 2PiTHz  310.663930 cm-1    38.517432 meV</span><br><span class="line">7221              X         Y         Z           dx          dy          dz</span><br><span class="line">7222       6.003159 11.629641  6.067545            0           0           0</span><br><span class="line">7223       7.651085  3.894943  9.628260            0           0           0</span><br><span class="line">7224       2.424442  5.785382  9.658882            0           0           0</span><br><span class="line">7225       5.384679  7.755200  0.000000            0           0           0</span><br><span class="line">7226       0.004928  9.643165  0.000000            0           0           0</span><br><span class="line">7227       8.286347  7.755200  0.877073            0           0           0</span><br><span class="line">7228       2.944132  9.643165  0.971480            0           0           0</span><br><span class="line">7229       6.823299  9.643165  1.459420            0           0           0</span><br><span class="line">7230       1.481083  7.755200  1.553827            0           0           0</span><br><span class="line">7231       4.619917  7.755200  2.336493            0           0           0</span><br><span class="line">7232       9.762503  9.643165  2.430900            0           0           0</span><br><span class="line">7233       6.756153  7.724844  3.627352            0           0           0</span><br><span class="line">7234       1.491401  9.684490  3.647528            0           0           0</span><br><span class="line">7235       8.239374  9.666853  5.136018            0           0           0</span><br><span class="line">7236       3.012611  7.740104  5.091365            0           0           0</span><br><span class="line">7237       6.016826  7.737975  6.049788            0           0           0</span><br><span class="line">7238       0.788563  9.668849  6.080188            0           0           0</span><br><span class="line">7239       8.321833  7.730633  7.184644            0           0           0</span><br><span class="line">7240       3.081015  9.671865  7.187374            0           0           0</span><br><span class="line">7241       0.815711  7.728916  8.180983            0           0           0</span><br><span class="line">7242       6.063762  9.648841  8.115270            0           0           0</span><br><span class="line">7243       9.839838  9.660462  8.962566            0           0           0</span><br><span class="line">7244       4.631258  7.730218  9.011537            0           0           0</span><br><span class="line">7245       7.668770  7.725888  9.623941            0           0           0</span><br><span class="line">7246       2.424191  9.657803  9.623832            0           0           0</span><br><span class="line">7247       2.095436  3.874640 10.694551            0           0           0</span><br><span class="line">7248       0.099192 11.590822 10.709980    -0.736317    0.002031   -0.676634</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>脚本内容 (命名为： <code>vib_correct.py</code> )</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Qiang Li</span></span><br><span class="line"><span class="string">Command: python3 vib_correct.py </span></span><br><span class="line"><span class="string">This is a temporary script file.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> ase.io <span class="keyword">import</span> read, write</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取虚频开始行</span></span><br><span class="line">l_position = <span class="number">0</span>  <span class="comment">#虚频振动方向部分在OUTCAR中的起始行数</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;OUTCAR&#x27;</span>) <span class="keyword">as</span> f_in:</span><br><span class="line">    lines = f_in.readlines()</span><br><span class="line">    wave_num = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> num, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(lines):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;f/i&#x27;</span> <span class="keyword">in</span> line:</span><br><span class="line">            wave_tem = <span class="built_in">float</span>(line.rstrip().split()[<span class="number">6</span>])</span><br><span class="line">            <span class="keyword">if</span> wave_tem &gt; wave_num: <span class="comment">#获取最大的虚频</span></span><br><span class="line">                wave_num = wave_tem</span><br><span class="line">                l_position = num+<span class="number">2</span></span><br><span class="line"><span class="comment"># ASE读POSCAR</span></span><br><span class="line">model = read(<span class="string">&#x27;POSCAR&#x27;</span>)</span><br><span class="line">model_positions = model.get_positions()</span><br><span class="line">num_atoms = <span class="built_in">len</span>(model)</span><br><span class="line"><span class="comment">#print(model_positions)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取虚频对应的OUTCAR部分 </span></span><br><span class="line">vib_lines = lines[l_position:l_position + num_atoms] <span class="comment">#振动部分 7222到7248行</span></span><br><span class="line"><span class="comment">#print(vib_lines)</span></span><br><span class="line">vib_dis = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> vib_lines:</span><br><span class="line">    <span class="comment">#model_positions = [float(i) for i in line.rstrip().split()[:3]]</span></span><br><span class="line">    vib_infor = [<span class="built_in">float</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> line.rstrip().split()[<span class="number">3</span>:]] <span class="comment"># dx， dy， dz对应的那三列</span></span><br><span class="line">    vib_dis.append(vib_infor)</span><br><span class="line">vib_dis = np.array(vib_dis) <span class="comment">#将振动部分写到一个array中。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 微调结构</span></span><br><span class="line">new_positions = model_positions + vib_dis * <span class="number">0.4</span> <span class="comment"># 0.4是微调的校正因子，即虚频对应振动位移的0.4，具体多大自己根据经验调。</span></span><br><span class="line">model.positions = new_positions</span><br><span class="line"></span><br><span class="line"><span class="comment">###保存结构</span></span><br><span class="line">write(<span class="string">&#x27;POSCAR_new&#x27;</span>, model, vasp5=<span class="literal">True</span>) <span class="comment"># POSCAR_new是微调后的结构，用于下一步的计算（别忘了把POSCAR_new改成POSCAR）。</span></span><br></pre></td></tr></table></figure>



<p>脚本使用：</p>
<ol>
<li>脚本跟计算文件在同一个目录下：<code>python3  vib_correct.py </code></li>
</ol>
<ol start="2">
<li>如果赋予了脚本可执行权限，并放到了<code>~/bin</code>目录下，直接运行：<code> vib_correct.py</code> 命令即可得到校正后的结构文件：<code>POSCAR_new</code>。</li>
<li>重新计算的时候，新建一个文件夹，把<code>POSCAR_new</code> 复制到文件夹里面，记得把名字改成<code>POSCAR</code>。</li>
<li>这个脚本只适用于普通结构优化时候的虚频。如果过渡态计算的时候出现好几个虚频，不要使用这个脚本，因为脚本默认使用最大虚频对应的位移进行校正。</li>
<li>不用ASE，自己直接写个<code>python</code>脚本也能实现。不过使用ASE可以很方便地获取<code>POSCAR</code>中原子数目，保存原子固定的信息。参考如下。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Qiang Li</span></span><br><span class="line"><span class="string">Command: python3 vib_correct.py</span></span><br><span class="line"><span class="string">This is a temporary script file.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取虚频开始行</span></span><br><span class="line">l_position = <span class="number">0</span>  <span class="comment">#虚频振动方向部分在OUTCAR中的起始行数</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;OUTCAR&#x27;</span>) <span class="keyword">as</span> f_in:</span><br><span class="line">    lines = f_in.readlines()</span><br><span class="line">    wave_num = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> num, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(lines):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;f/i&#x27;</span> <span class="keyword">in</span> line:</span><br><span class="line">            wave_tem = <span class="built_in">float</span>(line.rstrip().split()[<span class="number">6</span>])</span><br><span class="line">            <span class="keyword">if</span> wave_tem &gt; wave_num: <span class="comment">#获取最大的虚频</span></span><br><span class="line">                wave_num = wave_tem</span><br><span class="line">                l_position = num+<span class="number">2</span></span><br><span class="line"><span class="comment"># 读POSCAR</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;POSCAR&#x27;</span>) <span class="keyword">as</span> f_pos:</span><br><span class="line">    lines_pos = f_pos.readlines()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取虚频对应的OUTCAR部分    </span></span><br><span class="line">num_atoms = <span class="built_in">sum</span>([<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> lines_pos[<span class="number">6</span>].rstrip().split()])</span><br><span class="line">vib_lines = lines[l_position:l_position + num_atoms] <span class="comment">#振动部分 7222到7248行</span></span><br><span class="line"></span><br><span class="line">model_positions = []</span><br><span class="line">vib_dis = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> vib_lines:</span><br><span class="line">    position = [<span class="built_in">float</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> line.rstrip().split()[:<span class="number">3</span>]]</span><br><span class="line">    vib_infor = [<span class="built_in">float</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> line.rstrip().split()[<span class="number">3</span>:]] <span class="comment"># dx， dy， dz对应的那三列</span></span><br><span class="line">    model_positions.append(position)</span><br><span class="line">    vib_dis.append(vib_infor)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 微调结构</span></span><br><span class="line">model_positions = np.array(model_positions)</span><br><span class="line">vib_dis = np.array(vib_dis) <span class="comment">#将振动部分写到一个array中。</span></span><br><span class="line">new_positions = model_positions + vib_dis * <span class="number">0.4</span> <span class="comment"># 0.4是微调的校正因子，即虚频对应振动位移的0.4，具体多大自己根据经验调。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###保存结构</span></span><br><span class="line">f_out = <span class="built_in">open</span>(<span class="string">&#x27;POSCAR_new&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">f_out.writelines(lines_pos[:<span class="number">8</span>])</span><br><span class="line">f_out.write(<span class="string">&#x27;Cartesian\n&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> new_positions:</span><br><span class="line">    f_out.write(<span class="string">&#x27; &#x27;</span>.join([<span class="built_in">str</span>(coord) <span class="keyword">for</span> coord <span class="keyword">in</span> i]) + <span class="string">&#x27;  F  F  F\n&#x27;</span>)</span><br><span class="line">f_out.close()</span><br></pre></td></tr></table></figure>



<p><img src="/2022/04/29/A29/qrcode.png"></p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>ASE</tag>
        <tag>软件</tag>
        <tag>虚频</tag>
      </tags>
  </entry>
  <entry>
    <title>VASP官方视频</title>
    <url>/2022/04/29/A30/</url>
    <content><![CDATA[<p><img src="/2022/04/29/A30/fig1.png"></p>
<p>VASP官方在Youtube上开了自己的channel，虽然只有寥寥300多人关注，但也分析了9个视频。下载下来后大约是1G左右。1G只是个嚼头而已。主要内容如下：</p>
<p><img src="/2022/04/29/A30/fig2.png"></p>
<p>1 Advanced_methods_of_molecular_dynamics_VASP_Lecture</p>
<p>2 Basics_of_machine_learning_force_fields_VASP_Lecture</p>
<p>3 Electronic_Convergence_VASP_Lecture</p>
<p>4 Hybrid_functionals_VASP_Lecture</p>
<p>5 Introduction_to_ab_initio_simulation_in_VASP_VASP_Lecture</p>
<p>6 Introduction_to_molecular_dynamics_VASP_Lecture</p>
<p>7 py4vasp_04_release</p>
<p>8 Symmetry_and_sampling_in_reciprocal_space_VASP_Lecture</p>
<p>9 VASP_6.3_release</p>
<p>从图1里面文件大小可以看出来，除了7和9介绍新的后处理工具py4vasp和vasp6.3新版本之外，其他的7个视频都干货满满。不信的话再看看视频的时间，都在1个小时以上，相信对大家学习VASP肯定有帮助。</p>
<p><img src="/2022/04/29/A30/fig3.png"></p>
<p>建议大家关注下VASP的Youtube频道，这么牛逼的软件，才300多号人关注。哈哈。不过得科学上网，没有条件可以通过大师兄分享的网盘链接下载，</p>
<p>下载方式：关注公众号：大师兄科研网，后台回复： youtube   即可。</p>
<p><img src="/2022/04/29/A30/qrcode.png"></p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>VASP</tag>
        <tag>视频教程</tag>
      </tags>
  </entry>
  <entry>
    <title>VTST的编译</title>
    <url>/2022/05/23/A31/</url>
    <content><![CDATA[<p>VTST的编译并不难，关键主要有2点：</p>
<p>1）VASP能顺利编译</p>
<p>2）VTST编译的时候，严格按照官网的说明一步一步来即可。</p>
<p>为什么要编译VTST，说白了还是VASP自带的功能不强大，没法解决我们的实际计算问题，主要是过渡态结构的搜索。因此，我们需要把VTST的一些功能添加到VASP中。网上可以搜到很多相关的编译教程，这里主要简单介绍下编译的几点注意事项，理清编译的思路，增加成功率。</p>
<p>首先，在编译VTST之前，要确定你顺利编译了VASP。如果这一步你还没搞定，就打算直接编译VTST，会导致你不知道问题从哪里来？是VASP编译的原因呢？还是VTST的原因？另外，VTST编译命令跟VASP是一样的，都是make，只要按照VTST官网的说明，复制文件到指定目录， 修改特定的文件内容，其他的和VASP编译设置一致即可。</p>
<p>其次，一定要看官网。记住，官网永远是学习的第一手资料，很多人喜欢看各种各样的教程，大部分教程都是官网的阉割版。或多或少会丢失些重要的信息，导致出错了不知道怎么解决。</p>
<p>最后，我们介绍下官网的编译说明 (<a href="https://theory.cm.utexas.edu/vtsttools/installation.html)，大家编译好VASP之后，按照说明一步一步走，基本都能顺利编译VTST到VASP中：">https://theory.cm.utexas.edu/vtsttools/installation.html)，大家编译好VASP之后，按照说明一步一步走，基本都能顺利编译VTST到VASP中：</a></p>
<ol>
<li>第一步当然是下载并解压VTST的程序包喽：(<a href="https://theory.cm.utexas.edu/vtsttools/download.html">https://theory.cm.utexas.edu/vtsttools/download.html</a>)</li>
</ol>
<p>解压后，发现压缩包里的文件有些令人犯迷糊，简单说明下： VTST提供了对应三种VASP版本编译的文件。</p>
<p>i)  vtstcode5 文件夹里面对应的是VASP5 版本的</p>
<p>ii) vtstcode6.1 文件夹里面对应的是VASP6.1和6.2版本的</p>
<p>iii) vtstcode5 和 vtstcode6.1两个文件夹外面的文件对应的是VASP6.3版本的。</p>
<p>iv) VASP5升级到VASP6不管是6.1还是6.3）要额外花钱，如果你有VASP5的版权，那么就用vtstcode5的文件，VASP5也有很多的子版本，尽量用最新的5.4.4。</p>
<p>v)  VASP6.1/2升级到VASP6.3不花钱，6.3还支持机器学习，所以vtst6.1这个文件夹，直接删掉就OK了，暂不用它，直接搞6.3。</p>
<p><img src="/2022/05/23/A31/Users/qli/Desktop/A31.png" alt=""></p>
<p>2) 编译前的准备：</p>
<p>   i) cp 5.4.4   5.4.4_vtst   &amp;&amp; cd  5.4.4_vtst  </p>
<p>   5.4.4 为已经编译好的VASP目录，这样的话，我们可以用原生的VASP,亦可以用VTST强化过的。另外，这也是对VASP的一个备份；</p>
<p>   ii) 将下载的文件复制到 src文件中： </p>
<p>   ii) 编辑src文件中的main.F 文件</p>
<p>   按照官网的说明，VIM打开src/main.F 文件，找到对应的部分，直接替换即可。 </p>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In VTST v2.04 and later, a modification is required in main.F for the solid-state NEB.</span><br><span class="line"></span><br><span class="line">Find and replace:</span><br><span class="line"></span><br><span class="line">CALL CHAIN_FORCE(T_INFO%NIONS,DYN%POSION,TOTEN,TIFOR, &amp;</span><br><span class="line">     LATT_CUR%A,LATT_CUR%B,IO%IU6)</span><br><span class="line">with</span><br><span class="line"></span><br><span class="line">CALL CHAIN_FORCE(T_INFO%NIONS,DYN%POSION,TOTEN,TIFOR, &amp;</span><br><span class="line">     TSIF,LATT_CUR%A,LATT_CUR%B,IO%IU6)</span><br><span class="line">For vasp.6.2 also find and replace:</span><br><span class="line"></span><br><span class="line">IF (LCHAIN) CALL chain_init( T_INFO, IO)</span><br><span class="line">with</span><br><span class="line"></span><br><span class="line">CALL chain_init( T_INFO, IO)</span><br><span class="line">For vasp.6.2.1 you will need vtstcode 4.1 (revision 182). A version of the vtstcode that will work with vasp.6.1.x - vasp.6.2.0 has been saved in the vtstcode6.1 directory.</span><br></pre></td></tr></table></figure>
<p>   <strong>注意</strong>：VASP6.2还需要额外替换一行，至于6.3是不是跟6.2一样？ 可以编译2个版本,一个替换，一个不替换，然后对比下。本人测试的结果是，如果不替换，编译会失败。</p>
<p>   iii) 编辑 src/.objects文件</p>
<p>   先看下官网的说明：</p>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">To build the code, the VASP makefile needs to be changed. Find the variable SOURCE, which defines which objects will be built, and add the following objects before chain.o:</span><br><span class="line"></span><br><span class="line">bfgs.o dynmat.o  instanton.o  lbfgs.o sd.o   cg.o dimer.o bbm.o \</span><br><span class="line">fire.o lanczos.o neb.o  qm.o opt.o</span><br><span class="line">The objects dynmat.o, neb.o, dimer.o, lanczos.o, and instanton.o must be in the SOURCE list before chain.o appears. The optimizer objects, sd.o, cg.o, qm.o, lbfgs.o, bfgs.o, and fire.o must appear before the optimizer driver opt.o. Nothing else needs to be done. </span><br></pre></td></tr></table></figure>
<p>   官网里面有句话：Find the variable SOURCE, which defines which objects will be built, and add the following objects before chain.o。</p>
<p>   这里的<code>variable SOURCE</code>指的就是src目录里面的<code>.objects</code>文件，这个文件前面带<code>.</code>，是隐藏的。用VIM或者其他文本编辑软件直接打开编辑就行。</p>
<p>   主要有2点，加粗的<code>Before</code>告诉你怎么改<code>.objects</code>文件：</p>
<p>   1： The objects dynmat.o, neb.o, dimer.o, lanczos.o, and instanton.o must be in the SOURCE list <strong>before</strong> chain.o appears. </p>
<p>   2： The optimizer objects, sd.o, cg.o, qm.o, lbfgs.o, bfgs.o, and fire.o must appear <strong>before</strong> the optimizer driver opt.o. </p>
   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">70         tetweight.o \</span><br><span class="line">71         hamil_rot.o \</span><br><span class="line">72         bfgs.o dynmat.o  instanton.o  lbfgs.o sd.o   cg.o dimer.o bbm.o \</span><br><span class="line">73         fire.o lanczos.o neb.o  qm.o opt.o \</span><br><span class="line">74         chain.o \</span><br></pre></td></tr></table></figure>
<p>   直接复制官网的文本，将72,73行内容放到指定的位置即可(chain.o前面)，不要随便改顺序。</p>
<p>3) 回顾下，1）将VTST的文件复制到src目录里面，2） 修改main.F，3） 修改 .object文件。没有遗漏的话，就可以直接编译了。直接make命令，喝杯咖啡等着即可，下面是本人编译的一些具体命令：<code>5.4.4</code> 是已经编译好的VASP5的目录，VTST（<code>5.4.4_vtst</code>）编译时环境变量的设置跟<code>5.4.4</code>完全一样。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp 5.4.4   5.4.4_vtst  </span><br><span class="line">cd  5.4.4_vtst  </span><br><span class="line">cp ~/Downloads/vtstcode-184/vtstcode5/*  src/</span><br><span class="line">vi src/main.F</span><br><span class="line">vi src/.objects</span><br><span class="line">make </span><br></pre></td></tr></table></figure>
<ol>
<li>确认是否顺利编译，直接运行个例子看看就知道了。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep VTST -A 10 02/OUTCAR</span><br></pre></td></tr></table></figure>
<p>没问题的话则会出现下面的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VTST: version 3.2, (02/03/18)</span><br><span class="line"></span><br><span class="line"> CHAIN: initializing optimizer</span><br><span class="line"> </span><br><span class="line"> OPT: Using Conjugate-Gradient optimizer</span><br><span class="line"> OPT: CG, Init</span><br><span class="line"> OPT: CG, FDSTEP      0.005000</span><br><span class="line"> OPT: CG, MAXMOVE      0.200000</span><br><span class="line"> </span><br><span class="line"> CHAIN: Read ICHAIN            0</span><br><span class="line"> CHAIN: Running the NEB</span><br></pre></td></tr></table></figure>
<ol>
<li><p>简单总结下：编译VTST主要有以下4个小细节：</p>
<p>i) 前提是顺利编译完成了VASP，这也是最关键的地方。</p>
<p>ii) 下载VTST的code，找到对应VASP版本的文件，并复制到src目录中</p>
<p>iii) 修改src/main.F 文件</p>
<p>iv) 修改src/.objects 文件</p>
</li>
<li><p>欢迎大家分享自己的经验，放到自己的网站，公众号等平台，帮助更多的人解决VTST编译的问题，也可以添加到本文章中 （lqcata@gmail.com）。此外，VTST的Code怎么下载？有没有具体运行的案例？提交任务的命令怎么写？按照这个说明编译失败了，怎么办？这些问题就不要找我了。我相当圣母，可俺是男的。实在没办法，放弃也是个很好的选择。</p>
</li>
</ol>
<p><img src="/2022/05/23/A31/A30/qrcode.png" alt=""></p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>过渡态</tag>
        <tag>VTST</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>Improved Dimer Method计算过渡态的脚本</title>
    <url>/2022/06/22/A32/</url>
    <content><![CDATA[<p>今天分享一个Improved Dimer Method （IDM）的小脚本。IDM和传统的Dimer方法，NEB一样，都用于优化过渡态。Dimer方法的话，VTST（<a href="https://theory.cm.utexas.edu/vtsttools/）已经包含很多相关的脚本，咱们就不重复造车了。NEB结合IDM优化过渡态也很高效，成功率非常高，有兴趣的可以尝试下。分享脚本前主要介绍以下几点：">https://theory.cm.utexas.edu/vtsttools/）已经包含很多相关的脚本，咱们就不重复造车了。NEB结合IDM优化过渡态也很高效，成功率非常高，有兴趣的可以尝试下。分享脚本前主要介绍以下几点：</a></p>
<p>1） IDM已经编译在VASP里面了，不需要额外编译。</p>
<p>2） IDM跟平时的优化计算差不多，主要修改IBRION = 44即可。</p>
<p>3） IDM计算主要包括5步：</p>
<p>3.1： 生成初始的过渡态结构：可以有以下三种做法:</p>
<p>3.1.1 经验多的，可以直接手动初步搭一个，保存成<code>POSCAR</code>；</p>
<p>3.1.2 胆儿不大不小小的，可以借助NEB的方法，先准备初末态的结构，然后用VTST的nebmake.pl插点，挑出来接近过渡态结构的POSCAR；</p>
<p>3.1.3 胆儿最小的，可以先NEB跑上30步左右，把能量最高的结构检查下，感觉过渡态结构合理的话，把CONTCAR保存成POSCAR。</p>
<p>3.2：用3.1步中获得的POSCAR做一个频率计算；主要有以下几个注意事项：</p>
<p>3.2.1： NWRITE = 3  一定要注意，必须是3。</p>
<p>3.2.2:  这一步频率计算用不着那么高的精度，差不多就OK。比如我主要做表面催化反应，这一步计算的时候，</p>
<p>i) slab的原子都直接固定住，</p>
<p>ii) 分子大的话只放开对应键断开、生成的原子，分子其他部分都固定住。</p>
<p>iii) gamma点直接算。</p>
<p>这样的话，可以在很快的时间内完成频率计算，得到键断开、生成时过渡态所对应的虚频振动方向。如果有好几个小虚频，不用尝试着去消虚频，因为过渡态结构本来就是一个粗糙的，这里消虚频也没必要；不过一定要有过渡态对应的虚频，如果没有的话，重新搭一个过渡态结构，继续算频率。</p>
<p>3.3 读取频率计算的结果，生成IDM计算的POSCAR。这也是本节中脚本的作用；</p>
<p>3.4 准备IDM计算的INCAR, KPOINTS, POTCAR, 提交任务，等待结束。</p>
<p>3.5 精度稍微高点的频率计算，验证IDM优化出来的过渡态结构。</p>
<p>3.6 以上是正常计算的一个流程，具体细节，大家根据自己情况随机应变，官网的介绍只有一页，很短，一定要认真读一下：<a href="https://www.vasp.at/wiki/index.php/Improved_Dimer_Method">https://www.vasp.at/wiki/index.php/Improved_Dimer_Method</a></p>
<p>脚本部分：</p>
<p>脚本<a href="https://github.com/bigbrosci/q-robot/blob/main/actions/get_dimer.py">get_dimer.py</a>可以在我的Github页面下载: <a href="https://github.com/bigbrosci/q-robot/tree/main/actions。">https://github.com/bigbrosci/q-robot/tree/main/actions。</a> <code>q-robot</code>是本人这些年来计算常用的一些小脚本，有兴趣的也可以全部下载下来。根据自己需求酌情修改使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">@author: qli</span><br><span class="line">Created on Thu Jun  2 22:09:18 2022</span><br><span class="line">Creat POSCAR for improved dimer calculations from frequency calculations.</span><br><span class="line">1) run frequency calculation: </span><br><span class="line">IBRION = 5</span><br><span class="line">POTIM = 0.015</span><br><span class="line">NFREE = 2</span><br><span class="line">NWRITE = 3 ### Must be 3</span><br><span class="line">2) run this script:</span><br><span class="line">get_dimer.py </span><br><span class="line">3) use the POSCAR for IDM calc.</span><br><span class="line">NSW = 100           </span><br><span class="line">Prec=Normal</span><br><span class="line">IBRION=44           !  use the dimer method as optimization engine</span><br><span class="line">EDIFFG=-0.05</span><br><span class="line">POTIM = 0.05</span><br><span class="line">    </span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">import numpy as np</span><br><span class="line">from ase.io import read, write</span><br><span class="line">import os</span><br><span class="line">from sys import exit</span><br><span class="line"></span><br><span class="line">model = read(&#x27;POSCAR_relax&#x27;) ### POSCAR_relax is the POSCAR before freq calculations, that means some atoms are not fixed.</span><br><span class="line">#model_positions = model.get_positions()</span><br><span class="line">model.write(&#x27;POSCAR_dimer&#x27;, vasp5=True)</span><br><span class="line"></span><br><span class="line"># print(model_positions)</span><br><span class="line"># print(len(model))</span><br><span class="line"></span><br><span class="line">l_start = 0 # the number of line which contains  &#x27;Eigenvectors after division by SQRT(mass)&#x27; </span><br><span class="line">with open(&#x27;OUTCAR&#x27;) as f_in:</span><br><span class="line">    lines = f_in.readlines()</span><br><span class="line">    for num, line in enumerate(lines):</span><br><span class="line">        if &#x27;Eigenvectors after division by SQRT(mass)&#x27; in line:</span><br><span class="line">            l_start = num</span><br><span class="line"></span><br><span class="line">if l_start == 0:</span><br><span class="line">    print(&#x27;&#x27;&#x27;Check Frequency results and then rerun this script.\n**Remember**: NWRITE must be 3. BYEBYE! &#x27;&#x27;&#x27; )</span><br><span class="line">    exit()</span><br><span class="line">    </span><br><span class="line">freq_infor_block = lines[l_start:]        </span><br><span class="line">l_position = 0</span><br><span class="line">wave_num = 0.0</span><br><span class="line">for num, line in enumerate(freq_infor_block): </span><br><span class="line">        if &#x27;f/i&#x27; in line:           </span><br><span class="line">            wave_tem = float(line.rstrip().split()[6])</span><br><span class="line">            if wave_tem &gt; wave_num:</span><br><span class="line">                wave_num = wave_tem  </span><br><span class="line">                l_position = num+2</span><br><span class="line"></span><br><span class="line">pos_dimer = open(&#x27;POSCAR_dimer&#x27;, &#x27;a&#x27;)</span><br><span class="line">pos_dimer.write(&#x27;  ! Dimer Axis Block\n&#x27;)</span><br><span class="line"></span><br><span class="line">vib_lines = freq_infor_block[l_position:l_position+len(model)]</span><br><span class="line">for line in vib_lines:</span><br><span class="line">    infor = line.rstrip().split()[3:]</span><br><span class="line">    pos_dimer.write(&#x27; &#x27;.join(infor)+&#x27;\n&#x27;)</span><br><span class="line"></span><br><span class="line">pos_dimer.close()</span><br><span class="line">print(&#x27;&#x27;&#x27;</span><br><span class="line">      DONE!</span><br><span class="line">      Output file is named as: POSCAR_dimer and can be used for dimer calculations.</span><br><span class="line">      Don&#x27;t forget to rename POSCAR_dimer to POSCAR before you run the dimer jobs.      </span><br><span class="line">      &#x27;&#x27;&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>需要注意的有以下几点：</p>
<p>1） 前面介绍了，频率计算为了图快，我们固定了一些原子。脚本会读取一个<code>POSCAR_relax</code>,也就是没有固定这些原子的结构。用ASE读取，输出一下，保证POSCAR里面的结构干净，避免出错。</p>
<p>2）脚本会读取最大的虚频，然后把它所对应的振动方向附到POSCAR_relax的后面，然后IDM的POSCAR就准备好了。</p>
<p>3）输出为POSCAR_dimer， 计算的时候记得把它改成POSCAR。</p>
<p>4）IDM任务的INCAR在脚本里面有说明，改下IBRION = 44。 剩下的基本跟平时优化是一样的。</p>
<p>5）直接在频率计算的目录里面运行：get_dimer.py 即可。</p>
<p>IDM结合NEB的成功率很高，非常推荐。另外，计算出的结果极少出现多个虚频的情况。因此，这个方法也可以用来消虚频。差不多就这些了，剩下的就是多操作练习，熟能生巧的事情了。欢迎大家分享自己的经验，放到自己的网站，公众号等平台，帮助更多的人解决VASP计算相关的问题，有兴趣的也可以把自己的经验心得放到大师兄网站上，直接给我发邮件即可（lqcata@gmail.com）。</p>
<p><img src="/2022/06/22/A32/qrcode.png" alt=""></p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>过渡态</tag>
        <tag>VTST</tag>
        <tag>Improved Dimer Method</tag>
      </tags>
  </entry>
  <entry>
    <title>利用matminer和pymatgen获取material project结构</title>
    <url>/2022/06/22/A33/</url>
    <content><![CDATA[<h1 id="首先导入模块"><a href="#首先导入模块" class="headerlink" title="首先导入模块"></a>首先导入模块</h1><p>from matminer.data_retrieval.retrieve_MP import MPDataRetrieval</p>
<h1 id="实例化-MPDataRetrieval-这个类"><a href="#实例化-MPDataRetrieval-这个类" class="headerlink" title="实例化 MPDataRetrieval 这个类"></a>实例化 MPDataRetrieval 这个类</h1><p>mpdr &#x3D; MPDataRetrieval(api_key&#x3D;’qIAww9QnUnXQJO41’)   # 自行查阅自己的api_key</p>
<h1 id="在实例化-MPDataRetrieval-时需要输入用户在-Material-Project-网站的“”-API-Key"><a href="#在实例化-MPDataRetrieval-时需要输入用户在-Material-Project-网站的“”-API-Key" class="headerlink" title="在实例化 MPDataRetrieval 时需要输入用户在 Material Project 网站的“” API Key."></a>在实例化 MPDataRetrieval 时需要输入用户在 Material Project 网站的“” API Key.</h1><p>df &#x3D; mpdr.get_dataframe(criteria&#x3D;{“nelements”: 1,<br>                                  “elements”: {“$in”: [“Cu”]}},<br>                        properties&#x3D;[‘pretty_formula’,’cif’])<br>print(“There are {} entries on MP with 2 element”.format(df[‘pretty_formula’].count())) # 计算有多少材料<br>#请自行关注 df[‘density’].count() 语句，获取Cu金属的各种结构</p>
<h1 id="导入pymatgen-ext-matproj下的MPRester模块"><a href="#导入pymatgen-ext-matproj下的MPRester模块" class="headerlink" title="导入pymatgen.ext.matproj下的MPRester模块"></a>导入pymatgen.ext.matproj下的MPRester模块</h1><p>from pymatgen.ext.matproj import MPRester</p>
<h1 id="实例化-MPRester-这个类"><a href="#实例化-MPRester-这个类" class="headerlink" title="实例化 MPRester 这个类"></a>实例化 MPRester 这个类</h1><p>mpr &#x3D; MPRester(api_key&#x3D;”qIAww9QnUnXQJO41”)  # 自行查阅自己的api_key</p>
<h1 id="获取Cu金属某一结构文件"><a href="#获取Cu金属某一结构文件" class="headerlink" title="获取Cu金属某一结构文件"></a>获取Cu金属某一结构文件</h1><p>data_structure&#x3D;mpr.get_structure_by_material_id(‘mp-1009018’)</p>
<h1 id="利用pymatgen-io-cif下的CifWriter模块导出Cu-cif文件"><a href="#利用pymatgen-io-cif下的CifWriter模块导出Cu-cif文件" class="headerlink" title="利用pymatgen.io.cif下的CifWriter模块导出Cu.cif文件"></a>利用pymatgen.io.cif下的CifWriter模块导出Cu.cif文件</h1><p>from pymatgen.io.cif import CifWriter<br>w &#x3D; CifWriter(data_structure)<br>w.write_file(‘Cu.cif’)</p>
<p><img src="/2022/06/22/A33/A32/qrcode.png"></p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>matminer</tag>
        <tag>cif</tag>
        <tag>pymatgen</tag>
      </tags>
  </entry>
  <entry>
    <title>通过Ubuntu连接国科智算的方法</title>
    <url>/2017/11/18/A01_not_used/</url>
    <content><![CDATA[<p>本教程主要讲述的是如何在Ubuntu16.04操作系统上连接国科智算超算。分3部分：</p>
<ul>
<li>1）前期准备； </li>
<li>2）连接和挂载超算中心； </li>
<li>3）数据传输测试。</li>
</ul>
<p>在使用本教程前，首先确认已经收到了超算管理员分配的秘钥。通过Vim或者其他文本编辑工具，可以查看一下这个秘钥。超算中心好比是一个宝藏，这个宝藏的大门上有把锁，而开启这把锁的钥匙，就是管理员给我们的秘钥。</p>
<h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>下面的工作，一步一步来，相信99.99% 的人都可以顺利完成。</p>
<ul>
<li>为了方便理解，本人将管理员给的秘钥重新命名了一下。将下面的999改成管理员给你的那个数字。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@bigbro:~$ cp  ~/Desktop/id_rsa_gkzshpc999.gkzshpc999  .ssh/my_key</span><br></pre></td></tr></table></figure>
<p>经过上面的一步，管理员给的秘钥就被我们命名成：my_key了。这好比是我们在钥匙上贴了个标签，开门的时候直接找这个标签对应的钥匙就可以了。</p>
<p>如果你的Ubuntu系统下没有 .ssh 文件夹，可以自己先建一个，然后再运行上面的命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@bigbro:~$ mkdir .ssh</span><br></pre></td></tr></table></figure>
<ul>
<li><p>安装sshfs </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@bigbro:~$ sudo apt-get install sshfs </span><br><span class="line">[sudo] password <span class="keyword">for</span> qli: </span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree       </span><br><span class="line">Reading state information... Done</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建挂载国科智算的文件目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@bigbro:~$ mkdir gkzs</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开~/.bashrc文件，并添加下面的两行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> gkzs=<span class="string">&#x27;ssh -i /home/qli/.ssh/my_key  gkzshpc999@59.49.37.9 -p 9236&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> mgkzs=<span class="string">&#x27;sshfs -o IdentityFile=/home/qli/.ssh/my_key  -p 9236 gkzshpc999@59.49.37.9:  /home/qli/gkzs&#x27;</span></span><br></pre></td></tr></table></figure>
<p>上面我们的两行alias后面的内容主要为：</p>
<ul>
<li>我们的手（ssh）拿着钥匙（-i /home/qli/.ssh/my_key） 打开大门 （gkzshpc999@59.49.37.9 -p 9236）</li>
<li>我们的手（sshfs）拿着钥匙 （-o IdentityFile=/home/qli/.ssh/my_key） 打开大门 （-p 9236 gkzshpc999@59.49.37.9）后，并将宝藏运回家（/home/qli/gkzs） </li>
</ul>
</li>
<li><p>source 一下 ~/.bashrc 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@bigbro:~$ . ~/.bashrc</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="连接超算中心"><a href="#连接超算中心" class="headerlink" title="连接超算中心"></a>连接超算中心</h3><p>上面的工作完成之后，剩下的就是命令操作的事情了：</p>
<ul>
<li><p>连接超算中心：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@bigbro:~$ ls</span><br><span class="line">Desktop  Documents  Downloads  gkzs  lvliang  Music  Pictures  Public  SCVPN  teklahome  Templates  Videos</span><br><span class="line">qli@bigbro:~$ gkzs</span><br><span class="line">Last login: Thu Nov 22 05:07:16 2018 from 80.29.50.15</span><br><span class="line">[gkzshpc999@login02 ~]$ ls</span><br><span class="line">perl5</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开新的一个Terminal，我们挂载超算中心到我们的电脑上面，以便传输数据。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@bigbro:~$ ls</span><br><span class="line">Desktop  Documents  Downloads  gkzs  lvliang  Music  Pictures  Public  SCVPN  teklahome  Templates  Videos</span><br><span class="line">qli@bigbro:~$ ls gkzs/</span><br><span class="line"> </span><br><span class="line">qli@bigbro:~$ mgksz</span><br><span class="line">qli@bigbro:~$ ls gkzs/</span><br><span class="line">perl5</span><br></pre></td></tr></table></figure>
<h3 id="数据传输测试"><a href="#数据传输测试" class="headerlink" title="数据传输测试"></a>数据传输测试</h3><ul>
<li><p>在连接到服务器的界面：我们创建一个文件：mount_test。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[gkzshpc999@login02 ~]$ <span class="built_in">echo</span>  <span class="string">&#x27;I love BigBro&#x27;</span> &gt;  mount_test</span><br><span class="line">[gkzshpc999@login02 ~]$ ls</span><br><span class="line">mount_test  perl5</span><br><span class="line">[gkzshpc999@login02 ~]$ cat mount_test </span><br><span class="line">I love BigBro</span><br><span class="line">[gkzshpc999@login02 ~]$ </span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>在挂载的目录下查看：目录下多出来了刚刚创建的 mount_test文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@bigbro:~$ <span class="built_in">cd</span>  gkzs/</span><br><span class="line">qli@bigbro:~/gkzs$ ls</span><br><span class="line">mount_test  perl5</span><br><span class="line">qli@bigbro:~/gkzs$ cat mount_test </span><br><span class="line">I love BigBro</span><br><span class="line">qli@bigbro:~/gkzs$ </span><br><span class="line">qli@bigbro:~/gkzs$ cp ~/Desktop/CONTCAR  .</span><br><span class="line">qli@bigbro:~/gkzs$ ls</span><br><span class="line">CONTCAR  mount_test  perl5</span><br><span class="line">qli@bigbro:~/gkzs$ </span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面的最后操作中，我们从桌面上复制了一个CONTCAR到挂载的目录下，然后查看下服务器的终端：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[gkzshpc999@login02 ~]$ ls</span><br><span class="line">CONTCAR  mount_test  perl5</span><br><span class="line">[gkzshpc999@login02 ~]$ head -n 5 CONTCAR  </span><br><span class="line">Ru\(0\0\1)                              </span><br><span class="line">   1.00000000000000     </span><br><span class="line">     8.1377999784000004    0.0000000000000000    0.0000000000000000</span><br><span class="line">     4.0688999892000002    7.0475415119999996    0.0000000000000000</span><br><span class="line">     0.0000000000000000    0.0000000000000000   21.5631999968999999</span><br><span class="line">[gkzshpc999@login02 ~]$ </span><br></pre></td></tr></table></figure>
<p>完成了上面的操作，下面你就可以将自己电脑上准备的一些计算文件或者文件夹通过命令复制到超算中心，然后就可以提交任务了。</p>
]]></content>
      <categories>
        <category>LVASPTHW附录</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>超算中心</tag>
        <tag>sshfs</tag>
      </tags>
  </entry>
  <entry>
    <title>A34 利用ASE的热力学模块计算气体的熵</title>
    <url>/2022/07/23/A34/</url>
    <content><![CDATA[<h3 id="简单说明："><a href="#简单说明：" class="headerlink" title="简单说明："></a>简单说明：</h3><p>ASE提供的热力学模块可以很方便地获取气体分子的热力学数据比如吉布斯自由能，熵等。具体参见：<a href="https://wiki.fysik.dtu.dk/ase/ase/thermochemistry/thermochemistry.html。本节介绍下气体分子熵的计算，用到的是**IdealGasThermo**这一个模块，例子为氨气分子（NH3）。**IdealGasThermo**计算气体分子的热力学自由能，除了VASP计算之外，要注意的有4点注意的，这些都要输入到对应的参数之中。">https://wiki.fysik.dtu.dk/ase/ase/thermochemistry/thermochemistry.html。本节介绍下气体分子熵的计算，用到的是**IdealGasThermo**这一个模块，例子为氨气分子（NH3）。**IdealGasThermo**计算气体分子的热力学自由能，除了VASP计算之外，要注意的有4点注意的，这些都要输入到对应的参数之中。</a></p>
<p>1） 分子的对称数；</p>
<p>2）分子的结构：线性或者非线性；</p>
<p>3）分子中未成对的电子数目，或者多重度。</p>
<p>4）温度，压强</p>
<p>这些具体的输入，网站上都有相应的说明，自己根据分子的特性改下即可。比如对称数不会算的话，可以参考下面的这个表格。</p>
<p><img src="/2022/07/23/A34/A34_1.png" alt=""></p>
<h3 id="脚本部分："><a href="#脚本部分：" class="headerlink" title="脚本部分："></a>脚本部分：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Created on Tue Jul 12 18:38:35 2022</span></span><br><span class="line"><span class="string">https://janaf.nist.gov/tables/H-083.html #Database</span></span><br><span class="line"><span class="string">Symmetry Number: Table 10.1 and Appendix B of C. Cramer “Essentials of Computational Chemistry”, 2nd Ed.</span></span><br><span class="line"><span class="string">spin:  0 for molecules in which all electrons are paired, 0.5 for a free radical with a single unpaired electron, 1.0 for a triplet with two unpaired electrons, such as O_2.</span></span><br><span class="line"><span class="string">@author: qli</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> ase.io <span class="keyword">import</span> read, write</span><br><span class="line"><span class="keyword">from</span> ase.thermochemistry <span class="keyword">import</span> IdealGasThermo</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> constants <span class="keyword">as</span> con</span><br><span class="line"></span><br><span class="line">atoms = read(<span class="string">&#x27;./freq/POSCAR&#x27;</span>)</span><br><span class="line">sym = <span class="number">3</span> <span class="comment"># symmetry number of NH3 </span></span><br><span class="line">spin = <span class="number">0</span> <span class="comment"># spin of NH3. </span></span><br><span class="line">tem = <span class="number">298.15</span> <span class="comment"># Temperature</span></span><br><span class="line">out = read(<span class="string">&#x27;./OUTCAR&#x27;</span>,  <span class="built_in">format</span>=<span class="string">&#x27;vasp-out&#x27;</span>)</span><br><span class="line">potentialenergy = out.get_potential_energy()</span><br><span class="line"></span><br><span class="line">model = read(<span class="string">&#x27;./freq/POSCAR&#x27;</span>)</span><br><span class="line"><span class="comment"># model_positions = model.get_positions()</span></span><br><span class="line"></span><br><span class="line">vib_energies = []</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;./freq/OUTCAR&#x27;</span>) <span class="keyword">as</span> f_in:</span><br><span class="line">    lines = f_in.readlines()</span><br><span class="line">    <span class="keyword">for</span> num, line <span class="keyword">in</span> <span class="built_in">enumerate</span>(lines):</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;cm-1&#x27;</span> <span class="keyword">in</span> line:</span><br><span class="line">            vib_e = <span class="built_in">float</span>(line.rstrip().split()[-<span class="number">2</span>])</span><br><span class="line">            vib_energies.append(vib_e)</span><br><span class="line"></span><br><span class="line">vib_energies = np.array(vib_energies[:-<span class="number">6</span>])/<span class="number">1000</span> <span class="comment"># For Gas, the last six are translation and rotation</span></span><br><span class="line"><span class="comment"># zpe = sum(vib_energies)/2</span></span><br><span class="line"></span><br><span class="line">thermo = IdealGasThermo(vib_energies=vib_energies,</span><br><span class="line">                        potentialenergy=potentialenergy,</span><br><span class="line">                        atoms=atoms,</span><br><span class="line">                        geometry=<span class="string">&#x27;nonlinear&#x27;</span>,</span><br><span class="line">                        symmetrynumber=<span class="number">3</span>, spin=spin)</span><br><span class="line"></span><br><span class="line">zpe = thermo.get_ZPE_correction()</span><br><span class="line">entropy = thermo.get_entropy(temperature=tem, pressure=<span class="number">101325</span>,verbose=<span class="literal">True</span>)  <span class="comment"># Unit eV/K</span></span><br><span class="line">TS = tem * entropy   </span><br><span class="line">G = potentialenergy + zpe - TS</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;G&#x27;</span>, G)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;S&#x27;</span>, con.Avogadro * con.electron_volt * entropy, <span class="string">&#x27;J/K/mol&#x27;</span>)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="运行实例："><a href="#运行实例：" class="headerlink" title="运行实例："></a>运行实例：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qli@bigbro test_nh3 % ls</span><br><span class="line">CONTCAR             INCAR               OUTCAR              freq/</span><br><span class="line">H-083.txt           KPOINTS             POSCAR              get_gas_entropy.py*</span><br><span class="line">qli@bigbro test_nh3 % python3 get_gas_entropy.py </span><br><span class="line">Entropy components at T = 298.15 K and P = 101325.0 Pa:</span><br><span class="line">=================================================</span><br><span class="line">                           S               T*S</span><br><span class="line">S_trans (1 bar)    0.0014947 eV/K        0.446 eV</span><br><span class="line">S_rot              0.0004981 eV/K        0.149 eV</span><br><span class="line">S_elec             0.0000000 eV/K        0.000 eV</span><br><span class="line">S_vib              0.0000047 eV/K        0.001 eV</span><br><span class="line">S (1 bar -&gt; P)    -0.0000011 eV/K       -0.000 eV</span><br><span class="line">-------------------------------------------------</span><br><span class="line">S                  0.0019964 eV/K        0.595 eV</span><br><span class="line">=================================================</span><br><span class="line">G -19.220631915628093</span><br><span class="line">S 192.6230402411749 J/K/mol</span><br></pre></td></tr></table></figure>
<h4 id="简单说明：-1"><a href="#简单说明：-1" class="headerlink" title="简单说明："></a>简单说明：</h4><p>1）目录里面H-083.txt是NIST-<em>JANAF</em>的热力学数据库的值。自己可以测试对比下。</p>
<p>2）脚本所在目录是NH3分子优化的计算，脚本读取当前的OUTCAR获取能量，</p>
<p>3）目录里面还有个<code>freq/</code>，对应的是NH3分子的频率计算，读取其中的POSCAR和OUTCAR获取分子结构和频率信息。对分子来说，VASP频率计算结果中的后面6个对应的是平动和转动部分，不能作为振动计算熵。平动和转动的熵是通过IdealGasThermo模块和分子结构来计算的，具体计算公式参考统计热力学、物理化学等。</p>
<p>4）计算表面吸附物种的可以使用<code>Harmonic limit</code>这个模块。</p>
<h3 id="示例下载："><a href="#示例下载：" class="headerlink" title="示例下载："></a>示例下载：</h3><p>关注公众号：大师兄科研网， 后台回复关键词： NH3 </p>
<p><img src="/2022/07/23/A34/qrcode.png" alt=""></p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
      <tags>
        <tag>ASE</tag>
        <tag>气体</tag>
        <tag>Entropy</tag>
      </tags>
  </entry>
  <entry>
    <title>Ex01_V3 学习VASP的基本要求</title>
    <url>/2022/07/23/ex01_v3/</url>
    <content><![CDATA[<h6 id="在学习本书时，大师兄们会默认读者掌握了一些基本的电脑操作技能，以及化学的基本常识（结构化学，物理化学等）。本章列举出一些常用的计算工具和软件，以及假设大家掌握的一些技能。如果没有达到基本的要求，那么请在学习前面几章的同时，抓紧提升自己的能力。-化学的基本知识如果没有掌握，不建议学习本书。"><a href="#在学习本书时，大师兄们会默认读者掌握了一些基本的电脑操作技能，以及化学的基本常识（结构化学，物理化学等）。本章列举出一些常用的计算工具和软件，以及假设大家掌握的一些技能。如果没有达到基本的要求，那么请在学习前面几章的同时，抓紧提升自己的能力。-化学的基本知识如果没有掌握，不建议学习本书。" class="headerlink" title="在学习本书时，大师兄们会默认读者掌握了一些基本的电脑操作技能，以及化学的基本常识（结构化学，物理化学等）。本章列举出一些常用的计算工具和软件，以及假设大家掌握的一些技能。如果没有达到基本的要求，那么请在学习前面几章的同时，抓紧提升自己的能力。 化学的基本知识如果没有掌握，不建议学习本书。"></a>在学习本书时，大师兄们会默认读者掌握了一些基本的电脑操作技能，以及化学的基本常识（结构化学，物理化学等）。本章列举出一些常用的计算工具和软件，以及假设大家掌握的一些技能。如果没有达到基本的要求，那么请在学习前面几章的同时，抓紧提升自己的能力。 化学的基本知识如果没有掌握，不建议学习本书。</h6><h2 id="1-操作系统"><a href="#1-操作系统" class="headerlink" title="1  操作系统"></a>1  <strong>操作系统</strong></h2><p>做计算，有三个操作系统可以选择：</p>
<ul>
<li>Windows 系统：会使用Windows系统:会开机，打字，安装软件;</li>
<li><p>Linux 系统，强烈推荐，大师兄本人一直用的是Ubuntu，但不局限于Ubuntu系统，自己喜欢什么就用什么。</p>
</li>
<li><p>Mac系统，兼顾Windows和Linux，一般比较贵，经济条件允许，也可以。</p>
</li>
</ul>
<h5 id="给重点照顾对象：Windows用户的第一个提醒："><a href="#给重点照顾对象：Windows用户的第一个提醒：" class="headerlink" title="给重点照顾对象：Windows用户的第一个提醒："></a>给重点照顾对象：Windows用户的第一个提醒：</h5><p>Windows用户在进行计算的时候，只要计算出错了，就要本能地记起第一个解决的办法： dos2unix 。 这个命令干什么的不要紧，先死死记住即可。</p>
<h2 id="2-文本编辑工具"><a href="#2-文本编辑工具" class="headerlink" title="2 文本编辑工具"></a>2 <strong>文本编辑工具</strong></h2><p>文本编辑工具主要用来编辑，查看VASP的输入（出）文件，要求会打开文件，打字，保存文件。</p>
<h3 id="1）vim"><a href="#1）vim" class="headerlink" title="1）vim"></a>1）<a href="https://www.vim.org/">vim</a></h3><p>这个<strong>必须要学会</strong>，linux下面自带。原因是绝大多数的计算都是在linux下面进行的，学会vim的基本操作可以极大提高你的文字处理能力和工作效率。关于VIM的使用介绍，自己百度下或者搜一搜相关的视频，学习下。</p>
<h3 id="2-notepad"><a href="#2-notepad" class="headerlink" title="2) notepad++"></a>2) <a href="https://notepad-plus-plus.org/">notepad++</a></h3><ul>
<li>这个是对于Windows用户来说的，要求会创建文件，输入内容并保存文件，<strong>这个软件或者类似的必须学会使用!</strong></li>
</ul>
<p>原因在于：Windows下面自带的记事本保存的文件与linux下的文件格式不匹配，提交任务的时候经常出问题，用notepad++则不会出现这个问题。</p>
<p><strong>因此</strong>，Windows的记事本杜绝使用。为了安全，即使用了notepad++，Windows用户在进行计算的时候，也需要注意下面两点：</p>
<ul>
<li><p>Windows下面编辑的输入文件，如果想在linux服务器上运行，最好先执行: dos2unix 这个命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dos2unix  INCAR</span><br></pre></td></tr></table></figure>
</li>
<li><p>Windows用户计算出错了，一定要首先想到 dos2linux 这个命令来解决问题!!!</p>
</li>
</ul>
<h3 id="3）-Atom"><a href="#3）-Atom" class="headerlink" title="3） Atom"></a>3） <a href="https://atom.io/">Atom</a></h3><p>这个Atom是文本编辑工具，不是原子的意思。Windows，Linux，Mac系统均可使用。</p>
<h2 id="3-常用建模相关软件"><a href="#3-常用建模相关软件" class="headerlink" title="3 常用建模相关软件:"></a>3 <strong>常用建模相关软件:</strong></h2><p>本书默认大家已经在自己的电脑里安装了下面三个软件：</p>
<h3 id="1-Material-Studio"><a href="#1-Material-Studio" class="headerlink" title="1) Material Studio"></a><strong>1) Material Studio</strong></h3><ul>
<li>这个软件，百度里面一大堆下载链接，安装教程，大家自行下载安装即可。</li>
<li>本书默认大家已经安装成功，会不会使用暂且不要求；</li>
<li>不要问我从哪里下载，安装出现问题也不要找我解决。</li>
<li>另外，MS很贵，国内大部分人都是用的盗版软件，没有版权，不建议使用。</li>
</ul>
<h3 id="2）VESTA"><a href="#2）VESTA" class="headerlink" title="2）VESTA"></a>2）<strong><a href="http://jp-minerals.org/vesta/en/">VESTA</a></strong></h3><p>来自日本的良心软件，Linux，Windows，Mac系统均可使用。链接：<a href="http://jp-minerals.org/vesta/en/。无版权困扰，发文章的时候要注明下图是用VESTA做的，引用下对应的文章。">http://jp-minerals.org/vesta/en/。无版权困扰，发文章的时候要注明下图是用VESTA做的，引用下对应的文章。</a></p>
<ul>
<li><p>Windows下面安装就不再介绍了，下载程序，解压，双击图标即可运行，相信大家都能搞定。</p>
</li>
<li><p>Linux下安装: </p>
<ul>
<li><p>下载binary程序文件，本人解压后放到了/opt/VESTA-x86_64目录</p>
</li>
<li><p>编辑 ~/.bashrc 文件，在文件最后，添加下面2行。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export VESTA=/opt/VESTA-x86_64 </span><br><span class="line">export PATH=&quot;$PATH:$VESTA&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>在终端里面进行的操作如下：第一行打开~/.bashrc文件, 自己添加上面提到的两行即可，第二行更新下~/bashrc文件，第三行运行VESTA。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ vim ~/.bashrc</span><br><span class="line">$ . ~/.bashrc</span><br><span class="line">$ VESTA</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3）p4vasp"><a href="#3）p4vasp" class="headerlink" title="3）p4vasp"></a>3）<a href="http://www.p4vasp.at"><strong>p4vasp</strong></a></h3><p>p4vasp主要有建模，可视化以及后处理的一些功能。</p>
<ul>
<li>链接：<a href="http://www.p4vasp.at/">http://www.p4vasp.at/</a></li>
</ul>
<ul>
<li><p>Windows版本，很久没有更新了，点击此处下载，解压,双击图标即可运行。也可以在大师兄QQ群或者其他QQ群文件中下载。</p>
</li>
<li><p>Linux版本功能更加强大。也很久没更新了。 Ubuntu（18以及更老的版本）用户使用命令一键安装： <strong>sudo apt-get install p4vasp</strong></p>
<p>Ubuntu 20以及后续的安装有些麻烦。p4vasp已经不更新了，很多功能可以用其他的软件替代。如果坚持使用p4vasp，可以联系大师兄付费安装（50块钱）。</p>
</li>
</ul>
<h3 id="4）-ASE"><a href="#4）-ASE" class="headerlink" title="4） ASE"></a>4） <a href="https://wiki.fysik.dtu.dk/ase/index.html">ASE</a></h3><p>ASE 是Atomic Simulation Environment的缩写，可以实现搭建结构，读取VASP的输入和输出，以及一些后处理功能。如果p4vasp没办法安装，那么ASE必须要安装在你的电脑上。</p>
<h3 id="5）其他软件"><a href="#5）其他软件" class="headerlink" title="5）其他软件"></a>5）其他软件</h3><p>这里说的软件主要是针对VASP计算的模型搭建这一方面，有兴趣的也可以试试<a href="https://avogadro.cc">Avogadro</a>. 值得一提的是，我们自己的国产建模软件那是相当得少，更别提计算软件了。而我们比较擅长的是写教程和后处理，然后发公众号割韭菜。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a><strong>总结:</strong></h2><ul>
<li>初学者学习本书,所必须具有的技能:</li>
<li><ul>
<li>熟练使用一个操作系统；</li>
<li>会编辑文本，写入和保存文件；</li>
<li><ul>
<li><strong>Windows 用户Notepad++必须掌握</strong>,</li>
<li>linux用户可以vim或者其他编辑器，比如Atom</li>
</ul>
</li>
<li>安装好或者会初步使用一款建模软件。-<ul>
<li><strong>p4vasp </strong>，<strong>ASE</strong>安装在Windows和Ubuntu系统上；</li>
<li><strong>VESTA</strong> 安装在Windows，Ubuntu，Mac系统上；</li>
<li><strong>Materials Studio</strong> 安装在Windows上（没版权就别安装了）</li>
</ul>
</li>
<li>会连接服务器，使用的vasp程序并且会提交任务<ul>
<li>这个大师兄帮不了你，找师兄师姐，到时、自行找服务器商或者其他售后人员解决。</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
  </entry>
  <entry>
    <title>Ex00 为什么是&quot;The Hard Way&quot;</title>
    <url>/2022/07/23/ex00_v3/</url>
    <content><![CDATA[<h2 id="1）为什么Hard？"><a href="#1）为什么Hard？" class="headerlink" title="1）为什么Hard？"></a>1）为什么Hard？</h2><p>现如今浮躁的科研圈，社会风气下，速成思想，快餐文化害死人，图快的读者中，就有很多来自做实验的。现在大家普遍认为：实验+计算很好发文章。两者结合可以更深入地理解你的研究体系，发现并解决科研中有价值的科学问题。但很多老师却感觉计算就是动动鼠标，操作个软件的活，是个人就能做计算似的。在这种错误的理解，对计算难度过分低估，在高IF文章的诱惑下，安（suan）排（ji）自己的学生去搞计算。写到这里，很多脏话硬生生从嗓子眼憋回去了。骂是解决不了问题的。那么我们就理一理，一个实验的课题组，在没有任何计算背景的条件下，安（Po）排（Hai）一个学生做计算所遇到的问题吧：</p>
<ul>
<li>计算软件的选择：大千世界无奇不有，计算的软件也是多得数不过来，每个软件都有自己适用的体系，哪个更适合你的体系，你不会选择；</li>
<li>软件的购买：比如你决定了使用VASP，你需要找代理商购买软件（有些还很贵，舍不得买，用盗版的，发文章的时候还担心版权问题）；</li>
<li><p>服务器的购买：买了软件我们要安装啊。你可能说，这个容易，直接买几台电脑装上就可以了。这里的问题在于：用台电脑就可以算，就可以发文章的时代造就过去了，你可能被淘汰十几年了。所以，</p>
<ul>
<li>要买服务器，但服务器价格不菲，怎么选你也不知道；</li>
<li>不买服务器，可以买超算中心的机时啊。好吧，就当这一关也过了。</li>
</ul>
</li>
<li><p>软件安装：这也是个麻烦事。计算软件不是QQ，也不是360安全卫士，不是你下载个exe文件双击选择d盘就可以傻瓜式安装成功的。各种环境变量，依赖的库都是需要自己安装的。要不然那么多培训班上来就先给大家介绍软件是怎么安装的呢。</p>
</li>
<li><p>熟悉Linux系统：计算软件大部分都是在Linux系统下安装的，所以Linux系统的一些常用命令操作你得学会；而Linux的桌面之所以不如Windows，用户习惯是个难以突破的瓶颈，在没人陪伴的情况下，自己熟练Linux系统也是非常不易；</p>
</li>
<li>软件学习：这也是本书的重点，纯做计算的菜鸟，每天屁活都不干，就看本书，Linux系统下操练，有人指导的情况下差不多2个月能入门。对号入座，你一个做实验的，每天捣鼓设备，转转反应，就快累的嗝屁了，恨不得回到家或者宿舍就躺着歇会，还要跟朋友出去嗨，陪对象逛，当然还要玩把王者农药。真的能抽出时间来认真学习么？</li>
<li>有些体系对软件参数依赖性很强，没人指导，你不会设置，软件出错不会解决，计算结果不会分析，算对算错都不知道，迷迷糊糊就这样得到了一些结果。</li>
<li>计算的目的，肯定要跟实验对比啊？怎么对比，从哪方面下手，又没头绪，很多时候都是硬凑，结论反了也傻呵呵地跟别人说实验和理论吻合地很好，可以冲个大文章。</li>
<li>折腾完了，要投文章了。因为计算太烂，XJB乱扯结论而被直接拒掉的又有一批；</li>
<li>好不容易送审了， 最好去烧烧香，祈求不要落到做计算的人手里。真落到计算的人手里，算的太烂，也是很有可能因此丧命或者大修。</li>
<li>就当你运气好，大修了。审稿人抛出来的专业计算问题你可能又答不上来，怎么补数据都无从下手。</li>
<li>让你再幸运一把，补上数据，文章接受了。</li>
<li>那下一篇还这样弄么？ 可以，但经过上面的折腾，小硕士估计要毕业了，小博士也要滚蛋了。又得找下一个垫背的，也就是因为这样，上一批的不知对和错的经验就传授给了下一代。</li>
<li>总结：一个做实验的老师，不把自己在实验方面的专长传授给自己的学生，硬让人家自己去琢磨你什么都不懂的领域，最后造就了一个四不像的怪物出来，何为师道？</li>
</ul>
<p>这种情况到底怎么办？ 很多人在的课题组都是做实验的，老板头脑发热的时候，就安排做起了计算。但老板除了一颗乐观的心，屁都不懂啊。这时候的你，除非脑子很好用，否则就会陷入一种叫天天不应，叫地地不灵的境界。在这里,大师兄建议你：</p>
<ul>
<li>说服老板，找个计算靠谱的组，合作一下，避免自己直接算，自己专心做实验，计算可以跟国内相关领域的老师合作一下，各取所长。</li>
<li>说服不了，找个计算靠谱的组，让老板派你去交流学习一段时间，别自己在那里瞎捣鼓。</li>
<li>认真学习本书，看VASP的手册，以及各种网站上的教程，先摸索一阵子再算老板给你的体系。</li>
<li>总之，时间和精力的成本，自己心里要有个数。</li>
</ul>
<p>在这里还要吐槽2点：</p>
<ul>
<li>有些做实验的跟计算合作，挂名的时候把计算放到不起眼位置的人，随意挪动计算作者的顺序，甚至是放到了通讯位置上，但没加*。生活不易，给做计算的留条活口，也给自己留个好名声。</li>
<li>有些跟实验合作的计算工作者，随随便便优化个结构，做个漂亮的图就完事。只做锦上添花工作，而不深入研究课题机理。做计算的日子本来就难，请不要因为自己的不专业坏了计算的名声。</li>
<li>如果想合作，就双方正儿八经地合作，真正意义的合作至少是通过计算解决了课题中的难点，机理，有助于组里课题的下一步进行，更高级点是实验验证了计算的假设，不过能做到这种程度的也没多少课题组。而对于这种良性的合作，实验和计算都给挂个一作，双方老板都挂个通讯，也无可厚非。</li>
<li>不想合作，非让自己的学生做计算。这种情况就不要怕花钱，派学生到做计算的课题组学习上一两个月，然后再回来继续搞。如果有需要，也可以派出去参加参加一些高质量的培训班，暑期学校等，来弥补自己在学生指导方面的不足。</li>
</ul>
<p>虽然书名叫The hard Way，这本书还是给了很多人一种DFT极品快餐的感觉；更会越来越”毁了”专业做计算的，让各种做实验的做计算的扰乱市场。虽然有这种负面的作用，但我还是想尽自己可能，稍微提高我们做计算的平均水平。因此，<strong>认真声明一下</strong>：本教程的初衷是给专门做计算菜鸟准备的。对于那些以为靠本书就可以快速入门的筒子们（不管是做计算还是做实验的），劝你们还是趁早放弃本书的学习，科研的路上，从来就没有速成二字。</p>
<p>在BB了这么多废话之后，感觉时候再强调下本书的重点了：The Hard Way。The Hard Way 在本人的眼里，类似于书山有路勤为径，学海无涯苦作舟的感觉，类似于经过无数瞎折腾终于尝到一点点小胜利甜头的感觉，类似于苦尽甘来，柳暗花明又一村的感觉。所以：Hard Way是本书的重点，也是痛苦学习的一个过程。别人耗费精力和时间开发出来的软件，短时间就精通是不可能的事情。所以，也别指望着一口气吃成个胖子，耐住寂寞。 </p>
<p>本人学习和使用VASP已经快10年了，该教程差不多也5岁了。我进入课题组之前，不会用Ubuntu系统，也不会用脚本，也不会用python写脚本，也没用过VASP。我的VASP入门，是花了一个月看了Davide Sholl的书后，老板又手把手花了一个多月的时间学会的，学习的资料是老版本的Hand on Session系列。每天做的是系列中的练习，准备老板布置的作业，思考老板预留的问题，然后第二天听老板解释每个参数的含义，里面的关键点。而真正操作起来进入课题的时候，又有组里细心的博后专门帮忙指导答疑，也有很多人可以进行讨论学习。写这么多并不是在秀自己遇到了一个多好的老板，多好的课题组。在这样的环境中，经过了四年的学习，好几个课题的实战，才变成你们感觉很牛逼的大师兄（其实我只是经验比你们多一点点而已）。而这本书，也是本人这四年来学习到的精华，每一节都要花费差不多4个小时的样子才能完成，或者更多。而这四年的精华，岂能让你把这本书看一遍就掌握了?  到现在为止，瞎BB了76节。每节你花一天的时间去学习，加上其他参考书的学习，也需要2个月的时间。而2个月，对一个新手来说，完全在承受范围之内，<strong>请相信时间的力量</strong>。这里，我们澄清下对新手的定义：全职搞计算的菜鸟。所以，Hard Way 就是需要你花掉每一个整天的时间，一点点认真琢磨，反复操练，绝对不是什么速成。而现在我们搞科研都很浮躁，什么都喜欢图快，我们也有句古话：欲速则不达。因此，打算朝夕之内就学会VASP的读者，本书可能真的不适合你。</p>
<h2 id="2）-计算-转行？"><a href="#2）-计算-转行？" class="headerlink" title="2） 计算 = 转行？"></a>2） 计算 = 转行？</h2><ul>
<li>很多人吐槽计算化学是个坑告诉你，既然选择了这条路，就准备改行吧。请避开这些负能量的说法，拿出自己的主见。无论放弃或者坚持，都要拿出你自己的判断力出来，请不要再听别人在你耳边瞎磨。也就是我的人生我做主。</li>
<li>每一行的人都会说自己这一行是个坑，不管你怎么跳，都是坑。引用我老婆的原话：之前带两个孩子的时候，感觉自己每天都很累，现在孩子父母帮忙看着，自己工作了，但每天还是很累。美好的生活，累总是一路同行。</li>
<li>个人的理解是，学习理论计算可以使你的视野更加开阔，思维方式更加灵活，对事物本质的把握和理解上，比别人要更胜一筹。也就是一眼就能找到问题的关键所在。不论是否继续相关的研究，转行与否，对今后的发展总会有所帮助。当然，我这个穷酸书生说的话，大家也可以一笑了之。</li>
</ul>
<h2 id="3-心态"><a href="#3-心态" class="headerlink" title="3 心态"></a>3 心态</h2><h3 id="主动行动、思考"><a href="#主动行动、思考" class="headerlink" title="主动行动、思考"></a>主动行动、思考</h3><p>前面说的都没有阻挡你继续学习vasp的脚步，那么首先要注意的就是自己的心态：学习过程中要时刻抱着<strong>主动</strong>的心态去解决问题。</p>
<ul>
<li>遇到不会的问题,<strong>主动</strong>去查找解决方法;</li>
<li>遇到不懂的基础知识,<strong>主动</strong>去找教科书;</li>
<li>遇到什么好的资源,书籍,课件等,<strong>主动</strong>去网上搜索,下载;</li>
<li>本书中的练习，看到别人有意思的计算，<strong>主动</strong>去重复重复。</li>
<li>没事就<strong>主动</strong>去官网溜达,</li>
<li>VASP计算出错，<strong>主动</strong>去google或者官网的论坛找答案! </li>
</ul>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h4><ul>
<li><p>上面说的<strong>主动</strong>是对于你自己来说的，别碰到不会的就主动求助别人，这样你很难得到提升。</p>
</li>
<li><p>去google搜索遇到的问题，也就意味着你要学会科学上网。</p>
</li>
<li><p>如果遇到热心帮你解决问题的人，好好准备你的问题，千万不要一个劲的追问，因为这样显得你不动脑子，非常惹人烦。</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a><strong>总结:</strong></h2><ul>
<li><p>学习VASP所具有的心态：</p>
<ul>
<li>主动去面对遇到的问题和困难，冰冻三尺,非一日之寒，遇到问题，主动解决，日积月累就会收获良多；</li>
<li>对自己要有自信，即使自己是彻头彻底的小白,也不必要担心。相对于那些积累了很多错误经验的人来说，什么都不知道则具有更好的可塑性。</li>
<li>不要盲目相信他人，有自己的理解。如果你在网上搜索问题的答案，会找到很多人的回答，但实际熵很多人水平都可能没有你高，而你却把他们的话当成真理一般去相信，这是致命的。</li>
</ul>
</li>
<li><p>大师兄的要求：</p>
<ul>
<li><p>新手认真阅读序言里面推荐的那本参考书；</p>
</li>
<li><p>尽可能多地浏览VASP官网，对某些参数有疑惑，认真查阅手册；</p>
</li>
<li><p>最重要的是不要偷懒，遇到不会的东西或者困难，立刻记下来或者去解决，否则明天你就会忘掉；</p>
</li>
<li><p>好东西要学会分享，可以在QQ群里分享自己的心得，帮助其他正在入门的小师弟，妹们。</p>
</li>
</ul>
</li>
</ul>
<h2 id="致谢："><a href="#致谢：" class="headerlink" title="致谢："></a><strong>致谢：</strong></h2><p>本教程在写作的过程中，得到了很多人的支持。 有些地方可能描述不清，当然书里面也肯定避免不了错误的出现，也收到了很多人的建议和批评指正。在这里，向他们表示诚挚的谢意。很多人认为，通过这个教程，学到了很多东西，但请不要过分把功劳归在我身上。引用佛系的观点：<strong>因果，完全是自作自受</strong>。你自己学习了，自己认真练习了，水平的提高完全是你自己辛苦付出的结果。<strong>教程就在这里，你学或者不学，都跟我没有关系。</strong>私以为，收获最大的还是本人。一方面把自己多年的学习的经验整理总结出来，另一方面，很多当时一知半解的地方，在写作的过程中，通过查阅资料，认真分析得到了解决。</p>
<p>教程的宗旨在于快速带领大家入门VASP的使用，这里大师兄想起了金庸笔下的打狗棒法， 本书传授的只是招式，而心法口诀则是你扎实的科研基础功，是自己这些年（高中，大学，硕士，博士）通过坚持不懈学习来积累获得的，对次，本人确实无能为力，而这一点也恰恰是我们最欠缺的部分，希望可以引起大家的重视，在等待任务结束的时候，多多补习自己的基础知识。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
  </entry>
  <entry>
    <title>Ex02_V3 服务器和程序语言</title>
    <url>/2022/07/24/ex02_v3/</url>
    <content><![CDATA[<h2 id="服务器相关"><a href="#服务器相关" class="headerlink" title="服务器相关"></a>服务器相关</h2><p>VASP的计算就跟开车一样，设计到很多的内容，比如大街上的路怎么铺的？桥怎么建的？发动机怎么工作的？方向盘怎么工作的，刹车片什么材料做的？车身颜色怎么喷的？ 没有人会懂所有相关的知识。但是怎么打开车门，坐车里，启动发动机，踩油门，打方向盘，这是本教程所关心的，也就是类似驾校教练指导你学会如何开车，而不是关系如何去造车，去铺路。这里的车就是VASP。要开车，必须手头上有车，没车我瞎BB再多也是白搭。</p>
<h3 id="1-知道怎么连接自己组内或者租赁的服务器"><a href="#1-知道怎么连接自己组内或者租赁的服务器" class="headerlink" title="1) 知道怎么连接自己组内或者租赁的服务器"></a>1) 知道怎么连接自己组内或者租赁的服务器</h3><p>后面大师兄会介绍一些挂载服务器的方法，但这些基本的连接服务器操作是基础。一般来说通过终端（terminal）来实现，Windows下有很多软件可以参考，比如：</p>
<ul>
<li>Winscp + Putty</li>
<li><em>MobaXterm</em></li>
</ul>
<p>当然还有其他的软件，大师兄平时很少用Windows，推荐的就这两个。尤其是MobaXterm。 对于Ubuntu和Mac，则可以直接打开Terminal进行连接。</p>
<h3 id="2-初步学习使用基本的linux命令"><a href="#2-初步学习使用基本的linux命令" class="headerlink" title="2) 初步学习使用基本的linux命令:"></a>2) 初步学习使用基本的linux命令:</h3><ul>
<li><p>进入目录 : cd </p>
</li>
<li><p>移动文件(夹): mv </p>
</li>
<li>复制文件: cp </li>
<li>复制文件夹用: cp -r ; 注意 cp 和 -r 之间有个或者N个空格</li>
<li>创建文件夹:mkdir     </li>
<li>删除文件: rm ;    </li>
<li>删除文件夹: rm  -r    </li>
<li>强制删除文件夹: rm -fr  或者 rm -rf  (f 和 r 的顺序可以颠倒 )        </li>
<li>显示目录下文件: ls 等命令;   </li>
<li>这里大师兄就不再啰嗦了，后面教程里会介绍一些命令的使用，老司机们自动略过，新手自行百度：linux 命令，你会得到铺天盖地的信息。</li>
</ul>
<h3 id="3-手上有可以正常运行的VASP程序"><a href="#3-手上有可以正常运行的VASP程序" class="headerlink" title="3) 手上有可以正常运行的VASP程序"></a>3) 手上有可以正常运行的VASP程序</h3><ul>
<li><p>组里面已经安装好vasp程序，或者使用超算中心的VASP程序，只要手上有可以正常运行的VASP即可。因为我们在本书里，<strong>不讨论</strong>：</p>
<ul>
<li>去哪里下载VASP? 怎么安装VASP? 去哪里下载VASP的pseudo potentials?</li>
</ul>
<ul>
<li>前面的问题可以在QQ群里面讨论，也可以付费求助别人解决。</li>
<li>对于VASP的pseudo potentials，也就是POTCAR。<ul>
<li>你老板买了VASP的版权，就直接问他要。</li>
<li>用的盗版VASP，找其他人要一份，但是发文章的时候会很麻烦。国内很多人都是找有版权的老师挂名，其实这是非常学术不道德的事情。一方面涉及到版权，一方面涉及到瞎几把挂名。</li>
<li>免费的可以用QE，CP2K，GPAW等开源的软件，没必要非得在VASP上面死磕。</li>
</ul>
</li>
</ul>
</li>
<li><p>知道怎么提交VASP任务？</p>
<ul>
<li>自己组里都有提交任务的脚本，如果没有的话只能自行动手解决咯，可以<ul>
<li>找组里的师兄师姐帮忙;</li>
<li>第一个啃螃蟹的人，找老师解决，求助服务器商，求助超算管理员；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="程序语言学习"><a href="#程序语言学习" class="headerlink" title="程序语言学习"></a><strong>程序语言学习</strong></h2><p>建议大家学习两个语言: bash 和 python。主要是为了辅助计算，节省时间，并拓展自己的思维方式。现在机器学习，人工智能越来越热，学会使用Python或者其他语言，或许可以上升到以后能否生存的高度了。</p>
<ul>
<li>bash语言：日常terminal里面常用的基本命令，比如cd，ls这些，以及结合基本的逻辑语法，可以让你写出一些简单的小脚本。极大提高自己的工作效率；极大的意思就是别人一天或者N天的活，你可能几秒就完事。</li>
<li>Python 语言：python是一款语法简单，很容易上手的程序，有着丰富的数据库支持，目前深受科研人员的喜爱。<strong>注意</strong>，这里我们不讨论类似：python是一门高级语言，运行的时候跟机器交互性差，需要时间比C++长这样的问题。因为这是专业程序员的事。不出意外，看这本书的大部分人，能够用python写个小脚本，方便地处理自己的任务和数据，就已经非常棒了，快和慢，对于我们来说，顶死了也就几秒的问题，完全可以接受。</li>
<li>学习程序语言，一方面可以极大地提高自己的工作效率，另一方面也可以改变自己看待事物的思维方式。  </li>
<li>如果不喜欢Python，当然也可以学习其他的程序语言，C++，R，Java等。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1）学习VASP前，先保证自己能顺利连接到服务器，然后运行VASP。这个大师兄没法帮忙，可以求助自己课题组中的师兄师姐，老板，或者群里咨询。</p>
<p>2）新手有大把的时间，建议系统性学习bash，python语言。Python可以换成其他你自己感兴趣的。</p>
]]></content>
      <categories>
        <category>LVASPTHW</category>
      </categories>
  </entry>
</search>
